{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyMT5 SDK Documentation","text":"<p>Complete Python SDK for MetaTrader 5 trading automation via gRPC</p> rocket_launch Quick Start <p>Your first project from scratch in 10 minutes</p> bolt Getting Started <p>New here? Start with setup and overview</p> map Project Map <p>Architecture overview</p> menu_book Glossary <p>MT5 terms and concepts</p> build MT5Service <p>Wrapper methods layer</p> settings MT5Account <p>Low-level gRPC protocol layer</p> auto_awesome MT5Sugar <p>High-level convenience API</p>"},{"location":"API_Reference/MT5Account/","title":"\ud83c\udfaf MT5Account API Reference","text":"<p>Documentation Status</p> <p>Auto-generated from source code (<code>package/MetaRpcMT5/helpers/mt5_account.py</code>) and enhanced for readability. Complete API reference with enhanced navigation. Single-page format for easy browsing.</p>"},{"location":"API_Reference/MT5Account/#overview","title":"\ud83d\udccc Overview","text":"<p>MT5Account represents a low-level async Python client for MetaTrader 5 terminal via gRPC protocol. API methods accept typed parameters and return either protobuf Data objects or native Python types (float, int, str). This is the foundation layer that directly communicates with the MT5 gRPC server, providing automatic reconnection, error handling, and streaming capabilities.</p> <p>Key Features</p> <ul> <li>\u2705 Async/await API for most operations (42 async methods + 4 sync constructors/utilities)</li> <li>\u2705 Automatic reconnection on transient errors (UNAVAILABLE, TERMINAL_INSTANCE_NOT_FOUND)</li> <li>\u2705 Built-in error handling and retry logic via execute_with_reconnect wrappers</li> <li>\u2705 Streaming support for real-time data (5 async generators: ticks, trades, positions, profit, transactions)</li> <li>\u2705 Complete trading operations (market/pending orders, modifications, closures)</li> <li>\u2705 Comprehensive account, symbol, and position information retrieval (40+ methods)</li> </ul> <p>Detailed Guides Available</p> <p>For in-depth understanding of each method group with examples and best practices, see:</p> <ul> <li>\ud83d\udcd6 MT5Account Master Overview - Complete low-level API guide</li> <li>\ud83d\udc64 Account Information - Balance, equity, margin methods</li> <li>\ud83d\udcca Symbol Information - Symbol properties, ticks, sessions</li> <li>\ud83d\udcc8 Positions &amp; Orders - Position/order snapshots and history</li> <li>\ud83d\udcd6 Market Depth - Level II quotes (DOM)</li> <li>\ud83d\udcb0 Trading Operations - Order execution and validation</li> <li>\ud83d\udce1 Streaming Methods - Real-time data streams</li> </ul>"},{"location":"API_Reference/MT5Account/#table-of-contents","title":"\ud83d\udcd1 Table of Contents","text":""},{"location":"API_Reference/MT5Account/#initialization","title":"\ud83d\udd27 Initialization","text":"<ul> <li>init \u2014 Initialize MT5Account instance</li> <li>create \u2014 Factory method with UUID generation</li> </ul>"},{"location":"API_Reference/MT5Account/#connection","title":"\ud83d\udd0c Connection","text":"<ul> <li>connect_by_server_name \u2014 Connect using MT5 server name</li> <li>connect_by_host_port \u2014 Connect using host:port</li> </ul>"},{"location":"API_Reference/MT5Account/#account-info","title":"\ud83d\udc64 Account Info","text":"<ul> <li>account_summary \u2014 Full account information</li> <li>account_info_double \u2014 Account float property</li> <li>account_info_integer \u2014 Account integer property</li> <li>account_info_string \u2014 Account string property</li> </ul>"},{"location":"API_Reference/MT5Account/#symbol-info","title":"\ud83d\udcca Symbol Info","text":"<ul> <li>symbols_total \u2014 Total symbols count</li> <li>symbol_exist \u2014 Check symbol existence</li> <li>symbol_name \u2014 Get symbol name by index</li> <li>symbol_select \u2014 Select/deselect symbol</li> <li>symbol_is_synchronized \u2014 Check symbol sync status</li> <li>symbol_info_double \u2014 Symbol float property</li> <li>symbol_info_integer \u2014 Symbol integer property</li> <li>symbol_info_string \u2014 Symbol string property</li> <li>symbol_info_margin_rate \u2014 Margin rate for order type</li> <li>symbol_info_tick \u2014 Latest tick data</li> <li>symbol_info_session_quote \u2014 Quote session times</li> <li>symbol_info_session_trade \u2014 Trade session times</li> <li>symbol_params_many \u2014 Batch symbol parameters</li> </ul>"},{"location":"API_Reference/MT5Account/#positions-orders","title":"\ud83d\udcc8 Positions &amp; Orders","text":"<ul> <li>positions_total \u2014 Total open positions count</li> <li>opened_orders \u2014 All opened orders and positions</li> <li>opened_orders_tickets \u2014 Tickets snapshot</li> <li>order_history \u2014 Historical orders</li> <li>positions_history \u2014 Historical positions</li> <li>tick_value_with_size \u2014 Tick value calculations</li> </ul>"},{"location":"API_Reference/MT5Account/#market-depth","title":"\ud83d\udcd6 Market Depth","text":"<ul> <li>market_book_add \u2014 Subscribe to DOM</li> <li>market_book_get \u2014 Get current DOM</li> <li>market_book_release \u2014 Unsubscribe from DOM</li> </ul>"},{"location":"API_Reference/MT5Account/#trading","title":"\ud83d\udcb0 Trading","text":"<ul> <li>order_send \u2014 Send trading order</li> <li>order_modify \u2014 Modify existing order</li> <li>order_close \u2014 Close position</li> <li>order_check \u2014 Check order validity</li> <li>order_calc_margin \u2014 Calculate required margin</li> <li>order_calc_profit \u2014 Calculate profit/loss</li> </ul>"},{"location":"API_Reference/MT5Account/#streaming","title":"\ud83d\udce1 Streaming","text":"<ul> <li>on_symbol_tick \u2014 Real-time tick stream</li> <li>on_trade \u2014 Trade event stream</li> <li>on_position_profit \u2014 Position profit updates</li> <li>on_positions_and_pending_orders_tickets \u2014 Tickets stream</li> <li>on_trade_transaction \u2014 Transaction event stream</li> </ul>"},{"location":"API_Reference/MT5Account/#internal","title":"\ud83d\udd27 Internal","text":"<ul> <li>get_headers \u2014 Get gRPC headers</li> <li>reconnect \u2014 Reconnect to MT5</li> <li>execute_with_reconnect \u2014 Execute with auto-reconnect</li> <li>execute_stream_with_reconnect \u2014 Stream with auto-reconnect</li> </ul>"},{"location":"API_Reference/MT5Account/#class-mt5account","title":"\ud83c\udfd7\ufe0f Class: MT5Account","text":"<p>Source: Line 122</p> <p>Low-level gRPC client for MetaTrader 5 terminal operations.</p> <p>MT5Account provides direct protobuf-based interface to MT5 terminal operations including account management, symbol queries, position tracking, market depth, trading operations, and real-time streaming. Most methods use async/await patterns and include automatic reconnection on transient errors.</p> <p>Recommended Usage</p> <ol> <li>Use <code>MT5Account.create()</code> to create instance with auto-generated UUID</li> <li>Connect using <code>connect_by_server_name()</code> (recommended) or <code>connect_by_host_port()</code></li> <li>Call async methods to interact with MT5</li> <li>Close connection with <code>await account.channel.close()</code></li> </ol> <p>Constructor Requirements</p> <ul> <li>Requires MT5 credentials (user, password) and gRPC server address</li> <li>Optional terminal instance UUID (if None, must use factory method <code>create()</code>)</li> <li>Establishes secure gRPC channel with TLS, keepalive, and 100MB message limits</li> </ul>"},{"location":"API_Reference/MT5Account/#initialization-factory-methods","title":"\ud83d\udd27 Initialization &amp; Factory Methods","text":""},{"location":"API_Reference/MT5Account/#init","title":"init","text":"<p>Signature: <code>def __init__(self, user, password, grpc_server, id_)</code></p> <p>Source: Line 123</p> <p>Initialize MT5Account with gRPC connection.</p> <p>Parameters:</p> Parameter Type Description <code>user</code> int MT5 account login <code>password</code> str MT5 account password <code>grpc_server</code> str gRPC server address (default: \"mt5.mrpc.pro:443\") <code>id_</code> UUID Terminal instance UUID (auto-generated if not provided)"},{"location":"API_Reference/MT5Account/#create","title":"create","text":"<p>Signature: <code>def create(cls, user, password, grpc_server, id_) -&gt; MT5Account</code></p> <p>Source: Line 200</p> <p>Create MT5Account instance with explicit UUID.</p> <p>Factory method that creates a new MT5Account with gRPC connection. The connection is established with TLS, keepalive, and automatic reconnect configured.</p> <p>Parameters:</p> Parameter Type Description <code>user</code> int MT5 account login number <code>password</code> str MT5 account password <code>grpc_server</code> str gRPC server address (default: \"mt5.mrpc.pro:443\" if empty) <code>id_</code> UUID Terminal instance UUID (optional, will be generated if not provided) <p>Returns: <code>MT5Account</code> - Initialized account instance (not yet connected to MT5 server)</p> <p>Usage Example</p> <pre><code>from uuid import uuid4\naccount = MT5Account.create(\n    user=12345678,\n    password=\"mypassword\",\n    grpc_server=\"mt5.mrpc.pro:443\",\n    id_=uuid4()\n)\nawait account.connect_by_server_name(\"MetaQuotes-Demo\", \"EURUSD\")\n</code></pre>"},{"location":"API_Reference/MT5Account/#connection-methods","title":"\ud83d\udd0c Connection Methods","text":""},{"location":"API_Reference/MT5Account/#connect_by_server_name","title":"connect_by_server_name","text":"<p>Signature: <code>async def connect_by_server_name(self, server_name, base_chart_symbol, wait_for_terminal_is_alive, timeout_seconds, deadline)</code></p> <p>Source: Line 463</p> <p>Recommended Method</p> <p>This is the RECOMMENDED connection method - simpler than connect_by_host_port. Used in all demonstration examples via create_and_connect_mt5() helper.</p> <p>Connects to MT5 server by broker server name (cluster name).</p> <p>The method establishes connection to MT5 terminal, waits for terminal readiness, and updates the instance GUID (self.id) from server response.</p> <p>Parameters:</p> Parameter Type Default Description <code>server_name</code> str - MT5 broker server/cluster name (e.g., \"MetaQuotes-Demo\") <code>base_chart_symbol</code> str \"EURUSD\" Base symbol for chart initialization <code>wait_for_terminal_is_alive</code> bool True Wait for terminal readiness before returning <code>timeout_seconds</code> int 30 Timeout in seconds for terminal readiness waiting <code>deadline</code> datetime None Deadline for gRPC call completion <p>Raises:</p> <ul> <li><code>ApiExceptionMT5</code> - If the server returns an error in the response</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails due to communication errors</li> </ul> <p>Usage Example</p> <pre><code>account = MT5Account(user=12345, password=\"pass\", grpc_server=\"localhost:9999\")\nawait account.connect_by_server_name(\"MetaQuotes-Demo\", \"EURUSD\")\nprint(f\"Connected! Terminal GUID: {account.id}\")\n</code></pre>"},{"location":"API_Reference/MT5Account/#connect_by_host_port","title":"connect_by_host_port","text":"<p>Signature: <code>async def connect_by_host_port(self, host, port, base_chart_symbol, wait_for_terminal_is_alive, timeout_seconds, deadline)</code></p> <p>Source: Line 394</p> <p>Connects to MT5 server by IP address or hostname and port.</p> <p>Alternative connection method when you know the exact server address. For most cases, use connect_by_server_name() instead (simpler and recommended).</p> <p>The method establishes connection to MT5 terminal, waits for terminal readiness, and updates the instance GUID (self.id) from server response.</p> <p>Parameters:</p> Parameter Type Default Description <code>host</code> str - Server IP address or hostname (e.g., \"mt5.broker.com\") <code>port</code> int 443 Server port number <code>base_chart_symbol</code> str \"EURUSD\" Base symbol for chart initialization <code>wait_for_terminal_is_alive</code> bool True Wait for terminal readiness before returning <code>timeout_seconds</code> int 30 Timeout in seconds for terminal readiness waiting <code>deadline</code> datetime None Deadline for gRPC call completion <p>Raises:</p> <ul> <li><code>ApiExceptionMT5</code> - If the server returns an error in the response</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails due to communication errors</li> </ul> <p>Usage Example</p> <pre><code>account = MT5Account(user=12345, password=\"pass\", grpc_server=\"localhost:9999\")\nawait account.connect_by_host_port(\"mt5.broker.com\", 443, \"EURUSD\")\nprint(f\"Connected! Terminal GUID: {account.id}\")\n</code></pre>"},{"location":"API_Reference/MT5Account/#account-information-methods","title":"\ud83d\udc64 Account Information Methods","text":""},{"location":"API_Reference/MT5Account/#account_summary","title":"account_summary","text":"<p>Signature: <code>async def account_summary(self, deadline, cancellation_event)</code></p> <p>Source: Line 532</p> <p>Gets the summary information for a trading account asynchronously.</p> <p>Parameters:</p> Parameter Type Description <code>deadline</code> datetime Deadline after which the request will be canceled if not completed <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>AccountSummaryData</code> - The server's response containing account summary data</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected before calling this method</li> <li><code>ApiExceptionMT5</code> - If the server returns an error in the response</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails due to communication or protocol errors</li> </ul>"},{"location":"API_Reference/MT5Account/#account_info_double","title":"account_info_double","text":"<p>Signature: <code>async def account_info_double(self, property_id, deadline, cancellation_event) -&gt; float</code></p> <p>Source: Line 579</p> <p>Retrieves a double-precision account property (e.g. balance, equity, margin).</p> <p>Parameters:</p> Parameter Type Description <code>property_id</code> AccountInfoDoublePropertyType The account double property to retrieve <code>deadline</code> datetime Deadline after which the call will be cancelled <code>cancellation_event</code> asyncio.Event Event to cancel the operation <p>Returns: <code>float</code> - The double value of the requested account property</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#account_info_integer","title":"account_info_integer","text":"<p>Signature: <code>async def account_info_integer(self, property_id, deadline, cancellation_event) -&gt; int</code></p> <p>Source: Line 622</p> <p>Retrieves an integer account property (e.g. login, leverage, trade mode).</p> <p>Parameters:</p> Parameter Type Description <code>property_id</code> AccountInfoIntegerPropertyType The account integer property to retrieve <code>deadline</code> datetime Deadline after which the call will be cancelled <code>cancellation_event</code> asyncio.Event Event to cancel the operation <p>Returns: <code>int</code> - The integer value of the requested account property</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#account_info_string","title":"account_info_string","text":"<p>Signature: <code>async def account_info_string(self, property_id, deadline, cancellation_event) -&gt; str</code></p> <p>Source: Line 665</p> <p>Retrieves a string account property (e.g. account name, currency, server).</p> <p>Parameters:</p> Parameter Type Description <code>property_id</code> AccountInfoStringPropertyType The account string property to retrieve <code>deadline</code> datetime Deadline after which the call will be cancelled <code>cancellation_event</code> asyncio.Event Event to cancel the operation <p>Returns: <code>str</code> - The string value of the requested account property</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#symbol-information-methods","title":"\ud83d\udcca Symbol Information Methods","text":""},{"location":"API_Reference/MT5Account/#symbols_total","title":"symbols_total","text":"<p>Signature: <code>async def symbols_total(self, selected_only, deadline, cancellation_event)</code></p> <p>Source: Line 714</p> <p>Returns the total number of symbols available on the platform.</p> <p>Parameters:</p> Parameter Type Description <code>selected_only</code> bool True to count only Market Watch symbols, false to count all <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>SymbolsTotalData</code> - Total symbol count data</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#symbol_exist","title":"symbol_exist","text":"<p>Signature: <code>async def symbol_exist(self, symbol, deadline, cancellation_event)</code></p> <p>Source: Line 757</p> <p>Checks if a symbol with the specified name exists (standard or custom).</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str The symbol name to check <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>SymbolExistData</code> - Information about symbol existence and type</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#symbol_name","title":"symbol_name","text":"<p>Signature: <code>async def symbol_name(self, index, selected, deadline, cancellation_event)</code></p> <p>Source: Line 800</p> <p>Returns the name of a symbol by index.</p> <p>Parameters:</p> Parameter Type Description <code>index</code> int Symbol index (starting at 0) <code>selected</code> bool True to use only Market Watch symbols <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>SymbolNameData</code> - The symbol name at the specified index</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#symbol_select","title":"symbol_select","text":"<p>Signature: <code>async def symbol_select(self, symbol, select, deadline, cancellation_event)</code></p> <p>Source: Line 845</p> <p>Adds or removes a symbol from Market Watch.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>select</code> bool True to add, false to remove <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>SymbolSelectData</code> - Success status of the operation</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#symbol_is_synchronized","title":"symbol_is_synchronized","text":"<p>Signature: <code>async def symbol_is_synchronized(self, symbol, deadline, cancellation_event)</code></p> <p>Source: Line 890</p> <p>Checks if the symbol's data is synchronized with the server.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name to check <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>SymbolIsSynchronizedData</code> - True if synchronized, false otherwise</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#symbol_info_double","title":"symbol_info_double","text":"<p>Signature: <code>async def symbol_info_double(self, symbol, property, deadline, cancellation_event)</code></p> <p>Source: Line 933</p> <p>Retrieves a double-precision property value of a symbol.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>property</code> SymbolInfoDoubleProperty The double-type property to retrieve <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>SymbolInfoDoubleData</code> - The double property value</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#symbol_info_integer","title":"symbol_info_integer","text":"<p>Signature: <code>async def symbol_info_integer(self, symbol, property, deadline, cancellation_event)</code></p> <p>Source: Line 978</p> <p>Retrieves an integer-type property value of a symbol.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>property</code> SymbolInfoIntegerProperty The integer property to query <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>SymbolInfoIntegerData</code> - The integer property value</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#symbol_info_string","title":"symbol_info_string","text":"<p>Signature: <code>async def symbol_info_string(self, symbol, property, deadline, cancellation_event)</code></p> <p>Source: Line 1023</p> <p>Retrieves a string-type property value of a symbol.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>property</code> SymbolInfoStringProperty The string property to retrieve <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>SymbolInfoStringData</code> - The string property value</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#symbol_info_margin_rate","title":"symbol_info_margin_rate","text":"<p>Signature: <code>async def symbol_info_margin_rate(self, symbol, order_type, deadline, cancellation_event)</code></p> <p>Source: Line 1068</p> <p>Retrieves the margin rates for a given symbol and order type.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>order_type</code> ENUM_ORDER_TYPE The order type (buy/sell/etc) <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>SymbolInfoMarginRateData</code> - The initial and maintenance margin rates</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#symbol_info_tick","title":"symbol_info_tick","text":"<p>Signature: <code>async def symbol_info_tick(self, symbol, deadline, cancellation_event)</code></p> <p>Source: Line 1113</p> <p>Retrieves the current tick data (bid, ask, last, volume) for a given symbol.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name to fetch tick info for <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>MrpcMqlTick</code> - The latest tick information</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns an error in the response</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#symbol_info_session_quote","title":"symbol_info_session_quote","text":"<p>Signature: <code>async def symbol_info_session_quote(self, symbol, day_of_week, session_index, deadline, cancellation_event)</code></p> <p>Source: Line 1156</p> <p>Gets the quoting session start and end time for a symbol on a specific day and session index.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str The symbol name <code>day_of_week</code> DayOfWeek The day of the week <code>session_index</code> int Index of the quoting session (starting at 0) <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>SymbolInfoSessionQuoteData</code> - The session quote start and end time</p>"},{"location":"API_Reference/MT5Account/#symbol_info_session_trade","title":"symbol_info_session_trade","text":"<p>Signature: <code>async def symbol_info_session_trade(self, symbol, day_of_week, session_index, deadline, cancellation_event)</code></p> <p>Source: Line 1202</p> <p>Gets the trading session start and end time for a symbol on a specific day and session index.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str The symbol name <code>day_of_week</code> DayOfWeek The day of the week <code>session_index</code> int Index of the trading session (starting at 0) <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>SymbolInfoSessionTradeData</code> - The trading session start and end time</p>"},{"location":"API_Reference/MT5Account/#symbol_params_many","title":"symbol_params_many","text":"<p>Signature: <code>async def symbol_params_many(self, request, deadline, cancellation_event)</code></p> <p>Source: Line 1248</p> <p>Retrieves symbol parameters for multiple instruments asynchronously.</p> <p>Parameters:</p> Parameter Type Description <code>request</code> SymbolParamsManyRequest The request containing filters and pagination <code>deadline</code> datetime Deadline after which the request will be canceled <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>SymbolParamsManyData</code> - Symbol parameter details</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected before calling this method</li> <li><code>ApiExceptionMT5</code> - If the server returns an error in the response</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails due to communication or protocol errors</li> </ul>"},{"location":"API_Reference/MT5Account/#positions-orders-methods","title":"\ud83d\udcc8 Positions &amp; Orders Methods","text":""},{"location":"API_Reference/MT5Account/#positions_total","title":"positions_total","text":"<p>Signature: <code>async def positions_total(self, deadline, cancellation_event)</code></p> <p>Source: Line 1299</p> <p>Returns the total number of open positions on the current account.</p> <p>Parameters:</p> Parameter Type Description <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>PositionsTotalData</code> - The total number of open positions</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If gRPC fails to connect or respond</li> </ul>"},{"location":"API_Reference/MT5Account/#opened_orders","title":"opened_orders","text":"<p>Signature: <code>async def opened_orders(self, sort_mode, deadline, cancellation_event)</code></p> <p>Source: Line 1343</p> <p>Gets the currently opened orders and positions for the connected account asynchronously.</p> <p>Parameters:</p> Parameter Type Description <code>sort_mode</code> BMT5_ENUM_OPENED_ORDER_SORT_TYPE The sort mode for the opened orders (0 - open time, 1 - close time, 2 - ticket ID) <code>deadline</code> datetime Deadline after which the request will be canceled if not completed <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>OpenedOrdersData</code> - The result containing opened orders and positions</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected before calling this method</li> <li><code>ApiExceptionMT5</code> - If the server returns an error in the response</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails due to communication or protocol errors</li> </ul>"},{"location":"API_Reference/MT5Account/#opened_orders_tickets","title":"opened_orders_tickets","text":"<p>Signature: <code>async def opened_orders_tickets(self, deadline, cancellation_event)</code></p> <p>Source: Line 1392</p> <p>Gets ticket IDs of all currently opened orders and positions asynchronously.</p> <p>Parameters:</p> Parameter Type Description <code>deadline</code> datetime Deadline after which the request will be canceled <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>OpenedOrdersTicketsData</code> - Collection of opened order and position tickets</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected before calling this method</li> <li><code>ApiExceptionMT5</code> - If the server returns an error in the response</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails due to communication or protocol errors</li> </ul>"},{"location":"API_Reference/MT5Account/#order_history","title":"order_history","text":"<p>Signature: <code>async def order_history(self, from_dt, to_dt, sort_mode, page_number, items_per_page, deadline, cancellation_event)</code></p> <p>Source: Line 1437</p> <p>Gets the historical orders for the connected trading account within the specified time range asynchronously.</p> <p>Parameters:</p> Parameter Type Description <code>from_dt</code> datetime The start time for the history query (server time) <code>to_dt</code> datetime The end time for the history query (server time) <code>sort_mode</code> BMT5_ENUM_ORDER_HISTORY_SORT_TYPE The sort mode (0 - by open time, 1 - by close time, 2 - by ticket ID) <code>page_number</code> int Page number for paginated results (default 0) <code>items_per_page</code> int Number of items per page (default 0 = all) <code>deadline</code> datetime Deadline after which the request will be canceled <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>OrdersHistoryData</code> - The server's response containing paged historical order data</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected before calling this method</li> <li><code>ApiExceptionMT5</code> - If the server returns an error in the response</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails due to communication or protocol errors</li> </ul>"},{"location":"API_Reference/MT5Account/#positions_history","title":"positions_history","text":"<p>Signature: <code>async def positions_history(self, sort_type, open_from, open_to, page, size, deadline, cancellation_event)</code></p> <p>Source: Line 1502</p> <p>Retrieves historical positions based on filter and time range asynchronously.</p> <p>Parameters:</p> Parameter Type Description <code>sort_type</code> AH_ENUM_POSITIONS_HISTORY_SORT_TYPE Sorting type for historical positions <code>open_from</code> datetime Start of open time filter (UTC) <code>open_to</code> datetime End of open time filter (UTC) <code>page</code> int Page number for paginated results (default 0) <code>size</code> int Number of items per page (default 0 = all) <code>deadline</code> datetime Deadline after which the request will be canceled <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>PositionsHistoryData</code> - Historical position records</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected before calling this method</li> <li><code>ApiExceptionMT5</code> - If the server returns an error in the response</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails due to communication or protocol errors</li> </ul>"},{"location":"API_Reference/MT5Account/#tick_value_with_size","title":"tick_value_with_size","text":"<p>Signature: <code>async def tick_value_with_size(self, symbols, deadline, cancellation_event)</code></p> <p>Source: Line 1566</p> <p>Gets tick value and tick size data for the given symbols asynchronously.</p> <p>Parameters:</p> Parameter Type Description <code>symbols</code> list[str] List of symbol names <code>deadline</code> datetime Deadline after which the request will be canceled <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>TickValueWithSizeData</code> - Tick value and contract size info per symbol</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected before calling this method</li> <li><code>ApiExceptionMT5</code> - If the server returns an error in the response</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails due to communication or protocol errors</li> </ul>"},{"location":"API_Reference/MT5Account/#market-depth-dom-methods","title":"\ud83d\udcd6 Market Depth (DOM) Methods","text":""},{"location":"API_Reference/MT5Account/#market_book_add","title":"market_book_add","text":"<p>Signature: <code>async def market_book_add(self, symbol, deadline, cancellation_event)</code></p> <p>Source: Line 1620</p> <p>Opens the Depth of Market (DOM) for a symbol and subscribes to updates.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name to subscribe <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>MarketBookAddData</code> - True if DOM subscription was successful</p>"},{"location":"API_Reference/MT5Account/#market_book_release","title":"market_book_release","text":"<p>Signature: <code>async def market_book_release(self, symbol, deadline, cancellation_event)</code></p> <p>Source: Line 1658</p> <p>Releases the Depth of Market (DOM) for a symbol and stops receiving updates.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name to unsubscribe <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>MarketBookReleaseData</code> - True if DOM release was successful</p>"},{"location":"API_Reference/MT5Account/#market_book_get","title":"market_book_get","text":"<p>Signature: <code>async def market_book_get(self, symbol, deadline, cancellation_event)</code></p> <p>Source: Line 1696</p> <p>Gets the current Depth of Market (DOM) data for a symbol.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>MarketBookGetData</code> - A list of book entries for the symbol's DOM</p>"},{"location":"API_Reference/MT5Account/#trading-operations-methods","title":"\ud83d\udcb0 Trading Operations Methods","text":""},{"location":"API_Reference/MT5Account/#order_send","title":"order_send","text":"<p>Signature: <code>async def order_send(self, request, deadline, cancellation_event) -&gt; trading_helper_pb2.OrderSendData</code></p> <p>Source: Line 1740</p> <p>Sends a market or pending order to the trading server asynchronously.</p> <p>Parameters:</p> Parameter Type Description <code>request</code> OrderSendRequest The order request to send <code>deadline</code> datetime Deadline for the operation <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>OrderSendData</code> - Response with deal/order confirmation data</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns an error in the response</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#order_modify","title":"order_modify","text":"<p>Signature: <code>async def order_modify(self, request, deadline, cancellation_event)</code></p> <p>Source: Line 1785</p> <p>Modifies an existing order or position asynchronously.</p> <p>Parameters:</p> Parameter Type Description <code>request</code> OrderModifyRequest The modification request (SL, TP, price, expiration, etc.) <code>deadline</code> datetime Deadline for the operation <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>OrderModifyData</code> - Response containing updated order/deal info</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns an error in the response</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#order_close","title":"order_close","text":"<p>Signature: <code>async def order_close(self, request, deadline, cancellation_event)</code></p> <p>Source: Line 1830</p> <p>Closes a market or pending order asynchronously.</p> <p>Parameters:</p> Parameter Type Description <code>request</code> OrderCloseRequest The close request including ticket, volume, and slippage <code>deadline</code> datetime Deadline for the operation <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>OrderCloseData</code> - The close result and return codes</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns an error in the response</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails</li> </ul>"},{"location":"API_Reference/MT5Account/#order_check","title":"order_check","text":"<p>Signature: <code>async def order_check(self, request, deadline, cancellation_event)</code></p> <p>Source: Line 1875</p> <p>Checks whether a trade request can be successfully executed under current market conditions.</p> <p>Parameters:</p> Parameter Type Description <code>request</code> OrderCheckRequest The trade request to validate <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>OrderCheckData</code> - Result of the trade request check, including margin and balance details</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If gRPC fails to connect or respond</li> </ul>"},{"location":"API_Reference/MT5Account/#order_calc_margin","title":"order_calc_margin","text":"<p>Signature: <code>async def order_calc_margin(self, request, deadline, cancellation_event)</code></p> <p>Source: Line 1919</p> <p>Calculates the margin required for a planned trade operation.</p> <p>Parameters:</p> Parameter Type Description <code>request</code> OrderCalcMarginRequest The request containing symbol, order type, volume, and price <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>OrderCalcMarginData</code> - The required margin in account currency</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If gRPC fails to connect or respond</li> </ul>"},{"location":"API_Reference/MT5Account/#order_calc_profit","title":"order_calc_profit","text":"<p>Signature: <code>async def order_calc_profit(self, request, deadline, cancellation_event)</code></p> <p>Source: Line 1963</p> <p>Calculates potential profit/loss for a planned trade operation.</p> <p>Parameters:</p> Parameter Type Description <code>request</code> OrderCalcProfitRequest The request containing symbol, order type, volume, open price, and close price <code>deadline</code> datetime Deadline for the gRPC call <code>cancellation_event</code> asyncio.Event Event to cancel the request <p>Returns: <code>OrderCalcProfitData</code> - The potential profit/loss in account currency</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the client is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a business error</li> <li><code>grpc.aio.AioRpcError</code> - If gRPC fails to connect or respond</li> </ul>"},{"location":"API_Reference/MT5Account/#streaming-methods","title":"\ud83d\udce1 Streaming Methods","text":""},{"location":"API_Reference/MT5Account/#on_symbol_tick","title":"on_symbol_tick","text":"<p>Signature: <code>async def on_symbol_tick(self, symbols, cancellation_event)</code></p> <p>Source: Line 2013</p> <p>Subscribes to real-time tick data for specified symbols.</p> <p>Parameters:</p> Parameter Type Description <code>symbols</code> list[str] The symbol names to subscribe to <code>cancellation_event</code> asyncio.Event Event to cancel streaming <p>Yields: <code>OnSymbolTickData</code> - Async stream of tick data responses</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected before calling this method</li> <li><code>ApiExceptionMT5</code> - If the server returns an error in the stream</li> <li><code>grpc.aio.AioRpcError</code> - If the stream fails due to communication or protocol errors</li> </ul>"},{"location":"API_Reference/MT5Account/#on_trade","title":"on_trade","text":"<p>Signature: <code>async def on_trade(self, cancellation_event)</code></p> <p>Source: Line 2048</p> <p>Subscribes to all trade-related events: orders, deals, positions.</p> <p>Parameters:</p> Parameter Type Description <code>cancellation_event</code> asyncio.Event Event to cancel streaming <p>Yields: <code>OnTradeData</code> - Trade event data</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a known API error</li> <li><code>grpc.aio.AioRpcError</code> - If the stream fails due to communication or protocol errors</li> </ul>"},{"location":"API_Reference/MT5Account/#on_position_profit","title":"on_position_profit","text":"<p>Signature: <code>async def on_position_profit(self, interval_ms, ignore_empty, cancellation_event)</code></p> <p>Source: Line 2080</p> <p>Subscribes to real-time profit updates for open positions.</p> <p>Parameters:</p> Parameter Type Description <code>interval_ms</code> int Interval in milliseconds to poll the server <code>ignore_empty</code> bool Skip frames with no change <code>cancellation_event</code> asyncio.Event Event to cancel streaming <p>Yields: <code>OnPositionProfitData</code> - Profit update data</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a known API error</li> <li><code>grpc.aio.AioRpcError</code> - If the stream fails due to communication or protocol errors</li> </ul>"},{"location":"API_Reference/MT5Account/#on_positions_and_pending_orders_tickets","title":"on_positions_and_pending_orders_tickets","text":"<p>Signature: <code>async def on_positions_and_pending_orders_tickets(self, interval_ms, cancellation_event)</code></p> <p>Source: Line 2119</p> <p>Subscribes to updates of position and pending order ticket IDs.</p> <p>Parameters:</p> Parameter Type Description <code>interval_ms</code> int Polling interval in milliseconds <code>cancellation_event</code> asyncio.Event Event to cancel streaming <p>Yields: <code>OnPositionsAndPendingOrdersTicketsData</code> - Snapshot of tickets</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a known API error</li> <li><code>grpc.aio.AioRpcError</code> - If the stream fails due to communication or protocol errors</li> </ul>"},{"location":"API_Reference/MT5Account/#on_trade_transaction","title":"on_trade_transaction","text":"<p>Signature: <code>async def on_trade_transaction(self, cancellation_event)</code></p> <p>Source: Line 2155</p> <p>Subscribes to real-time trade transaction events such as order creation, update, or execution.</p> <p>Parameters:</p> Parameter Type Description <code>cancellation_event</code> asyncio.Event Event to cancel streaming <p>Yields: <code>OnTradeTransactionData</code> - Trade transaction replies</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If the account is not connected</li> <li><code>ApiExceptionMT5</code> - If the server returns a known API error</li> <li><code>grpc.aio.AioRpcError</code> - If the stream fails due to communication or protocol errors</li> </ul>"},{"location":"API_Reference/MT5Account/#internallow-level-methods","title":"\ud83d\udd27 Internal/Low-level Methods","text":"<p>Internal Methods</p> <p>These methods are used internally by the MT5Account class. Regular users don't need to call them directly. All public API methods already include proper usage of these internal helpers.</p>"},{"location":"API_Reference/MT5Account/#get_headers","title":"get_headers","text":"<p>Signature: <code>def get_headers(self)</code></p> <p>Source: Line 277</p> <p>Returns gRPC metadata headers for API requests.</p> <p>Internal helper method that constructs gRPC metadata headers containing the terminal instance UUID. Used automatically by execute_with_reconnect and execute_stream_with_reconnect wrappers.</p> <p>Returns: <code>list[tuple[str, str]]</code> - List of metadata tuples containing (\"id\", terminal_uuid)</p> <p>Note</p> <p>This is an internal method. Regular users don't need to call it directly. All public API methods already include proper headers automatically.</p>"},{"location":"API_Reference/MT5Account/#reconnect","title":"reconnect","text":"<p>Signature: <code>async def reconnect(self, deadline)</code></p> <p>Source: Line 280</p> <p>Reconnects to MT5 terminal using previously saved connection parameters.</p> <p>Internal method that re-establishes connection to MT5 terminal using the connection parameters from the last successful connect_by_server_name() or connect_by_host_port() call. Automatically called by execute_with_reconnect wrappers on transient connection errors.</p> <p>Parameters:</p> Parameter Type Description <code>deadline</code> datetime Deadline for gRPC call completion <p>Raises:</p> <ul> <li><code>ApiExceptionMT5</code> - If the server returns an error in the response</li> <li><code>grpc.aio.AioRpcError</code> - If the gRPC call fails due to communication errors</li> </ul> <p>Note</p> <p>This is an internal method used by automatic reconnection logic. Regular users don't need to call it manually - reconnection happens automatically when needed.</p>"},{"location":"API_Reference/MT5Account/#execute_with_reconnect","title":"execute_with_reconnect","text":"<p>Signature: <code>async def execute_with_reconnect(self, grpc_call, error_selector, deadline, cancellation_event)</code></p> <p>Source: Line 289</p> <p>Executes a gRPC unary call with automatic reconnection on transient errors.</p> <p>Internal wrapper method that executes a gRPC unary (request-response) call with built-in resilience against transient network errors and terminal restarts. Automatically reconnects on UNAVAILABLE errors and TERMINAL_INSTANCE_NOT_FOUND errors, then retries the operation.</p> <p>All public API methods (account_info_double, symbol_info_tick, order_send, etc.) use this wrapper internally to provide automatic reconnection.</p> <p>Parameters:</p> Parameter Type Description <code>grpc_call</code> Callable A function that performs the gRPC call. Takes headers as parameter and returns the response <code>error_selector</code> Callable A function that extracts error object from response. Return object with .error_code to check for reconnection-triggering errors <code>deadline</code> datetime Deadline for gRPC call completion <code>cancellation_event</code> asyncio.Event Event to cancel the operation <p>Returns: <code>Any</code> - The response from the successful gRPC call</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If reconnection fails due to missing connection context</li> <li><code>ApiExceptionMT5</code> - If the server returns a business logic error</li> <li><code>grpc.aio.AioRpcError</code> - If a non-recoverable gRPC error occurs</li> <li><code>asyncio.CancelledError</code> - If operation was cancelled via cancellation_event</li> </ul> <p>Note</p> <p>This is an internal method. Regular users don't need to call it directly. It's used as a wrapper by all public API methods for automatic resilience.</p>"},{"location":"API_Reference/MT5Account/#execute_stream_with_reconnect","title":"execute_stream_with_reconnect","text":"<p>Signature: <code>async def execute_stream_with_reconnect(self, request, stream_invoker, get_error, get_data, cancellation_event)</code></p> <p>Source: Line 320</p> <p>Executes a gRPC server-streaming call with automatic reconnection logic on recoverable errors.</p> <p>Parameters:</p> Parameter Type Description <code>request</code> - The request object to initiate the stream with <code>stream_invoker</code> Callable A function that opens the stream. It receives the request and metadata headers, and returns an async streaming call <code>get_error</code> Callable A function that extracts the error object (if any) from a reply. Return an object with .error_code == \"TERMINAL_INSTANCE_NOT_FOUND\" to trigger reconnect, or any non-null error to raise ApiExceptionMT5 <code>get_data</code> Callable A function that extracts the data object from a reply. If it returns None, the message is skipped <code>cancellation_event</code> asyncio.Event Event to cancel streaming and reconnection attempts <p>Yields: Extracted data items streamed from the server</p> <p>Raises:</p> <ul> <li><code>ConnectExceptionMT5</code> - If reconnection logic fails due to missing account context</li> <li><code>ApiExceptionMT5</code> - When the stream response contains a known API error</li> <li><code>grpc.aio.AioRpcError</code> - If a non-recoverable gRPC error occurs</li> </ul>"},{"location":"API_Reference/MT5Service/","title":"\ud83c\udfaf MT5Service API Reference","text":"<p>Documentation Status</p> <p>Auto-generated from source code (<code>src/pymt5/mt5_service.py</code>) and enhanced for readability. Complete API reference with enhanced navigation. Single-page format for easy browsing.</p>"},{"location":"API_Reference/MT5Service/#overview","title":"\ud83d\udccc Overview","text":"<p>MT5Service represents a mid-level Python wrapper over MT5Account (low-level gRPC client). It provides clean Python API with native types (float, int, str, datetime) instead of protobuf structures, automatically unpacks .data wrappers, converts timestamps, and reduces boilerplate code by 30-70% for common operations.</p> <p>Key Features</p> <ul> <li>\u2705 Native Python types instead of protobuf (float, int, str, datetime)</li> <li>\u2705 Automatic .data wrapper extraction (no manual <code>.data.requested_value</code> access)</li> <li>\u2705 Timestamp datetime conversion for all time fields</li> <li>\u2705 36 methods covering all MT5 operations (account, symbols, trading, streaming)</li> <li>\u2705 Cleaner API with dataclasses (AccountSummary, SymbolTick, OrderResult, etc.)</li> <li>\u2705 Built on top of MT5Account with automatic reconnection and error handling</li> </ul>"},{"location":"API_Reference/MT5Service/#important-understanding-mt5service-role","title":"\u26a0\ufe0f Important: Understanding MT5Service Role","text":"<p>This is a Middleware Layer - Not for Most Users</p> <p>MT5Service exists primarily for MT5Sugar's architectural needs.</p> <ul> <li>\ud83c\udfaf For most users: Use MT5Sugar instead (high-level, ready patterns)</li> <li>\ud83d\udd27 For advanced users: This layer is useful when you need specific mid-level operations</li> <li>\ud83d\udce6 Architectural purpose: Bridges protobuf (MT5Account) and business logic (MT5Sugar)</li> </ul> <p>Value Reality Check</p> <p>Not all 36 methods add equal value:</p> <ul> <li> <p>\u2705 HIGH value (8 methods): Complex protobuf unpacking + dataclass conversion</p> <ul> <li>Worth using directly: <code>get_account_summary()</code>, <code>get_symbol_params_many()</code>, <code>check_order()</code>, <code>place_order()</code>, <code>modify_order()</code>, etc.</li> </ul> </li> <li> <p>\u26aa MEDIUM/LOW value (10 methods): Simple field extraction</p> <ul> <li>Consider using if convenient, or call MT5Account directly</li> </ul> </li> <li> <p>\u26aa NONE value (18 methods!): Direct pass-through to MT5Account</p> <ul> <li>Just proxy calls like <code>return await account.method()</code> or <code>yield data</code></li> <li>For these, consider calling MT5Account directly to avoid extra layer</li> </ul> </li> </ul> <p>Detailed Guides Available</p> <p>For in-depth understanding of each method group, see:</p> <ul> <li>\ud83d\udcd6 Complete MT5Service Overview - Value analysis of all 36 methods</li> <li>\ud83d\udc64 Account Information - 4 methods (1 HIGH, 3 NONE)</li> <li>\ud83d\udcca Symbol Information - 13 methods (4 HIGH, 5 LOW, 4 NONE)</li> <li>\ud83d\udcc8 Positions &amp; Orders - 5 methods (1 MEDIUM, 1 LOW, 3 NONE)</li> <li>\ud83d\udcd6 Market Depth - 3 methods (1 HIGH, 2 MEDIUM)</li> <li>\ud83d\udcb0 Trading Operations - 6 methods (3 HIGH, 3 LOW)</li> <li>\ud83d\udce1 Streaming Methods - 5 methods (1 HIGH, 4 NONE)</li> </ul>"},{"location":"API_Reference/MT5Service/#table-of-contents","title":"\ud83d\udcd1 Table of Contents","text":""},{"location":"API_Reference/MT5Service/#account-information","title":"\ud83d\udc64 Account Information","text":"<ul> <li>get_account_summary \u2014 Complete account data in one call</li> <li>get_account_double \u2014 Account float property</li> <li>get_account_integer \u2014 Account integer property</li> <li>get_account_string \u2014 Account string property</li> </ul>"},{"location":"API_Reference/MT5Service/#symbol-information","title":"\ud83d\udcca Symbol Information","text":"<ul> <li>get_symbols_total \u2014 Total symbols count</li> <li>symbol_exist \u2014 Check symbol existence</li> <li>get_symbol_name \u2014 Get symbol name by index</li> <li>symbol_select \u2014 Add/remove symbol from Market Watch</li> <li>is_symbol_synchronized \u2014 Check symbol sync status</li> <li>get_symbol_double \u2014 Symbol float property</li> <li>get_symbol_integer \u2014 Symbol integer property</li> <li>get_symbol_string \u2014 Symbol string property</li> <li>get_symbol_margin_rate \u2014 Margin rates for symbol</li> <li>get_symbol_tick \u2014 Current market prices</li> <li>get_symbol_session_quote \u2014 Quote session times</li> <li>get_symbol_session_trade \u2014 Trade session times</li> <li>get_symbol_params_many \u2014 Batch symbol parameters</li> </ul>"},{"location":"API_Reference/MT5Service/#positions-orders","title":"\ud83d\udcc8 Positions &amp; Orders","text":"<ul> <li>get_positions_total \u2014 Total open positions count</li> <li>get_opened_orders \u2014 All opened orders and positions</li> <li>get_opened_tickets \u2014 Tickets snapshot (lightweight)</li> <li>get_order_history \u2014 Historical orders</li> <li>get_positions_history \u2014 Closed positions with P&amp;L</li> </ul>"},{"location":"API_Reference/MT5Service/#market-depth-dom","title":"\ud83d\udcd6 Market Depth (DOM)","text":"<ul> <li>subscribe_market_depth \u2014 Subscribe to DOM updates</li> <li>unsubscribe_market_depth \u2014 Unsubscribe from DOM</li> <li>get_market_depth \u2014 Current DOM snapshot</li> </ul>"},{"location":"API_Reference/MT5Service/#trading-operations","title":"\ud83d\udcb0 Trading Operations","text":"<ul> <li>place_order \u2014 Send market/pending order</li> <li>modify_order \u2014 Modify order or position</li> <li>close_order \u2014 Close position or delete order</li> <li>check_order \u2014 Validate order before sending</li> <li>calculate_margin \u2014 Calculate required margin</li> <li>calculate_profit \u2014 Calculate potential profit</li> </ul>"},{"location":"API_Reference/MT5Service/#streaming-methods","title":"\ud83d\udce1 Streaming Methods","text":"<ul> <li>stream_ticks \u2014 Real-time tick data stream</li> <li>stream_trade_updates \u2014 Trade events stream</li> <li>stream_position_profits \u2014 Position profit updates</li> <li>stream_opened_tickets \u2014 Tickets stream (lightweight)</li> <li>stream_transactions \u2014 Transaction event stream</li> </ul>"},{"location":"API_Reference/MT5Service/#class-mt5service","title":"\ud83c\udfd7\ufe0f Class: MT5Service","text":"<p>Source: Line 222</p> <p>Mid-level wrapper over MT5Account providing clean Python API with native types.</p> <p>MT5Service sits between the low-level MT5Account (protobuf gRPC client) and high-level business logic layers. It simplifies common operations by automatically unpacking protobuf wrappers, converting timestamps to datetime objects, and returning native Python types instead of protobuf structures. This reduces boilerplate code by 30-70% compared to using MT5Account directly.</p> <p>Architecture Position</p> <ul> <li>LOW MT5Account (protobuf Request/Data, direct gRPC)</li> <li>MID MT5Service (Python types, removes Data wrappers) \u2190 THIS CLASS</li> <li>HIGH MT5Sugar (business logic, ready-made patterns)</li> </ul> <p>Constructor Requirements</p> <ul> <li>Requires MT5Account instance (already connected low-level client)</li> <li>No direct connection logic - uses wrapped account's channel</li> <li>Lightweight wrapper - minimal overhead over MT5Account</li> </ul> <p>Usage Pattern</p> <ol> <li>Create and connect MT5Account instance</li> <li>Wrap it with <code>service = MT5Service(account)</code></li> <li>Call methods with cleaner API (returns native types)</li> <li>Close underlying account connection when done</li> </ol> <p>Key Advantages</p> <ul> <li>Native types: Returns <code>float</code>/<code>int</code>/<code>str</code>/<code>datetime</code> instead of protobuf wrappers</li> <li>Auto-unpacking: No manual <code>.data.requested_value</code> extraction needed</li> <li>Time conversion: Timestamps automatically converted to Python datetime</li> <li>Dataclasses: Clean DTOs (AccountSummary, SymbolTick, OrderResult, etc.)</li> <li>Code reduction: 30-70% less boilerplate for common operations</li> </ul>"},{"location":"API_Reference/MT5Service/#methods","title":"\ud83d\udd27 Methods","text":""},{"location":"API_Reference/MT5Service/#init","title":"init","text":"<p>Signature: <code>def __init__(self, account)</code></p> <p>Source: Line 234</p> <p>Create MT5Service wrapper.</p> <p>Parameters:</p> Parameter Type Description <code>account</code> MT5Account Low-level gRPC client instance"},{"location":"API_Reference/MT5Service/#get_account","title":"get_account","text":"<p>Signature: <code>def get_account(self) -&gt; MT5Account</code></p> <p>Source: Line 243</p> <p>Return the underlying MT5Account for direct low-level access.</p> <p>Returns: MT5Account instance for advanced operations</p>"},{"location":"API_Reference/MT5Service/#account-information-methods","title":"\ud83d\udc64 Account Information Methods","text":""},{"location":"API_Reference/MT5Service/#get_account_summary","title":"get_account_summary","text":"<p>Signature: <code>async def get_account_summary(self, deadline, cancellation_event) -&gt; AccountSummary</code></p> <p>Source: Line 254</p> <p>Get complete account information in ONE method call.</p> <p>Returns: <code>AccountSummary</code> with all account data in native Python types (14 fields)</p> <p>Technical Details</p> <p>Internally makes 5 RPC calls:</p> <ol> <li><code>account_summary()</code> - gets 11 basic fields (login, balance, equity, username, etc.) 2-5. <code>account_info_double()</code> \u00d7 4 - gets margin, free_margin, margin_level, profit</li> </ol> <p>Result: AccountSummary dataclass with 14 fields in native Python types.</p> <p>Advantage</p> <p>93% code reduction: Single method call vs 14 separate <code>AccountInfo*</code> calls</p>"},{"location":"API_Reference/MT5Service/#get_account_double","title":"get_account_double","text":"<p>Signature: <code>async def get_account_double(self, property_id, deadline, cancellation_event) -&gt; float</code></p> <p>Source: Line 309</p> <p>Get individual account double property.</p> <p>Parameters:</p> Parameter Type Description <code>property_id</code> int Property to retrieve (ACCOUNT_BALANCE, ACCOUNT_EQUITY, etc.) <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>float</code> value directly (no Data struct extraction)</p> <p>Technical Details</p> <p>Low-level method returns <code>AccountInfoDoubleResponse</code> with <code>res.data.requested_value</code>. This wrapper auto-extracts the float, eliminating the <code>.data.requested_value</code> access. Supports automatic reconnection on gRPC errors via <code>execute_with_reconnect</code>.</p>"},{"location":"API_Reference/MT5Service/#get_account_integer","title":"get_account_integer","text":"<p>Signature: <code>async def get_account_integer(self, property_id, deadline, cancellation_event) -&gt; int</code></p> <p>Source: Line 330</p> <p>Get individual account integer property.</p> <p>Parameters:</p> Parameter Type Description <code>property_id</code> int Property to retrieve (ACCOUNT_LEVERAGE, ACCOUNT_LOGIN, etc.) <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>int</code> value directly (no Data struct extraction)</p> <p>Technical Details</p> <p>Low-level returns <code>AccountInfoIntegerResponse</code> with <code>res.data.requested_value</code>. This wrapper auto-extracts the int. Used for properties like leverage (1:100), login number.</p>"},{"location":"API_Reference/MT5Service/#get_account_string","title":"get_account_string","text":"<p>Signature: <code>async def get_account_string(self, property_id, deadline, cancellation_event) -&gt; str</code></p> <p>Source: Line 350</p> <p>Get individual account string property.</p> <p>Parameters:</p> Parameter Type Description <code>property_id</code> int Property to retrieve (ACCOUNT_CURRENCY, ACCOUNT_COMPANY, etc.) <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>str</code> value directly (no Data struct extraction)</p> <p>Technical Details</p> <p>Low-level returns <code>AccountInfoStringResponse</code> with <code>res.data.requested_value</code>. This wrapper auto-extracts the string. Used for properties like currency (\"USD\"), company name.</p>"},{"location":"API_Reference/MT5Service/#symbol-information-methods","title":"\ud83d\udcca Symbol Information Methods","text":""},{"location":"API_Reference/MT5Service/#get_symbols_total","title":"get_symbols_total","text":"<p>Signature: <code>async def get_symbols_total(self, selected_only, deadline, cancellation_event) -&gt; int</code></p> <p>Source: Line 377</p> <p>Get count of available symbols.</p> <p>Parameters:</p> Parameter Type Description <code>selected_only</code> bool True to count only Market Watch symbols, False for all <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>int</code> count directly (no Data struct)</p> <p>Technical Details</p> <p>Low-level returns <code>SymbolsTotalData</code> with <code>data.total</code> wrapper. This auto-extracts the count. <code>selected_only=True</code> counts Market Watch, <code>False</code> counts all available symbols in terminal.</p>"},{"location":"API_Reference/MT5Service/#symbol_exist","title":"symbol_exist","text":"<p>Signature: <code>async def symbol_exist(self, symbol, deadline, cancellation_event)</code></p> <p>Source: Line 398</p> <p>Check if symbol exists in terminal.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name to check <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: Tuple of <code>(exists, is_custom)</code></p>"},{"location":"API_Reference/MT5Service/#get_symbol_name","title":"get_symbol_name","text":"<p>Signature: <code>async def get_symbol_name(self, index, selected_only, deadline, cancellation_event) -&gt; str</code></p> <p>Source: Line 416</p> <p>Get symbol name by index position.</p> <p>Parameters:</p> Parameter Type Description <code>index</code> int Symbol index (starting at 0) <code>selected_only</code> bool True to use only Market Watch symbols <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: Symbol name string directly</p>"},{"location":"API_Reference/MT5Service/#symbol_select","title":"symbol_select","text":"<p>Signature: <code>async def symbol_select(self, symbol, select, deadline, cancellation_event) -&gt; bool</code></p> <p>Source: Line 436</p> <p>Add/remove symbol from Market Watch.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>select</code> bool True to add, False to remove <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: Success status directly</p>"},{"location":"API_Reference/MT5Service/#is_symbol_synchronized","title":"is_symbol_synchronized","text":"<p>Signature: <code>async def is_symbol_synchronized(self, symbol, deadline, cancellation_event) -&gt; bool</code></p> <p>Source: Line 456</p> <p>Check if symbol data is synchronized.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name to check <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>True</code> if synchronized, <code>False</code> otherwise</p>"},{"location":"API_Reference/MT5Service/#get_symbol_double","title":"get_symbol_double","text":"<p>Signature: <code>async def get_symbol_double(self, symbol, property, deadline, cancellation_event) -&gt; float</code></p> <p>Source: Line 474</p> <p>Get individual symbol double property.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>property</code> int Property to retrieve (SYMBOL_BID, SYMBOL_ASK, etc.) <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>float</code> value directly</p> <p>Technical Details</p> <p>Low-level returns <code>SymbolInfoDoubleResponse</code> with <code>data.value</code> wrapper. This extracts the float from nested structure. Common properties: SYMBOL_BID, SYMBOL_ASK, SYMBOL_POINT.</p>"},{"location":"API_Reference/MT5Service/#get_symbol_integer","title":"get_symbol_integer","text":"<p>Signature: <code>async def get_symbol_integer(self, symbol, property, deadline, cancellation_event) -&gt; int</code></p> <p>Source: Line 497</p> <p>Get individual symbol integer property.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>property</code> int Property to retrieve (SYMBOL_DIGITS, SYMBOL_SPREAD, etc.) <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>int</code> value directly</p>"},{"location":"API_Reference/MT5Service/#get_symbol_string","title":"get_symbol_string","text":"<p>Signature: <code>async def get_symbol_string(self, symbol, property, deadline, cancellation_event) -&gt; str</code></p> <p>Source: Line 517</p> <p>Get individual symbol string property.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>property</code> int Property to retrieve (SYMBOL_DESCRIPTION, etc.) <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>str</code> value directly</p>"},{"location":"API_Reference/MT5Service/#get_symbol_margin_rate","title":"get_symbol_margin_rate","text":"<p>Signature: <code>async def get_symbol_margin_rate(self, symbol, order_type, deadline, cancellation_event) -&gt; SymbolMarginRate</code></p> <p>Source: Line 537</p> <p>Get margin rates for a symbol and order type.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>order_type</code> int Order type (BUY, SELL, etc.) <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>SymbolMarginRate</code> with initial and maintenance rates</p>"},{"location":"API_Reference/MT5Service/#get_symbol_tick","title":"get_symbol_tick","text":"<p>Signature: <code>async def get_symbol_tick(self, symbol, deadline, cancellation_event) -&gt; SymbolTick</code></p> <p>Source: Line 560</p> <p>Get current market prices for a symbol.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>SymbolTick</code> with time already converted to datetime</p> <p>Technical Details</p> <p>Low-level returns <code>SymbolInfoTickData</code> with Unix timestamp (<code>data.time</code>). This wrapper converts time field from Unix seconds to Python datetime via <code>fromtimestamp()</code>. Also provides <code>time_msc</code> (milliseconds) for sub-second precision and tick flags for tick type detection.</p>"},{"location":"API_Reference/MT5Service/#get_symbol_session_quote","title":"get_symbol_session_quote","text":"<p>Signature: <code>async def get_symbol_session_quote(self, symbol, day_of_week, session_index, deadline, cancellation_event) -&gt; SessionTime</code></p> <p>Source: Line 594</p> <p>Get quote session times.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>day_of_week</code> int Day of the week <code>session_index</code> int Session index (starting at 0) <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>SessionTime</code> with start/end times as datetime</p> <p>Technical Details</p> <p>Low-level returns <code>SymbolInfoSessionQuoteData</code> with 'from' and 'to' Timestamp fields. This wrapper converts both protobuf Timestamps to Python datetimes via <code>ToDatetime()</code>. Shows when quotes (prices) are available for symbol on specified day. Most symbols have 1 session (0).</p>"},{"location":"API_Reference/MT5Service/#get_symbol_session_trade","title":"get_symbol_session_trade","text":"<p>Signature: <code>async def get_symbol_session_trade(self, symbol, day_of_week, session_index, deadline, cancellation_event) -&gt; SessionTime</code></p> <p>Source: Line 628</p> <p>Get trading session times.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>day_of_week</code> int Day of the week <code>session_index</code> int Session index (starting at 0) <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>SessionTime</code> with start/end times as datetime</p>"},{"location":"API_Reference/MT5Service/#get_symbol_params_many","title":"get_symbol_params_many","text":"<p>Signature: <code>async def get_symbol_params_many(self, name_filter, sort_mode, page_number, items_per_page, deadline, cancellation_event)</code></p> <p>Source: Line 658</p> <p>Get parameters of multiple symbols at once.</p> <p>Parameters:</p> Parameter Type Description <code>name_filter</code> str Optional symbol name filter <code>sort_mode</code> int Optional sort mode <code>page_number</code> int Optional page number for pagination <code>items_per_page</code> int Optional items per page <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: Tuple of <code>(list of SymbolParams, total count)</code></p> <p>Technical Details</p> <p>Low-level returns <code>SymbolParamsManyResponse</code> with <code>data.symbol_infos</code> (protobuf repeated field). This wrapper unpacks each <code>SymbolInfo</code> protobuf into <code>SymbolParams</code> dataclass with 17 fields. Much faster than 17 separate <code>SymbolInfoDouble/Integer/String</code> calls per symbol.</p>"},{"location":"API_Reference/MT5Service/#positions-orders-methods","title":"\ud83d\udcc8 Positions &amp; Orders Methods","text":""},{"location":"API_Reference/MT5Service/#get_positions_total","title":"get_positions_total","text":"<p>Signature: <code>async def get_positions_total(self, deadline, cancellation_event) -&gt; int</code></p> <p>Source: Line 728</p> <p>Get total number of open positions.</p> <p>Returns: <code>int</code> count directly (no Data struct)</p>"},{"location":"API_Reference/MT5Service/#get_opened_orders","title":"get_opened_orders","text":"<p>Signature: <code>async def get_opened_orders(self, sort_mode, deadline, cancellation_event) -&gt; Any</code></p> <p>Source: Line 742</p> <p>Get all open positions and pending orders.</p> <p>Parameters:</p> Parameter Type Description <code>sort_mode</code> int Sort mode for results <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>OpenedOrdersData</code> with separate lists for positions and orders</p> <p>Technical Details</p> <p>Returns protobuf <code>OpenedOrdersData</code> with <code>data.position_infos</code> and <code>data.order_infos</code>. Each contains full position/order details (ticket, symbol, volume, profit, SL/TP, etc.). For tickets only (faster), use <code>get_opened_tickets()</code> which skips detailed field parsing.</p>"},{"location":"API_Reference/MT5Service/#get_opened_tickets","title":"get_opened_tickets","text":"<p>Signature: <code>async def get_opened_tickets(self, deadline, cancellation_event)</code></p> <p>Source: Line 763</p> <p>Get only ticket numbers (lightweight).</p> <p>Returns: Tuple of <code>(position_tickets, order_tickets)</code></p> <p>Performance</p> <p>10-20x faster than <code>get_opened_orders()</code> when you only need ticket IDs for existence checks or counting.</p> <p>Technical Details</p> <p>Low-level returns <code>OpenedOrdersTicketsData</code> with two repeated int64 fields. This extracts <code>position_tickets</code> and <code>order_tickets</code> lists without parsing full position/order details.</p>"},{"location":"API_Reference/MT5Service/#get_order_history","title":"get_order_history","text":"<p>Signature: <code>async def get_order_history(self, from_dt, to_dt, sort_mode, page_number, items_per_page, deadline, cancellation_event) -&gt; Any</code></p> <p>Source: Line 781</p> <p>Get historical orders and deals for a time period.</p> <p>Parameters:</p> Parameter Type Description <code>from_dt</code> datetime Start time <code>to_dt</code> datetime End time <code>sort_mode</code> int Sort mode <code>page_number</code> int Page number for pagination <code>items_per_page</code> int Items per page <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>OrdersHistoryData</code> with orders and deals</p> <p>Technical Details</p> <p>Returns protobuf <code>OrdersHistoryData</code> with <code>data.order_history_infos</code> (repeated field). Includes both orders and their related deals. Supports pagination for large result sets. For closed positions with P&amp;L, use <code>get_positions_history()</code> instead (more detailed profit tracking).</p>"},{"location":"API_Reference/MT5Service/#get_positions_history","title":"get_positions_history","text":"<p>Signature: <code>async def get_positions_history(self, sort_type, open_from, open_to, page, size, deadline, cancellation_event) -&gt; Any</code></p> <p>Source: Line 810</p> <p>Get closed positions history with P&amp;L.</p> <p>Parameters:</p> Parameter Type Description <code>sort_type</code> int Sort type <code>open_from</code> datetime Start of open time filter <code>open_to</code> datetime End of open time filter <code>page</code> int Page number <code>size</code> int Items per page <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>PositionsHistoryData</code> with closed positions</p> <p>Technical Details</p> <p>Returns protobuf <code>PositionsHistoryData</code> with <code>data.history_positions</code> (repeated field). Each <code>PositionHistoryInfo</code> includes profit, commission, swap, open/close times and prices. Filters by position open time (not close time). Better than <code>order_history</code> for profit calculations.</p>"},{"location":"API_Reference/MT5Service/#market-depth-dom-methods","title":"\ud83d\udcd6 Market Depth (DOM) Methods","text":""},{"location":"API_Reference/MT5Service/#subscribe_market_depth","title":"subscribe_market_depth","text":"<p>Signature: <code>async def subscribe_market_depth(self, symbol, deadline, cancellation_event) -&gt; bool</code></p> <p>Source: Line 846</p> <p>Subscribe to Depth of Market (DOM) updates.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name to subscribe <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: Success status</p> <p>Technical Details</p> <p>Low-level returns <code>MarketBookAddData</code> with <code>data.success</code> wrapper. This auto-extracts bool. Required before calling <code>get_market_depth()</code> to receive DOM snapshots. Terminal maintains subscription - call <code>unsubscribe_market_depth()</code> when done to free resources.</p>"},{"location":"API_Reference/MT5Service/#unsubscribe_market_depth","title":"unsubscribe_market_depth","text":"<p>Signature: <code>async def unsubscribe_market_depth(self, symbol, deadline, cancellation_event) -&gt; bool</code></p> <p>Source: Line 868</p> <p>Unsubscribe from DOM updates.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name to unsubscribe <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: Success status</p> <p>Important</p> <p>Always unsubscribe when done - brokers may limit concurrent DOM subscriptions.</p> <p>Technical Details</p> <p>Low-level returns <code>MarketBookReleaseData</code> with <code>data.success</code> wrapper. This auto-extracts bool. Releases DOM subscription to free terminal resources.</p>"},{"location":"API_Reference/MT5Service/#get_market_depth","title":"get_market_depth","text":"<p>Signature: <code>async def get_market_depth(self, symbol, deadline, cancellation_event)</code></p> <p>Source: Line 890</p> <p>Get current DOM snapshot.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: List of <code>BookInfo</code> entries</p> <p>Technical Details</p> <p>Low-level returns <code>MarketBookGetData</code> with <code>data.books</code> (repeated <code>BookRecord</code> protobuf). This wrapper unpacks each <code>BookRecord</code> into <code>BookInfo</code> dataclass (type, price, volume, volume_real). Requires prior <code>market_book_add</code> subscription. <code>BookRecord.type</code>: 1=BUY (bid), 2=SELL (ask) levels.</p>"},{"location":"API_Reference/MT5Service/#trading-operations-methods","title":"\ud83d\udcb0 Trading Operations Methods","text":""},{"location":"API_Reference/MT5Service/#place_order","title":"place_order","text":"<p>Signature: <code>async def place_order(self, request, deadline, cancellation_event) -&gt; OrderResult</code></p> <p>Source: Line 929</p> <p>Send market/pending order to broker.</p> <p>Parameters:</p> Parameter Type Description <code>request</code> OrderSendRequest Order request details <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>OrderResult</code> with deal/order tickets</p> <p>Success Check</p> <p>Check <code>returned_code == 10009</code> (TRADE_RETCODE_DONE) for successful execution.</p> <p>Technical Details</p> <p>Low-level returns <code>OrderSendData</code> protobuf with nested broker response fields. This wrapper flattens protobuf into <code>OrderResult</code> dataclass with 10 fields (returned_code, deal, order, etc.).</p>"},{"location":"API_Reference/MT5Service/#modify_order","title":"modify_order","text":"<p>Signature: <code>async def modify_order(self, request, deadline, cancellation_event) -&gt; OrderResult</code></p> <p>Source: Line 963</p> <p>Modify existing order or position (SL/TP).</p> <p>Parameters:</p> Parameter Type Description <code>request</code> OrderModifyRequest Modification request details <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>OrderResult</code> with modification details</p> <p>Technical Details</p> <p>Low-level returns <code>OrderModifyData</code> protobuf (same structure as <code>OrderSendData</code>). This wrapper flattens into <code>OrderResult</code>. Used to change SL/TP on positions or modify pending order price/SL/TP.</p>"},{"location":"API_Reference/MT5Service/#close_order","title":"close_order","text":"<p>Signature: <code>async def close_order(self, request, deadline, cancellation_event) -&gt; int</code></p> <p>Source: Line 996</p> <p>Close position or delete pending order.</p> <p>Parameters:</p> Parameter Type Description <code>request</code> OrderCloseRequest Close request details <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: Return code directly (10009 = success)</p> <p>Technical Details</p> <p>Low-level returns <code>OrderCloseData</code> with <code>data.returned_code</code> wrapper. This auto-extracts the int return code (10009=TRADE_RETCODE_DONE means successful close/delete). For positions, creates opposite market order. For pending orders, sends delete request.</p>"},{"location":"API_Reference/MT5Service/#check_order","title":"check_order","text":"<p>Signature: <code>async def check_order(self, request, deadline, cancellation_event) -&gt; OrderCheckResult</code></p> <p>Source: Line 1018</p> <p>Validate order before sending to broker.</p> <p>Parameters:</p> Parameter Type Description <code>request</code> OrderCheckRequest Order to validate <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: <code>OrderCheckResult</code> with validation details</p> <p>Use Case</p> <p>Use this before <code>place_order()</code> to pre-validate margin requirements without sending to broker.</p> <p>Technical Details</p> <p>Low-level returns <code>OrderCheckResponse</code> with deeply nested <code>mrpc_mql_trade_check_result</code>. This wrapper extracts 8 validation fields (<code>returned_code=0</code> means valid, balance_after_deal, margin, etc.).</p>"},{"location":"API_Reference/MT5Service/#calculate_margin","title":"calculate_margin","text":"<p>Signature: <code>async def calculate_margin(self, request, deadline, cancellation_event) -&gt; float</code></p> <p>Source: Line 1053</p> <p>Calculate required margin for an order.</p> <p>Parameters:</p> Parameter Type Description <code>request</code> OrderCalcMarginRequest Margin calculation request <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: Margin value directly (no Data struct)</p> <p>Technical Details</p> <p>Low-level returns <code>OrderCalcMarginResponse</code> with <code>data.margin</code> wrapper. This auto-extracts margin float from protobuf response. Use to check margin requirements before placing order.</p>"},{"location":"API_Reference/MT5Service/#calculate_profit","title":"calculate_profit","text":"<p>Signature: <code>async def calculate_profit(self, request, deadline, cancellation_event) -&gt; float</code></p> <p>Source: Line 1074</p> <p>Calculate potential profit for a trade.</p> <p>Parameters:</p> Parameter Type Description <code>request</code> OrderCalcProfitRequest Profit calculation request <code>deadline</code> datetime Optional deadline for the operation <code>cancellation_event</code> Event Optional cancellation event <p>Returns: Profit value directly (no Data struct)</p> <p>Technical Details</p> <p>Low-level returns <code>OrderCalcProfitResponse</code> with <code>data.profit</code> wrapper. This auto-extracts profit float. Calculates P&amp;L for hypothetical trade given entry/exit prices and volume.</p>"},{"location":"API_Reference/MT5Service/#streaming-methods_1","title":"\ud83d\udce1 Streaming Methods","text":""},{"location":"API_Reference/MT5Service/#stream_ticks","title":"stream_ticks","text":"<p>Signature: <code>async def stream_ticks(self, symbols, cancellation_event)</code></p> <p>Source: Line 1101</p> <p>Real-time tick data stream.</p> <p>Parameters:</p> Parameter Type Description <code>symbols</code> List[str] List of symbol names to stream <code>cancellation_event</code> Event Optional cancellation event <p>Yields: <code>SymbolTick</code> with time already converted to datetime</p> <p>Technical Details</p> <p>Low-level streams <code>OnSymbolTickData</code> with <code>symbol_tick.time</code> as protobuf Timestamp. This wrapper converts each Timestamp to Python datetime via <code>ToDatetime()</code> for every tick. Stream continues until <code>cancellation_event.set()</code> or connection loss (auto-reconnects via <code>execute_stream_with_reconnect</code>).</p>"},{"location":"API_Reference/MT5Service/#stream_trade_updates","title":"stream_trade_updates","text":"<p>Signature: <code>async def stream_trade_updates(self, cancellation_event)</code></p> <p>Source: Line 1135</p> <p>Real-time trade events stream (new/closed positions).</p> <p>Parameters:</p> Parameter Type Description <code>cancellation_event</code> Event Optional cancellation event <p>Yields: <code>OnTradeData</code> events</p> <p>Technical Details</p> <p>Server pushes <code>OnTradeData</code> when position opens/closes or pending order placed/deleted. Each event contains <code>position_info</code> or <code>order_info</code> with full details (ticket, symbol, volume, type, etc.). Thin wrapper - passes through protobuf <code>OnTradeData</code> without conversion (minimal overhead).</p>"},{"location":"API_Reference/MT5Service/#stream_position_profits","title":"stream_position_profits","text":"<p>Signature: <code>async def stream_position_profits(self, interval_ms, ignore_empty, cancellation_event)</code></p> <p>Source: Line 1155</p> <p>Real-time position profit updates stream.</p> <p>Parameters:</p> Parameter Type Description <code>interval_ms</code> int Polling interval in milliseconds <code>ignore_empty</code> bool Skip frames with no changes <code>cancellation_event</code> Event Optional cancellation event <p>Yields: <code>OnPositionProfitData</code> with P&amp;L updates</p> <p>Technical Details</p> <p>Server polls positions every <code>interval_ms</code> and pushes updates when profit changes. <code>ignore_empty=True</code> filters out frames where no position P&amp;L changed, reducing bandwidth. Each <code>OnPositionProfitData</code> contains <code>position_profits</code> repeated field with ticket\u2192profit mapping.</p>"},{"location":"API_Reference/MT5Service/#stream_opened_tickets","title":"stream_opened_tickets","text":"<p>Signature: <code>async def stream_opened_tickets(self, interval_ms, cancellation_event)</code></p> <p>Source: Line 1179</p> <p>Real-time position/order ticket updates stream (lightweight).</p> <p>Parameters:</p> Parameter Type Description <code>interval_ms</code> int Polling interval in milliseconds <code>cancellation_event</code> Event Optional cancellation event <p>Yields: <code>OnPositionsAndPendingOrdersTicketsData</code> with ticket IDs</p> <p>Performance</p> <p>10-20x less bandwidth than <code>stream_trade_updates()</code> - use when you only need to track ticket changes.</p> <p>Technical Details</p> <p>Server polls every <code>interval_ms</code> and pushes <code>OnPositionsAndPendingOrdersTicketsData</code>. Contains <code>opened_position_tickets</code> and <code>opened_orders_tickets</code> repeated int64 fields.</p>"},{"location":"API_Reference/MT5Service/#stream_transactions","title":"stream_transactions","text":"<p>Signature: <code>async def stream_transactions(self, cancellation_event)</code></p> <p>Source: Line 1201</p> <p>Real-time trade transaction stream (detailed).</p> <p>Parameters:</p> Parameter Type Description <code>cancellation_event</code> Event Optional cancellation event <p>Yields: <code>OnTradeTransactionData</code> events</p> <p>Technical Details</p> <p>Server pushes <code>OnTradeTransactionData</code> for every trade operation step (request\u2192broker\u2192result). More detailed than <code>on_trade</code>: includes <code>transaction_type</code> (DEAL_ADD, ORDER_DELETE, etc.) and request details. Thin wrapper - passes through protobuf <code>OnTradeTransactionData</code> without conversion.</p>"},{"location":"API_Reference/MT5Sugar/","title":"\ud83c\udfaf MT5Sugar API Reference","text":"<p>Documentation Status</p> <p>Auto-generated from source code (<code>src/pymt5/mt5_sugar.py</code>) and enhanced for readability. Complete API reference with enhanced navigation. Single-page format for easy browsing.</p>"},{"location":"API_Reference/MT5Sugar/#overview","title":"\ud83d\udccc Overview","text":"<p>MT5Sugar represents a high-level convenience API for MT5 trading using Python best practices. It sits at the top of the architecture stack, providing maximum simplicity with properties for instant access, context managers, enums instead of magic numbers, unified methods with smart defaults, and comprehensive type hints. This is the recommended layer for most trading applications.</p> <p>Key Features</p> <ul> <li>\u2705 Python properties for instant access (<code>await sugar.balance</code>, <code>await sugar.equity</code>)</li> <li>\u2705 Context managers for automatic connection handling (<code>async with MT5Sugar.connect(...)</code>)</li> <li>\u2705 Enums instead of magic numbers (Period.TODAY, OrderType.BUY)</li> <li>\u2705 Smart defaults and unified method signatures</li> <li>\u2705 62 async methods + 7 properties covering all trading scenarios</li> <li>\u2705 Built-in risk management and position sizing calculators</li> <li>\u2705 Comprehensive type hints for IDE autocomplete</li> </ul> <p>Detailed Guide Available</p> <p>\ud83d\udcd6 MT5Sugar Master Overview - Complete high-level API guide with examples, best practices, and usage patterns for all 62 methods</p>"},{"location":"API_Reference/MT5Sugar/#table-of-contents","title":"\ud83d\udcd1 Table of Contents","text":""},{"location":"API_Reference/MT5Sugar/#account-information","title":"\ud83d\udc64 Account Information","text":"<ul> <li>get_balance \u2014 Get account balance</li> <li>get_equity \u2014 Get current equity</li> <li>get_margin \u2014 Get used margin</li> <li>get_free_margin \u2014 Get available margin</li> <li>get_margin_level \u2014 Get margin level %</li> <li>get_floating_profit \u2014 Get floating profit/loss</li> <li>get_account_info \u2014 Complete account info</li> </ul>"},{"location":"API_Reference/MT5Sugar/#account-properties-async","title":"\ud83d\udd11 Account Properties (async)","text":"<ul> <li>balance \u2014 Property: Account balance</li> <li>equity \u2014 Property: Current equity</li> <li>margin \u2014 Property: Used margin</li> <li>free_margin \u2014 Property: Free margin</li> <li>margin_level \u2014 Property: Margin level %</li> <li>profit \u2014 Property: Total floating profit/loss</li> </ul>"},{"location":"API_Reference/MT5Sugar/#prices-quotes","title":"\ud83d\udcb9 Prices &amp; Quotes","text":"<ul> <li>get_bid \u2014 Get BID price</li> <li>get_ask \u2014 Get ASK price</li> <li>get_spread \u2014 Get spread in points</li> <li>get_price_info \u2014 Complete price info</li> <li>wait_for_price \u2014 Wait for valid price</li> </ul>"},{"location":"API_Reference/MT5Sugar/#simple-trading-market-pending","title":"\ud83d\udcca Simple Trading (Market &amp; Pending)","text":"<ul> <li>buy_market \u2014 Open BUY at market</li> <li>sell_market \u2014 Open SELL at market</li> <li>buy_limit \u2014 Place BUY LIMIT</li> <li>sell_limit \u2014 Place SELL LIMIT</li> <li>buy_stop \u2014 Place BUY STOP</li> <li>sell_stop \u2014 Place SELL STOP</li> </ul>"},{"location":"API_Reference/MT5Sugar/#trading-with-sltp","title":"\ud83c\udfaf Trading with SL/TP","text":"<ul> <li>buy_market_with_sltp \u2014 BUY with stop loss/take profit</li> <li>sell_market_with_sltp \u2014 SELL with stop loss/take profit</li> <li>buy_limit_with_sltp \u2014 BUY LIMIT with SL/TP</li> <li>sell_limit_with_sltp \u2014 SELL LIMIT with SL/TP</li> <li>buy_market_with_pips \u2014 BUY with SL/TP in pips</li> <li>sell_market_with_pips \u2014 SELL with SL/TP in pips</li> <li>calculate_sltp \u2014 Convert pips to prices</li> </ul>"},{"location":"API_Reference/MT5Sugar/#position-management","title":"\ud83d\udcc8 Position Management","text":"<ul> <li>close_position \u2014 Close position by ticket</li> <li>close_position_partial \u2014 Partial close</li> <li>close_all_positions \u2014 Close all positions</li> <li>modify_position_sltp \u2014 Modify SL/TP</li> <li>modify_position_sl \u2014 Modify stop loss only</li> <li>modify_position_tp \u2014 Modify take profit only</li> <li>get_open_positions \u2014 Get all open positions</li> <li>get_position_by_ticket \u2014 Get position by ticket</li> <li>get_positions_by_symbol \u2014 Get positions for symbol</li> <li>has_open_position \u2014 Check if positions exist</li> <li>count_open_positions \u2014 Count open positions</li> <li>get_total_profit \u2014 Total P&amp;L across positions</li> <li>get_profit_by_symbol \u2014 P&amp;L for symbol</li> </ul>"},{"location":"API_Reference/MT5Sugar/#history-statistics","title":"\ud83d\udcdc History &amp; Statistics","text":"<ul> <li>get_deals \u2014 Get deals for period</li> <li>get_profit \u2014 Get profit for period</li> <li>get_deals_today \u2014 Today's deals</li> <li>get_deals_yesterday \u2014 Yesterday's deals</li> <li>get_deals_this_week \u2014 This week's deals</li> <li>get_deals_this_month \u2014 This month's deals</li> <li>get_deals_date_range \u2014 Deals in date range</li> <li>get_profit_today \u2014 Today's profit</li> <li>get_profit_this_week \u2014 This week's profit</li> <li>get_profit_this_month \u2014 This month's profit</li> <li>get_daily_stats \u2014 Daily trading statistics</li> </ul>"},{"location":"API_Reference/MT5Sugar/#symbol-information","title":"\ud83d\udd0d Symbol Information","text":"<ul> <li>get_symbol_info \u2014 Complete symbol info</li> <li>get_all_symbols \u2014 List all symbols</li> <li>is_symbol_available \u2014 Check symbol availability</li> <li>get_min_stop_level \u2014 Minimum SL/TP distance</li> <li>get_symbol_digits \u2014 Decimal places</li> </ul>"},{"location":"API_Reference/MT5Sugar/#risk-management","title":"\ud83d\udee1\ufe0f Risk Management","text":"<ul> <li>calculate_position_size \u2014 Calculate lot size by risk</li> <li>can_open_position \u2014 Validate position opening</li> <li>get_max_lot_size \u2014 Maximum allowed lot size</li> <li>calculate_required_margin \u2014 Calculate required margin</li> </ul>"},{"location":"API_Reference/MT5Sugar/#class-mt5sugar","title":"\ud83c\udfd7\ufe0f Class: MT5Sugar","text":"<p>Source: Line 225</p> <p>High-level convenience API for MT5 trading using Python best practices.</p> <p>MT5Sugar represents the highest-level API layer in the PyMT5 architecture, designed for maximum simplicity and developer productivity. It wraps MT5Service with intuitive Pythonic patterns including async properties (<code>await sugar.balance</code>), context managers (<code>async with sugar.connect()</code>), enums instead of magic numbers, smart method defaults, and comprehensive risk management tools. This is the recommended layer for building trading applications, bots, and analysis tools.</p> <p>Architecture Position</p> <ul> <li>LOW MT5Account (protobuf Request/Data, direct gRPC)</li> <li>MID MT5Service (Python types, removes Data wrappers)</li> <li>HIGH MT5Sugar (business logic, ready-made patterns) \u2190 THIS CLASS</li> </ul> <p>Constructor Requirements</p> <ul> <li>Requires MT5Service instance (mid-level wrapper)</li> <li>Optional <code>default_timeout</code> (seconds for operations, default 10.0)</li> <li>Optional <code>default_symbol</code> (default trading symbol like \"EURUSD\")</li> <li>Recommended: Use <code>MT5Sugar.connect()</code> class method instead of direct construction</li> </ul> <p>Usage Patterns</p> <p>Pattern 1: Context Manager (Recommended) <pre><code>async with MT5Sugar.connect(\"ICMarkets-Demo\") as sugar:\n    balance = await sugar.balance\n    ticket = await sugar.buy_market(\"EURUSD\", 0.1)\n</code></pre></p> <p>Pattern 2: Manual Connection <pre><code>account = MT5Account.create(user=12345, password=\"pass\", grpc_server=\"mt5.mrpc.pro:443\")\nawait account.connect_by_server_name(\"ICMarkets-Demo\", \"EURUSD\")\nservice = MT5Service(account)\nsugar = MT5Sugar(service, default_symbol=\"EURUSD\")\n\nbalance = await sugar.balance\nticket = await sugar.buy_market(\"EURUSD\", 0.1)\n</code></pre></p> <p>Pattern 3: Properties for Quick Access <pre><code>balance = await sugar.balance  # Instead of await sugar.get_balance()\nequity = await sugar.equity\nmargin_level = await sugar.margin_level\n</code></pre></p> <p>Key Advantages</p> <ul> <li>Pythonic API: Properties, context managers, enums, type hints</li> <li>Smart defaults: Default symbol, automatic price fetching, sensible timeouts</li> <li>Risk management: Position sizing by risk %, margin validation, lot size limits</li> <li>Convenience methods: Today's profit, this week's deals, close all positions</li> <li>Flexible SL/TP: Specify as absolute prices OR pips (auto-converted)</li> <li>Error handling: Clear RuntimeError messages on trading failures</li> </ul>"},{"location":"API_Reference/MT5Sugar/#constructor-connection","title":"\ud83d\udd27 Constructor &amp; Connection","text":""},{"location":"API_Reference/MT5Sugar/#init","title":"init","text":"<p>Signature: <code>def __init__(self, service, default_timeout, default_symbol)</code></p> <p>Source: Line 245</p> <p>Initialize MT5Sugar with a service instance.</p> <p>Parameters:</p> Parameter Type Default Description <code>service</code> MT5Service - Mid-level service instance <code>default_timeout</code> float 10.0 Default timeout for operations in seconds <code>default_symbol</code> str None Default trading symbol (e.g., \"EURUSD\")"},{"location":"API_Reference/MT5Sugar/#connect","title":"connect","text":"<p>Signature: <code>async def connect(cls, host, port, login, password) -&gt; MT5Sugar</code></p> <p>Source: Line 264</p> <p>Create and connect MT5Sugar instance (use as context manager).</p> <p>Recommended Usage</p> <p>Use this method with <code>async with</code> for automatic cleanup: <pre><code>async with MT5Sugar.connect(\"ICMarkets-Demo\") as sugar:\n    # Your trading code here\n    pass\n# Connection automatically closed\n</code></pre></p>"},{"location":"API_Reference/MT5Sugar/#service","title":"service","text":"<p>Signature: <code>def service(self) -&gt; MT5Service</code></p> <p>Source: Line 280</p> <p>Get underlying MT5Service for advanced operations.</p> <p>Returns: MT5Service instance</p>"},{"location":"API_Reference/MT5Sugar/#is_connected","title":"is_connected","text":"<p>Signature: <code>def is_connected(self) -&gt; bool</code></p> <p>Source: Line 291</p> <p>Check if connection to MT5 server is active.</p> <p>Returns: <code>True</code> if gRPC channel is ready or idle, <code>False</code> otherwise</p> <p>Example</p> <pre><code>if sugar.is_connected():\n    balance = await sugar.get_balance()\nelse:\n    print(\"Not connected to MT5 server\")\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#ping","title":"ping","text":"<p>Signature: <code>async def ping(self, timeout) -&gt; bool</code></p> <p>Source: Line 318</p> <p>Ping MT5 server to check connection health.</p> <p>Parameters:</p> Parameter Type Default Description <code>timeout</code> float - Timeout in seconds for ping attempt <p>Returns: <code>True</code> if server responds successfully, <code>False</code> otherwise</p>"},{"location":"API_Reference/MT5Sugar/#quick_connect","title":"quick_connect","text":"<p>Signature: <code>async def quick_connect(self, cluster_name, base_symbol) -&gt; None</code></p> <p>Source: Line 340</p> <p>Quick connect (or reconnect) to MT5 cluster by name.</p> <p>Parameters:</p> Parameter Type Default Description <code>cluster_name</code> str - MT5 cluster identifier (e.g., \"ICMarkets-Demo\", \"FxPro-Live01\") <code>base_symbol</code> str \"EURUSD\" Base chart symbol for connection <p>Raises</p> <ul> <li><code>RuntimeError</code>: If credentials are not accessible in MT5Account</li> <li><code>Exception</code>: If connection to cluster fails</li> </ul>"},{"location":"API_Reference/MT5Sugar/#account-information-methods","title":"\ud83d\udc64 Account Information Methods","text":""},{"location":"API_Reference/MT5Sugar/#get_balance","title":"get_balance","text":"<p>Signature: <code>async def get_balance(self) -&gt; float</code></p> <p>Source: Line 386</p> <p>Get account balance (realized profit only).</p> <p>Returns: Account balance as float</p>"},{"location":"API_Reference/MT5Sugar/#get_equity","title":"get_equity","text":"<p>Signature: <code>async def get_equity(self) -&gt; float</code></p> <p>Source: Line 396</p> <p>Get current equity (balance + floating P/L).</p> <p>Returns: Current equity as float</p>"},{"location":"API_Reference/MT5Sugar/#get_margin","title":"get_margin","text":"<p>Signature: <code>async def get_margin(self) -&gt; float</code></p> <p>Source: Line 406</p> <p>Get used margin.</p> <p>Returns: Used margin as float</p>"},{"location":"API_Reference/MT5Sugar/#get_free_margin","title":"get_free_margin","text":"<p>Signature: <code>async def get_free_margin(self) -&gt; float</code></p> <p>Source: Line 417</p> <p>Get available margin for new positions.</p> <p>Returns: Free margin as float</p>"},{"location":"API_Reference/MT5Sugar/#get_margin_level","title":"get_margin_level","text":"<p>Signature: <code>async def get_margin_level(self) -&gt; float</code></p> <p>Source: Line 428</p> <p>Get margin level % (Equity/Margin \u00d7 100).</p> <p>Returns: Margin level percentage</p> <p>Important</p> <p>Brokers trigger margin call/stop out when level drops below threshold (typically 100%/50%).</p>"},{"location":"API_Reference/MT5Sugar/#get_floating_profit","title":"get_floating_profit","text":"<p>Signature: <code>async def get_floating_profit(self) -&gt; float</code></p> <p>Source: Line 439</p> <p>Get total floating profit/loss from open positions.</p> <p>Returns: Total floating P&amp;L</p>"},{"location":"API_Reference/MT5Sugar/#account-properties-async_1","title":"\ud83d\udd11 Account Properties (async)","text":""},{"location":"API_Reference/MT5Sugar/#balance","title":"balance","text":"<p>Signature: <code>async def balance(self) -&gt; float</code></p> <p>Source: Line 452</p> <p>Property: Account balance</p> <p>Usage</p> <pre><code>balance = await sugar.balance\nprint(f\"Balance: ${balance:.2f}\")\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#equity","title":"equity","text":"<p>Signature: <code>async def equity(self) -&gt; float</code></p> <p>Source: Line 457</p> <p>Property: Current equity</p>"},{"location":"API_Reference/MT5Sugar/#margin","title":"margin","text":"<p>Signature: <code>async def margin(self) -&gt; float</code></p> <p>Source: Line 462</p> <p>Property: Used margin</p>"},{"location":"API_Reference/MT5Sugar/#free_margin","title":"free_margin","text":"<p>Signature: <code>async def free_margin(self) -&gt; float</code></p> <p>Source: Line 467</p> <p>Property: Free margin</p>"},{"location":"API_Reference/MT5Sugar/#margin_level","title":"margin_level","text":"<p>Signature: <code>async def margin_level(self) -&gt; float</code></p> <p>Source: Line 472</p> <p>Property: Margin level %</p>"},{"location":"API_Reference/MT5Sugar/#profit","title":"profit","text":"<p>Signature: <code>async def profit(self) -&gt; float</code></p> <p>Source: Line 477</p> <p>Property: Total floating profit/loss</p>"},{"location":"API_Reference/MT5Sugar/#prices-quotes-methods","title":"\ud83d\udcb9 Prices &amp; Quotes Methods","text":""},{"location":"API_Reference/MT5Sugar/#get_bid","title":"get_bid","text":"<p>Signature: <code>async def get_bid(self, symbol) -&gt; float</code></p> <p>Source: Line 488</p> <p>Get current BID price.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name (uses default_symbol if None) <p>Returns: BID price</p>"},{"location":"API_Reference/MT5Sugar/#get_ask","title":"get_ask","text":"<p>Signature: <code>async def get_ask(self, symbol) -&gt; float</code></p> <p>Source: Line 502</p> <p>Get current ASK price.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name (uses default_symbol if None) <p>Returns: ASK price</p>"},{"location":"API_Reference/MT5Sugar/#get_spread","title":"get_spread","text":"<p>Signature: <code>async def get_spread(self, symbol) -&gt; float</code></p> <p>Source: Line 516</p> <p>Get current spread in points.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name (uses default_symbol if None) <p>Returns: Spread in points</p>"},{"location":"API_Reference/MT5Sugar/#get_price_info","title":"get_price_info","text":"<p>Signature: <code>async def get_price_info(self, symbol) -&gt; PriceInfo</code></p> <p>Source: Line 530</p> <p>Get complete price information.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name (uses default_symbol if None) <p>Returns: <code>PriceInfo</code> dataclass with bid, ask, spread, time</p>"},{"location":"API_Reference/MT5Sugar/#wait_for_price","title":"wait_for_price","text":"<p>Signature: <code>async def wait_for_price(self, symbol, timeout) -&gt; PriceInfo</code></p> <p>Source: Line 545</p> <p>Wait for valid price update with timeout.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name (uses default_symbol if None) <code>timeout</code> float 10.0 Timeout in seconds <p>Returns: <code>PriceInfo</code> when price updates</p>"},{"location":"API_Reference/MT5Sugar/#simple-trading-methods","title":"\ud83d\udcca Simple Trading Methods","text":""},{"location":"API_Reference/MT5Sugar/#buy_market","title":"buy_market","text":"<p>Signature: <code>async def buy_market(self, symbol, volume, comment, magic) -&gt; int</code></p> <p>Source: Line 568</p> <p>Open BUY position at market price.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name (uses default_symbol if None) <code>volume</code> float - Volume in lots <code>comment</code> str \"\" Order comment <code>magic</code> int 0 Magic number <p>Returns: Position ticket number</p> <p>Example</p> <pre><code>ticket = await sugar.buy_market(\"EURUSD\", 0.1)\nprint(f\"Opened BUY position #{ticket}\")\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#sell_market","title":"sell_market","text":"<p>Signature: <code>async def sell_market(self, symbol, volume, comment, magic) -&gt; int</code></p> <p>Source: Line 613</p> <p>Open SELL position at market price.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name (uses default_symbol if None) <code>volume</code> float - Volume in lots <code>comment</code> str \"\" Order comment <code>magic</code> int 0 Magic number <p>Returns: Position ticket number</p>"},{"location":"API_Reference/MT5Sugar/#buy_limit","title":"buy_limit","text":"<p>Signature: <code>async def buy_limit(self, symbol, volume, price, comment, magic) -&gt; int</code></p> <p>Source: Line 658</p> <p>Place BUY LIMIT pending order (buy below current price).</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name (uses default_symbol if None) <code>volume</code> float - Volume in lots <code>price</code> float - Limit price <code>comment</code> str \"\" Order comment <code>magic</code> int 0 Magic number <p>Returns: Order ticket number</p> <p>Example</p> <pre><code>ticket = await sugar.buy_limit(\"EURUSD\", 0.1, price=1.0850)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#sell_limit","title":"sell_limit","text":"<p>Signature: <code>async def sell_limit(self, symbol, volume, price, comment, magic) -&gt; int</code></p> <p>Source: Line 698</p> <p>Place SELL LIMIT pending order (sell above current price).</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name (uses default_symbol if None) <code>volume</code> float - Volume in lots <code>price</code> float - Limit price <code>comment</code> str \"\" Order comment <code>magic</code> int 0 Magic number <p>Returns: Order ticket number</p> <p>Example</p> <pre><code>ticket = await sugar.sell_limit(\"EURUSD\", 0.1, price=1.0950)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#buy_stop","title":"buy_stop","text":"<p>Signature: <code>async def buy_stop(self, symbol, volume, price, comment, magic) -&gt; int</code></p> <p>Source: Line 738</p> <p>Place BUY STOP pending order (buy above current price).</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name (uses default_symbol if None) <code>volume</code> float - Volume in lots <code>price</code> float - Stop price <code>comment</code> str \"\" Order comment <code>magic</code> int 0 Magic number <p>Returns: Order ticket number</p> <p>Example</p> <pre><code>ticket = await sugar.buy_stop(\"EURUSD\", 0.1, price=1.0950)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#sell_stop","title":"sell_stop","text":"<p>Signature: <code>async def sell_stop(self, symbol, volume, price, comment, magic) -&gt; int</code></p> <p>Source: Line 778</p> <p>Place SELL STOP pending order (sell below current price).</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name (uses default_symbol if None) <code>volume</code> float - Volume in lots <code>price</code> float - Stop price <code>comment</code> str \"\" Order comment <code>magic</code> int 0 Magic number <p>Returns: Order ticket number</p> <p>Example</p> <pre><code>ticket = await sugar.sell_stop(\"EURUSD\", 0.1, price=1.0850)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#trading-with-sltp-methods","title":"\ud83c\udfaf Trading with SL/TP Methods","text":""},{"location":"API_Reference/MT5Sugar/#buy_market_with_sltp","title":"buy_market_with_sltp","text":"<p>Signature: <code>async def buy_market_with_sltp(self, symbol, volume, sl, tp, sl_pips, tp_pips, comment, magic) -&gt; int</code></p> <p>Source: Line 824</p> <p>Open BUY position with Stop Loss and Take Profit.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name <code>volume</code> float - Volume in lots <code>sl</code> float None Stop Loss price (absolute) <code>tp</code> float None Take Profit price (absolute) <code>sl_pips</code> float None Stop Loss in pips (alternative to sl) <code>tp_pips</code> float None Take Profit in pips (alternative to tp) <code>comment</code> str \"\" Order comment <code>magic</code> int 0 Magic number <p>Returns: Position ticket number</p> <p>Flexible SL/TP</p> <p>You can specify SL/TP as either: - Absolute prices: <code>sl=1.0900, tp=1.1000</code> - Pips distance: <code>sl_pips=50, tp_pips=100</code></p> <p>Examples</p> <pre><code># Using absolute prices\nticket = await sugar.buy_market_with_sltp(\"EURUSD\", 0.1, sl=1.0900, tp=1.1000)\n\n# Using pips\nticket = await sugar.buy_market_with_sltp(\"EURUSD\", 0.1, sl_pips=50, tp_pips=100)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#sell_market_with_sltp","title":"sell_market_with_sltp","text":"<p>Signature: <code>async def sell_market_with_sltp(self, symbol, volume, sl, tp, sl_pips, tp_pips, comment, magic) -&gt; int</code></p> <p>Source: Line 903</p> <p>Open SELL position with Stop Loss and Take Profit.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name <code>volume</code> float - Volume in lots <code>sl</code> float None Stop Loss price (absolute) <code>tp</code> float None Take Profit price (absolute) <code>sl_pips</code> float None Stop Loss in pips (alternative to sl) <code>tp_pips</code> float None Take Profit in pips (alternative to tp) <code>comment</code> str \"\" Order comment <code>magic</code> int 0 Magic number <p>Returns: Position ticket number</p> <p>Examples</p> <pre><code># Using absolute prices\nticket = await sugar.sell_market_with_sltp(\"EURUSD\", 0.1, sl=1.1000, tp=1.0900)\n\n# Using pips\nticket = await sugar.sell_market_with_sltp(\"EURUSD\", 0.1, sl_pips=50, tp_pips=100)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#buy_limit_with_sltp","title":"buy_limit_with_sltp","text":"<p>Signature: <code>async def buy_limit_with_sltp(self, symbol, volume, price, sl, tp, sl_pips, tp_pips, comment, magic) -&gt; int</code></p> <p>Source: Line 984</p> <p>Place BUY LIMIT pending order with Stop Loss and Take Profit.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name <code>volume</code> float - Volume in lots <code>price</code> float - Limit order price <code>sl</code> float None Stop Loss price (absolute) <code>tp</code> float None Take Profit price (absolute) <code>sl_pips</code> float None Stop Loss in pips (alternative to sl) <code>tp_pips</code> float None Take Profit in pips (alternative to tp) <code>comment</code> str \"\" Order comment <code>magic</code> int 0 Magic number <p>Returns: Order ticket number</p> <p>Example</p> <pre><code>ticket = await sugar.buy_limit_with_sltp(\"EURUSD\", 0.1, price=1.0850, sl_pips=50, tp_pips=100)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#sell_limit_with_sltp","title":"sell_limit_with_sltp","text":"<p>Signature: <code>async def sell_limit_with_sltp(self, symbol, volume, price, sl, tp, sl_pips, tp_pips, comment, magic) -&gt; int</code></p> <p>Source: Line 1059</p> <p>Place SELL LIMIT pending order with Stop Loss and Take Profit.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name <code>volume</code> float - Volume in lots <code>price</code> float - Limit order price <code>sl</code> float None Stop Loss price (absolute) <code>tp</code> float None Take Profit price (absolute) <code>sl_pips</code> float None Stop Loss in pips (alternative to sl) <code>tp_pips</code> float None Take Profit in pips (alternative to tp) <code>comment</code> str \"\" Order comment <code>magic</code> int 0 Magic number <p>Returns: Order ticket number</p> <p>Example</p> <pre><code>ticket = await sugar.sell_limit_with_sltp(\"EURUSD\", 0.1, price=1.0950, sl_pips=50, tp_pips=100)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#buy_market_with_pips","title":"buy_market_with_pips","text":"<p>Signature: <code>async def buy_market_with_pips(self, symbol, volume, sl_pips, tp_pips, comment, magic) -&gt; int</code></p> <p>Source: Line 1948</p> <p>Open BUY position at market with SL/TP specified in pips.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name <code>volume</code> float - Volume in lots <code>sl_pips</code> float - Stop Loss in pips <code>tp_pips</code> float - Take Profit in pips <code>comment</code> str \"\" Order comment <code>magic</code> int 0 Magic number <p>Returns: Position ticket number</p> <p>Example</p> <pre><code># Buy 0.1 lot with 50 pip SL and 100 pip TP\nticket = await sugar.buy_market_with_pips(\"EURUSD\", 0.1, 50, 100)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#sell_market_with_pips","title":"sell_market_with_pips","text":"<p>Signature: <code>async def sell_market_with_pips(self, symbol, volume, sl_pips, tp_pips, comment, magic) -&gt; int</code></p> <p>Source: Line 1986</p> <p>Open SELL position at market with SL/TP specified in pips.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Symbol name <code>volume</code> float - Volume in lots <code>sl_pips</code> float - Stop Loss in pips <code>tp_pips</code> float - Take Profit in pips <code>comment</code> str \"\" Order comment <code>magic</code> int 0 Magic number <p>Returns: Position ticket number</p> <p>Example</p> <pre><code># Sell 0.1 lot with 50 pip SL and 100 pip TP\nticket = await sugar.sell_market_with_pips(\"EURUSD\", 0.1, 50, 100)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#calculate_sltp","title":"calculate_sltp","text":"<p>Signature: <code>async def calculate_sltp(self, symbol, is_buy, sl_pips, tp_pips)</code></p> <p>Source: Line 1896</p> <p>Convert SL/TP from pips to absolute prices.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str - Symbol name <code>is_buy</code> bool - True for BUY, False for SELL <code>sl_pips</code> float None Stop Loss in pips <code>tp_pips</code> float None Take Profit in pips <p>Returns: Tuple <code>(sl_price, tp_price)</code>. Returns <code>None</code> for values not specified.</p> <p>Examples</p> <pre><code># For BUY position\nsl_price, tp_price = await sugar.calculate_sltp(\"EURUSD\", True, 50, 100)\nprint(f\"SL: {sl_price}, TP: {tp_price}\")\n\n# For SELL position\nsl_price, tp_price = await sugar.calculate_sltp(\"EURUSD\", False, 50, 100)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#position-management-methods","title":"\ud83d\udcc8 Position Management Methods","text":""},{"location":"API_Reference/MT5Sugar/#close_position","title":"close_position","text":"<p>Signature: <code>async def close_position(self, ticket) -&gt; bool</code></p> <p>Source: Line 1141</p> <p>Close position completely by ticket.</p> <p>Parameters:</p> Parameter Type Description <code>ticket</code> int Position ticket number <p>Returns: <code>True</code> if position closed successfully</p>"},{"location":"API_Reference/MT5Sugar/#close_position_partial","title":"close_position_partial","text":"<p>Signature: <code>async def close_position_partial(self, ticket, volume) -&gt; bool</code></p> <p>Source: Line 1241</p> <p>Partially close position by specified volume.</p> <p>Parameters:</p> Parameter Type Description <code>ticket</code> int Position ticket number <code>volume</code> float Volume to close (must be less than position volume) <p>Returns: <code>True</code> if partial close successful</p> <p>Example</p> <pre><code># Close half of the position volume\nsuccess = await sugar.close_position_partial(123456, 0.05)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#close_all_positions","title":"close_all_positions","text":"<p>Signature: <code>async def close_all_positions(self, symbol) -&gt; int</code></p> <p>Source: Line 1165</p> <p>Close all open positions.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None If specified, close only positions for this symbol <p>Returns: Number of positions closed</p>"},{"location":"API_Reference/MT5Sugar/#modify_position_sltp","title":"modify_position_sltp","text":"<p>Signature: <code>async def modify_position_sltp(self, ticket, sl, tp) -&gt; bool</code></p> <p>Source: Line 1196</p> <p>Modify position SL/TP.</p> <p>Parameters:</p> Parameter Type Description <code>ticket</code> int Position ticket number <code>sl</code> float New Stop Loss price (None to keep current) <code>tp</code> float New Take Profit price (None to keep current) <p>Returns: <code>True</code> if modification successful</p>"},{"location":"API_Reference/MT5Sugar/#modify_position_sl","title":"modify_position_sl","text":"<p>Signature: <code>async def modify_position_sl(self, ticket, sl) -&gt; bool</code></p> <p>Source: Line 1299</p> <p>Modify position Stop Loss only.</p> <p>Parameters:</p> Parameter Type Description <code>ticket</code> int Position ticket number <code>sl</code> float New Stop Loss price <p>Returns: <code>True</code> if modification successful</p> <p>Example</p> <pre><code>success = await sugar.modify_position_sl(123456, 1.0900)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#modify_position_tp","title":"modify_position_tp","text":"<p>Signature: <code>async def modify_position_tp(self, ticket, tp) -&gt; bool</code></p> <p>Source: Line 1315</p> <p>Modify position Take Profit only.</p> <p>Parameters:</p> Parameter Type Description <code>ticket</code> int Position ticket number <code>tp</code> float New Take Profit price <p>Returns: <code>True</code> if modification successful</p> <p>Example</p> <pre><code>success = await sugar.modify_position_tp(123456, 1.1000)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#get_open_positions","title":"get_open_positions","text":"<p>Signature: <code>async def get_open_positions(self)</code></p> <p>Source: Line 1338</p> <p>Get all open positions.</p> <p>Returns: List of open positions</p>"},{"location":"API_Reference/MT5Sugar/#get_position_by_ticket","title":"get_position_by_ticket","text":"<p>Signature: <code>async def get_position_by_ticket(self, ticket)</code></p> <p>Source: Line 1343</p> <p>Get position by ticket number.</p> <p>Parameters:</p> Parameter Type Description <code>ticket</code> int Position ticket number <p>Returns: Position info or <code>None</code></p>"},{"location":"API_Reference/MT5Sugar/#get_positions_by_symbol","title":"get_positions_by_symbol","text":"<p>Signature: <code>async def get_positions_by_symbol(self, symbol)</code></p> <p>Source: Line 1353</p> <p>Get all positions for specified symbol.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <p>Returns: List of positions for symbol</p>"},{"location":"API_Reference/MT5Sugar/#has_open_position","title":"has_open_position","text":"<p>Signature: <code>async def has_open_position(self, symbol) -&gt; bool</code></p> <p>Source: Line 1359</p> <p>Check if there are open positions (optionally filtered by symbol).</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Optional symbol filter <p>Returns: <code>True</code> if positions exist</p>"},{"location":"API_Reference/MT5Sugar/#count_open_positions","title":"count_open_positions","text":"<p>Signature: <code>async def count_open_positions(self, symbol) -&gt; int</code></p> <p>Source: Line 1368</p> <p>Count open positions (optionally filtered by symbol).</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str None Optional symbol filter <p>Returns: Number of open positions</p>"},{"location":"API_Reference/MT5Sugar/#get_total_profit","title":"get_total_profit","text":"<p>Signature: <code>async def get_total_profit(self) -&gt; float</code></p> <p>Source: Line 1377</p> <p>Get total profit/loss across all open positions.</p> <p>Returns: Total floating P&amp;L</p>"},{"location":"API_Reference/MT5Sugar/#get_profit_by_symbol","title":"get_profit_by_symbol","text":"<p>Signature: <code>async def get_profit_by_symbol(self, symbol) -&gt; float</code></p> <p>Source: Line 1383</p> <p>Get total profit/loss for positions of specified symbol.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <p>Returns: Total P&amp;L for symbol</p>"},{"location":"API_Reference/MT5Sugar/#history-statistics-methods","title":"\ud83d\udcdc History &amp; Statistics Methods","text":""},{"location":"API_Reference/MT5Sugar/#get_deals","title":"get_deals","text":"<p>Signature: <code>async def get_deals(self, period, from_date, to_date) -&gt; List</code></p> <p>Source: Line 1437</p> <p>Get deals for specified period.</p> <p>Parameters:</p> Parameter Type Default Description <code>period</code> Period - Predefined period (TODAY, YESTERDAY, THIS_WEEK, THIS_MONTH, CUSTOM) <code>from_date</code> date None Custom start date (required if period=CUSTOM) <code>to_date</code> date None Custom end date (required if period=CUSTOM) <p>Returns: List of orders (deals) for the specified period</p>"},{"location":"API_Reference/MT5Sugar/#get_profit","title":"get_profit","text":"<p>Signature: <code>async def get_profit(self, period, from_date, to_date) -&gt; float</code></p> <p>Source: Line 1473</p> <p>Get total profit for specified period.</p> <p>Parameters:</p> Parameter Type Default Description <code>period</code> Period - Predefined period (TODAY, YESTERDAY, THIS_WEEK, THIS_MONTH, CUSTOM) <code>from_date</code> date None Custom start date (required if period=CUSTOM) <code>to_date</code> date None Custom end date (required if period=CUSTOM) <p>Returns: Total profit for the period</p>"},{"location":"API_Reference/MT5Sugar/#get_deals_today","title":"get_deals_today","text":"<p>Signature: <code>async def get_deals_today(self) -&gt; List</code></p> <p>Source: Line 1497</p> <p>Get all deals made today.</p> <p>Returns: List of today's orders</p> <p>Example</p> <pre><code>deals = await sugar.get_deals_today()\nprint(f\"Today's deals: {len(deals)}\")\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#get_deals_yesterday","title":"get_deals_yesterday","text":"<p>Signature: <code>async def get_deals_yesterday(self) -&gt; List</code></p> <p>Source: Line 1510</p> <p>Get all deals made yesterday.</p> <p>Returns: List of yesterday's orders</p>"},{"location":"API_Reference/MT5Sugar/#get_deals_this_week","title":"get_deals_this_week","text":"<p>Signature: <code>async def get_deals_this_week(self) -&gt; List</code></p> <p>Source: Line 1522</p> <p>Get all deals made this week (from Monday to today).</p> <p>Returns: List of this week's orders</p> <p>Example</p> <pre><code>deals = await sugar.get_deals_this_week()\nprint(f\"This week: {len(deals)} deals\")\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#get_deals_this_month","title":"get_deals_this_month","text":"<p>Signature: <code>async def get_deals_this_month(self) -&gt; List</code></p> <p>Source: Line 1535</p> <p>Get all deals made this month.</p> <p>Returns: List of this month's orders</p> <p>Example</p> <pre><code>deals = await sugar.get_deals_this_month()\ntotal_volume = sum(d.volume for d in deals)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#get_deals_date_range","title":"get_deals_date_range","text":"<p>Signature: <code>async def get_deals_date_range(self, from_date, to_date) -&gt; List</code></p> <p>Source: Line 1548</p> <p>Get all deals within a specific date range.</p> <p>Parameters:</p> Parameter Type Description <code>from_date</code> date Start date (inclusive) <code>to_date</code> date End date (inclusive) <p>Returns: List of orders in the date range</p> <p>Example</p> <pre><code># Get January 2024 deals\ndeals = await sugar.get_deals_date_range(\n    date(2024, 1, 1),\n    date(2024, 1, 31)\n)\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#get_profit_today","title":"get_profit_today","text":"<p>Signature: <code>async def get_profit_today(self) -&gt; float</code></p> <p>Source: Line 1568</p> <p>Get total profit made today.</p> <p>Returns: Today's profit/loss</p> <p>Example</p> <pre><code>profit = await sugar.get_profit_today()\nprint(f\"Today's P/L: {profit:.2f}\")\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#get_profit_this_week","title":"get_profit_this_week","text":"<p>Signature: <code>async def get_profit_this_week(self) -&gt; float</code></p> <p>Source: Line 1581</p> <p>Get total profit made this week.</p> <p>Returns: This week's profit/loss</p>"},{"location":"API_Reference/MT5Sugar/#get_profit_this_month","title":"get_profit_this_month","text":"<p>Signature: <code>async def get_profit_this_month(self) -&gt; float</code></p> <p>Source: Line 1593</p> <p>Get total profit made this month.</p> <p>Returns: This month's profit/loss</p> <p>Example</p> <pre><code>profit = await sugar.get_profit_this_month()\nbalance = await sugar.get_balance()\nmonthly_return = (profit / balance) * 100\nprint(f\"Monthly return: {monthly_return:.2f}%\")\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#get_daily_stats","title":"get_daily_stats","text":"<p>Signature: <code>async def get_daily_stats(self, target_date) -&gt; DailyStats</code></p> <p>Source: Line 2061</p> <p>Get daily trading statistics.</p> <p>Parameters:</p> Parameter Type Default Description <code>target_date</code> date None Date to get stats for (default: today) <p>Returns: <code>DailyStats</code> dataclass with trading statistics for the day</p> <p>Examples</p> <pre><code># Today's stats\nstats = await sugar.get_daily_stats()\nprint(f\"Deals: {stats.deals_count}\")\nprint(f\"Profit: {stats.profit}\")\nprint(f\"Volume: {stats.volume} lots\")\n\n# Specific date\nstats = await sugar.get_daily_stats(date(2024, 1, 15))\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#symbol-information-methods","title":"\ud83d\udd0d Symbol Information Methods","text":""},{"location":"API_Reference/MT5Sugar/#get_symbol_info","title":"get_symbol_info","text":"<p>Signature: <code>async def get_symbol_info(self, symbol) -&gt; SymbolInfo</code></p> <p>Source: Line 1615</p> <p>Get complete symbol information.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <p>Returns: <code>SymbolInfo</code> dataclass</p>"},{"location":"API_Reference/MT5Sugar/#get_all_symbols","title":"get_all_symbols","text":"<p>Signature: <code>async def get_all_symbols(self)</code></p> <p>Source: Line 1642</p> <p>Get list of all available symbols.</p> <p>Returns: List of all symbols</p>"},{"location":"API_Reference/MT5Sugar/#is_symbol_available","title":"is_symbol_available","text":"<p>Signature: <code>async def is_symbol_available(self, symbol) -&gt; bool</code></p> <p>Source: Line 1672</p> <p>Check if symbol exists and is tradable.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <p>Returns: <code>True</code> if available</p>"},{"location":"API_Reference/MT5Sugar/#get_min_stop_level","title":"get_min_stop_level","text":"<p>Signature: <code>async def get_min_stop_level(self, symbol) -&gt; int</code></p> <p>Source: Line 1677</p> <p>Get minimum stop level (minimum distance for SL/TP) in points.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <p>Returns: Minimum stop level in points</p> <p>Example</p> <pre><code>min_level = await sugar.get_min_stop_level(\"EURUSD\")\nprint(f\"Minimum SL/TP distance: {min_level} points\")\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#get_symbol_digits","title":"get_symbol_digits","text":"<p>Signature: <code>async def get_symbol_digits(self, symbol) -&gt; int</code></p> <p>Source: Line 1697</p> <p>Get number of decimal places in symbol price.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <p>Returns: Number of digits after decimal point</p> <p>Example</p> <pre><code>digits = await sugar.get_symbol_digits(\"EURUSD\")\nprint(f\"EURUSD has {digits} digits\")  # Usually 5 for EURUSD\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#risk-management-methods","title":"\ud83d\udee1\ufe0f Risk Management Methods","text":""},{"location":"API_Reference/MT5Sugar/#calculate_position_size","title":"calculate_position_size","text":"<p>Signature: <code>async def calculate_position_size(self, symbol, risk_percent, sl_pips) -&gt; float</code></p> <p>Source: Line 1724</p> <p>Calculate position size based on risk percentage.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>risk_percent</code> float Risk as percentage of balance (e.g., 2.0 for 2%) <code>sl_pips</code> float Stop Loss distance in pips <p>Returns: Optimal position size in lots</p> <p>Risk Management Formula</p> <p>Formula: <code>volume = risk_amount / (sl_pips \u00d7 pip_value)</code></p> <p>Where: - <code>risk_amount = balance \u00d7 (risk_percent / 100)</code> - <code>pip_value = point \u00d7 10 \u00d7 contract_size</code></p> <p>Rounds to <code>volume_step</code>, clamps to <code>volume_min/max</code>.</p> <p>Example</p> <pre><code># Risk 2% of balance with 50 pip SL\nlot_size = await sugar.calculate_position_size(\"EURUSD\", 2.0, 50)\nprint(f\"Optimal lot size: {lot_size}\")\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#can_open_position","title":"can_open_position","text":"<p>Signature: <code>async def can_open_position(self, symbol, volume)</code></p> <p>Source: Line 1774</p> <p>Validate if position can be opened.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <code>volume</code> float Position volume in lots <p>Returns: <code>(can_open, reason)</code> tuple</p>"},{"location":"API_Reference/MT5Sugar/#get_max_lot_size","title":"get_max_lot_size","text":"<p>Signature: <code>async def get_max_lot_size(self, symbol) -&gt; float</code></p> <p>Source: Line 1821</p> <p>Get maximum lot size allowed for this symbol.</p> <p>Parameters:</p> Parameter Type Description <code>symbol</code> str Symbol name <p>Returns: Maximum volume in lots</p> <p>Example</p> <pre><code>max_lots = await sugar.get_max_lot_size(\"EURUSD\")\nprint(f\"Maximum lot size: {max_lots}\")\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#calculate_required_margin","title":"calculate_required_margin","text":"<p>Signature: <code>async def calculate_required_margin(self, symbol, volume, order_type) -&gt; float</code></p> <p>Source: Line 1841</p> <p>Calculate margin required to open a position.</p> <p>Parameters:</p> Parameter Type Default Description <code>symbol</code> str - Symbol name <code>volume</code> float - Position volume in lots <code>order_type</code> OrderType BUY Order type enum value <p>Returns: Required margin in account currency</p>"},{"location":"API_Reference/MT5Sugar/#get_account_info","title":"get_account_info","text":"<p>Signature: <code>async def get_account_info(self) -&gt; AccountInfo</code></p> <p>Source: Line 2031</p> <p>Get complete account information in a structured dataclass.</p> <p>Returns: <code>AccountInfo</code> dataclass with all account details</p> <p>Example</p> <pre><code>account = await sugar.get_account_info()\nprint(f\"Account: {account.login}\")\nprint(f\"Balance: {account.balance}\")\nprint(f\"Equity: {account.equity}\")\nprint(f\"Free Margin: {account.free_margin}\")\nprint(f\"Margin Level: {account.margin_level}%\")\n</code></pre>"},{"location":"API_Reference/MT5Sugar/#context-manager-methods","title":"\ud83d\udd04 Context Manager Methods","text":""},{"location":"API_Reference/MT5Sugar/#aenter","title":"aenter","text":"<p>Signature: <code>async def __aenter__(self)</code></p> <p>Source: Line 2128</p> <p>Async context manager entry.</p>"},{"location":"API_Reference/MT5Sugar/#aexit","title":"aexit","text":"<p>Signature: <code>async def __aexit__(self, exc_type, exc_val, exc_tb)</code></p> <p>Source: Line 2132</p> <p>Async context manager exit.</p>"},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/","title":"ENUMs Usage Reference - MT5Account (Python)","text":"<p>ENUM presence lookup table for all MT5Account low-level methods</p>"},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#summary-statistics","title":"\u2705 Summary Statistics","text":"Method Group With ENUMs Total Percentage Account Information 4 4 100% Symbol Information 7 13 54% Positions &amp; Orders 3 6 50% Market Depth/DOM 1 3 33% Trading Operations 6 6 100% Streaming Methods 3 5 60% TOTAL 24 37 65%"},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#1-account-information-4-methods","title":"\ud83d\udc64 1. Account Information (4 methods)","text":""},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#44-methods-use-enums-100","title":"4/4 methods use ENUMs (100%)","text":"Method ENUMs Count Description Input ENUMs Output ENUMs account_summary [In: 0, Out: 1]Total: 1 ENUM (3 values) Get all account data in one call (RECOMMENDED) - <code>MrpcEnumAccountTradeMode</code> (3 values) - Account type: DEMO, CONTEST, REAL account_info_double [In: 1, Out: 0]Total: 1 ENUM (14 values) Get double properties (Balance, Equity, Margin, etc.) <code>AccountInfoDoublePropertyType</code> (14 values): ACCOUNT_BALANCE, ACCOUNT_CREDIT, ACCOUNT_PROFIT, ACCOUNT_EQUITY, ACCOUNT_MARGIN, ACCOUNT_MARGIN_FREE, ACCOUNT_MARGIN_LEVEL, ACCOUNT_MARGIN_SO_CALL, ACCOUNT_MARGIN_SO_SO, ACCOUNT_MARGIN_INITIAL, ACCOUNT_MARGIN_MAINTENANCE, ACCOUNT_ASSETS, ACCOUNT_LIABILITIES, ACCOUNT_COMMISSION_BLOCKED - account_info_integer [In: 1, Out: 0]Total: 1 ENUM (11 values) Get integer properties (Login, Leverage, etc.) <code>AccountInfoIntegerPropertyType</code> (11 values): ACCOUNT_LOGIN, ACCOUNT_TRADE_MODE, ACCOUNT_LEVERAGE, ACCOUNT_LIMIT_ORDERS, ACCOUNT_MARGIN_SO_MODE, ACCOUNT_TRADE_ALLOWED, ACCOUNT_TRADE_EXPERT, ACCOUNT_MARGIN_MODE, ACCOUNT_CURRENCY_DIGITS, ACCOUNT_FIFO_CLOSE, ACCOUNT_HEDGE_ALLOWED - account_info_string [In: 1, Out: 0]Total: 1 ENUM (4 values) Get string properties (Currency, Company, etc.) <code>AccountInfoStringPropertyType</code> (4 values): ACCOUNT_NAME, ACCOUNT_SERVER, ACCOUNT_CURRENCY, ACCOUNT_COMPANY -"},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#2-symbol-information-13-methods","title":"\ud83d\udcca 2. Symbol Information (13 methods)","text":""},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#713-methods-use-enums-54","title":"7/13 methods use ENUMs (54%)","text":"Method ENUMs Count Description Input ENUMs Output ENUMs symbols_total [In: 0, Out: 0]Total: 0 ENUMs Count total/selected symbols - - symbol_exist [In: 0, Out: 0]Total: 0 ENUMs Check if symbol exists - - symbol_name [In: 0, Out: 0]Total: 0 ENUMs Get symbol name by index - - symbol_select [In: 0, Out: 0]Total: 0 ENUMs Add/remove symbol from Market Watch - - symbol_is_synchronized [In: 0, Out: 0]Total: 0 ENUMs Check sync status with server - - symbol_info_double [In: 1, Out: 0]Total: 1 ENUM (60 values) Get double properties (Bid, Ask, Point, etc.) <code>SymbolInfoDoubleProperty</code> (60 values) - Property selector - symbol_info_integer [In: 1, Out: 0]Total: 1 ENUM (37 values) Get integer properties (Digits, Spread, etc.) <code>SymbolInfoIntegerProperty</code> (37 values) - Property selector - symbol_info_string [In: 1, Out: 0]Total: 1 ENUM (15 values) Get string properties (Description, etc.) <code>SymbolInfoStringProperty</code> (15 values) - Property selector - symbol_info_margin_rate [In: 1, Out: 0]Total: 1 ENUM (9 values) Get margin requirements for order types <code>ENUM_ORDER_TYPE</code> (9 values) - Order type - symbol_info_tick [In: 0, Out: 0]Total: 0 ENUMs Get last tick data with timestamp - - symbol_info_session_quote [In: 1, Out: 0]Total: 1 ENUM (7 values) Get quote session times <code>BMT5_ENUM_DAY_OF_WEEK</code> (7 values) - Day of week - symbol_info_session_trade [In: 1, Out: 0]Total: 1 ENUM (7 values) Get trade session times <code>BMT5_ENUM_DAY_OF_WEEK</code> (7 values) - Day of week - symbol_params_many [In: 1, Out: 13]Total: 14 ENUMs Get detailed parameters for multiple symbols <code>AH_SYMBOL_PARAMS_MANY_SORT_TYPE</code> (4 values) - Sort mode 13 ENUMs in SymbolParameters: BMT5_ENUM_SYMBOL_SECTOR, BMT5_ENUM_SYMBOL_INDUSTRY, BMT5_ENUM_SYMBOL_CHART_MODE, BMT5_ENUM_SYMBOL_CALC_MODE, BMT5_ENUM_SYMBOL_TRADE_MODE, BMT5_ENUM_SYMBOL_TRADE_EXECUTION, BMT5_ENUM_SYMBOL_SWAP_MODE, BMT5_ENUM_DAY_OF_WEEK, BMT5_ENUM_ORDER_TYPE_FILLING, BMT5_ENUM_ORDER_TYPE, BMT5_ENUM_SYMBOL_ORDER_GTC_MODE, BMT5_ENUM_SYMBOL_OPTION_MODE, BMT5_ENUM_SYMBOL_OPTION_RIGHT"},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#3-positions-orders-information-6-methods","title":"\ud83d\udccb 3. Positions &amp; Orders Information (6 methods)","text":""},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#36-methods-use-enums-50","title":"3/6 methods use ENUMs (50%)","text":"Method ENUMs Count Description Input ENUMs Output ENUMs positions_total [In: 0, Out: 0]Total: 0 ENUMs Count open positions - - opened_orders [In: 1, Out: 6]Total: 7 ENUMs Get all opened orders &amp; positions <code>BMT5_ENUM_OPENED_ORDER_SORT_TYPE</code> (4 values) - Sort mode 6 ENUMs:In PositionInfo: BMT5_ENUM_POSITION_TYPE, BMT5_ENUM_POSITION_REASONIn OpenedOrderInfo: BMT5_ENUM_ORDER_TYPE, BMT5_ENUM_ORDER_STATE, BMT5_ENUM_ORDER_TYPE_FILLING, BMT5_ENUM_ORDER_TYPE_TIME opened_orders_tickets [In: 0, Out: 0]Total: 0 ENUMs Get only ticket numbers (lightweight) - - order_history [In: 1, Out: 7]Total: 8 ENUMs Get historical orders with pagination <code>BMT5_ENUM_ORDER_HISTORY_SORT_TYPE</code> (6 values) - Sort mode 7 ENUMs:In OrderHistoryData: BMT5_ENUM_ORDER_STATE, BMT5_ENUM_ORDER_TYPE, BMT5_ENUM_ORDER_TYPE_FILLING, BMT5_ENUM_ORDER_TYPE_TIMEIn DealHistoryData: BMT5_ENUM_DEAL_ENTRY_TYPE, BMT5_ENUM_DEAL_TYPE, BMT5_ENUM_DEAL_REASON positions_history [In: 1, Out: 1]Total: 2 ENUMs Get historical positions with P&amp;L <code>AH_ENUM_POSITIONS_HISTORY_SORT_TYPE</code> (4 values) - Sort mode <code>AH_ENUM_POSITIONS_HISTORY_ORDER_TYPE</code> (9 values) - Order type tick_value_with_size [In: 0, Out: 0]Total: 0 ENUMs Get tick value and size for symbols - -"},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#4-market-depth-dom-3-methods","title":"\ud83d\udcda 4. Market Depth / DOM (3 methods)","text":""},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#13-methods-use-enums-33","title":"1/3 methods use ENUMs (33%)","text":"Method ENUMs Count Description Input ENUMs Output ENUMs market_book_add [In: 0, Out: 0]Total: 0 ENUMs Subscribe to Depth of Market updates - - market_book_release [In: 0, Out: 0]Total: 0 ENUMs Unsubscribe from DOM - - market_book_get [In: 0, Out: 1]Total: 1 ENUM (4 values) Get current market depth snapshot - <code>BookType</code> (4 values) - Order type in book: BOOK_TYPE_SELL, BOOK_TYPE_BUY, BOOK_TYPE_SELL_MARKET, BOOK_TYPE_BUY_MARKET"},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#5-trading-operations-6-methods","title":"\ud83d\udcb0 5. Trading Operations (6 methods)","text":""},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#66-methods-use-enums-100","title":"6/6 methods use ENUMs (100%)","text":"Method ENUMs Count Description Input ENUMs Output ENUMs order_send [In: 2, Out: 0]Total: 2 ENUMs (13 values) Send market or pending order 2 ENUMs:<code>TMT5_ENUM_ORDER_TYPE</code> (9 values) - Order type<code>TMT5_ENUM_ORDER_TYPE_TIME</code> (4 values) - Order lifetime - order_modify [In: 1, Out: 0]Total: 1 ENUM (4 values) Modify existing order parameters <code>TMT5_ENUM_ORDER_TYPE_TIME</code> (4 values) - Order lifetime - order_close [In: 0, Out: 1]Total: 1 ENUM (3 values) Close market or pending order - <code>MRPC_ORDER_CLOSE_MODE</code> (3 values): MRPC_MARKET_ORDER_CLOSE, MRPC_MARKET_ORDER_PARTIAL_CLOSE, MRPC_PENDING_ORDER_REMOVE order_check [In: 4, Out: 0]Total: 4 ENUMs (23 values) Validate order before sending 4 ENUMs in MrpcMqlTradeRequest:<code>MRPC_ENUM_TRADE_REQUEST_ACTIONS</code> (6 values) - Trade action type<code>ENUM_ORDER_TYPE_TF</code> (9 values) - Order type<code>MRPC_ENUM_ORDER_TYPE_FILLING</code> (4 values) - Order filling policy<code>MRPC_ENUM_ORDER_TYPE_TIME</code> (4 values) - Order lifetime - order_calc_margin [In: 1, Out: 0]Total: 1 ENUM (9 values) Calculate required margin <code>ENUM_ORDER_TYPE_TF</code> (9 values) - Order type - order_calc_profit [In: 1, Out: 0]Total: 1 ENUM (9 values) Calculate potential profit/loss <code>ENUM_ORDER_TYPE_TF</code> (9 values) - Order type -"},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#6-streaming-methods-5-methods","title":"\ud83d\udce1 6. Streaming Methods (5 methods)","text":""},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#35-methods-use-enums-60","title":"3/5 methods use ENUMs (60%)","text":"Method ENUMs Count Description Input ENUMs Output ENUMs on_symbol_tick [In: 0, Out: 0]Total: 0 ENUMs Stream tick data (Bid/Ask updates) - - on_trade [In: 0, Out: 1]Total: 11 ENUMs (68 values) Stream trade events - 1 direct + 10 in nested structures:1. <code>MT5_SUB_ENUM_EVENT_GROUP_TYPE</code> (2 values) - OnTradeData.type2-11. In event_data nested structures: SUB_ENUM_POSITION_TYPE (2), SUB_ENUM_POSITION_REASON (7), SUB_ENUM_ORDER_TYPE (9), SUB_ENUM_ORDER_STATE (10), SUB_ENUM_DEAL_TYPE (8), SUB_ENUM_ORDER_TYPE_TIME (4), SUB_ENUM_ORDER_TYPE_FILLING (4), SUB_ENUM_ORDER_REASON (7), SUB_ENUM_DEAL_ENTRY (4), SUB_ENUM_DEAL_REASON (11) on_position_profit [In: 0, Out: 1]Total: 1 ENUM (2 values) Stream position P&amp;L updates - <code>MT5_SUB_ENUM_EVENT_GROUP_TYPE</code> (2 values) - Event type in OnPositionProfitData.type field on_positions_and_pending_orders_tickets [In: 0, Out: 0]Total: 0 ENUMs Stream ticket changes - - on_trade_transaction [In: 0, Out: 9]Total: 9 ENUMs (107 values) Stream trade transaction events - 11 ENUM fields from 9 unique types:1. <code>MT5_SUB_ENUM_EVENT_GROUP_TYPE</code> (2 values) - OnTradeTransactionData.type2-6. In MqlTradeTransaction: SUB_ENUM_TRADE_TRANSACTION_TYPE (11 values), SUB_ENUM_ORDER_TYPE (9 values), SUB_ENUM_ORDER_STATE (10 values), SUB_ENUM_DEAL_TYPE (18 values), SUB_ENUM_ORDER_TYPE_TIME (4 values)7-10. In MqlTradeRequest: SUB_ENUM_TRADE_REQUEST_ACTIONS (7 values), SUB_ENUM_ORDER_TYPE (9 values), SUB_ENUM_ORDER_TYPE_FILLING (4 values), SUB_ENUM_ORDER_TYPE_TIME (4 values)11. In MqlTradeResult: MqlErrorTradeCode (42 values)"},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#important-notes","title":"Important Notes","text":""},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#python-enum-access","title":"Python ENUM Access","text":"<p>Python accesses ENUMs through protobuf modules:</p> <p>Correct: <pre><code>from MetaRpcMT5 import mt5_term_api_account_information_pb2 as account_info_pb2\n\n# Using ENUM\nproperty_id = account_info_pb2.AccountInfoDoublePropertyType.ACCOUNT_BALANCE\n</code></pre></p> <p>Incorrect: <pre><code>ACCOUNT_BALANCE  # NameError: name 'ACCOUNT_BALANCE' is not defined\n</code></pre></p>"},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#special-cases","title":"Special Cases","text":"<p>1. AccountInfoInteger and SymbolInfoInteger:</p> <ul> <li> <p>Some properties return values that represent ENUMs, but are returned as <code>int64</code></p> </li> <li> <p>These are NOT typed ENUMs, just numbers!</p> </li> </ul> <p>2. ReturnedCode:</p> <ul> <li> <p>ReturnedCode field in trading operations is NOT an ENUM</p> </li> <li> <p>It's a plain uint32 operation return code</p> </li> </ul>"},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#see-also","title":"See Also","text":""},{"location":"All_Guides/ENUMS_USAGE_REFERENCE/#documentation-by-group","title":"Documentation by Group:","text":"<ul> <li> <p>Account Information Overview</p> </li> <li> <p>Symbol Information Overview</p> </li> <li> <p>Positions &amp; Orders Overview</p> </li> <li> <p>Market Depth Overview</p> </li> <li> <p>Trading Operations Overview</p> </li> <li> <p>Streaming Methods Overview</p> </li> </ul>"},{"location":"All_Guides/GETTING_STARTED/","title":"Getting Started with PyMT5","text":"<p>Welcome to PyMT5 - a comprehensive educational project for learning MT5 trading automation from scratch using Python.</p>"},{"location":"All_Guides/GETTING_STARTED/#prerequisites-and-installation","title":"Prerequisites and Installation","text":"<p>Before starting work with PyMT5, you need to set up your development environment.</p>"},{"location":"All_Guides/GETTING_STARTED/#step-1-install-python-38","title":"Step 1: Install Python 3.8+","text":"<p>PyMT5 requires Python version 3.8 or higher.</p> <p>Download and install:</p> <ul> <li>Official website: Python Downloads</li> <li>Choose the installer for your platform</li> <li>Important for Windows: Check \"Add Python to PATH\" during installation</li> </ul> <p>Verify installation:</p> <pre><code>python --version\n# Should show: Python 3.8.x or higher\n</code></pre>"},{"location":"All_Guides/GETTING_STARTED/#step-2-install-code-editor","title":"Step 2: Install Code Editor","text":"<p>Visual Studio Code (Recommended):</p> <ul> <li> <p>Download: VS Code</p> </li> <li> <p>Extensions to install:</p> </li> <li> <p>Python (official Python extension from Microsoft)</p> </li> <li>Pylance (Python language server)</li> <li>Python Test Explorer (optional)</li> </ul> <p>PyCharm (Alternative):</p> <ul> <li> <p>Download: PyCharm by JetBrains</p> </li> <li> <p>Professional IDE for Python with advanced features</p> </li> </ul> <p>You can also use:</p> <ul> <li>Vim/Neovim with python plugins</li> <li>Sublime Text</li> <li>Any text editor + command line</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#step-3-clone-the-repository","title":"Step 3: Clone the Repository","text":"<p>Clone the PyMT5 project from GitHub:</p> <pre><code>git clone https://github.com/MetaRPC/PyMT5\ncd PyMT5\n</code></pre> <p>If you don't have Git installed:</p> <ul> <li>Download from git-scm.com</li> <li>Or download the project as ZIP from GitHub and extract</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#step-4-understanding-the-connection-flow","title":"Step 4: Understanding the Connection Flow","text":"<p>PyMT5 connects to the MT5 terminal via gRPC gateway.</p> <p>Connection flow: <pre><code>PyMT5 -&gt; gRPC -&gt; mt5term Gateway -&gt; MT5 Terminal\n</code></pre></p> <p>What is mt5term Gateway?</p> <ul> <li>External gateway process that bridges PyMT5 with the MT5 terminal</li> <li>Handles connection pooling and session management</li> <li>Connection settings are specified in <code>examples/0_common/settings.json</code></li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#configuration-file-settingsjson","title":"\ud83d\udcdd Configuration File: settings.json","text":"<ul> <li>Before starting work, let's specify your actual credentials in the configuration file.</li> <li>It's better to use a Demo account for learning.</li> </ul> <pre><code>{\n  \"user\": 591129415,\n  \"password\": \"IpoHj17tYu67@\",\n  \"grpc_server\": \"mt5.mrpc.pro:443\",\n  \"mt_cluster\": \"FxPro-MT5 Demo\",\n  \"test_symbol\": \"EURUSD\"\n}\n</code></pre> <p>Configuration parameters explanation:</p> Parameter Description Example user Your MT5 account login number <code>591129415</code> password Your MT5 account password (master password) <code>\"YourPassword\"</code> mt_cluster MT5 server name from your broker <code>\"FxPro-MT5 Demo\"</code> grpc_server Full gRPC server address (host:port) <code>\"mt5.mrpc.pro:443\"</code> test_symbol Default trading symbol for examples <code>\"EURUSD\"</code> <p>Important notes:</p> <ul> <li>user, password, mt_cluster - These are your MT5 account credentials</li> <li>grpc_server - Provided by the MetaRPC team</li> <li>test_symbol - Change to your preferred trading symbol</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#mt5-account-setup","title":"\u2795 MT5 Account Setup","text":"<p>If you don't have an MT5 demo account yet or need help creating one, refer to the beginner's guide:</p> <p>MT5 for Beginners - Creating Demo Account</p> <p>This guide covers:</p> <ul> <li>Downloading and installing MT5 terminal</li> <li>Step-by-step demo account creation</li> <li>Understanding master password and investor password</li> <li>Choosing a broker (optional)</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#about-the-project","title":"About the Project","text":"<p>This project is a demonstration of capabilities of our team's gateway for reproducing methods and functionality. It is designed to help you build your own trading logic system in the future.</p> <p>We will guide you through all major aspects - from basic manual trading to a fully customizable algorithmic trading system. This journey will reveal the full potential of your acquired knowledge and fundamental understanding of trading and markets.</p> <p>What you will learn:</p> <ul> <li>What gRPC methods do and how to use them directly</li> <li>How methods can be modified for your needs</li> <li>How to optimize your Python code for performance</li> <li>How to create convenient input/output systems</li> <li>How to effectively track positions by symbols</li> <li>How to build intelligent risk management systems</li> <li>How to work with Python asyncio for real-time streaming</li> </ul> <p>All we ask from you:</p> <p>The desire to learn, learn, and learn again. In the end, this will lead to significant results and, most importantly, to a solid foundation of knowledge in algorithmic trading with Python.</p>"},{"location":"All_Guides/GETTING_STARTED/#project-architecture-three-tier-system","title":"\ud83c\udfd7\ufe0f Project Architecture: Three-Tier System","text":"<p>The project consists of three interconnected layers in the <code>src/pymt5/</code> and <code>package/MetaRpcMT5/helpers/</code> directories, each building upon the previous one. Understanding this chain is key to mastering PyMT5.</p>"},{"location":"All_Guides/GETTING_STARTED/#tier-1-mt5account-low-level-grpc-foundation","title":"\ud83d\udd39 Tier 1: MT5Account - Low-Level gRPC Foundation","text":"<p>What it is: Direct gRPC calls to the MT5 terminal - the absolute foundation of everything.</p> <p>MT5Account Master Overview</p> <p>File: <code>package/MetaRpcMT5/helpers/mt5_account.py</code> (2100+ lines)</p> <ul> <li>Raw protocol buffer messages and gRPC communication</li> <li>Maximum control and flexibility over each request/response</li> <li>All other tiers use this internally</li> <li>Automatic reconnection with exponential backoff</li> <li>42 async methods, covering all MT5 operations</li> <li>Best for: Advanced users who need granular control</li> </ul> <p>Key features:</p> <ul> <li>Async/await based API</li> <li>Automatic reconnection on transient errors</li> <li>Built-in retry logic for network failures</li> <li>Session management with UUID tracking</li> </ul> <p>Two-Level Documentation:</p> <p>For each MT5Account methods, two types of documentation are available:</p> <ol> <li>Main reference - complete method description with all input/output parameters and enums</li> <li> <p>Example: <code>docs/MT5Account/2. Symbol_Information/symbol_info_double.md</code></p> </li> <li> <p>HOW_IT_WORK - detailed step-by-step explanation with live code examples</p> </li> <li>Example: <code>docs/MT5Account/HOW_IT_WORK/2. Symbol_Information_HOW/symbol_info_double_HOW.md</code></li> <li>Line-by-line breakdown of actual code from demo files</li> <li>Detailed comments for each step</li> </ol> <p>This two-level approach allows you to quickly find reference information OR deeply understand how the method works internally.</p>"},{"location":"All_Guides/GETTING_STARTED/#tier-2-mt5service-selective-convenience-layer","title":"\ud83d\udd38 Tier 2: MT5Service - Selective Convenience Layer","text":"<p>What it is: Mid-level wrapper that provides value-added methods on top of MT5Account.</p> <p>MT5Service Overview</p> <p>File: <code>src/pymt5/mt5_service.py</code> (1200+ lines)</p> <p>Primary purpose: Architectural middleware layer for MT5Sugar. MT5Service exists primarily to serve as a foundation for high-level MT5Sugar operations.</p> <p>Reality check: Not all 36 methods add the same value:</p> <ul> <li>\u2705 11 HIGH/VERY HIGH value methods - Aggregate multiple RPC calls, complex protobuf unpacking, datetime conversions, create structured dataclasses</li> <li>\u26aa 26 NONE/LOW value methods - Direct pass-through or simple single-field extraction</li> </ul> <p>Key insight: Since MT5Account already provides async methods with unpacked protobuf values, MT5Service's direct usage value comes from:</p> <ul> <li>Methods that aggregate multiple calls (e.g., <code>get_account_summary()</code> - combines 5 RPC calls)</li> <li>Methods that create rich dataclasses (e.g., <code>check_order()</code> - extracts deeply nested structures)</li> <li>Methods with datetime conversions (e.g., <code>get_symbol_tick()</code> - unix timestamp \u2192 datetime)</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#tier-3-mt5sugar-high-level-helpers","title":"\ud83d\udd3a Tier 3: MT5Sugar - High-Level Helpers","text":"<p>What it is: Syntactic sugar and helper methods for maximum productivity.</p> <p>MT5Sugar Overview</p> <p>File: <code>src/pymt5/mt5_sugar.py</code> (2100+ lines)</p> <ul> <li>One-line operations for common tasks</li> <li>Smart defaults and automatic parameter inference</li> <li>Risk-based position size calculation</li> <li>SL/TP calculation based on pips</li> <li>Most intuitive and beginner-friendly</li> <li>Best for: Quick prototyping and simple strategies</li> </ul> <p>Key features:</p> <ul> <li><code>buy_market(symbol, volume)</code> - one line to open a position</li> <li><code>calculate_position_size(symbol, risk_percent, sl_pips)</code> - automatic volume calculation by risk</li> <li><code>buy_market_with_pips(symbol, volume, sl_pips, tp_pips)</code> - open with SL/TP in pips</li> <li><code>get_balance()</code>, <code>get_equity()</code> - async methods for account information</li> <li><code>close_all_positions()</code> - emergency exit</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#understanding-the-chain","title":"\u2699\ufe0f Understanding the Chain","text":"<p>This three-tier chain represents the evolution from low-level control to high-level convenience:</p> <pre><code>MT5Sugar (easiest, highest abstraction)\n    \" uses\nMT5Service (convenient wrappers)\n    \" uses\nMT5Account (raw gRPC, foundation)\n    \" communicates with\nMT5 Terminal (via gateway)\n</code></pre> <p>Each overview document includes:</p> <ul> <li>Detailed method descriptions with parameters</li> <li>Return types and error handling patterns</li> <li>Usage examples and best practices</li> <li>Common patterns and pitfalls to avoid</li> <li>Python-specific guidance (asyncio, type hints, dataclasses)</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#i-recommended-learning-paths","title":"\u2139\ufe0f Recommended Learning Paths","text":"<p>Path A: For Python Developers (Bottom-Up Approach)</p> <p>If you have experience with Python and want to understand everything deeply:</p> <ol> <li>Start with MT5Account - Study the gRPC foundation and async patterns</li> <li>Move to MT5Service - Understand convenient wrappers</li> <li>Finish with MT5Sugar - Appreciate high-level abstractions</li> </ol> <p>This path gives you full control and deep understanding.</p> <p>Path B: For Traders (Top-Down Approach)</p> <p>If you're new to trading automation and want quick results:</p> <ol> <li>Start with MT5Sugar - Easy, intuitive methods for quick trading</li> <li>Move to MT5Service - Learn more advanced patterns as needed</li> <li>Deep dive into MT5Account - Understand the foundation for full control</li> </ol> <p>This path allows you to start trading quickly, leaving room for growth.</p>"},{"location":"All_Guides/GETTING_STARTED/#demo-examples","title":"Demo Examples","text":"<p>You can explore demo files that showcase various aspects of the SDK. These files are organized by complexity level and are located in the <code>examples/</code> folder.</p> <p>Each file includes inline code comments explaining what each operation does.</p>"},{"location":"All_Guides/GETTING_STARTED/#examples0_common-common-utilities","title":"examples/0_common/ (Common Utilities)","text":"<p>Helper utilities and configuration:</p> <ul> <li>demo_helpers.py - Connection helper, config loading, error formatting</li> <li>settings.json - Configuration file (credentials, server)</li> <li>protobuf_inspector.py - Interactive protobuf types inspector (run: <code>python main.py inspect</code>)</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#i-examples1_lowlevel-mt5account-low-level","title":"\u2160 examples/1_lowlevel/ (MT5Account - Low Level)","text":"<p>Protobuf/gRPC methods - full control, maximum flexibility:</p> <ul> <li>01_general_operations.py - Information methods (account, symbols, positions, ticks)</li> <li>02_trading_operations.py - Trading operations (calculations, validation, orders)</li> <li>03_streaming_methods.py - Streaming methods (real-time ticks, deals, positions)</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#ii-examples2_service-mt5service-mid-level","title":"\u2161 examples/2_service/ (MT5Service - Mid Level)","text":"<p>Python wrappers over protobuf - native types, more convenient to work with:</p> <ul> <li>04_service_demo.py - Service API wrappers (account, symbols, positions, orders)</li> <li>05_service_streaming.py - Service API streaming methods (ticks, deals, profits)</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#iii-examples3_sugar-mt5sugar-high-level","title":"\u2162 examples/3_sugar/ (MT5Sugar - High Level)","text":"<p>High-level API - maximum simplification, one line of code:</p> <ul> <li>06_sugar_basics.py - Basics: connection, balance, prices</li> <li>07_sugar_trading.py - Trading: market/pending orders, SL/TP</li> <li>08_sugar_positions.py - Positions: queries, modification, closing</li> <li>09_sugar_history.py - History: deals, profit over period</li> <li>10_sugar_advanced.py - Advanced: risk management, symbol info, helpers</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#iv-examples4_orchestrators-strategies","title":"\u2163 examples/4_orchestrators/ (Strategies)","text":"<p>Full-fledged trading strategies - examples of complex automation:</p> <ul> <li>11_trailing_stop.py - Automatic trailing stop manager</li> <li>12_position_scaler.py - Position scaling</li> <li>13_grid_trader.py - Grid trading for sideways market</li> <li>14_risk_manager.py - Automatic risk management</li> <li>15_portfolio_rebalancer.py - Portfolio rebalancing</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#v-examples5_usercode","title":"\u2164 examples/5_usercode/","text":"<p>Sandbox for your custom code:</p> <ul> <li>17_usercode.py - Template file for your own trading logic</li> </ul> <p>User Code Sandbox Guide</p>"},{"location":"All_Guides/GETTING_STARTED/#running-examples-with-mainpy","title":"Running Examples with main.py","text":""},{"location":"All_Guides/GETTING_STARTED/#what-is-mainpy","title":"What is main.py?","text":"<p><code>examples/main.py</code> is the single entry point for all PyMT5 demo examples. It works as a dispatcher that:</p> <ol> <li>Runs any example by number or readable name (alias)</li> <li>Manages connection to MT5 via gRPC (creation, validation, closing)</li> <li>Loads configuration from <code>0_common/settings.json</code> (credentials, server)</li> <li>Ensures clean exit (graceful shutdown, connection closing)</li> <li>Shows interactive menu for example selection (if run without parameters)</li> </ol> <p>Benefits of centralized main.py:</p> <ul> <li>No need to copy connection code into each example</li> <li>All examples use one configuration</li> <li>Easy to switch between examples</li> <li>Automatic error handling and cleanup</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#two-ways-to-run","title":"\ud83c\udfc1 Two Ways to Run","text":""},{"location":"All_Guides/GETTING_STARTED/#method-1-interactive-menu-recommended-for-learning","title":"Method 1: Interactive Menu (recommended for learning)","text":"<p>Run without parameters - a menu with all available examples will appear:</p> <pre><code>cd examples\npython main.py\n</code></pre> <p>You will see: <pre><code>================================================================\n                 PyMT5 - DEMONSTRATION EXAMPLES\n================================================================\n\nSelect an example to run:\n\n[LOW-LEVEL] MT5Account - Direct gRPC/Protobuf\n  1  - General operations (account, symbols, positions)\n  2  - Trading operations (orders, modify, close)\n  3  - Streaming methods (real-time ticks, trades)\n\n[MID-LEVEL] MT5Service - Python Wrappers\n  4  - Service API demo\n  5  - Service streaming demo\n\n[HIGH-LEVEL] MT5Sugar - Convenience API\n  6  - Sugar basics (connection, balance, prices)\n  7  - Sugar trading (market orders, pending orders)\n  8  - Sugar positions (query, modify, close)\n  9  - Sugar history (deals, profit calculations)\n  10 - Sugar advanced (risk management, symbol info)\n\n[ORCHESTRATORS] Trading Strategies\n  11 - Trailing Stop Manager\n  12 - Position Scaler (pyramiding/averaging)\n  13 - Grid Trader\n  14 - Risk Manager\n  15 - Portfolio Rebalancer\n\n[TOOLS]\n  16 - User Code Sandbox (your custom code)\n\nEnter number or alias (or 'x' to exit):\n</code></pre></p>"},{"location":"All_Guides/GETTING_STARTED/#method-2-direct-run-quick-access","title":"Method 2: Direct Run (quick access)","text":"<p>If you know what you want to run, use number or alias:</p> <pre><code>cd examples\n\n# By number\npython main.py 1        # Will run example #1\npython main.py 11       # Will run Trailing Stop\npython main.py 16       # Will run User Sandbox\n\n# By alias (more memorable)\npython main.py lowlevel01       # Same as 1\npython main.py trailing         # Same as 11\npython main.py usercode         # Same as 16\n</code></pre>"},{"location":"All_Guides/GETTING_STARTED/#full-command-table","title":"Full Command Table","text":""},{"location":"All_Guides/GETTING_STARTED/#low-level-mt5account-direct-grpc-calls","title":"LOW-LEVEL (MT5Account) - Direct gRPC Calls","text":"Number Aliases File Description 1 <code>lowlevel01</code>, <code>general</code> <code>1_lowlevel/01_general_operations.py</code> Information methods: account, symbols, positions, ticks 2 <code>lowlevel02</code>, <code>trading</code> <code>1_lowlevel/02_trading_operations.py</code> Trading operations: calculations, validation, orders 3 <code>lowlevel03</code>, <code>streaming</code>, <code>stream</code> <code>1_lowlevel/03_streaming_methods.py</code> Real-time streaming: ticks, deals, positions <p>When to use: Learning low-level protobuf structures, maximum control.</p>"},{"location":"All_Guides/GETTING_STARTED/#mid-level-mt5service-python-wrappers","title":"MID-LEVEL (MT5Service) - Python Wrappers","text":"Number Aliases File Description 4 <code>service</code>, <code>mid</code> <code>2_service/04_service_demo.py</code> Service API wrappers: account, symbols, positions, orders 5 <code>service05</code>, <code>servicestreaming</code> <code>2_service/05_service_streaming.py</code> Service streaming methods: ticks, deals, profits <p>When to use: More convenient work with Python types, less boilerplate code.</p>"},{"location":"All_Guides/GETTING_STARTED/#high-level-mt5sugar-simplified-api","title":"HIGH-LEVEL (MT5Sugar) - Simplified API","text":"Number Aliases File Description 6 <code>sugar06</code>, <code>sugarbasics</code>, <code>basics</code> <code>3_sugar/06_sugar_basics.py</code> Basics: connection, balance, prices 7 <code>sugar07</code>, <code>sugartrading</code> <code>3_sugar/07_sugar_trading.py</code> Trading: market/pending orders, SL/TP 8 <code>sugar08</code>, <code>sugarpositions</code>, <code>positions</code> <code>3_sugar/08_sugar_positions.py</code> Positions: queries, modification, closing 9 <code>sugar09</code>, <code>sugarhistory</code>, <code>history</code> <code>3_sugar/09_sugar_history.py</code> History: deals over period, profit calculation 10 <code>sugar10</code>, <code>sugaradvanced</code>, <code>advanced</code> <code>3_sugar/10_sugar_advanced.py</code> Advanced: risk management, symbol info <p>When to use: Quick prototyping, simple scripts, one line of code.</p>"},{"location":"All_Guides/GETTING_STARTED/#orchestrators-trading-strategies","title":"ORCHESTRATORS - Trading Strategies","text":"Number Aliases File Description 11 <code>trailing</code>, <code>trailingstop</code> <code>4_orchestrators/11_trailing_stop.py</code> Automatic trailing stop manager 12 <code>scaler</code>, <code>positionscaler</code> <code>4_orchestrators/12_position_scaler.py</code> Position scaling (pyramiding/averaging) 13 <code>grid</code>, <code>gridtrading</code> <code>4_orchestrators/13_grid_trader.py</code> Grid trading for sideways market 14 <code>risk</code>, <code>riskmanager</code> <code>4_orchestrators/14_risk_manager.py</code> Automatic risk management 15 <code>rebalancer</code>, <code>portfolio</code> <code>4_orchestrators/15_portfolio_rebalancer.py</code> Portfolio rebalancing <p>When to use: Learning complex strategies, combining multiple API methods.</p>"},{"location":"All_Guides/GETTING_STARTED/#tools-developer-tools","title":"TOOLS - Developer Tools","text":"Number Aliases File Description 16 <code>inspect</code>, <code>inspector</code>, <code>proto</code> <code>0_common/16_protobuf_inspector.py</code> Interactive protobuf types explorer 17 <code>usercode</code>, <code>user</code>, <code>sandbox</code>, <code>custom</code> <code>5_usercode/17_usercode.py</code> Sandbox for your code <p>When to use: Exploring protobuf structures (16), writing your own trading logic (17)</p>"},{"location":"All_Guides/GETTING_STARTED/#initial-setup-mandatory","title":"\u26a1 Initial Setup (mandatory!)","text":"<p>After cloning the repository, you must install dependencies:</p> <pre><code># 1. Navigate to the project root\ncd PyMT5\n\n# 2. Install dependencies and link local package (only once)\npip install -e ./package\n</code></pre> <p>What <code>pip install -e ./package</code> does:</p> <ul> <li>Installs required dependencies into your Python environment:</li> <li><code>grpcio&gt;=1.60.0</code> (gRPC runtime)</li> <li><code>grpcio-tools&gt;=1.60.0</code> (protobuf tools)</li> <li> <p><code>googleapis-common-protos&gt;=1.56.0</code> (Google API types)</p> </li> <li> <p>Creates editable link to local <code>package/MetaRpcMT5/</code> folder</p> </li> <li>Does NOT copy or duplicate the package</li> <li>Uses the existing code from your repository</li> <li>All changes to <code>package/</code> are immediately visible</li> </ul> <p>Important notes:</p> <ul> <li>MetaRpcMT5 package already exists in the repository (<code>package/MetaRpcMT5/</code>)</li> <li>This command installs only external dependencies (grpcio, etc.)</li> <li>Run this command only ONCE after cloning the repository</li> <li>After installation, all examples will work immediately</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#usage-examples","title":"Usage Examples","text":""},{"location":"All_Guides/GETTING_STARTED/#initial-learning-with-interactive-menu","title":"Initial Learning (with interactive menu)","text":"<pre><code>cd examples\n\n# Run menu (dependencies already installed above)\npython main.py\n\n# Select an example (enter number and press Enter)\n# Start with 1, 2, 3 to understand the basics\n</code></pre>"},{"location":"All_Guides/GETTING_STARTED/#quick-testing-of-specific-functions","title":"Quick Testing of Specific Functions","text":"<pre><code>cd examples\n\n# Testing Sugar API (simplest)\npython main.py basics          # Balance, prices\npython main.py trading         # Opening orders\npython main.py positions       # Working with positions\n\n# Testing orchestrators\npython main.py trailing        # Trailing stop\npython main.py grid            # Grid trading\npython main.py scaler          # Pyramiding/averaging\n\n# Working with your code\npython main.py usercode        # Your sandbox\n</code></pre>"},{"location":"All_Guides/GETTING_STARTED/#learning-sequence-recommended","title":"Learning Sequence (recommended)","text":"<pre><code># 1. Start with low level (understanding basics)\npython main.py 1               # How gRPC calls work\npython main.py 2               # How trading operations execute\n\n# 2. Move to mid level (Python wrappers)\npython main.py service         # More convenient API\n\n# 3. Explore high level (simplification)\npython main.py basics          # Sugar API - one line of code\npython main.py trading         # Simple trading operations\npython main.py advanced        # Risk management\n\n# 4. Explore orchestrators (strategies)\npython main.py trailing        # Ready-made strategy\npython main.py grid            # Complex logic\n\n# 5. Write your code\npython main.py usercode        # Your trading logic\n</code></pre>"},{"location":"All_Guides/GETTING_STARTED/#how-mainpy-handles-commands","title":"\ud83d\udd04 How main.py Handles Commands","text":"<p>Inside <code>main.py</code> there is a large routing block that handles commands:</p> <pre><code>if arg in [\"1\", \"lowlevel01\"]:\n    return await lowlevel01.main()  # -&gt; 1_lowlevel/01_general_operations.py\n\nelif arg in [\"11\", \"trailing\", \"trailingstop\"]:\n    return await trailing.main()     # -&gt; 4_orchestrators/11_trailing_stop.py\n\nelif arg in [\"16\", \"usercode\", \"user\", \"sandbox\", \"custom\"]:\n    return await usercode.main()     # -&gt; 5_usercode/17_usercode.py\n</code></pre> <p>Each command calls the corresponding module, which:</p> <ol> <li>Creates its own MT5Account connection using <code>create_and_connect_mt5()</code> helper</li> <li>Executes the demonstration with full connection control</li> <li>Closes the connection in <code>finally</code> block via <code>await account.channel.close()</code></li> <li>Returns control to main.py</li> </ol> <p>This means: Each example is fully independent and manages its own connection lifecycle. The examples are self-contained and can be run standalone or through main.py.</p>"},{"location":"All_Guides/GETTING_STARTED/#development-dependencies","title":"\ud83d\udee0\ufe0f Development Dependencies","text":"<p>PyMT5 uses the following key packages:</p> <pre><code># Core dependencies\ngrpcio&gt;=1.60.0                    # gRPC framework\ngrpcio-tools&gt;=1.60.0              # gRPC code generation tools\ngoogleapis-common-protos&gt;=1.56.0  # Google API common protobuf types\n# protobuf - installed automatically as dependency of grpcio\n\n# Built-in Python modules (no installation needed)\nasyncio         # Async I/O support (built-in)\ndataclasses     # Structured data (built-in for Python 3.7+)\ntyping          # Type hints (built-in)\n</code></pre> <p>All dependencies are listed in <code>package/pyproject.toml</code> and will be installed automatically with <code>pip install -e ./package</code></p>"},{"location":"All_Guides/GETTING_STARTED/#exploring-advanced-features","title":"\ud83e\udde9 Exploring Advanced Features","text":"<p>After mastering the three-tier chain (MT5Account -&gt; MT5Service -&gt; MT5Sugar), you can explore advanced features:</p>"},{"location":"All_Guides/GETTING_STARTED/#real-time-streaming","title":"Real-Time Streaming","text":"<p>Learn how to work with real-time data streams in Python:</p> <p>gRPC Stream Management</p> <p>Topics covered in the guide:</p> <ul> <li>Async generator patterns for streaming</li> <li>Reading streamed data with async for</li> <li>Asyncio task management and cancellation</li> <li>Automatic reconnection patterns</li> <li>Multiple concurrent streams</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#protobuf-inspector","title":"Protobuf Inspector","text":"<p>Interactive tool for exploring MT5 API types:</p> <p>Protobuf Inspector Guide</p> <p>Features:</p> <ul> <li>Explore protobuf message types</li> <li>Search types and fields</li> <li>View enum values</li> <li>Understand message structures</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#building-your-own-system","title":"Building Your Own System","text":"<p>After studying all examples and understanding the architecture, you can start building your own trading system:</p> <p>Sandbox location: <code>examples/5_usercode/17_usercode.py</code></p> <p>This file is prepared as a starter template for your custom code. Before you start coding here, make sure you've studied:</p> <ol> <li>The three-tier API (MT5Account -&gt; MT5Service -&gt; MT5Sugar)</li> <li>At least a few helper examples to understand the patterns</li> <li>Error handling patterns from examples</li> <li>Stream management, if you need real-time data</li> </ol> <p>User Code Sandbox Guide</p> <p>Quick start:</p> <pre><code>cd examples\npython main.py 16\n# Edit 5_usercode/17_usercode.py and add your code\n</code></pre>"},{"location":"All_Guides/GETTING_STARTED/#error-handling","title":"Error Handling","text":"<p>PyMT5 has comprehensive error handling:</p> <p>File: <code>package/MetaRpcMT5/helpers/errors.py</code></p> <p>Features:</p> <ul> <li><code>NotConnectedError</code> - raised when connection is not established</li> <li><code>ApiError</code> - wraps protobuf errors with Python exception</li> <li>Trading operation return codes - constants for all MT5 return codes</li> <li>Helper functions: <code>is_retcode_success()</code>, <code>is_retcode_retryable()</code></li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#return-codes-reference","title":"Return Codes Reference","text":"<p>Understanding return code meanings when executing trading operations:</p> <p>Return Codes Reference</p> <p>Common codes:</p> <ul> <li><code>10009</code> - Success (market order)</li> <li><code>10008</code> - Success (pending order)</li> <li><code>10019</code> - Insufficient margin</li> <li><code>10016</code> - Invalid stops (SL/TP too close)</li> <li><code>10018</code> - Market closed</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#grpc-stream-management","title":"gRPC Stream Management","text":"<p>If you're working with real-time streaming (ticks, events):</p> <p>gRPC Stream Management</p> <p>Primary pattern (recommended):</p> <ul> <li>Create <code>cancellation_event = asyncio.Event()</code> at start</li> <li>Pass <code>cancellation_event</code> to all streaming method calls</li> <li>Use <code>async for</code> to iterate over streams</li> <li>Stop streams with <code>cancellation_event.set()</code></li> </ul> <p>Additional patterns:</p> <ul> <li><code>asyncio.wait_for()</code> - auto-timeout (used in: 05_service_streaming.py, 03_streaming_methods.py)</li> <li><code>asyncio.create_task()</code> - background tasks (used in: 03_streaming_methods.py)</li> <li><code>asyncio.gather()</code> - concurrent streams (documentation only: GRPC_STREAM_MANAGEMENT.md)</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#complete-documentation","title":"\ud83d\uddc2\ufe0f Complete Documentation","text":""},{"location":"All_Guides/GETTING_STARTED/#core-api-documentation","title":"Core API Documentation","text":"<ul> <li>MT5Account Master Overview - Complete low-level API reference</li> <li>MT5Service Overview - Mid-level wrappers API</li> <li>MT5Sugar Overview - High-level Sugar API</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#guides-and-tutorials","title":"Guides and Tutorials","text":"<ul> <li>User Code Sandbox Guide - Quick start for custom code</li> <li>gRPC Stream Management - Working with real-time streams</li> <li>Protobuf Inspector Guide - Interactive type explorer</li> <li>Return Codes Reference - Trading operation return codes</li> <li>ENUMs Usage Reference - MT5 enum constants and usage</li> </ul>"},{"location":"All_Guides/GETTING_STARTED/#conclusion","title":"Conclusion","text":"<p>The MetaRPC team strives to create favorable conditions for learning fundamental trading principles and building algorithmic trading systems with Python.</p> <p>We believe that with diligence and desire to learn, you will be able to master everything - from low-level protocol communication to complex trading systems.</p> <p>Your journey starts here:</p> <ol> <li>Set up the environment (above)</li> <li>Create or configure your MT5 demo account (MT5 for Beginners)</li> <li>Choose a learning path (bottom-up or top-down)</li> <li>Run your first example: <code>python main.py 1</code></li> <li>Study the code, experiment and create</li> </ol> <p>Good luck on your algorithmic trading journey with Python!</p> <p>\"The foundation of success in algorithmic trading is not only understanding markets, but also understanding the code that interacts with them. Master both, and you will have unlimited possibilities.\"</p> <p>\u2014 MetaRPC Team</p>"},{"location":"All_Guides/GETTING_STARTED/#i-want-results-here-and-now","title":"\u2139\ufe0f Want Results Here and Now?","text":"<p>Don't want to clone the entire repository and study the architecture?</p> <p>Need a quick start in your own directory?</p> <p>If you can't wait to try the gRPC gateway capabilities as soon as possible and see your first working code in 10 minutes:</p> <p>Your First Project - Project from Scratch</p> <p>What you'll get:</p> <ul> <li>Create your project from scratch (without cloning the repository)</li> <li>Connect only necessary dependencies</li> <li>Write your first low-level method in 10 minutes</li> <li>Get account balance and see the result</li> <li>Start working with the gateway in your code immediately</li> </ul> <p>Difference in approaches:</p> This Document (GETTING_STARTED) Your First Project Clone ready-made repository Create project from scratch Study examples and architecture Write working code immediately Full SDK immersion Minimal quick start For deep understanding For instant result <p>Recommendation: After a quick start with Your First Project, return to this document to learn the complete architecture and all SDK capabilities.</p>"},{"location":"All_Guides/GETTING_STARTED/#python-specific-tips","title":"Python-Specific Tips","text":"<p>Effective Python practices used in this project:</p> <ul> <li>Async/await everywhere - All methods use asyncio for non-blocking I/O</li> <li>Type hints - Full type annotations for better IDE support</li> <li>Dataclasses - Structured data instead of raw protobuf</li> <li>Context managers - Clean resource management with async with</li> <li>Generators - Streaming data with async for</li> <li>Exception propagation - Python exceptions for validation and errors (ValueError, RuntimeError, TimeoutError)</li> <li>F-strings - Modern string formatting</li> </ul> <p>Resources for Python beginners:</p> <ul> <li>Python Official Tutorial - Official guide</li> <li>Real Python - Practical Python tutorials</li> <li>Python Asyncio - Async programming guide</li> </ul>"},{"location":"All_Guides/GLOSSARY/","title":"PyMT5 Glossary","text":"<p>Project-specific terms and concepts. This glossary covers PyMT5 architecture, components, and trading automation terminology used throughout the codebase.</p>"},{"location":"All_Guides/GLOSSARY/#architectural-terms","title":"\ud83c\udfd7\ufe0f Architectural Terms","text":""},{"location":"All_Guides/GLOSSARY/#three-tier-architecture","title":"Three-Tier Architecture","text":"<p>Core design pattern of PyMT5 with three abstraction levels:</p> <ul> <li>Tier 1 (MT5Account): Low-level gRPC communication with MT5 terminal</li> <li>Tier 2 (MT5Service): Wrapper methods with dataclasses and Python types</li> <li>Tier 3 (MT5Sugar): High-level convenience methods with ready patterns</li> </ul>"},{"location":"All_Guides/GLOSSARY/#mt5account","title":"MT5Account","text":"<p>\ud83d\udd39 Tier 1 - Low-Level API</p> <p>Base layer providing direct access to MT5 terminal via gRPC protocol.</p> <p>Key characteristics:</p> <ul> <li>Raw gRPC calls to MT5 terminal</li> <li>Built-in connection resilience with automatic reconnection</li> <li>Works with protobuf Request/Response objects</li> <li>Full control, maximum complexity</li> <li>42 async methods, covering all MT5 operations</li> <li>Returns protobuf Data objects</li> <li>Automatic reconnection with exponential backoff</li> <li>Session management with UUID tracking</li> </ul> <p>When to use: Advanced users who need granular control, custom integrations, building custom wrappers.</p> <p>Location: <code>package/MetaRpcMT5/helpers/mt5_account.py</code> (2100+ lines)</p> <p>Documentation: MT5Account.Master.Overview.md</p>"},{"location":"All_Guides/GLOSSARY/#mt5service","title":"MT5Service","text":"<p>\ud83d\udd38 Tier 2 - Wrappers API</p> <p>Middle layer providing simplified method signatures without proto complexity.</p> <p>Key characteristics:</p> <ul> <li>Returns clean Python types (float, int, str, datetime)</li> <li>Automatically unpacks protobuf .data wrappers</li> <li>Converts Timestamp to datetime objects</li> <li>Type conversion (proto to Python primitives/dataclasses)</li> <li>Simplified method names</li> <li>No auto-normalization (you control precision)</li> <li>36 methods for common scenarios</li> <li>Primary purpose: Architectural middleware layer for MT5Sugar</li> </ul> <p>Value distribution:</p> <ul> <li> <p>\u2705 11 HIGH/VERY HIGH value methods - Aggregate multiple RPC calls, complex protobuf unpacking, datetime conversions</p> </li> <li> <p>\u26aa 25 NONE/LOW value methods - Direct pass-through or simple single-field extraction</p> </li> </ul> <p>When to use: Building custom strategies that need more control than Sugar but less complexity than MT5Account.</p> <p>Location: <code>src/pymt5/mt5_service.py</code> (1200+ lines)</p> <p>Documentation: MT5Service.Overview.md</p>"},{"location":"All_Guides/GLOSSARY/#mt5sugar","title":"MT5Sugar","text":"<p>\ud83d\udd3a Tier 3 - Convenience API</p> <p>High-level API for common trading operations.</p> <p>Key characteristics:</p> <ul> <li>Properties for instant access (<code>await sugar.balance</code>)</li> <li>Context manager support (<code>async with MT5Sugar(service) as sugar</code>)</li> <li>Enums instead of magic numbers (<code>Period.TODAY</code>, <code>OrderType.BUY</code>)</li> <li>Unified methods with smart defaults</li> <li>One-line operations</li> <li>Type hints everywhere</li> <li>Simplest API, handles edge cases</li> <li>Best starting point for 95% of use cases</li> <li>62 methods + 7 properties = 69 total</li> </ul> <p>Key features:</p> <ul> <li><code>buy_market(symbol, volume)</code> - one line to open a position</li> <li><code>calculate_position_size(symbol, risk_percent, sl_pips)</code> - automatic volume calculation by risk</li> <li><code>buy_market_with_pips(symbol, volume, sl_pips, tp_pips)</code> - open with SL/TP in pips</li> <li><code>get_balance()</code>, <code>get_equity()</code> - async methods for account information</li> <li><code>close_all_positions()</code> - emergency exit</li> </ul> <p>When to use: Rapid development, prototyping, simple strategies, quick scripts.</p> <p>Location: <code>src/pymt5/mt5_sugar.py</code> (2100+ lines)</p> <p>Documentation: MT5Sugar Overview</p>"},{"location":"All_Guides/GLOSSARY/#python-specific-concepts","title":"\ud83e\udde9 Python-Specific Concepts","text":""},{"location":"All_Guides/GLOSSARY/#asyncawait-pattern","title":"Async/Await Pattern","text":"<p>Python's built-in asynchronous programming model.</p> <p>All methods in PyMT5 are async: <pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nfrom MetaRpcMT5 import mt5_term_api_account_information_pb2 as account_info_pb2\n\nasync def main():\n    # Create and connect\n    account = MT5Account.create()\n    await account.connect_by_server_name(...)\n\n    # Must use 'await' for all async operations\n    balance = await account.account_info_double(\n        account_info_pb2.AccountInfoDoublePropertyType.ACCOUNT_BALANCE\n    )\n    positions = await account.positions_total()\n\n    await account.channel.close()\n\n# Run async function\nasyncio.run(main())\n</code></pre></p> <p>Why async?</p> <ul> <li>Non-blocking I/O for gRPC calls</li> <li>Better performance for multiple operations</li> <li>Can handle streaming data efficiently</li> <li>Standard Python pattern for network operations</li> </ul> <p>Documentation: Python asyncio</p>"},{"location":"All_Guides/GLOSSARY/#dataclasses","title":"Dataclasses","text":"<p>Python's structured data containers.</p> <p>MT5Service uses dataclasses for clean data structures: <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass AccountSummary:\n    login: int                                      # Account login number\n    balance: float                                  # Account balance\n    equity: float                                   # Equity (balance + floating P&amp;L)\n    user_name: str                                  # Client name\n    leverage: int                                   # Account leverage (e.g., 100)\n    trade_mode: Any                                 # Trade mode (demo/real/contest)\n    company_name: str                               # Broker company name\n    currency: str                                   # Deposit currency\n    server_time: Optional[datetime]                 # Server time\n    utc_timezone_shift_minutes: int                 # UTC timezone shift\n    credit: float                                   # Credit facility\n    margin: float                                   # Used margin\n    free_margin: float                              # Free margin\n    margin_level: float                             # Margin level %\n    profit: float                                   # Floating P&amp;L\n\n# Usage\nsummary = await service.get_account_summary()\nprint(f\"Balance: {summary.balance}\")  # Clean attribute access\nprint(f\"Time: {summary.server_time}\")  # Already datetime object\n</code></pre></p> <p>Benefits:</p> <ul> <li>Type hints for IDE autocomplete</li> <li>Clean attribute access (no dict keys)</li> <li>Automatic repr and eq</li> <li>Immutable with frozen=True</li> </ul>"},{"location":"All_Guides/GLOSSARY/#async-generators","title":"Async Generators","text":"<p>Python's way to stream data asynchronously.</p> <p>Streaming methods return async generators: <pre><code># Streaming returns async generator\nasync for tick_data in account.on_symbol_tick([\"EURUSD\"]):\n    tick = tick_data.symbol_tick\n    print(f\"Bid: {tick.bid}, Ask: {tick.ask}\")\n    print(f\"Time: {tick.time}\")\n\n    # Can break anytime\n    if some_condition:\n        break\n\n# Auto cleanup when loop exits\n</code></pre></p> <p>Critical rules:</p> <ul> <li>Use <code>async for</code> to consume data</li> <li>Generator auto-stops when you break</li> <li>No manual cleanup needed</li> <li>Can use <code>async with</code> for scoped streaming</li> </ul> <p>Example with timeout: <pre><code>import asyncio\n\ntry:\n    async for tick_data in account.on_symbol_tick([\"EURUSD\"]):\n        tick = tick_data.symbol_tick\n        await asyncio.wait_for(process_tick(tick), timeout=5.0)\nexcept asyncio.TimeoutError:\n    print(\"Processing timeout\")\n</code></pre></p>"},{"location":"All_Guides/GLOSSARY/#properties","title":"\u2795 Properties","text":"<p>Python's computed attributes that look like simple fields.</p> <p>MT5Sugar uses properties for instant access: <pre><code># Properties - no parentheses needed!\nbalance = await sugar.balance       # Not sugar.get_balance()\nequity = await sugar.equity         # Not sugar.get_equity()\nmargin = await sugar.margin         # Not sugar.get_margin()\nfree_margin = await sugar.free_margin\nmargin_level = await sugar.margin_level\nprofit = await sugar.profit\n\n# All are async properties\n@property\nasync def balance(self) -&gt; float:\n    return await self.get_balance()\n</code></pre></p> <p>Benefits:</p> <ul> <li>Cleaner syntax</li> <li>Looks like attribute access</li> <li>Still async under the hood</li> <li>Better for quick scripts</li> </ul>"},{"location":"All_Guides/GLOSSARY/#context-managers","title":"Context Managers","text":"<p>Python's pattern for automatic resource cleanup.</p> <p>MT5Sugar supports async with: <pre><code># Create full stack\naccount = MT5Account.create(\n    user=591129415,\n    password=\"password\",\n    grpc_server=\"mt5.mrpc.pro:443\"\n)\n\nawait account.connect_by_server_name(\n    server_name=\"FxPro-MT5 Demo\",\n    base_chart_symbol=\"EURUSD\"\n)\n\nservice = MT5Service(account)\n\n# Use sugar with context manager\nasync with MT5Sugar(service) as sugar:\n    balance = await sugar.balance\n    ticket = await sugar.buy_market(\"EURUSD\", 0.01)\n\n# Manual cleanup still needed\nawait account.channel.close()\n</code></pre></p> <p>Why context managers?</p> <ul> <li>Cleaner code structure</li> <li>Standard Python pattern</li> <li>Scoped resource usage</li> </ul> <p>Important: Manual channel cleanup required</p> <p><code>account.channel</code> is the gRPC connection to MT5 terminal. You MUST call <code>await account.channel.close()</code> to:</p> <ul> <li>Close the persistent gRPC connection</li> <li>Release network resources</li> <li>Prevent connection leaks</li> <li>Avoid DEADLINE_EXCEEDED errors on exit</li> </ul> <p>Without <code>channel.close()</code>, the connection stays open and may cause resource leaks or errors on program shutdown.</p> <p>Recommended pattern with proper cleanup:</p> <pre><code>account = MT5Account.create(\n    user=591129415,\n    password=\"password\",\n    grpc_server=\"mt5.mrpc.pro:443\"\n)\n\ntry:\n    await account.connect_by_server_name(\n        server_name=\"FxPro-MT5 Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    # Work here\n    balance = await sugar.balance\n    ticket = await sugar.buy_market(\"EURUSD\", 0.01)\n\nfinally:\n    await account.channel.close()  # Always cleanup\n</code></pre>"},{"location":"All_Guides/GLOSSARY/#technical-concepts","title":"\ud83d\udce6 Technical Concepts","text":""},{"location":"All_Guides/GLOSSARY/#auto-normalization","title":"Auto-Normalization","text":"<p>Automatic adjustment of trading parameters to broker requirements.</p> <p>What gets normalized:</p> <ul> <li>Volumes: Rounded to broker's volume step (e.g., 0.01 lot)</li> <li>Prices: Rounded to symbol's tick size/digits (e.g., 5 decimal places for EURUSD)</li> <li>Stop Loss / Take Profit: Adjusted to symbol precision</li> </ul> <p>Where: MT5 terminal itself handles normalization (both MT5Service and MT5Sugar benefit)</p> <p>Example: <pre><code># You pass: volume=0.0234\n# Terminal normalizes to: volume=0.02 (if broker's step is 0.01)\nticket = await sugar.buy_market(\"EURUSD\", 0.0234)\n</code></pre></p> <p>Manual normalization if needed: <pre><code>from MetaRpcMT5 import mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get volume step\nvolume_step = await service.get_symbol_double(\n    \"EURUSD\",\n    market_info_pb2.SymbolInfoDoubleProperty.SYMBOL_VOLUME_STEP\n)\n\n# Round to step\nvolume = 0.0234\nnormalized_volume = round(volume / volume_step) * volume_step\n# Result: 0.02\n\n# Get symbol digits for price normalization\ndigits = await service.get_symbol_integer(\n    \"EURUSD\",\n    market_info_pb2.SymbolInfoIntegerProperty.SYMBOL_DIGITS\n)\n\n# Round price to digits\nprice = 1.09876543\nnormalized_price = round(price, digits)\n# Result: 1.09877 (for 5-digit broker)\n</code></pre></p>"},{"location":"All_Guides/GLOSSARY/#risk-based-volume-calculation","title":"Risk-Based Volume Calculation","text":"<p>Calculate position size based on dollar risk rather than fixed lot size.</p> <p>Formula: <code>volume = risk_amount / (stop_loss_pips * pip_value)</code></p> <p>Parameters:</p> <ul> <li><code>risk_amount</code> - Dollar amount you're willing to risk (e.g., $50)</li> <li><code>stop_loss_pips</code> - Distance to SL in pips (e.g., 20 pips)</li> <li>Result: Lot size that risks exactly $50 if SL hits</li> </ul> <p>Methods (MT5Sugar):</p> <pre><code># Calculate volume for given risk\nvolume = await sugar.calculate_position_size(\"EURUSD\", risk_percent=2.0, sl_pips=50)\n# 2% risk with 50 pip SL\n\n# Buy with risk-based calculation\nlot_size = await sugar.calculate_position_size(\"EURUSD\", 2.0, 50)\nticket = await sugar.buy_market_with_pips(\"EURUSD\", lot_size, sl_pips=50, tp_pips=100)\n</code></pre> <p>Use case: Consistent risk management across all trades.</p>"},{"location":"All_Guides/GLOSSARY/#points-vs-pips","title":"Points vs Pips","text":"<p>Point: Smallest price movement for a symbol (1 tick).</p> <p>Pip: Traditional forex unit (0.0001 for most pairs).</p> <p>Relationship:</p> <ul> <li>5-digit brokers: 1 pip = 10 points (EURUSD: 1.10000 to 1.10010 = 1 pip)</li> <li>3-digit brokers: 1 pip = 1 point (USDJPY: 110.00 to 110.01 = 1 pip)</li> </ul> <p>In PyMT5: All APIs use points for consistency.</p> <p>Conversion: <pre><code>from MetaRpcMT5 import mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get point size\npoint = await service.get_symbol_double(\"EURUSD\", market_info_pb2.SymbolInfoDoubleProperty.SYMBOL_POINT)\n# point = 0.00001 for 5-digit broker\n\n# Convert pips to points\npips = 20\npoints = pips * 10  # For 5-digit pairs\n</code></pre></p> <p>Why points? Universal across all instruments (forex, metals, indices, crypto).</p>"},{"location":"All_Guides/GLOSSARY/#pip-based-methods","title":"Pip-Based Methods","text":"<p>Convenience methods that work with pips instead of points for forex traders.</p> <p>Methods (MT5Sugar):</p> <pre><code># Market orders with SL/TP in pips\nticket = await sugar.buy_market_with_sltp(\"EURUSD\", 0.01, sl_pips=20, tp_pips=30)\n# Or use alias:\nticket = await sugar.buy_market_with_pips(\"EURUSD\", 0.01, sl_pips=20, tp_pips=30)\n\nticket = await sugar.sell_market_with_sltp(\"GBPUSD\", 0.01, sl_pips=20, tp_pips=30)\n# Or use alias:\nticket = await sugar.sell_market_with_pips(\"GBPUSD\", 0.01, sl_pips=20, tp_pips=30)\n\n# Pending orders with SL/TP in pips (requires absolute price)\ncurrent_ask = await sugar.get_ask(\"EURUSD\")\nticket = await sugar.buy_limit_with_sltp(\"EURUSD\", 0.01, price=current_ask - 0.0020, sl_pips=15, tp_pips=30)\n\ncurrent_bid = await sugar.get_bid(\"EURUSD\")\nticket = await sugar.sell_limit_with_sltp(\"EURUSD\", 0.01, price=current_bid + 0.0020, sl_pips=15, tp_pips=30)\n</code></pre> <p>Benefits:</p> <ul> <li>SL/TP specified in pips (familiar for forex traders)</li> <li>Automatic conversion to prices</li> <li>Fewer errors than manual calculations</li> </ul>"},{"location":"All_Guides/GLOSSARY/#trailing-stop","title":"Trailing Stop","text":"<p>Dynamic Stop Loss that follows price in profit direction.</p> <p>How it works:</p> <ol> <li>Position opens with initial SL</li> <li>When profit reaches threshold (e.g., +40 pips)</li> <li>SL moves to breakeven or better</li> <li>SL continues to follow price at fixed distance</li> <li>Locks in profit as price moves favorably</li> </ol> <p>Implementation example: <pre><code>from MetaRpcMT5 import mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def trailing_stop_logic(sugar, ticket, symbol):\n    # Get position to check profit\n    position = await sugar.get_position_by_ticket(ticket)\n    if not position:\n        return\n\n    current_profit = position.profit\n    trailing_threshold = 40.0  # dollars\n    trailing_distance_pips = 20  # 20 pips\n\n    point = await sugar.service.get_symbol_double(\n        symbol, market_info_pb2.SymbolInfoDoubleProperty.SYMBOL_POINT\n    )\n    trailing_distance = trailing_distance_pips * 10 * point  # For 5-digit\n\n    if current_profit &gt;= trailing_threshold:\n        current_price = await sugar.get_bid(symbol)\n        new_sl = current_price - trailing_distance\n\n        # Only move SL up (for BUY position)\n        if new_sl &gt; position.sl:\n            await sugar.modify_position_sltp(ticket, sl=new_sl, tp=position.tp)\n</code></pre></p> <p>Use case: Locking in profit on trending markets.</p>"},{"location":"All_Guides/GLOSSARY/#hedging","title":"Hedging","text":"<p>Opening opposite position to lock in current profit/loss level.</p> <p>How it works:</p> <ol> <li>Main position open (e.g., BUY EURUSD 0.1 lot)</li> <li>Price moves against you (-50 pips)</li> <li>Hedge triggered: SELL EURUSD 0.1 lot</li> <li>Net position = 0 (loss locked at -50 pips)</li> </ol> <p>Purpose:</p> <ul> <li>Lock losses instead of closing at stop-loss</li> <li>Protect position during volatility/news</li> <li>Wait for better opportunity to exit</li> </ul> <p>Implementation: <pre><code># Main position\nbuy_ticket = await sugar.buy_market(\"EURUSD\", 0.1)\n\n# ... price moves against you ...\n\n# Hedge\nsell_ticket = await sugar.sell_market(\"EURUSD\", 0.1)\n# Net position = 0, loss locked\n</code></pre></p> <p>WARNING: Not all brokers/regulations allow hedging. US brokers typically do not support hedging.</p>"},{"location":"All_Guides/GLOSSARY/#pending-order","title":"Pending Order","text":"<p>Order that executes automatically when price reaches specified level.</p> <p>Types:</p> <ul> <li>BUY LIMIT: Buy at price BELOW current (expect pullback, then up)</li> <li>SELL LIMIT: Sell at price ABOVE current (expect rally, then down)</li> <li>BUY STOP: Buy at price ABOVE current (breakout up)</li> <li>SELL STOP: Sell at price BELOW current (breakout down)</li> </ul> <p>Methods (MT5Sugar): <pre><code># Buy limit without SL/TP\nticket = await sugar.buy_limit(\"EURUSD\", 0.01, price=1.09950)\n\n# Buy limit with SL/TP\nticket = await sugar.buy_limit_with_sltp(\"EURUSD\", 0.01, price=1.09950, sl=1.09900, tp=1.10050)\n\n# Sell stop without SL/TP\nticket = await sugar.sell_stop(\"EURUSD\", 0.01, price=1.09950)\n\n# Sell stop with SL/TP (no dedicated method, use sell_stop + modify)\nticket = await sugar.sell_stop(\"EURUSD\", 0.01, price=1.09950)\nawait sugar.modify_position_sltp(ticket, sl=1.10000, tp=1.09900)\n</code></pre></p>"},{"location":"All_Guides/GLOSSARY/#grpc-and-protocol-terms","title":"\ud83d\udd0c gRPC and Protocol Terms","text":""},{"location":"All_Guides/GLOSSARY/#grpc","title":"gRPC","text":"<p>High-performance RPC (Remote Procedure Call) framework using HTTP/2.</p> <p>In PyMT5:</p> <ul> <li>MT5Account tier sends gRPC requests to MT5 terminal</li> <li>Terminal runs gRPC server (configured via gateway)</li> <li>Request/Response pattern for all operations</li> <li>Async/await for non-blocking calls</li> </ul> <p>Connection setup: <pre><code>account = MT5Account.create(\n    user=591129415,\n    password=\"password\",\n    grpc_server=\"mt5.mrpc.pro:443\"\n)\n\nawait account.connect_by_server_name(\n    server_name=\"FxPro-MT5 Demo\",\n    base_chart_symbol=\"EURUSD\"\n)\n</code></pre></p> <p>Documentation: gRPC Python</p>"},{"location":"All_Guides/GLOSSARY/#protobuf","title":"Protobuf","text":"<p>Protocol Buffers - Google's language-neutral data serialization format.</p> <p>In PyMT5:</p> <ul> <li>All MT5Account methods use protobuf Request/Response</li> <li>Generated from .proto files</li> <li>Efficient binary serialization</li> <li>Type-safe message structures</li> </ul> <p>Example:</p> <pre><code>from MetaRpcMT5 import mt5_term_api_account_information_pb2 as account_info_pb2\n\n# MT5Account level - already unpacks protobuf response internally\nbalance = await account.account_info_double(\n    account_info_pb2.AccountInfoDoublePropertyType.ACCOUNT_BALANCE\n)\n# Returns: float (e.g., 10000.0)\n# NOTE: The method internally extracts res.data.requested_value before returning\n\n# MT5Service level - same result, just different method name\nbalance = await service.get_account_double(\n    account_info_pb2.AccountInfoDoublePropertyType.ACCOUNT_BALANCE\n)\n# Returns: float (e.g., 10000.0)\n</code></pre> <p>Both MT5Account and MT5Service return clean Python types (float, int, str), not protobuf objects.</p>"},{"location":"All_Guides/GLOSSARY/#i-return-codes","title":"\u2139\ufe0f Return Codes","text":"<p>Protobuf return codes indicating operation success/failure.</p> <p>Common codes:</p> <ul> <li>10009 = Success (TRADE_RETCODE_DONE)</li> <li>10008 = Pending order placed (TRADE_RETCODE_PLACED)</li> <li>10004 = Requote</li> <li>10006 = Request rejected</li> <li>10013 = Invalid request</li> <li>10014 = Invalid volume</li> <li>10015 = Invalid price</li> <li>10016 = Invalid stops</li> <li>10018 = Market closed</li> <li>10019 = Not enough money</li> <li>10031 = No connection to trade server</li> </ul> <p>Always check returned_code in trading operations.</p> <p>Example:</p> <pre><code>result = await account.order_send(request)\n\nif result.returned_code == 10009:  # TRADE_RETCODE_DONE\n    print(f\"Trade successful! Ticket: {result.order}\")\nelif result.returned_code == 10019:\n    print(\"Not enough money\")\nelse:\n    print(f\"Trade failed: code {result.returned_code}\")\n</code></pre> <p>Documentation: Return Codes Reference</p>"},{"location":"All_Guides/GLOSSARY/#streaming-pattern","title":"\ud83d\udce1 Streaming Pattern","text":"<p>Real-time data streams using async generators.</p> <p>Streaming methods: <pre><code># Stream tick data\nasync for tick_data in account.on_symbol_tick([\"EURUSD\"]):\n    if tick_data.symbol_tick:\n        tick = tick_data.symbol_tick\n        print(f\"Bid: {tick.bid}, Ask: {tick.ask}\")\n    if should_stop:\n        break  # Auto cleanup\n\n# Stream trade events\nasync for trade_data in account.on_trade():\n    print(f\"Type: {trade_data.type}\")\n    if trade_data.event_data:\n        print(f\"New orders: {len(trade_data.event_data.new_orders)}\")\n\n# Stream position profit (poll every 500ms)\nasync for profit_data in account.on_position_profit(interval_ms=500):\n    for pos in profit_data.updated_positions:\n        print(f\"Ticket {pos.ticket}: ${pos.profit}\")\n</code></pre></p> <p>Critical rules:</p> <ul> <li>Use <code>async for</code> to consume stream</li> <li>Break to stop stream (auto cleanup)</li> <li>No manual cleanup needed</li> <li>Can use asyncio.timeout for time limits (Python 3.11+)</li> </ul> <p>With timeout: <pre><code>import asyncio\n\n# Python 3.11+\nasync with asyncio.timeout(60):  # 60 seconds max\n    async for tick_data in account.on_symbol_tick([\"EURUSD\"]):\n        tick = tick_data.symbol_tick\n        process(tick)\n\n# Python 3.10 and earlier - use asyncio.wait_for instead\ntry:\n    await asyncio.wait_for(stream_processing(), timeout=60)\nexcept asyncio.TimeoutError:\n    pass\n</code></pre></p> <p>Documentation: gRPC Stream Management</p>"},{"location":"All_Guides/GLOSSARY/#trading-terms","title":"\ud83c\udfdb\ufe0f Trading Terms","text":""},{"location":"All_Guides/GLOSSARY/#basic-trading-terms","title":"Basic Trading Terms","text":"<p>Core trading concepts that every trader must understand before working with MT5.</p> Term Description Example / Details Bid Price at which broker buys from you (you sell at Bid) EURUSD Bid: 1.10000 Ask Price at which broker sells to you (you buy at Ask) EURUSD Ask: 1.10002 Spread Difference between Ask and Bid (broker's commission) Ask 1.10002 - Bid 1.10000 = 2 pips spread Long / Buy Opening a BUY position (profit when price goes up) Buy EURUSD at 1.10000, close at 1.10050 = +50 pips profit Short / Sell Opening a SELL position (profit when price goes down) Sell EURUSD at 1.10000, close at 1.09950 = +50 pips profit Position Open trade (BUY or SELL) that can result in profit or loss BUY 0.1 lot EURUSD at 1.10000 (currently in profit +$50) Order Command to open a position Market Order (immediate), Pending Order (at specific price) Market Order Order that executes immediately at current price BUY EURUSD at current Ask price Pending Order Order that triggers automatically when price reaches level BUY LIMIT at 1.09950 (when price drops to that level) Lot / Volume Position size (1 lot = 100,000 units of base currency) 0.01 lot = 1,000 units (micro lot) Stop Loss (SL) Price level for automatic loss-limiting exit SL at 1.09950 limits loss to 50 pips Take Profit (TP) Price level for automatic profit-taking exit TP at 1.10050 locks in 50 pips profit Pip Standard unit of price movement (0.0001 for most forex) EURUSD: 1.10000 to 1.10001 = 1 pip Point Smallest price movement (1 tick) For 5-digit broker: 1 pip = 10 points Leverage Borrowed capital from broker (e.g., 1:100) With 1:100, you control $100,000 with $1,000 margin Margin Funds locked as collateral for open positions Open 1 lot EURUSD with 1:100 leverage = $1,000 margin Free Margin Available funds for opening new positions Balance $10,000 - Margin $1,000 = Free Margin $9,000 Balance Account funds without considering open positions Initial deposit + closed trades profit/loss Equity Current account value (Balance +/- floating profit/loss) Balance $10,000 + Floating profit $500 = Equity $10,500 Floating P/L Unrealized profit/loss of open positions Position currently in +$50 profit (not yet closed) Margin Level Ratio of Equity to Margin (%) Equity $10,500 / Margin $1,000 = 1050% Margin Call Warning when Margin Level drops below threshold Broker warns at 100% Margin Level Stop Out Forced closure of positions when Margin Level critically low Broker closes positions at 50% Margin Level Drawdown Decline from peak balance/equity Peak $11,000 to Current $10,000 = $1,000 drawdown (9.09%) Slippage Difference between expected and executed price Requested 1.10000, executed at 1.10003 = 3 pips slippage <p>Critical for API usage:</p> <pre><code># Get prices\nbid = await sugar.get_bid(\"EURUSD\")\nask = await sugar.get_ask(\"EURUSD\")\n\n# Get account state\nbalance = await sugar.balance\nequity = await sugar.equity\nmargin = await sugar.margin\nfree_margin = await sugar.free_margin\n\n# Open positions\nbuy_ticket = await sugar.buy_market(\"EURUSD\", 0.01)\nsell_ticket = await sugar.sell_market(\"EURUSD\", 0.01)\n\n# Close positions\nawait sugar.close_position(buy_ticket)\n\n# Modify SL/TP\nawait sugar.modify_position_sltp(buy_ticket, sl=1.09950, tp=1.10050)\n</code></pre>"},{"location":"All_Guides/GLOSSARY/#risk-amount","title":"Risk Amount","text":"<p>Dollar amount you're willing to risk if Stop Loss hits.</p> <p>Example: $50 risk per trade means if SL hits, you lose exactly $50.</p> <p>Used in:</p> <pre><code># Calculate volume for 2% risk with 50 pip SL\nvolume = await sugar.calculate_position_size(\"EURUSD\", risk_percent=2.0, sl_pips=50)\n\n# Open with risk-based calculation\nlot_size = await sugar.calculate_position_size(\"EURUSD\", 2.0, 50)\nticket = await sugar.buy_market(\"EURUSD\", lot_size, sl_pips=50, tp_pips=100)\n# Risk exactly 2% of balance\n</code></pre>"},{"location":"All_Guides/GLOSSARY/#breakeven","title":"Breakeven","text":"<p>Moving Stop Loss to entry price to eliminate risk.</p> <p>Example:</p> <ul> <li>Entry: BUY at 1.10000</li> <li>Price rises to 1.10050 (+50 pips profit)</li> <li>Move SL from 1.09950 to 1.10000 (breakeven)</li> <li>Now risk-free: worst case = breakeven</li> </ul> <p>Implementation: <pre><code>position = await sugar.get_position_by_ticket(ticket)\nentry_price = position.price_open\nbreakeven_threshold = 40.0  # pips\n\ncurrent_profit = position.profit\nif current_profit &gt;= breakeven_threshold:\n    await sugar.modify_position_sltp(ticket, sl=entry_price, tp=position.tp)\n</code></pre></p>"},{"location":"All_Guides/GLOSSARY/#grid-trading","title":"Grid Trading","text":"<p>Strategy placing multiple pending orders at equal intervals above and below current price.</p> <p>How it works:</p> <ol> <li>Place Buy Limit orders below current price (e.g., every 20 pips)</li> <li>Place Sell Limit orders above current price (e.g., every 20 pips)</li> <li>As price oscillates, orders trigger and close at TP</li> <li>Works best in ranging markets</li> </ol> <p>Example: <pre><code>Price: 1.10000\nBuy Limits:  1.09980 (-20 pips), 1.09960 (-40 pips), 1.09940 (-60 pips)\nSell Limits: 1.10020 (+20 pips), 1.10040 (+40 pips), 1.10060 (+60 pips)\n</code></pre></p> <p>Implementation: <pre><code>from MetaRpcMT5 import mt5_term_api_market_info_pb2 as market_info_pb2\n\ngrid_step_pips = 20\nlevels = 5\n\nask = await sugar.get_ask(\"EURUSD\")\nbid = await sugar.get_bid(\"EURUSD\")\npoint = await sugar.service.get_symbol_double(\"EURUSD\", market_info_pb2.SymbolInfoDoubleProperty.SYMBOL_POINT)\n\nfor i in range(1, levels + 1):\n    offset = i * grid_step_pips * 10 * point  # Convert pips to points\n\n    # Buy Limit below Ask\n    buy_price = ask - offset\n    await sugar.buy_limit(\"EURUSD\", 0.01, price=buy_price, sl=buy_price - 15*10*point, tp=buy_price + 30*10*point)\n\n    # Sell Limit above Bid\n    sell_price = bid + offset\n    await sugar.sell_limit(\"EURUSD\", 0.01, price=sell_price, sl=sell_price + 15*10*point, tp=sell_price - 30*10*point)\n</code></pre></p> <p>WARNING: High volatility can trigger many orders, increasing exposure.</p>"},{"location":"All_Guides/GLOSSARY/#scalping","title":"Scalping","text":"<p>Fast trading strategy with small profits (5-25 pips) and tight stops (10-20 pips).</p> <p>Characteristics:</p> <ul> <li>Very short hold times (seconds-minutes)</li> <li>High win rate, small profit per trade</li> <li>Risk:Reward typically 1:1 to 1:2</li> <li>Requires low spreads</li> </ul> <p>Implementation: <pre><code># Scalp with 10 pip SL, 15 pip TP\nticket = await sugar.buy_market_with_pips(\"EURUSD\", 0.01, sl_pips=10, tp_pips=15)\n</code></pre></p>"},{"location":"All_Guides/GLOSSARY/#news-trading","title":"News Trading","text":"<p>Placing orders on both sides of price before major news events.</p> <p>How it works:</p> <ol> <li>Before news: Place Buy Stop above + Sell Stop below</li> <li>News releases: Price breaks in one direction</li> <li>One order triggers, cancel the other</li> <li>Capture volatility spike</li> </ol> <p>Example: <pre><code>Current price: 1.10000\nBuy Stop:  1.10030 (+30 pips)\nSell Stop: 1.09970 (-30 pips)\nNews -&gt; Price spikes to 1.10050 -&gt; Buy Stop triggers -&gt; Cancel Sell Stop\n</code></pre></p> <p>Implementation: <pre><code>from MetaRpcMT5 import mt5_term_api_market_info_pb2 as market_info_pb2\n\nask = await sugar.get_ask(\"EURUSD\")\nbid = await sugar.get_bid(\"EURUSD\")\npoint = await sugar.service.get_symbol_double(\"EURUSD\", market_info_pb2.SymbolInfoDoubleProperty.SYMBOL_POINT)\n\noffset = 30 * 10 * point  # 30 pips\n\nbuy_ticket = await sugar.buy_stop(\"EURUSD\", 0.01, price=ask + offset)\nsell_ticket = await sugar.sell_stop(\"EURUSD\", 0.01, price=bid - offset)\n\n# ... wait for news ...\n\n# NOTE: MT5Sugar doesn't have delete_order method\n# To cancel pending orders, use MT5Service or MT5Account level methods\n</code></pre></p> <p>WARNING: Slippage during news can trigger both orders.</p>"},{"location":"All_Guides/GLOSSARY/#volume-limits","title":"Volume Limits","text":"<p>Broker restrictions on position size.</p> <p>Get via: <pre><code>from MetaRpcMT5 import mt5_term_api_market_info_pb2 as market_info_pb2\n\nmin_vol = await service.get_symbol_double(\"EURUSD\", market_info_pb2.SymbolInfoDoubleProperty.SYMBOL_VOLUME_MIN)\nmax_vol = await service.get_symbol_double(\"EURUSD\", market_info_pb2.SymbolInfoDoubleProperty.SYMBOL_VOLUME_MAX)\nstep_vol = await service.get_symbol_double(\"EURUSD\", market_info_pb2.SymbolInfoDoubleProperty.SYMBOL_VOLUME_STEP)\n</code></pre></p> <p>Used for: Volume validation.</p> <p>Validation: <pre><code>from MetaRpcMT5 import mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def validate_volume(service, symbol, volume):\n    min_vol = await service.get_symbol_double(symbol, market_info_pb2.SymbolInfoDoubleProperty.SYMBOL_VOLUME_MIN)\n    max_vol = await service.get_symbol_double(symbol, market_info_pb2.SymbolInfoDoubleProperty.SYMBOL_VOLUME_MAX)\n    step_vol = await service.get_symbol_double(symbol, market_info_pb2.SymbolInfoDoubleProperty.SYMBOL_VOLUME_STEP)\n\n    if volume &lt; min_vol:\n        volume = min_vol\n    if volume &gt; max_vol:\n        volume = max_vol\n\n    # Round to step\n    volume = round(volume / step_vol) * step_vol\n    return volume\n</code></pre></p>"},{"location":"All_Guides/GLOSSARY/#configuration-terms","title":"\ud83d\udd11 Configuration Terms","text":""},{"location":"All_Guides/GLOSSARY/#environment-variables","title":"Environment Variables","text":"<p>Configuration via environment variables or .env file.</p> <p>Variables:</p> <pre><code># Required\nMT5_USER=591129415\nMT5_PASSWORD=\"YourPassword\"\nMT5_SERVER=\"FxPro-MT5 Demo\"\nMT5_GRPC_HOST=\"mt5.mrpc.pro:443\"\n\n# Optional (have defaults)\nMT5_SYMBOL=\"EURUSD\"\nMT5_VOLUME=0.01\n</code></pre> <p>Set (Windows PowerShell): <pre><code>$env:MT5_USER=\"591129415\"\n$env:MT5_PASSWORD=\"YourPassword\"\n</code></pre></p> <p>Set (Linux/Mac): <pre><code>export MT5_USER=591129415\nexport MT5_PASSWORD=\"YourPassword\"\n</code></pre></p> <p>Load in Python: <pre><code>import os\nfrom dotenv import load_dotenv\n\nload_dotenv()  # Load from .env file\n\nuser = int(os.getenv(\"MT5_USER\"))\npassword = os.getenv(\"MT5_PASSWORD\")\nserver = os.getenv(\"MT5_SERVER\")\ngrpc_host = os.getenv(\"MT5_GRPC_HOST\")\n</code></pre></p>"},{"location":"All_Guides/GLOSSARY/#env-file","title":".env File","text":"<p>Configuration file for environment variables.</p> <p>Location: Project root (<code>.env</code>)</p> <p>Format: <pre><code>MT5_USER=591129415\nMT5_PASSWORD=YourPassword\nMT5_SERVER=FxPro-MT5 Demo\nMT5_GRPC_HOST=mt5.mrpc.pro:443\nMT5_SYMBOL=EURUSD\nMT5_VOLUME=0.01\n</code></pre></p> <p>Usage: <pre><code>from dotenv import load_dotenv\nimport os\n\nload_dotenv()  # Loads .env into environment\n\n# Access via os.getenv()\nuser = int(os.getenv(\"MT5_USER\"))\npassword = os.getenv(\"MT5_PASSWORD\")\n</code></pre></p> <p>WARNING: Never commit .env to git (add to .gitignore)</p>"},{"location":"All_Guides/GLOSSARY/#cross-component-terms","title":"Cross-Component Terms","text":""},{"location":"All_Guides/GLOSSARY/#batch-operations","title":"Batch Operations","text":"<p>Executing action across multiple positions/orders at once.</p> <p>Methods (MT5Sugar): <pre><code># Close all positions\ncount = await sugar.close_all_positions()          # All positions\ncount = await sugar.close_all_positions(\"EURUSD\")  # By symbol only\n</code></pre></p> <p>Note: To delete pending orders, use MT5Service or MT5Account level methods.</p> <p>Use case: Emergency exits, end-of-session cleanup, strategy resets.</p>"},{"location":"All_Guides/GLOSSARY/#history-queries","title":"\ud83d\udcdd History Queries","text":"<p>Retrieving past orders and positions for analysis.</p> <p>Methods (MT5Account): <pre><code>from datetime import datetime, timedelta\nfrom MetaRpcMT5 import mt5_term_api_account_helper_pb2 as account_helper_pb2\n\n# Get order history\nend_date = datetime.now()\nstart_date = end_date - timedelta(days=30)\n\nhistory = await account.order_history(\n    from_dt=start_date,\n    to_dt=end_date,\n    sort_mode=account_helper_pb2.BMT5_SORT_BY_OPEN_TIME_ASC,\n    page_number=0,\n    items_per_page=100\n)\n\n# Get position history\npositions = await account.positions_history(\n    sort_type=account_helper_pb2.AH_POSITION_OPEN_TIME_ASC,\n    open_from=start_date,\n    open_to=end_date,\n    page=0,\n    size=100\n)\n</code></pre></p> <p>Use case: Performance analysis, trade logs, strategy validation.</p>"},{"location":"All_Guides/GLOSSARY/#educational-project","title":"Educational Project","text":"<p>PyMT5 examples and helpers are educational materials and API demonstrations, NOT production trading systems.</p> <p>Implications:</p> <ul> <li>Study code and patterns (YES)</li> <li>Modify for your needs (YES)</li> <li>Test on demo accounts (YES)</li> <li>Use as templates for building your strategies (YES)</li> <li>Don't use as-is with real money (NO)</li> <li>Don't expect production-grade risk management (NO)</li> <li>Don't expect proper error handling for all edge cases (NO)</li> </ul> <p>Remember: These are educational examples, not battle-tested production systems.</p>"},{"location":"All_Guides/GLOSSARY/#python-specific-patterns","title":"Python-Specific Patterns","text":""},{"location":"All_Guides/GLOSSARY/#exception-handling","title":"Exception Handling","text":"<p>Python's error handling mechanism for API errors.</p> <p>Custom exceptions: <pre><code>from MetaRpcMT5 import ConnectExceptionMT5, ApiExceptionMT5\n\ntry:\n    await account.connect_by_server_name(\n        server_name=\"FxPro-MT5 Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\nexcept ConnectExceptionMT5 as e:\n    print(f\"Connection failed: {e}\")\nexcept ApiExceptionMT5 as e:\n    print(f\"API error: {e}\")\n</code></pre></p> <p>Trading operation errors: <pre><code>try:\n    ticket = await sugar.buy_market(\"EURUSD\", 0.01)\n    print(f\"Position opened: ticket {ticket}\")\nexcept RuntimeError as e:\n    # MT5Sugar raises RuntimeError if returned_code != 10009\n    print(f\"Trade failed: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre></p>"},{"location":"All_Guides/GLOSSARY/#type-hints","title":"Type Hints","text":"<p>Python's optional static typing for better IDE support.</p> <p>All PyMT5 code uses type hints: <pre><code>from typing import Optional, List\nfrom datetime import datetime\n\nasync def get_balance(self) -&gt; float:\n    \"\"\"Get account balance.\"\"\"\n    from MetaRpcMT5 import mt5_term_api_account_information_pb2 as account_info_pb2\n    return await self.service.get_account_double(\n        account_info_pb2.AccountInfoDoublePropertyType.ACCOUNT_BALANCE\n    )\n\nasync def buy_market(\n    self,\n    symbol: str,\n    volume: float,\n    sl: Optional[float] = None,\n    tp: Optional[float] = None\n) -&gt; int:\n    \"\"\"Open BUY position at market price.\n\n    Returns:\n        int: Ticket number\n    \"\"\"\n    pass\n</code></pre></p> <p>Benefits:</p> <ul> <li>IDE autocomplete</li> <li>Static type checking (mypy)</li> <li>Better documentation</li> <li>Catch errors before runtime</li> </ul>"},{"location":"All_Guides/GLOSSARY/#enums","title":"\ud83e\uddf1 Enums","text":"<p>Python's enumeration types for named constants.</p> <p>PyMT5 uses enums instead of magic numbers: <pre><code># MT5Sugar enums\nfrom pymt5.mt5_sugar import OrderType, Period\n\n# Protobuf enums\nfrom MetaRpcMT5 import mt5_term_api_market_info_pb2 as market_info_pb2\nfrom MetaRpcMT5 import mt5_term_api_account_information_pb2 as account_info_pb2\n\n# Instead of magic numbers\norder_type = OrderType.BUY  # Not 0\nperiod = Period.TODAY       # Not 0\n\n# Symbol properties\nbid = await service.get_symbol_double(\n    \"EURUSD\",\n    market_info_pb2.SymbolInfoDoubleProperty.SYMBOL_BID  # Not 1\n)\n\n# Account properties\nbalance = await service.get_account_double(\n    account_info_pb2.AccountInfoDoublePropertyType.ACCOUNT_BALANCE  # Not 0\n)\n</code></pre></p> <p>Documentation: Enums Usage Reference</p>"},{"location":"All_Guides/GLOSSARY/#see-also","title":"See Also","text":"<ul> <li>MT5Account Master Overview - Complete low-level API reference</li> <li>MT5Service API Overview - Mid-level wrappers API</li> <li>MT5Sugar API Reference - High-level Sugar API</li> <li>gRPC Stream Management - Guide to streaming subscriptions</li> <li>Return Codes Reference - Complete return codes reference</li> <li>User Code Sandbox Guide - How to write custom code</li> <li>Your First Project - Setup and quick start guide</li> <li>Enums Usage Reference - All available enums</li> <li>Protobuf Inspector Guide - Explore protobuf types</li> </ul> <p>\"Trade safely, code cleanly, and may your async functions always await gracefully.\"</p>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/","title":"gRPC Streaming and Subscription Management Guide","text":"<p>Complete guide to working with real-time subscriptions in PyMT5</p> <p>This document covers:</p> <ul> <li>\u2705 How to subscribe properly to market data streams</li> <li>\u2705 How to stop subscriptions without resource leaks</li> <li>\u2705 Common patterns from simple to advanced</li> <li>\u2705 Architecture and built-in safety mechanisms</li> <li>\u2705 Troubleshooting and best practices</li> </ul>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Quick Start - Simple Subscription</li> <li>Available Streaming Methods</li> <li>Complete Patterns (Simple \u2192 Advanced)</li> <li>Problem: Why Streams Need Management</li> <li>Solutions and Best Practices</li> <li>Advanced Examples with Enums</li> <li>Multiple Concurrent Streams</li> <li>Architecture and Safety</li> <li>Troubleshooting</li> </ol>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#quick-start-simple-subscription","title":"Quick Start - Simple Subscription","text":""},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#1-simplest-pattern-auto-timeout","title":"1\ufe0f\u20e3 Simplest Pattern (Auto-timeout)","text":"<p>Use asyncio.wait_for - automatically stops after time expires:</p> <pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def main():\n    # Setup connection\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    # \u2705 Stream for 10 seconds - stops automatically!\n    try:\n        async def process_ticks():\n            tick_count = 0\n            async for tick_data in account.on_symbol_tick(symbols=[\"EURUSD\", \"GBPUSD\"]):\n                tick_count += 1\n                tick = tick_data.symbol_tick\n                print(f\"[{tick_count}] {tick.symbol}: Bid={tick.bid:.5f}, Ask={tick.ask:.5f}\")\n\n                if tick_count &gt;= 10:\n                    break\n\n        await asyncio.wait_for(process_ticks(), timeout=10.0)\n        print(\"Stream finished\")\n\n    finally:\n        try:\n            await account.channel.close()\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\nasyncio.run(main())\n</code></pre> <p>When to use: Quick examples, testing, short monitoring sessions</p>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#2-manual-control-pattern","title":"2\ufe0f\u20e3 Manual Control Pattern","text":"<p>For full control - you decide when to stop:</p> <pre><code>async def main():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    # \u2705 Create cancellation event\n    cancel_event = asyncio.Event()\n\n    async def monitor_prices():\n        async for tick_data in account.on_symbol_tick(\n            symbols=[\"EURUSD\"],\n            cancellation_event=cancel_event\n        ):\n            tick = tick_data.symbol_tick\n            print(f\"Price: {tick.bid:.5f}\")\n\n    # Start monitoring in background\n    monitor_task = asyncio.create_task(monitor_prices())\n\n    # ... do other work ...\n\n    # Stop when needed\n    await asyncio.sleep(5)\n    cancel_event.set()  # Signal stream to stop\n    await asyncio.sleep(0.5)  # Give stream time to cleanup\n\n    try:\n        await account.channel.close()\n    except Exception as e:\n        print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\nasyncio.run(main())\n</code></pre> <p>When to use: Long-term monitoring, background services, production applications</p>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#available-streaming-methods","title":"Available Streaming Methods","text":""},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#mt5account-low-level-streams","title":"MT5Account (Low-level Streams)","text":"<p>All streaming methods return async generators that yield data objects.</p> Method Description Returns (async generator) <code>on_symbol_tick()</code> Real-time price ticks for symbols <code>OnSymbolTickData</code> <code>on_trade()</code> Trade events (orders executed, modified, etc.) <code>OnTradeData</code> <code>on_position_profit()</code> Position P&amp;L updates <code>OnPositionProfitData</code> <code>on_positions_and_pending_orders_tickets()</code> Order/position tickets <code>OnPositionsAndPendingOrdersTicketsData</code> <code>on_trade_transaction()</code> Low-level trade transaction events <code>OnTradeTransactionData</code> <p>All support <code>cancellation_event</code> parameter for graceful stopping!</p> <p>Documentation: - Streaming Methods Overview - on_symbol_tick - on_trade</p> <p>Examples:</p> <ul> <li> <p><code>examples/1_lowlevel/03_streaming_methods.py</code> - Low-level streaming examples</p> </li> <li> <p><code>examples/2_service/05_service_streaming.py</code> - Mid-level streaming examples</p> </li> </ul>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#complete-patterns-simple-advanced","title":"Complete Patterns (Simple \u2192 Advanced)","text":""},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#pattern-1-quick-example-5-10-seconds","title":"Pattern 1: Quick Example (5-10 seconds)","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def quick_stream_example():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # \u2705 Auto-timeout - perfect for testing\n        async def process():\n            count = 0\n            async for tick_data in account.on_symbol_tick(symbols=[\"EURUSD\"]):\n                tick = tick_data.symbol_tick\n                count += 1\n                print(f\"Tick #{count}: {tick.bid:.5f}\")\n\n                if count &gt;= 5:\n                    break\n\n        await asyncio.wait_for(process(), timeout=10.0)\n\n    finally:\n        try:\n            await account.channel.close()\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\nasyncio.run(quick_stream_example())\n# Stops after 5 ticks or 10 seconds automatically \u2705\n</code></pre>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#pattern-2-event-limited-streaming","title":"Pattern 2: Event-limited Streaming","text":"<pre><code>async def event_limited_streaming():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    cancel_event = asyncio.Event()\n    max_events = 100\n    count = 0\n\n    try:\n        async for tick_data in account.on_symbol_tick(\n            symbols=[\"EURUSD\"],\n            cancellation_event=cancel_event\n        ):\n            count += 1\n            tick = tick_data.symbol_tick\n            print(f\"[{count}] {tick.symbol}: {tick.bid:.5f}\")\n\n            if count &gt;= max_events:\n                print(f\"Max events ({max_events}) reached - stopping\")\n                cancel_event.set()\n                break\n\n    finally:\n        await asyncio.sleep(0.5)  # Wait for graceful cleanup\n        try:\n            await account.channel.close()\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\nasyncio.run(event_limited_streaming())\n</code></pre>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#pattern-3-condition-based-stop","title":"Pattern 3: Condition-based Stop","text":"<pre><code>async def condition_based_stop():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    cancel_event = asyncio.Event()\n\n    try:\n        # \u2705 Stop when specific condition is met\n        async for tick_data in account.on_symbol_tick(\n            symbols=[\"EURUSD\"],\n            cancellation_event=cancel_event\n        ):\n            tick = tick_data.symbol_tick\n            print(f\"Price: {tick.bid:.5f}\")\n\n            # Stop if price crosses threshold\n            if tick.bid &gt; 1.10000:\n                print(\"Target price reached!\")\n                cancel_event.set()\n                break\n\n    finally:\n        await asyncio.sleep(0.5)\n        try:\n            await account.channel.close()\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\nasyncio.run(condition_based_stop())\n</code></pre>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#pattern-4-background-service-with-manual-control","title":"Pattern 4: Background Service with Manual Control","text":"<pre><code>class PriceMonitor:\n    def __init__(self, account: MT5Account):\n        self.account = account\n        self.cancel_event = asyncio.Event()\n        self.task = None\n\n    async def start(self, symbols: list[str]):\n        \"\"\"Start monitoring in background\"\"\"\n        self.task = asyncio.create_task(self._monitor_prices(symbols))\n\n    async def _monitor_prices(self, symbols: list[str]):\n        \"\"\"Internal monitoring loop\"\"\"\n        async for tick_data in self.account.on_symbol_tick(\n            symbols=symbols,\n            cancellation_event=self.cancel_event\n        ):\n            tick = tick_data.symbol_tick\n            self._process_tick(tick)\n\n    def _process_tick(self, tick):\n        \"\"\"Process each tick\"\"\"\n        print(f\"{tick.symbol}: {tick.bid:.5f} / {tick.ask:.5f}\")\n        # Your logic here...\n\n    async def stop(self):\n        \"\"\"Stop monitoring gracefully\"\"\"\n        self.cancel_event.set()\n\n        if self.task:\n            await asyncio.sleep(0.5)  # Give time to cleanup\n            await self.task\n\n# Usage:\nasync def main():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    monitor = PriceMonitor(account)\n    await monitor.start([\"EURUSD\", \"GBPUSD\"])\n\n    print(\"Monitoring... Press Ctrl+C to stop\")\n    await asyncio.sleep(30)  # Monitor for 30 seconds\n\n    await monitor.stop()\n    try:\n        await account.channel.close()\n    except Exception as e:\n        print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#problem-why-streams-need-management","title":"Problem: Why Streams Need Management","text":"<p>When working with gRPC streaming in PyMT5, understanding the stream lifecycle is critical:</p> <p>Stream subscriptions (<code>on_symbol_tick</code>, <code>on_trade</code>, etc.) are active async tasks with network connections that continue running until explicitly stopped.</p>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#problem-explanation","title":"Problem Explanation","text":""},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#what-happens-without-proper-cleanup","title":"What Happens Without Proper Cleanup","text":"<pre><code># \u274c BAD: Stream continues running forever\nasync def bad_example():\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    count = 0\n    async for tick_data in account.on_symbol_tick(symbols=[\"EURUSD\"]):\n        count += 1\n        print(f\"Tick: {tick_data.symbol_tick.bid:.5f}\")\n\n        if count &gt;= 10:\n            break  # \u274c PROBLEM: Stream still running in background!\n                   # \u274c PROBLEM: gRPC connection not closed!\n\n    # \u274c Stream continues consuming resources\n    # \u274c Network connection stays open\n    # \u274c Memory gradually accumulates\n</code></pre> <p>Result:</p> <ul> <li>Background async task continues consuming resources</li> <li>MT5 terminal continues sending updates</li> <li>Async task leak - tasks accumulate in event loop</li> <li>Network connection stays open</li> <li>Multiple abandoned streams = serious resource leak</li> </ul>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#solutions-and-best-practices","title":"Solutions and Best Practices","text":""},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#solution-1-always-use-cancellation_event","title":"Solution 1: Always Use cancellation_event \u2705","text":""},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#pattern-1-create-cancellation_event-early","title":"Pattern 1: Create cancellation_event early","text":"<pre><code>async def proper_cancellation():\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    # \u2705 CRITICAL: Create cancellation event\n    cancel_event = asyncio.Event()\n\n    try:\n        async for tick_data in account.on_symbol_tick(\n            symbols=[\"EURUSD\"],\n            cancellation_event=cancel_event  # \u2705 Pass to stream\n        ):\n            tick = tick_data.symbol_tick\n            print(f\"Price: {tick.bid:.5f}\")\n\n            if some_condition:\n                cancel_event.set()  # \u2705 CORRECT: Signal to stop\n                break\n\n    finally:\n        # \u2705 CRITICAL: Give stream time to cleanup\n        await asyncio.sleep(0.5)\n        try:\n            await account.channel.close()\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\nasyncio.run(proper_cancellation())\n</code></pre>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#pattern-2-timeout-with-asynciowait_for","title":"Pattern 2: Timeout with asyncio.wait_for","text":"<pre><code>async def timeout_pattern():\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    cancel_event = asyncio.Event()\n\n    try:\n        async def stream_with_limit():\n            async for tick_data in account.on_symbol_tick(\n                symbols=[\"EURUSD\"],\n                cancellation_event=cancel_event\n            ):\n                print(f\"Price: {tick_data.symbol_tick.bid:.5f}\")\n\n        # \u2705 Automatically stops after 30 seconds\n        await asyncio.wait_for(stream_with_limit(), timeout=30.0)\n\n    except asyncio.TimeoutError:\n        print(\"Stream reached timeout\")\n        cancel_event.set()\n\n    finally:\n        await asyncio.sleep(0.5)\n        try:\n            await account.channel.close()\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\nasyncio.run(timeout_pattern())\n</code></pre>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#solution-2-always-cleanup-in-finally-block","title":"Solution 2: Always Cleanup in finally Block \u2705","text":"<p>CRITICAL: Always close channel and wait for stream cleanup</p>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#correct-proper-cleanup","title":"\u2705 CORRECT - Proper Cleanup","text":"<pre><code>async def proper_cleanup():\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    cancel_event = asyncio.Event()\n\n    try:\n        async for tick_data in account.on_symbol_tick(\n            symbols=[\"EURUSD\"],\n            cancellation_event=cancel_event\n        ):\n            # Process data...\n            pass\n\n    finally:\n        # \u2705 CRITICAL: Proper cleanup sequence\n        # Step 1: Signal all streams to stop\n        cancel_event.set()\n\n        # Step 2: Wait for graceful cleanup (0.5-1.0 seconds)\n        await asyncio.sleep(0.5)\n\n        # Step 3: Close gRPC channel\n        try:\n            await account.channel.close()\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\nasyncio.run(proper_cleanup())\n</code></pre>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#common-streaming-mistakes","title":"Common Streaming Mistakes","text":""},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#mistake-1-no-cancellation-event","title":"\u274c Mistake 1: No Cancellation Event","text":"<pre><code># \u274c WRONG: No way to stop stream gracefully\nasync def bad():\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    async for tick_data in account.on_symbol_tick(symbols=[\"EURUSD\"]):\n        print(tick_data.symbol_tick.bid)\n        # If you want to stop - YOU CAN'T stop gracefully!\n</code></pre> <p>Fix: <pre><code># \u2705 CORRECT: Can stop gracefully anytime\nasync def good():\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    cancel_event = asyncio.Event()\n\n    async for tick_data in account.on_symbol_tick(\n        symbols=[\"EURUSD\"],\n        cancellation_event=cancel_event\n    ):\n        print(tick_data.symbol_tick.bid)\n        # Now can call cancel_event.set() to stop\n</code></pre></p>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#mistake-2-break-without-cleanup","title":"\u274c Mistake 2: Break Without Cleanup","text":"<pre><code># \u274c WRONG: Break doesn't cleanup resources\nasync def bad():\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    async for tick_data in account.on_symbol_tick(symbols=[\"EURUSD\"]):\n        if some_condition:\n            break  # \u274c Stream still running!\n\n    # \u274c No cleanup - resources leak!\n</code></pre> <p>Fix: <pre><code># \u2705 CORRECT: Proper cleanup in finally\nasync def good():\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    cancel_event = asyncio.Event()\n\n    try:\n        async for tick_data in account.on_symbol_tick(\n            symbols=[\"EURUSD\"],\n            cancellation_event=cancel_event\n        ):\n            if some_condition:\n                cancel_event.set()\n                break\n\n    finally:\n        await asyncio.sleep(0.5)  # \u2705 Cleanup time\n        try:\n            await account.channel.close()\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n</code></pre></p>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#mistake-3-no-channel-close","title":"\u274c Mistake 3: No Channel Close","text":"<pre><code># \u274c WRONG: Channel never closed\nasync def bad():\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    cancel_event = asyncio.Event()\n\n    async for tick_data in account.on_symbol_tick(\n        symbols=[\"EURUSD\"],\n        cancellation_event=cancel_event\n    ):\n        # Process...\n        pass\n\n    # \u274c Forgot to close channel - connection leak!\n</code></pre> <p>Fix: <pre><code># \u2705 CORRECT: Always close in finally\nasync def good():\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    cancel_event = asyncio.Event()\n\n    try:\n        async for tick_data in account.on_symbol_tick(\n            symbols=[\"EURUSD\"],\n            cancellation_event=cancel_event\n        ):\n            # Process...\n            pass\n\n    finally:\n        cancel_event.set()\n        await asyncio.sleep(0.5)\n        await account.channel.close()  # \u2705 CRITICAL: Always close\n</code></pre></p>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#advanced-examples-with-enums","title":"Advanced Examples with Enums","text":""},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#example-1-filter-trade-events-by-type","title":"Example 1: Filter Trade Events by Type","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_subscriptions_pb2 as sub_pb2\n\nasync def filter_trade_events():\n    \"\"\"\n    Monitor trade events and filter by type using protobuf enums.\n    Shows how to work with SUB_ENUM_TRADE_TRANSACTION_TYPE.\n    \"\"\"\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    cancel_event = asyncio.Event()\n\n    # \u2705 Using protobuf enums for filtering\n    ORDER_ADD = sub_pb2.SUB_TRADE_TRANSACTION_ORDER_ADD\n    ORDER_DELETE = sub_pb2.SUB_TRADE_TRANSACTION_ORDER_DELETE\n    DEAL_ADD = sub_pb2.SUB_TRADE_TRANSACTION_DEAL_ADD\n\n    try:\n        print(\"Monitoring trade transactions (filtered by type)...\")\n\n        async for tx_data in account.on_trade_transaction(cancellation_event=cancel_event):\n            if tx_data.trade_transaction:\n                tx = tx_data.trade_transaction\n\n                # \u2705 Filter by transaction type using enums\n                if tx.type == ORDER_ADD:\n                    print(f\"[NEW ORDER] Ticket={tx.order_ticket}, Symbol={tx.symbol}, \"\n                          f\"Price={tx.price:.5f}, Volume={tx.volume:.2f}\")\n\n                elif tx.type == ORDER_DELETE:\n                    print(f\"[ORDER DELETED] Ticket={tx.order_ticket}\")\n\n                elif tx.type == DEAL_ADD:\n                    print(f\"[NEW DEAL] Deal={tx.deal_ticket}, Order={tx.order_ticket}, \"\n                          f\"Symbol={tx.symbol}, Price={tx.price:.5f}\")\n\n    finally:\n        cancel_event.set()\n        await asyncio.sleep(0.5)\n        try:\n            await account.channel.close()\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\nasyncio.run(filter_trade_events())\n</code></pre>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#example-2-sort-and-filter-positions-by-profit","title":"Example 2: Sort and Filter Positions by Profit","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def sort_positions_by_profit():\n    \"\"\"\n    Monitor position profits and sort by P&amp;L.\n    Shows advanced data processing with streaming.\n    \"\"\"\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    cancel_event = asyncio.Event()\n\n    try:\n        print(\"Monitoring positions (sorted by profit)...\")\n        print(\"-\" * 60)\n\n        async for profit_data in account.on_position_profit(\n            interval_ms=1000,\n            ignore_empty=True,\n            cancellation_event=cancel_event\n        ):\n            # \u2705 Collect all updated positions\n            positions = list(profit_data.updated_positions)\n\n            if not positions:\n                continue\n\n            # \u2705 Sort by profit (descending - winners first)\n            positions_sorted = sorted(positions, key=lambda p: p.profit, reverse=True)\n\n            print(f\"\\n[UPDATE] Total positions: {len(positions_sorted)}\")\n            print(f\"{'Symbol':&lt;10} {'Ticket':&lt;10} {'Profit':&lt;12} {'Status':&lt;10}\")\n            print(\"-\" * 60)\n\n            # \u2705 Show top 5 winners and top 5 losers\n            for pos in positions_sorted[:5]:  # Top 5 winners\n                status = \"\u2705 PROFIT\" if pos.profit &gt; 0 else \"\u274c LOSS\"\n                print(f\"{pos.position_symbol:&lt;10} {pos.ticket:&lt;10} {pos.profit:&gt;10.2f}  {status:&lt;10}\")\n\n            if len(positions_sorted) &gt; 10:\n                print(\"   ... middle positions omitted ...\")\n\n            for pos in positions_sorted[-5:]:  # Top 5 losers\n                status = \"\u2705 PROFIT\" if pos.profit &gt; 0 else \"\u274c LOSS\"\n                print(f\"{pos.position_symbol:&lt;10} {pos.ticket:&lt;10} {pos.profit:&gt;10.2f}  {status:&lt;10}\")\n\n            # \u2705 Calculate statistics\n            total_profit = sum(p.profit for p in positions_sorted)\n            winners = sum(1 for p in positions_sorted if p.profit &gt; 0)\n            losers = sum(1 for p in positions_sorted if p.profit &lt; 0)\n\n            print(\"-\" * 60)\n            print(f\"Total P&amp;L: {total_profit:+.2f} | Winners: {winners} | Losers: {losers}\")\n\n    finally:\n        cancel_event.set()\n        await asyncio.sleep(0.5)\n        try:\n            await account.channel.close()\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\nasyncio.run(sort_positions_by_profit())\n</code></pre>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#example-3-filter-orders-by-state-and-type","title":"Example 3: Filter Orders by State and Type","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_subscriptions_pb2 as sub_pb2\n\nasync def filter_orders_by_state():\n    \"\"\"\n    Monitor trade events and filter orders by state and type.\n    Shows complex filtering using multiple enums.\n    \"\"\"\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    cancel_event = asyncio.Event()\n\n    # \u2705 Define enum values for filtering\n    ORDER_STATE_PLACED = sub_pb2.SUB_ORDER_STATE_PLACED\n    ORDER_STATE_FILLED = sub_pb2.SUB_ORDER_STATE_FILLED\n    ORDER_STATE_CANCELED = sub_pb2.SUB_ORDER_STATE_CANCELED\n\n    ORDER_TYPE_BUY_LIMIT = sub_pb2.SUB_ORDER_TYPE_BUY_LIMIT\n    ORDER_TYPE_SELL_LIMIT = sub_pb2.SUB_ORDER_TYPE_SELL_LIMIT\n\n    try:\n        print(\"Monitoring pending orders (filtered by state)...\")\n        print(\"-\" * 70)\n\n        async for trade_data in account.on_trade(cancellation_event=cancel_event):\n            event = trade_data.event_data\n\n            # \u2705 Process new orders - filter pending limit orders only\n            for order in event.new_orders:\n                if order.order_type in [ORDER_TYPE_BUY_LIMIT, ORDER_TYPE_SELL_LIMIT]:\n                    order_type_str = \"BUY LIMIT\" if order.order_type == ORDER_TYPE_BUY_LIMIT else \"SELL LIMIT\"\n                    print(f\"[NEW PENDING] {order_type_str} #{order.ticket}: \"\n                          f\"{order.symbol} @ {order.price_open:.5f} \"\n                          f\"Vol={order.volume_initial:.2f} SL={order.stop_loss:.5f}\")\n\n            # \u2705 Process state changed orders - show only filled or cancelled\n            for state_change in event.state_changed_orders:\n                current = state_change.current_order\n                previous = state_change.previous_order\n\n                if current.state == ORDER_STATE_FILLED:\n                    print(f\"[FILLED] Order #{current.ticket} was filled: \"\n                          f\"{current.symbol} @ {current.price_current:.5f}\")\n\n                elif current.state == ORDER_STATE_CANCELED:\n                    print(f\"[CANCELED] Order #{current.ticket} was cancelled: \"\n                          f\"{current.symbol}\")\n\n    finally:\n        cancel_event.set()\n        await asyncio.sleep(0.5)\n        try:\n            await account.channel.close()\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\nasyncio.run(filter_orders_by_state())\n</code></pre>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#example-4-multi-symbol-tick-aggregation-with-sorting","title":"Example 4: Multi-Symbol Tick Aggregation with Sorting","text":"<pre><code>import asyncio\nfrom collections import defaultdict\nfrom datetime import datetime\nfrom MetaRpcMT5 import MT5Account\n\nasync def aggregate_and_sort_ticks():\n    \"\"\"\n    Aggregate ticks from multiple symbols and sort by spread.\n    Shows advanced data processing with multiple symbols.\n    \"\"\"\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    cancel_event = asyncio.Event()\n\n    # \u2705 Track latest tick for each symbol\n    latest_ticks = {}\n    tick_counts = defaultdict(int)\n\n    symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\", \"AUDUSD\", \"USDCAD\"]\n\n    try:\n        print(f\"Monitoring {len(symbols)} symbols, sorting by spread...\")\n        print(\"-\" * 80)\n\n        update_interval = 5  # Print sorted results every 5 ticks\n        total_ticks = 0\n\n        async for tick_data in account.on_symbol_tick(\n            symbols=symbols,\n            cancellation_event=cancel_event\n        ):\n            tick = tick_data.symbol_tick\n\n            # \u2705 Update latest tick for symbol\n            latest_ticks[tick.symbol] = tick\n            tick_counts[tick.symbol] += 1\n            total_ticks += 1\n\n            # \u2705 Every N ticks, show sorted summary\n            if total_ticks % update_interval == 0:\n                print(f\"\\n[{datetime.now().strftime('%H:%M:%S')}] Tick Summary (sorted by spread):\")\n                print(\"-\" * 80)\n                print(f\"{'Rank':&lt;6} {'Symbol':&lt;10} {'Bid':&lt;12} {'Ask':&lt;12} {'Spread':&lt;10} {'Ticks':&lt;8}\")\n                print(\"-\" * 80)\n\n                # \u2705 Calculate spreads and sort\n                symbol_spreads = []\n                for symbol, tick in latest_ticks.items():\n                    spread = tick.ask - tick.bid\n                    symbol_spreads.append((symbol, tick, spread))\n\n                # Sort by spread (ascending - tightest first)\n                symbol_spreads.sort(key=lambda x: x[2])\n\n                # \u2705 Display sorted results\n                for rank, (symbol, tick, spread) in enumerate(symbol_spreads, 1):\n                    spread_pips = spread * 10000  # For 4-digit pairs\n                    print(f\"{rank:&lt;6} {symbol:&lt;10} {tick.bid:&lt;12.5f} {tick.ask:&lt;12.5f} \"\n                          f\"{spread_pips:&lt;10.1f} {tick_counts[symbol]:&lt;8}\")\n\n                print(\"-\" * 80)\n                print(f\"Total ticks received: {total_ticks}\")\n\n    finally:\n        cancel_event.set()\n        await asyncio.sleep(0.5)\n        try:\n            await account.channel.close()\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\nasyncio.run(aggregate_and_sort_ticks())\n</code></pre>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#multiple-concurrent-streams","title":"Multiple Concurrent Streams","text":""},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#example-run-multiple-streams-simultaneously","title":"Example: Run Multiple Streams Simultaneously","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def multiple_concurrent_streams():\n    \"\"\"\n    Run multiple streaming methods concurrently.\n    Shows proper management of multiple streams.\n    \"\"\"\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    # \u2705 Single cancellation event for ALL streams\n    cancel_event = asyncio.Event()\n\n    async def stream_ticks():\n        \"\"\"Monitor tick data\"\"\"\n        try:\n            async for tick_data in account.on_symbol_tick(\n                symbols=[\"EURUSD\"],\n                cancellation_event=cancel_event\n            ):\n                tick = tick_data.symbol_tick\n                print(f\"[TICK] {tick.symbol}: {tick.bid:.5f}\")\n        except Exception as e:\n            print(f\"[TICK ERROR] {e}\")\n\n    async def stream_trades():\n        \"\"\"Monitor trade events\"\"\"\n        try:\n            async for trade_data in account.on_trade(cancellation_event=cancel_event):\n                print(f\"[TRADE] Event received: {trade_data.type}\")\n        except Exception as e:\n            print(f\"[TRADE ERROR] {e}\")\n\n    async def stream_profits():\n        \"\"\"Monitor position profits\"\"\"\n        try:\n            async for profit_data in account.on_position_profit(\n                interval_ms=2000,\n                ignore_empty=True,\n                cancellation_event=cancel_event\n            ):\n                total_positions = len(profit_data.updated_positions)\n                print(f\"[PROFIT] {total_positions} positions updated\")\n        except Exception as e:\n            print(f\"[PROFIT ERROR] {e}\")\n\n    async def auto_stop(duration: float):\n        \"\"\"Auto-stop after duration\"\"\"\n        await asyncio.sleep(duration)\n        print(f\"\\n[STOP] Auto-stopping after {duration} seconds...\")\n        cancel_event.set()\n\n    try:\n        print(\"Starting multiple concurrent streams...\")\n        print(\"-\" * 60)\n\n        # \u2705 Run all streams concurrently\n        await asyncio.gather(\n            stream_ticks(),\n            stream_trades(),\n            stream_profits(),\n            auto_stop(30.0)  # Stop all after 30 seconds\n        )\n\n    finally:\n        # \u2705 Ensure cancellation event is set\n        cancel_event.set()\n\n        # \u2705 Wait for all streams to cleanup\n        await asyncio.sleep(0.5)\n\n        # \u2705 Close channel\n        try:\n            await account.channel.close()\n            print(\"[DONE] All streams stopped gracefully\")\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\nasyncio.run(multiple_concurrent_streams())\n</code></pre>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#architecture-notes","title":"Architecture Notes","text":""},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#how-python-streaming-works-in-mt5account","title":"How Python Streaming Works in MT5Account","text":"<p>\ud83d\udd11 Critical Understanding:</p> <p>ALL streaming methods (<code>on_symbol_tick</code>, <code>on_trade</code>, <code>on_position_profit</code>, <code>on_trade_transaction</code>, <code>on_positions_and_pending_orders_tickets</code>) internally use the same hidden mechanism: <code>execute_stream_with_reconnect</code>.</p> <p>This is why: - The while loop behavior applies to ALL streaming operations - The <code>cancellation_event</code> mechanism is required for ALL streaming methods - Resource cleanup rules are identical for all streaming operations</p> <p>Users don't see this directly - when you call <code>account.on_symbol_tick()</code>, internally it calls <code>execute_stream_with_reconnect</code> which contains the infinite reconnection loop.</p> <p>Data flow:</p> <pre><code>User code (async for loop)\n    \u2193\nAsync generator (yields data)\n    \u2193\nexecute_stream_with_reconnect (background async task)\n    \u2193\ngRPC ClientStream\n    \u2193\nNetwork (to MT5 terminal)\n</code></pre> <p>Cancellation propagation: <pre><code>User code \u2192 cancellation_event \u2192 async generator \u2192 gRPC call \u2192 Network\n</code></pre></p> <p>When you set cancellation_event:</p> <ol> <li>User calls <code>cancel_event.set()</code> in their code</li> <li>While loop checks condition on next iteration:    <pre><code>while cancellation_event is None or not cancellation_event.is_set():\n# After .set() \u2192 both conditions False \u2192 loop STOPS\n</code></pre></li> <li>Current iteration finishes (async for yields last data)</li> <li><code>finally</code> block executes \u2192 <code>stream.cancel()</code> closes gRPC stream \u2705</li> <li>Loop breaks (no new streams created)</li> <li>Network connection closes</li> <li>Resources freed \u2705</li> </ol> <p>Key insight: The while loop checks <code>cancellation_event.is_set()</code> on each iteration. Calling <code>.set()</code> makes the loop exit after current stream finishes.</p>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#mt5account-cleanup-mechanism","title":"MT5Account Cleanup Mechanism","text":"<p>\u26a0\ufe0f Important: This mechanism is internal to ALL streaming methods. When you call any streaming method (<code>on_symbol_tick</code>, <code>on_trade</code>, etc.), you're actually using <code>execute_stream_with_reconnect</code> behind the scenes.</p> <p>The <code>execute_stream_with_reconnect</code> method has built-in reconnection logic with automatic stream cleanup:</p> <pre><code># In MT5Account (real structure)\nasync def execute_stream_with_reconnect(..., cancellation_event):\n    # \u26a0\ufe0f CRITICAL: Infinite reconnection loop\n    while cancellation_event is None or not cancellation_event.is_set():\n        reconnect_required = False\n        stream = None\n\n        try:\n            stream = stream_invoker(request, headers)\n            async for response in stream:\n                # Yield data to user\n                yield data\n\n        except grpc.aio.AioRpcError as ex:\n            if ex.code() == grpc.StatusCode.UNAVAILABLE:\n                reconnect_required = True  # Network error \u2192 try reconnect\n            else:\n                raise\n\n        finally:\n            if stream:\n                stream.cancel()  # \u2705 ALWAYS closes current gRPC stream\n\n        # Reconnection logic\n        if reconnect_required:\n            await asyncio.sleep(0.5)\n            await self.reconnect()\n            # \u26a0\ufe0f Loop continues \u2192 creates NEW stream\n        else:\n            break  # Exit only here\n</code></pre> <p>What this means:</p> <p>\u2705 What it DOES do: - Closes current gRPC stream automatically (in <code>finally</code> block) - Handles network errors with automatic reconnection - Cleans up resources for each individual stream</p> <p>\u26a0\ufe0f What it DOESN'T do: - Stop the reconnection loop without <code>cancellation_event</code> - Prevent new streams from being created</p> <p>Critical understanding:</p> <pre><code># \u274c WITHOUT cancellation_event:\nasync for tick in account.on_symbol_tick([\"EURUSD\"]):  # No cancellation_event!\n    if count &gt;= 10:\n        break  # User breaks \u2192 current stream closes \u2705\n                # BUT while loop continues \u2192 creates NEW stream \u274c\n                # \u2192 LEAK: orphaned stream keeps running\n\n# \u2705 WITH cancellation_event:\ncancel_event = asyncio.Event()\nasync for tick in account.on_symbol_tick([\"EURUSD\"], cancellation_event=cancel_event):\n    if count &gt;= 10:\n        cancel_event.set()  # Stops while loop \u2705\n        break               # Current stream closes \u2705\n                            # \u2192 CLEAN: no new streams created\n</code></pre> <p>Bottom line: - \u2705 <code>stream.cancel()</code> cleans up current stream - \u274c Only <code>cancellation_event.set()</code> stops the reconnection while loop - \ud83d\udd11 How it works: <code>while cancellation_event is None or not cancellation_event.is_set()</code> checks on each iteration - \ud83d\udd34 Without cancellation_event \u2192 while condition is always True \u2192 loop runs forever \u2192 LEAK - \ud83d\udd34 With cancellation_event but no .set() \u2192 while condition stays True \u2192 loop runs forever \u2192 LEAK - \u2705 With cancellation_event.set() \u2192 while condition becomes False \u2192 loop stops \u2192 CLEAN - \u2705 You MUST close channel to free gRPC connection</p>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#recommendations","title":"Recommendations","text":""},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#do","title":"\u2705 DO:","text":"<ol> <li>Always use <code>cancellation_event</code> with streaming methods</li> <li>Always call <code>cancel_event.set()</code> before exiting</li> <li>Always use <code>try/finally</code> blocks for cleanup</li> <li>Always wait 0.5-1.0 seconds after setting cancellation_event</li> <li>Always close channel in finally block: <code>await account.channel.close()</code></li> <li>Use <code>asyncio.wait_for()</code> for automatic timeouts</li> <li>Use <code>asyncio.gather()</code> to run multiple streams concurrently</li> </ol>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#dont","title":"\u274c DON'T:","text":"<ol> <li>Never start streaming without cancellation_event</li> <li>Never break from loop without setting cancellation_event</li> <li>Never forget finally block with cleanup code</li> <li>Never skip waiting period after cancellation</li> <li>Never leave channel open after streaming</li> <li>Never ignore exceptions from streams</li> </ol>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#troubleshooting-and-async-task-leaks","title":"Troubleshooting and Async Task Leaks","text":""},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#checking-for-task-leaks","title":"Checking for Task Leaks","text":"<pre><code>import asyncio\n\nasync def check_task_leaks():\n    # Before streaming\n    before = len(asyncio.all_tasks())\n    print(f\"Tasks before: {before}\")\n\n    # Your streaming code here...\n    account = MT5Account(user=12345, password=\"password\", grpc_server=\"mt5.mrpc.pro:443\")\n    await account.connect_by_server_name(server_name=\"YourBroker-Demo\", base_chart_symbol=\"EURUSD\")\n\n    cancel_event = asyncio.Event()\n\n    try:\n        count = 0\n        async for tick_data in account.on_symbol_tick(\n            symbols=[\"EURUSD\"],\n            cancellation_event=cancel_event\n        ):\n            count += 1\n            if count &gt;= 5:\n                break\n\n    finally:\n        cancel_event.set()\n        await asyncio.sleep(0.5)\n        try:\n            await account.channel.close()\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\n    # After streaming (wait a bit for cleanup)\n    await asyncio.sleep(1.0)\n    after = len(asyncio.all_tasks())\n    print(f\"Tasks after: {after}\")\n    print(f\"Leaked tasks: {after - before}\")\n    # Should be 0-1 if properly cleaned up\n\nasyncio.run(check_task_leaks())\n</code></pre>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#debugging-pending-tasks","title":"Debugging Pending Tasks","text":"<pre><code>import asyncio\n\nasync def debug_pending_tasks():\n    # Get all tasks\n    tasks = asyncio.all_tasks()\n\n    print(f\"Total pending tasks: {len(tasks)}\")\n    print(\"-\" * 60)\n\n    for i, task in enumerate(tasks, 1):\n        print(f\"Task {i}: {task.get_name()}\")\n        print(f\"  Coro: {task.get_coro()}\")\n        print(f\"  Done: {task.done()}\")\n        if not task.done():\n            print(f\"  \u26a0\ufe0f  STILL RUNNING!\")\n        print()\n</code></pre>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#common-leak-patterns","title":"Common Leak Patterns","text":"<ol> <li> <p>Not using cancellation_event: <pre><code># \u274c Leak: stream never stops\nasync for data in account.on_symbol_tick(symbols=[\"EURUSD\"]):\n    # Forgot cancellation_event parameter\n    pass\n</code></pre></p> </li> <li> <p>Not setting cancellation_event: <pre><code># \u274c Leak: stream keeps running after break\ncancel_event = asyncio.Event()\nasync for data in account.on_symbol_tick(symbols=[\"EURUSD\"], cancellation_event=cancel_event):\n    if condition:\n        break  # Forgot cancel_event.set()\n</code></pre></p> </li> <li> <p>Not closing channel: <pre><code># \u274c Leak: connection stays open\ncancel_event.set()\nawait asyncio.sleep(0.5)\n# Forgot await account.channel.close()\n</code></pre></p> </li> </ol>"},{"location":"All_Guides/GRPC_STREAM_MANAGEMENT/#see-also","title":"See Also","text":"<ul> <li>Streaming Methods Overview - Complete streaming methods documentation</li> <li>on_symbol_tick - Tick streaming reference</li> <li>on_trade - Trade events reference</li> <li>Python asyncio documentation - Official asyncio guide</li> <li>gRPC Python - Official gRPC Python guide</li> </ul> <p>Remember: Streams are powerful tools for real-time market data, but they require proper lifecycle management. Master cancellation_event, always cleanup in finally blocks, and your streaming code will be robust and leak-free. Happy streaming! \ud83d\ude80</p>"},{"location":"All_Guides/MT5_For_Beginners/","title":"MT5 for Beginners: Your First Steps in Trading","text":"<p>Welcome! This guide is designed for complete beginners who have never worked with MetaTrader 5 or trading. We'll walk you through everything you need to know to get started.</p>"},{"location":"All_Guides/MT5_For_Beginners/#what-is-metatrader-5-mt5","title":"What is MetaTrader 5 (MT5)?","text":"<p>MetaTrader 5 is a powerful trading platform used by millions of traders worldwide. It allows you to:</p> <ul> <li>Trade forex, stocks, commodities, and cryptocurrencies</li> <li>Analyze markets with charts and indicators</li> <li>Execute automated trading strategies</li> <li>Monitor your positions in real-time</li> </ul> <p>Think of MT5 as your \"cockpit\" for accessing financial markets. PyMT5 allows you to programmatically control this cockpit using Python.</p>"},{"location":"All_Guides/MT5_For_Beginners/#demo-vs-live-account-start-safely","title":"Demo vs Live Account: Start Safely","text":""},{"location":"All_Guides/MT5_For_Beginners/#why-start-with-a-demo-account","title":"Why start with a demo account?","text":"<p>A demo account is a risk-free practice account with virtual money. We strongly recommend starting with demo for several reasons:</p> <ul> <li>\u2705 Zero risk - practice with virtual funds (typically $10,000 - $100,000)</li> <li>\u2705 Real market conditions - live prices and market behavior</li> <li>\u2705 Learn the platform - understand how MT5 works before risking real money</li> <li>\u2705 Test your code - perfect for developing and testing your PyMT5 applications</li> </ul>"},{"location":"All_Guides/MT5_For_Beginners/#live-account","title":"Live Account","text":"<p>A live account uses your real money. Only move to live trading when you:</p> <ul> <li>Understand how MT5 works</li> <li>Have thoroughly tested your strategies on demo</li> <li>Are aware of the risks involved</li> </ul>"},{"location":"All_Guides/MT5_For_Beginners/#quick-start-creating-a-demo-account","title":"Quick Start: Creating a Demo Account","text":"<p>The fastest way to get started is to create a demo account directly through the MT5 terminal application.</p>"},{"location":"All_Guides/MT5_For_Beginners/#step-1-download-and-install-mt5-terminal","title":"Step 1\ufe0f\u20e3: Download and Install MT5 Terminal","text":"<ol> <li> <p>Visit the official MetaTrader website: https://www.metatrader5.com/en/download</p> </li> <li> <p>Download the version for your operating system (Windows/Mac/Linux)</p> </li> <li> <p>Install the application</p> </li> </ol>"},{"location":"All_Guides/MT5_For_Beginners/#step-2-launch-mt5-and-locate-the-navigator-panel","title":"Step 2\ufe0f\u20e3: Launch MT5 and Locate the Navigator Panel","text":"<p>When you open the MetaTrader 5 application, you'll typically see a popup window offering to:</p> <ul> <li> <p>Register for the MQL community</p> </li> <li> <p>Open a new account or log into an existing one</p> </li> </ul> <p>If this popup doesn't appear automatically, you need to find the Navigator panel.</p> <p></p> <p>Finding the Navigator Panel:</p> <p>The Navigator panel is usually located on the left side of the screen, below the Market Watch panel.</p> <p>Inside the Navigator panel you'll see several sections: - Accounts - Subscriptions - Indicators - Expert Advisors - And others</p>"},{"location":"All_Guides/MT5_For_Beginners/#step-3-opening-a-new-demo-account","title":"Step 3\ufe0f\u20e3: Opening a New Demo Account","text":"<ol> <li>In the Navigator panel, find the Accounts section</li> <li>Right-click on \"Accounts\"</li> <li>Select \"Open an account\" from the context menu</li> </ol> <p>This will open the broker server search panel.</p>"},{"location":"All_Guides/MT5_For_Beginners/#step-4-select-metaquotes-demo-server","title":"Step 4\ufe0f\u20e3: Select MetaQuotes Demo Server","text":"<p>In the broker search window, you'll see a list of available MT5 servers.</p> <p>For your first demo account, we'll use the simplest option:</p> <ul> <li>Look for \"MetaQuotes-Demo\" or \"MetaQuotes Ltd\" in the list</li> <li>This is the standard demo server provided by MetaTrader developers</li> <li>If you don't see it immediately, use the search field at the top to find it</li> </ul> <p>Select the MetaQuotes server and click Next.</p> <p></p>"},{"location":"All_Guides/MT5_For_Beginners/#step-5-account-type-selection","title":"Step 5\ufe0f\u20e3: Account Type Selection","text":"<p>On the next screen, you'll have options:</p> <ul> <li>Open a new demo account (top option)</li> <li>Log into an existing account (demo or live)</li> </ul> <p>Select \"Open a new demo account\" and click Next.</p> <p></p>"},{"location":"All_Guides/MT5_For_Beginners/#step-6-fill-in-your-personal-information","title":"Step 6\ufe0f\u20e3: Fill in Your Personal Information","text":"<p>Now you'll see a form requesting your details:</p> <ul> <li>Name: Your first name</li> <li>Last Name: Your last name</li> <li>Email: Your email address</li> <li>Phone: Optional (can skip for demo)</li> <li>Account Type: Choose your preferred account settings</li> <li>Deposit: Virtual amount (e.g., $10,000)</li> <li>Leverage: 1:100 is a good starting point</li> <li>Currency: USD, EUR, etc.</li> </ul> <p>Check the box to agree to the terms and conditions, then click Next.</p> <p></p>"},{"location":"All_Guides/MT5_For_Beginners/#step-7-save-your-account-credentials","title":"Step 7\ufe0f\u20e3: Save Your Account Credentials","text":"<p>MT5 will now create your demo account and display your credentials:</p> <p>Important credentials displayed:</p> <ul> <li>Login: Your account number (e.g., 591129415)</li> <li>Password: Your master password for trading</li> <li>Investor Password: Read-only password (for monitoring)</li> <li>Server: Server name (e.g., \"MetaQuotes-Demo\")</li> </ul> <p>\u26a0\ufe0f CRITICALLY IMPORTANT: Save these credentials immediately! You'll need them for: - Logging back into MT5 - Configuring PyMT5 in <code>examples/0_common/settings.json</code></p> <p>Click Finish to complete account creation.</p> <p></p>"},{"location":"All_Guides/MT5_For_Beginners/#step-8-configure-pymt5-with-your-credentials","title":"Step 8\ufe0f\u20e3: Configure PyMT5 with Your Credentials","text":"<p>Now that you have an MT5 demo account, you need to configure PyMT5 to connect to it.</p> <ol> <li>Open your PyMT5 project</li> <li>Navigate to <code>examples/0_common/settings.json</code></li> <li>Fill in the credentials you just saved:</li> </ol> <pre><code>{\n  \"user\": 591129415,\n  \"password\": \"YourPasswordHere\",\n  \"host\": \"mt5.mrpc.pro\",\n  \"port\": 443,\n  \"grpc_server\": \"mt5.mrpc.pro:443\",\n  \"mt_cluster\": \"MetaQuotes-Demo\",\n  \"test_symbol\": \"EURUSD\",\n  \"test_volume\": 0.01\n}\n</code></pre> <p>Important notes:</p> <ul> <li>user: Replace with your login number</li> <li>password: Replace with your password</li> <li>mt_cluster: Use the exact server name from MT5 (e.g., \"MetaQuotes-Demo\")</li> <li>host, port, grpc_server: Provided by MetaRPC team (leave as is)</li> </ul>"},{"location":"All_Guides/MT5_For_Beginners/#step-9-verify-mt5-connection","title":"Step 9\ufe0f\u20e3: Verify MT5 Connection","text":"<p>Back in the MT5 terminal:</p> <ol> <li>MT5 should automatically log you into your new demo account</li> <li>Check the bottom right corner of the terminal window - you should see:</li> <li>Green connection indicator (means connected to server)</li> <li>Your account balance (e.g., $10,000)</li> </ol> <p>You're now ready to test!</p>"},{"location":"All_Guides/MT5_For_Beginners/#step-start-testing-pymt5","title":"Step \ud83d\udd1f: Start Testing PyMT5","text":"<p>With your MT5 demo account created and <code>settings.json</code> configured, you can start running examples:</p> <pre><code># Navigate to the examples folder\ncd examples\n\n# Run your first example\npython main.py 1\n\n# Or run interactively\npython main.py\n</code></pre> <p>When trading operations occur, your demo account balance will increase or decrease accordingly. Experiment freely - it's virtual money, so there's no risk!</p> <p>All trades executed by PyMT5 will appear in your MT5 terminal in real-time.</p>"},{"location":"All_Guides/MT5_For_Beginners/#understanding-mt5-password-types","title":"\ud83e\udde9 Understanding MT5 Password Types","text":"<p>MT5 uses two types of passwords for security and flexibility:</p>"},{"location":"All_Guides/MT5_For_Beginners/#master-password-main-password","title":"Master Password (Main Password)","text":"<ul> <li>Full access to your trading account</li> <li>Can open/close trades, deposit/withdraw funds, change settings</li> <li>This is the password you created during account registration</li> <li>Use this password for:</li> <li>Trading (including PyMT5 applications)</li> <li>Changing account settings</li> <li>Withdrawing funds (live accounts)</li> </ul>"},{"location":"All_Guides/MT5_For_Beginners/#investor-password-read-only-password","title":"Investor Password (Read-Only Password)","text":"<ul> <li>View-only access to your account</li> <li>Can see trades, balance, history - but cannot trade</li> <li>Useful for:</li> <li>Sharing your trading performance with others (investors, friends)</li> <li>Monitoring your account without risk</li> <li>Audit and analytics tools</li> </ul> <p>How to get your investor password:</p> <ol> <li>In MT5, go to Tools \u2192 Options</li> <li>Select the Server tab</li> <li>Click Change next to \"Investor Password\"</li> <li>Set a new investor password</li> </ol>"},{"location":"All_Guides/MT5_For_Beginners/#choosing-a-broker-optional","title":"Choosing a Broker (Optional)","text":"<p>While you can use the MetaQuotes demo server for practice, you may want to choose a specific broker for:</p> <ul> <li>Live trading later</li> <li>Better demo conditions (spreads, instruments)</li> <li>Specific regional support</li> </ul>"},{"location":"All_Guides/MT5_For_Beginners/#popular-mt5-brokers","title":"Popular MT5 Brokers:","text":"<p>Note: This is not financial advice. Always do your own research before choosing a broker.</p> <ul> <li>IC Markets - Popular for forex and low spreads</li> <li>Pepperstone - Well-regulated, beginner-friendly</li> <li>OANDA - Strong reputation, accepts US clients</li> <li>XM - Easy account opening, many account types</li> <li>RoboForex - Good for automated trading</li> <li>FxPro - Excellent demo trading conditions (used in PyMT5 examples)</li> </ul>"},{"location":"All_Guides/MT5_For_Beginners/#what-to-look-for","title":"What to look for:","text":"<ul> <li> <p>\u2705 Regulation - Check if regulated by FCA, ASIC, CySEC, etc.</p> </li> <li> <p>\u2705 MT5 Support - Make sure they offer MT5 (not just MT4).</p> </li> <li> <p>\u2705 Demo Account - Free demo without expiration (though demo accounts typically last 30 days, then become inactive).</p> </li> <li> <p>\u2705 Good Spreads - Lower spreads = lower trading costs.</p> </li> <li> <p>\u2705 Customer Support - Responsive support in your language.</p> </li> </ul>"},{"location":"All_Guides/MT5_For_Beginners/#whats-next","title":"What's Next?","text":"<p>Now that you have a demo account and understand the basics, you're ready for:</p>"},{"location":"All_Guides/MT5_For_Beginners/#1-setting-up-pymt5","title":"1. Setting Up PyMT5","text":"<p>Follow our main getting started guide to connect PyMT5 to your MT5 account:</p> <p>\ud83d\udc49 Getting Started with PyMT5</p>"},{"location":"All_Guides/MT5_For_Beginners/#2-understanding-api-architecture","title":"2. Understanding API Architecture","text":"<p>PyMT5 is built in three levels, from low-level to high-level. You can choose where to start depending on your needs:</p>"},{"location":"All_Guides/MT5_For_Beginners/#level-1-mt5account-low-level-grpc-foundation","title":"Level 1: MT5Account (Low-Level gRPC Foundation)","text":"<p>\ud83d\udc49 MT5Account Overview</p> <ul> <li>Direct gRPC calls to MT5 terminal</li> <li>Foundation of everything - all other levels use this internally</li> <li>Maximum control and flexibility</li> <li>Best for: Advanced users who need fine-grained control</li> </ul>"},{"location":"All_Guides/MT5_For_Beginners/#level-2-mt5service-convenient-wrappers","title":"Level 2: MT5Service (Convenient Wrappers)","text":"<p>\ud83d\udc49 MT5Service Overview</p> <ul> <li>Wrapper methods over MT5Account gRPC calls</li> <li>Simplified error handling and response parsing</li> <li>Easier to work with than raw gRPC</li> <li>Best for: Most common trading scenarios</li> </ul>"},{"location":"All_Guides/MT5_For_Beginners/#level-3-mt5sugar-high-level-helpers","title":"Level 3: MT5Sugar (High-Level Helpers)","text":"<p>\ud83d\udc49 MT5Sugar API Overview</p> <ul> <li>Syntactic sugar and convenience methods</li> <li>Chainable operations, smart defaults</li> <li>Most intuitive and beginner-friendly</li> <li>Best for: Rapid prototyping and simple strategies</li> </ul>"},{"location":"All_Guides/MT5_For_Beginners/#important-reminders","title":"Important Reminders","text":""},{"location":"All_Guides/MT5_For_Beginners/#security","title":"\ud83d\udee1\ufe0f Security","text":"<ul> <li>Never share your master password with anyone</li> <li>Use investor password for monitoring/analytics tools</li> <li>Keep your credentials safe (use password managers)</li> </ul>"},{"location":"All_Guides/MT5_For_Beginners/#risk-management","title":"\ud83d\udcca Risk Management","text":"<ul> <li>Demo accounts are risk-free, but form good habits:</li> <li>Always use Stop Loss</li> <li>Don't risk more than 1-2% per trade</li> <li>Understand position sizing calculations</li> </ul>"},{"location":"All_Guides/MT5_For_Beginners/#testing","title":"\ud83e\uddea Testing","text":"<ul> <li>Test all your PyMT5 code on demo first</li> <li>Verify strategies over weeks/months, not days</li> <li>Paper trading (demo) doesn't guarantee live results</li> </ul>"},{"location":"All_Guides/MT5_For_Beginners/#education","title":"\ud83d\udcda Education","text":"<ul> <li>Trading has a steep learning curve</li> <li>Focus on learning, not earning</li> <li>Consider courses, books, and communities</li> </ul>"},{"location":"All_Guides/MT5_For_Beginners/#useful-python-commands","title":"Useful Python Commands","text":""},{"location":"All_Guides/MT5_For_Beginners/#installation","title":"Installation","text":"<pre><code># Install PyMT5 package with all dependencies\npip install MetaRpcMT5\n</code></pre>"},{"location":"All_Guides/MT5_For_Beginners/#running-examples","title":"Running Examples","text":"<pre><code># Navigate to examples folder first\ncd examples\n\n# Option 1: Run specific example by number\npython main.py 1\n\n# Option 2: Interactive menu\npython main.py\n\n# Option 3: Run example file directly\npython 1_lowlevel/01_general_operations.py\npython 3_sugar/06_sugar_basics.py\n</code></pre>"},{"location":"All_Guides/MT5_For_Beginners/#checking-environment","title":"Checking Environment","text":"<pre><code># Verify Python version (requires 3.8+)\npython --version\n</code></pre> <p>Ready to start coding? Head over to Getting Started to connect PyMT5 to your MT5 account!</p> <p>Good luck with your trading journey! \ud83d\ude80</p>"},{"location":"All_Guides/PROJECT_MAP/","title":"PyMT5 Project Map","text":"<p>Complete reference to project structure. Shows what is located where, what is user-facing vs internal, and how components are connected.</p>"},{"location":"All_Guides/PROJECT_MAP/#project-overview","title":"\ud83d\uddc2\ufe0f Project Overview","text":"<pre><code>PyMT5/\n\u251c\u2500\u2500 \ud83d\udce6 package/ - Core package (portable)\n\u2502   \u2514\u2500\u2500 MetaRpcMT5/\n\u2502       \u251c\u2500\u2500 helpers/mt5_account.py (Layer 1 - Foundation)\n\u2502       \u251c\u2500\u2500 helpers/errors.py (Error handling &amp; trade return codes)\n\u2502       \u2514\u2500\u2500 (Protobuf definitions)\n\u2502   \n\u2502\n\u251c\u2500\u2500 \ud83d\udce6 src/pymt5/ - High-level API layers\n\u2502   \u251c\u2500\u2500 mt5_service.py (Layer 2 - Wrappers)\n\u2502   \u2514\u2500\u2500 mt5_sugar.py (Layer 3 - Convenience)\n\u2502\n\u251c\u2500\u2500 \ud83d\udc64 User Code (Orchestrators, Examples)\n\u251c\u2500\u2500 \ud83d\udcdd Documentation\n\u2514\u2500\u2500 \u2699\ufe0f Configuration and build\n\nExternal dependencies:\n\u2514\u2500\u2500 \ud83d\udd0c gRPC &amp; Protobuf (Python packages)\n</code></pre>"},{"location":"All_Guides/PROJECT_MAP/#core-api-three-layer-architecture","title":"\ud83d\udce6 Core API (Three-layer architecture)","text":"<p>What: Three-tier architecture for MT5 trading automation.</p> <pre><code>package/MetaRpcMT5/\n\u251c\u2500\u2500 helpers/\n\u2502   \u251c\u2500\u2500 mt5_account.py            &lt;- LAYER 1: Low-level gRPC \ud83d\udd25 FOUNDATION\n\u2502   \u2502   \u2514\u2500\u2500 Direct gRPC calls to MT5 terminal\n\u2502   \u2502   \u2514\u2500\u2500 Connection management with retry logic\n\u2502   \u2502   \u2514\u2500\u2500 Proto Request/Response handling\n\u2502   \u2502   \u2514\u2500\u2500 Built-in connection resilience\n\u2502   \u2502   \u2514\u2500\u2500 Independent Python package (portable)\n\u2502   \u2502   \u2514\u2500\u2500 Class: MT5Account\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 errors.py                 &lt;- Error handling &amp; trade result codes\n\u2502       \u2514\u2500\u2500 NotConnectedError exception (connection errors)\n\u2502       \u2514\u2500\u2500 ApiError wrapper (3-level: API/MQL/Trade)\n\u2502       \u2514\u2500\u2500 Trade return code constants &amp; helpers\n\u2502       \u2514\u2500\u2500 Centralized error inspection methods\n\u2502\n\u251c\u2500\u2500 *_pb2.py                      &lt;- Protobuf message definitions\n\u251c\u2500\u2500 *_pb2_grpc.py                 &lt;- gRPC service stubs\n\u251c\u2500\u2500 mt5_term_api_*.py             &lt;- MT5 API protocol definitions\n\u2514\u2500\u2500 __init__.py                   &lt;- Package initialization\n\nsrc/pymt5/\n\u251c\u2500\u2500 mt5_service.py                &lt;- LAYER 2: Wrapper methods\n\u2502   \u2514\u2500\u2500 Simplified signatures (no proto objects)\n\u2502   \u2514\u2500\u2500 Type conversion (proto \u2192 Python types)\n\u2502   \u2514\u2500\u2500 Direct data return\n\u2502   \u2514\u2500\u2500 Extension methods for convenience\n\u2502   \u2514\u2500\u2500 Class: MT5Service\n\u2502\n\u2514\u2500\u2500 mt5_sugar.py                  &lt;- LAYER 3: Convenience layer \ud83d\udd25\n    \u2514\u2500\u2500 Auto-normalization (volumes, prices)\n    \u2514\u2500\u2500 Risk management (CalculateVolume, BuyByRisk)\n    \u2514\u2500\u2500 Points-based methods (BuyLimitPoints, etc.)\n    \u2514\u2500\u2500 Batch operations (CloseAll, CancelAll)\n    \u2514\u2500\u2500 Snapshots (GetAccountSnapshot, GetSymbolSnapshot)\n    \u2514\u2500\u2500 Smart helpers (conversions, limits)\n    \u2514\u2500\u2500 Class: MT5Sugar\n\npackage/pyproject.toml            &lt;- Package configuration (dependencies, metadata)\n</code></pre> <p>Architecture flow: <pre><code>MT5Sugar \u2192 uses \u2192 MT5Service \u2192 uses \u2192 MT5Account \u2192 gRPC \u2192 MT5 Terminal\n       \u2193                \u2193                    \u2193\nsrc/pymt5/       src/pymt5/         package/MetaRpcMT5/helpers/\n</code></pre></p> <p>\ud83d\udca1 Creating Your Own Project:</p> <p>For your own standalone project using PyMT5, you only need to import the <code>package</code> module:</p> <pre><code>from MetaRpcMT5 import MT5Account\nfrom MetaRpcMT5.helpers.errors import ApiError, check_retcode\n</code></pre> <p>The <code>package</code> module contains everything you need to start:</p> <ul> <li>\u2705 All protobuf definitions (proto-generated code)</li> <li>\u2705 gRPC stubs and service contracts</li> <li>\u2705 MT5Account (Layer 1 - Foundation)</li> <li>\u2705 Independent Python package (can be used without src/)</li> </ul> <p>This makes the package portable and easy to integrate into any Python project!</p> <p>User decision:</p> <ul> <li>Building your own app: Import <code>package</code> and use MT5Account directly</li> <li>Learning/Examples: Use the full PyMT5 repo with all 3 layers</li> <li>95% of demo cases: Start with <code>MT5Sugar</code> (highest level, easiest)</li> <li>Need wrappers: Move to <code>MT5Service</code> (without auto-normalization)</li> <li>Need raw proto: Move to <code>MT5Account</code> (full control)</li> </ul>"},{"location":"All_Guides/PROJECT_MAP/#built-in-reconnect-protection","title":"Built-in Reconnect Protection","text":"<p>What: All low-level gRPC calls in <code>MT5Account</code> have automatic reconnection logic.</p> <p>Two protection mechanisms:</p>"},{"location":"All_Guides/PROJECT_MAP/#1-regular-grpc-calls-execute_with_reconnect","title":"1. Regular gRPC Calls (<code>execute_with_reconnect</code>)","text":"<p>All basic MT5Account methods (account info, trading operations, etc.) use built-in reconnection:</p> <p>How it works:</p> <ul> <li> <p>Detects gRPC <code>UNAVAILABLE</code> status (server unreachable)</p> </li> <li> <p>Detects terminal errors:</p> </li> <li> <p><code>TERMINAL_INSTANCE_NOT_FOUND</code></p> </li> <li> <p><code>TERMINAL_REGISTRY_TERMINAL_NOT_FOUND</code></p> </li> <li> <p>On error: waits 0.5 seconds, reconnects, retries the call</p> </li> <li> <p>Continues until success or cancellation</p> </li> </ul> <p>What this means for you:</p> <ul> <li>No manual reconnection needed</li> <li>Network hiccups handled automatically</li> <li>Terminal restarts recovered seamlessly</li> </ul> <p>Example:</p> <pre><code># This call automatically reconnects if connection is lost\nbalance = await account.account_info_double(\n    account_info_pb2.AccountInfoDoublePropertyType.ACCOUNT_BALANCE\n)\n# If connection drops: auto-reconnect \u2192 retry \u2192 return result\n</code></pre>"},{"location":"All_Guides/PROJECT_MAP/#2-streaming-calls-execute_stream_with_reconnect","title":"2. Streaming Calls (<code>execute_stream_with_reconnect</code>)","text":"<p>Streaming methods (position updates, tick streams, trade events) have separate stream-specific protection:</p> <p>How it works:</p> <ul> <li>Same error detection (UNAVAILABLE, terminal not found)</li> <li>Properly closes existing stream before reconnecting</li> <li>Reopens stream after reconnection</li> <li>Continues yielding data transparently</li> </ul> <p>What this means for you:</p> <ul> <li>Stream interruptions handled automatically</li> <li>No data loss on reconnection</li> <li>Seamless continuation of real-time data</li> </ul> <p>Example:</p> <pre><code># Stream automatically recovers from connection issues\nasync for trade in account.on_trade(cancellation_event):\n    print(f\"Trade: {trade}\")\n    # If connection drops: stream closes \u2192 reconnect \u2192 stream reopens \u2192 continues\n</code></pre> <p>Important notes:</p> <ul> <li>Both mechanisms require valid connection parameters (host/port or server_name)</li> <li>Reconnection uses the same credentials from initial connection</li> <li>Use <code>cancellation_event</code> to stop retry loops</li> <li>0.5 second delay between retry attempts prevents server overload</li> </ul>"},{"location":"All_Guides/PROJECT_MAP/#user-code-your-trading-strategies","title":"\ud83d\udc64 User Code (Your Trading Strategies)","text":""},{"location":"All_Guides/PROJECT_MAP/#orchestrators-examples4_orchestrators","title":"Orchestrators (examples/4_orchestrators/)","text":"<p>What: Ready-made trading strategy implementations.</p> <pre><code>examples/4_orchestrators/\n\u251c\u2500\u2500 11_trailing_stop.py           &lt;- Trailing stop (price following)\n\u251c\u2500\u2500 12_position_scaler.py         &lt;- Position scaling\n\u251c\u2500\u2500 13_grid_trader.py             &lt;- Grid trading (sideways markets)\n\u251c\u2500\u2500 14_risk_manager.py            &lt;- Risk manager\n\u2514\u2500\u2500 15_portfolio_rebalancer.py    &lt;- Portfolio rebalancing\n</code></pre> <p>Purpose: Educational examples showing complete strategy workflows:</p> <ul> <li>Entry logic (risk-based volume where applicable)</li> <li>Position monitoring with progress bars</li> <li>Exit management and cleanup</li> <li>Performance tracking (balance, equity, P/L)</li> <li>Configurable parameters via properties</li> </ul> <p>How to use:</p> <ol> <li>Study existing orchestrators</li> <li>Copy one as a template</li> <li>Modify for your strategy</li> <li>Test on demo account</li> </ol> <p>How to run: <pre><code>python examples/main.py 11         # Trailing Stop\npython examples/main.py trailing    # Same with alias\npython examples/main.py scaler      # Position Scaler\npython examples/main.py grid        # Grid Trader\npython examples/main.py risk        # Risk Manager\npython examples/main.py rebalancer  # Portfolio Rebalancer\n</code></pre></p> <p>Documentation: - Orchestrator documentation files: See source code comments in each .py file - Usage examples included directly in the Python files</p>"},{"location":"All_Guides/PROJECT_MAP/#examples-examples","title":"Examples (examples/)","text":"<p>What: Runnable examples demonstrating API usage at different layers.</p> <p>User interaction: \u2705 Learning materials - run to understand the API.</p> <pre><code>examples/\n\u251c\u2500\u2500 0_common/                          &lt;- Common utilities\n\u2502   \u251c\u2500\u2500 settings.json                  &lt;- Connection configuration\n\u2502   \u251c\u2500\u2500 demo_helpers.py                &lt;- Helper functions for demos\n\u2502   \u251c\u2500\u2500 progress_bar.py                &lt;- Progress bar utilities\n\u2502   \u2514\u2500\u2500 16_protobuf_inspector.py       &lt;- Protobuf structure inspector\n\u2502\n\u251c\u2500\u2500 1_lowlevel/                        &lt;- MT5Account examples (proto level) \ud83d\udd25 FOUNDATION\n\u2502   \u251c\u2500\u2500 01_general_operations.py       &lt;- General operations (connection, account, symbols)\n\u2502   \u251c\u2500\u2500 02_trading_operations.py       &lt;- Trading operations (orders, positions)\n\u2502   \u2514\u2500\u2500 03_streaming_methods.py        &lt;- Streaming methods (real-time subscriptions)\n\u2502\n\u251c\u2500\u2500 2_service/                         &lt;- MT5Service examples (wrapper level)\n\u2502   \u251c\u2500\u2500 04_service_demo.py             &lt;- Service API demonstration\n\u2502   \u2514\u2500\u2500 05_service_streaming.py        &lt;- Service streaming methods\n\u2502\n\u251c\u2500\u2500 3_sugar/                           &lt;- MT5Sugar examples (convenience level)\n\u2502   \u251c\u2500\u2500 06_sugar_basics.py             &lt;- Sugar API basics (balance, prices)\n\u2502   \u251c\u2500\u2500 07_sugar_trading.py            &lt;- Trading (market/limit orders)\n\u2502   \u251c\u2500\u2500 08_sugar_positions.py          &lt;- Position management\n\u2502   \u251c\u2500\u2500 09_sugar_history.py            &lt;- History and statistics\n\u2502   \u2514\u2500\u2500 10_sugar_advanced.py           &lt;- Advanced Sugar capabilities\n\u2502\n\u251c\u2500\u2500 4_orchestrators/                   &lt;- Strategy implementations\n\u2502   \u2514\u2500\u2500 (see Orchestrators section above)\n\u2502\n\u251c\u2500\u2500 5_usercode/                        &lt;- User code sandbox\n\u2502   \u2514\u2500\u2500 17_usercode.py                 &lt;- Your custom strategies\n\u2502\n\u2514\u2500\u2500 main.py                            &lt;- Main entry point with menu\n</code></pre> <p>How to run: <pre><code># Low-level examples (MT5Account - FOUNDATION OF EVERYTHING)\npython examples/main.py 1              # General operations\npython examples/main.py lowlevel01     # Same with alias\npython examples/main.py 2              # Trading operations\npython examples/main.py 3              # Streaming methods\n\n# Service examples (MT5Service - wrappers)\npython examples/main.py 4              # Service API demo\npython examples/main.py service        # Same with alias\npython examples/main.py 5              # Service streaming methods\n\n# Sugar examples (MT5Sugar - convenience API)\npython examples/main.py 6              # Sugar basics\npython examples/main.py sugar06        # Same with alias\npython examples/main.py 7              # Sugar trading\npython examples/main.py 8              # Sugar positions\npython examples/main.py 9              # Sugar history\npython examples/main.py 10             # Advanced Sugar\n\n# UserCode (your code)\npython examples/main.py 17             # Custom strategies\npython examples/main.py usercode       # Same with alias\n\n# Interactive menu\npython examples/main.py                # Show menu with all options\n</code></pre></p>"},{"location":"All_Guides/PROJECT_MAP/#mainpy-examples","title":"main.py (examples/)","text":"<p>What: Main entry point that routes commands to corresponding examples/orchestrators.</p> <p>User interaction: \ud83d\udccb Runner + Documentation - launches everything.</p> <pre><code>main.py\n\u251c\u2500\u2500 main()                              &lt;- Entry point, parses arguments\n\u251c\u2500\u2500 execute_command()                   &lt;- Maps aliases to runners\n\u251c\u2500\u2500 main_loop()                         &lt;- Interactive menu loop\n\u2514\u2500\u2500 Documentation in header             &lt;- Full command reference\n</code></pre> <p>How it works:</p> <pre><code>python main.py grid\n    \u2193\nmain(args)  # args[1] = \"grid\"\n    \u2193\nexecute_command(\"grid\")\n    \u2193\nimport and run grid orchestrator\n    \u2193\nGridTrader.main()\n</code></pre> <p>Purpose:</p> <ul> <li>Single entry point for all runnable code</li> <li>Command routing with aliases (grid, trailing, etc.)</li> <li>Interactive menu mode when no arguments provided</li> <li>Helpful error messages for unknown commands</li> <li>Ctrl+C handling for graceful shutdown</li> </ul> <p>Available commands: See header comment in <code>main.py</code> for full list.</p>"},{"location":"All_Guides/PROJECT_MAP/#helpers-examples0_common","title":"Helpers (examples/0_common/)","text":"<p>What: Utilities for examples and orchestrators.</p> <pre><code>examples/0_common/\n\u251c\u2500\u2500 settings.json                 &lt;- MT5 connection configuration\n\u251c\u2500\u2500 demo_helpers.py               &lt;- Connection setup &amp; error handling\n\u251c\u2500\u2500 progress_bar.py               &lt;- Visual progress bars\n\u2514\u2500\u2500 16_protobuf_inspector.py      &lt;- Protobuf structure inspector (runnable)\n</code></pre> <p>demo_helpers.py: <pre><code># Load configuration from settings.json\nsettings = load_settings()\n\n# Create and connect to MT5\naccount = await create_and_connect_mt5(settings)\n\n# Error handling helpers\nprint_if_error(response)\ncheck_retcode(response)\nprint_success(\"Order placed successfully\")\n</code></pre></p> <p>progress_bar.py: <pre><code># Visual countdown during orchestrator operation\nbar = TimeProgressBar(\n    total_seconds=60,\n    message=\"Monitoring positions\"\n)\n# Update progress in a loop\nbar.update(elapsed_seconds)\n# Finish when done\nbar.finish()\n</code></pre></p> <p>settings.json structure: <pre><code>{\n  \"user\": 12345678,\n  \"password\": \"YourPassword\",\n  \"host\": \"mt5.mrpc.pro\",\n  \"port\": 443,\n  \"grpc_server\": \"mt5.mrpc.pro:443\",\n  \"mt_cluster\": \"MetaQuotes-Demo\",\n  \"test_symbol\": \"EURUSD\",\n  \"test_volume\": 0.01\n}\n</code></pre></p> <p>ProtobufInspector: <pre><code># Inspect protobuf structures for debugging\npython examples/main.py 16\npython examples/main.py inspect\n</code></pre></p>"},{"location":"All_Guides/PROJECT_MAP/#documentation-docs","title":"\ud83d\udcdd Documentation (docs/)","text":"<p>What: Complete API and strategy documentation.</p> <p>User interaction: \ud83d\udcd6 Read first! Comprehensive reference.</p> <pre><code>docs/\n\u251c\u2500\u2500 index.md                           &lt;- Home page - project introduction\n\u2502\n\u251c\u2500\u2500 mkdocs.yml                         &lt;- MkDocs configuration\n\u251c\u2500\u2500 styles/custom.css                  &lt;- Custom theme (ocean aurora)\n\u251c\u2500\u2500 javascripts/ux.js                  &lt;- Interactive features\n\u2502\n\u251c\u2500\u2500 All_Guides/                        &lt;- Guides\n\u2502   \u251c\u2500\u2500 MT5_For_Beginners.md           &lt;- \ud83d\udd25 Demo account registration\n\u2502   \u251c\u2500\u2500 GETTING_STARTED.md             &lt;- \ud83d\udd25 Start here! Setup and first steps\n\u2502   \u251c\u2500\u2500 Your_First_Project.md          &lt;- Your first project\n\u2502   \u251c\u2500\u2500 GLOSSARY.md                    &lt;- \ud83d\udd25 Terms and definitions\n\u2502   \u251c\u2500\u2500 GRPC_STREAM_MANAGEMENT.md      &lt;- Managing streaming subscriptions\n\u2502   \u251c\u2500\u2500 RETURN_CODES_REFERENCE.md      &lt;- Proto return code reference\n\u2502   \u251c\u2500\u2500 ENUMS_USAGE_REFERENCE.md       &lt;- Enums and constants guide\n\u2502   \u251c\u2500\u2500 PROTOBUF_INSPECTOR_GUIDE.md    &lt;- Protobuf inspector tool\n\u2502   \u2514\u2500\u2500 USERCODE_SANDBOX_GUIDE.md      &lt;- How to write custom strategies\n\u2502\n\u251c\u2500\u2500 PROJECT_MAP.md                     &lt;- \ud83d\udd25 This file - complete structure\n\u2502\n\u251c\u2500\u2500 API_Reference/                     &lt;- Concise API documentation\n\u2502   \u251c\u2500\u2500 MT5Account.md                  &lt;- \ud83d\udd25 Layer 1 API (foundation) \u2192 from package/MetaRpcMT5/helpers/mt5_account.py\n\u2502   \u251c\u2500\u2500 MT5Service.md                  &lt;- Layer 2 API \u2192 from src/pymt5/mt5_service.py\n\u2502   \u2514\u2500\u2500 MT5Sugar.md                    &lt;- Layer 3 API \u2192 from src/pymt5/mt5_sugar.py\n\u2502\n\u251c\u2500\u2500 MT5Account/                        &lt;- \ud83d\udd25 FOUNDATION - Detailed Layer 1 documentation\n\u2502   \u251c\u2500\u2500 MT5Account.Master.Overview.md  &lt;- \ud83d\udd25 Complete API reference\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 1. Account_Information/        &lt;- Account methods (~4 files)\n\u2502   \u2502   \u251c\u2500\u2500 Account_Information.Overview.md  &lt;- Section overview\n\u2502   \u2502   \u251c\u2500\u2500 account_info_double.md     &lt;- Get account double parameters\n\u2502   \u2502   \u251c\u2500\u2500 account_info_integer.md    &lt;- Get account integer parameters\n\u2502   \u2502   \u251c\u2500\u2500 account_info_string.md     &lt;- Get account string parameters\n\u2502   \u2502   \u251c\u2500\u2500 account_summary.md         &lt;- Complete account summary\n\u2502   \u2502   \u2514\u2500\u2500 \ud83d\udca1 Each example linked with examples/1_lowlevel\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 2. Symbol_Information/         &lt;- Symbol/market data methods (~13 files)\n\u2502   \u2502   \u251c\u2500\u2500 Symbol_Information.Overview.md  &lt;- Section overview\n\u2502   \u2502   \u251c\u2500\u2500 symbol_info_tick.md        &lt;- Current symbol tick\n\u2502   \u2502   \u251c\u2500\u2500 symbol_info_double.md      &lt;- Symbol double parameters\n\u2502   \u2502   \u251c\u2500\u2500 symbols_total.md           &lt;- Total symbols count\n\u2502   \u2502   \u251c\u2500\u2500 symbol_exist.md            &lt;- Check if symbol exists\n\u2502   \u2502   \u251c\u2500\u2500 symbol_is_synchronized.md  &lt;- Check synchronization\n\u2502   \u2502   \u2514\u2500\u2500 ...                        &lt;- And other symbol methods\n\u2502   \u2502   \u2514\u2500\u2500 \ud83d\udca1 Examples in examples/1_lowlevel\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 3. Positions_Orders/           &lt;- Position/order methods (~6 files)\n\u2502   \u2502   \u251c\u2500\u2500 Positions_Orders.Overview.md  &lt;- Section overview\n\u2502   \u2502   \u251c\u2500\u2500 opened_orders.md           &lt;- List of open orders\n\u2502   \u2502   \u251c\u2500\u2500 positions_total.md         &lt;- Total positions count\n\u2502   \u2502   \u251c\u2500\u2500 positions_history.md       &lt;- Position history\n\u2502   \u2502   \u2514\u2500\u2500 ...                        &lt;- And other position methods\n\u2502   \u2502   \u2514\u2500\u2500 \ud83d\udca1 Examples in examples/1_lowlevel\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 4. Market_Depth/               &lt;- Market depth methods (~3 files)\n\u2502   \u2502   \u251c\u2500\u2500 Market_Depth.Overview.md   &lt;- Section overview\n\u2502   \u2502   \u251c\u2500\u2500 market_book_add.md         &lt;- Subscribe to market depth\n\u2502   \u2502   \u251c\u2500\u2500 market_book_get.md         &lt;- Get market depth data\n\u2502   \u2502   \u2514\u2500\u2500 market_book_release.md     &lt;- Unsubscribe from market depth\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 5. Trading_Operations/         &lt;- Trading operation methods (~7 files)\n\u2502   \u2502   \u251c\u2500\u2500 Trading_Operations.Overview.md  &lt;- Section overview\n\u2502   \u2502   \u251c\u2500\u2500 order_send.md              &lt;- Send order (main method)\n\u2502   \u2502   \u251c\u2500\u2500 order_check.md             &lt;- Check order before sending\n\u2502   \u2502   \u251c\u2500\u2500 order_calc_margin.md       &lt;- Calculate margin\n\u2502   \u2502   \u251c\u2500\u2500 order_calc_profit.md       &lt;- Calculate profit\n\u2502   \u2502   \u251c\u2500\u2500 order_close.md             &lt;- Close position\n\u2502   \u2502   \u251c\u2500\u2500 order_modify.md            &lt;- Modify order/position\n\u2502   \u2502   \u2514\u2500\u2500 \ud83d\udca1 Examples in examples/1_lowlevel/02_trading_operations.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 6. Streaming_Methods/          &lt;- Real-time subscription methods (~5 files)\n\u2502   \u2502   \u251c\u2500\u2500 Streaming_Methods.Overview.md  &lt;- Section overview\n\u2502   \u2502   \u251c\u2500\u2500 on_symbol_tick.md          &lt;- Subscribe to symbol ticks\n\u2502   \u2502   \u251c\u2500\u2500 on_trade.md                &lt;- Subscribe to trade events\n\u2502   \u2502   \u251c\u2500\u2500 on_position_profit.md      &lt;- Subscribe to profit changes\n\u2502   \u2502   \u251c\u2500\u2500 on_trade_transaction.md    &lt;- Subscribe to trade transactions\n\u2502   \u2502   \u2514\u2500\u2500 ...                        &lt;- And other streaming methods\n\u2502   \u2502   \u2514\u2500\u2500 \ud83d\udca1 Stream management examples in All_Guides/GRPC_STREAM_MANAGEMENT\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 HOW_IT_WORK/                   &lt;- Detailed algorithm explanations\n\u2502       \u251c\u2500\u2500 1. Account_information_HOW/\n\u2502       \u251c\u2500\u2500 2. Symbol_information_HOW/\n\u2502       \u251c\u2500\u2500 3. Position_Orders_Information_HOW/\n\u2502       \u251c\u2500\u2500 4. Market_Depth(DOM)_HOW/\n\u2502       \u251c\u2500\u2500 5. Trading_Operations_HOW/\n\u2502       \u2514\u2500\u2500 6. Streaming_Methods_HOW/\n\u2502\n\u251c\u2500\u2500 MT5Service/                        &lt;- Service level method documentation\n\u2502   \u251c\u2500\u2500 MT5Service.Overview.md          &lt;- \ud83d\udd25 Complete Service API reference\n\u2502   \u251c\u2500\u2500 1. Account_Information.md      &lt;- Account helper methods\n\u2502   \u251c\u2500\u2500 2. Symbol_Information.md       &lt;- Symbol helper methods\n\u2502   \u251c\u2500\u2500 3. Positions_Orders.md         &lt;- Position/order helper methods\n\u2502   \u251c\u2500\u2500 4. Market_Depth.md             &lt;- Market depth helper methods\n\u2502   \u251c\u2500\u2500 5. Trading_Operations.md       &lt;- Trading helper methods\n\u2502   \u2514\u2500\u2500 6. Streaming_Methods.md        &lt;- Streaming helper methods\n\u2502\n\u2514\u2500\u2500 MT5Sugar/                          &lt;- Sugar level method documentation\n    \u251c\u2500\u2500 MT5Sugar.Master.Overview.md     &lt;- \ud83d\udd25 Complete Sugar API reference\n    \u2502\n    \u251c\u2500\u2500 1. Connection/                  &lt;- Connection methods (~3 files)\n    \u2502   \u251c\u2500\u2500 quick_connect.md            &lt;- Quick connection\n    \u2502   \u251c\u2500\u2500 is_connected.md             &lt;- Check connection\n    \u2502   \u2514\u2500\u2500 ping.md                    &lt;- Connection test\n    \u2502\n    \u251c\u2500\u2500 2. Account_Properties/          &lt;- Account properties (~7 files)\n    \u2502   \u251c\u2500\u2500 get_balance.md              &lt;- Get balance\n    \u2502   \u251c\u2500\u2500 get_equity.md               &lt;- Get equity\n    \u2502   \u251c\u2500\u2500 get_free_margin.md          &lt;- Free margin\n    \u2502   \u2514\u2500\u2500 ...                        &lt;- And other account methods\n    \u2502\n    \u251c\u2500\u2500 3. Prices_Quotes/               &lt;- Prices and quotes (~5 files)\n    \u2502   \u251c\u2500\u2500 get_bid.md                  &lt;- Get Bid\n    \u2502   \u251c\u2500\u2500 get_ask.md                  &lt;- Get Ask\n    \u2502   \u251c\u2500\u2500 get_spread.md               &lt;- Get spread\n    \u2502   \u2514\u2500\u2500 ...                        &lt;- And other price methods\n    \u2502\n    \u251c\u2500\u2500 4. Simple_Trading/              &lt;- Simple trading (~6 files)\n    \u2502   \u251c\u2500\u2500 buy_market.md               &lt;- Buy at market\n    \u2502   \u251c\u2500\u2500 sell_market.md              &lt;- Sell at market\n    \u2502   \u251c\u2500\u2500 buy_limit.md                &lt;- Buy Limit order\n    \u2502   \u2514\u2500\u2500 ...                        &lt;- And other simple orders\n    \u2502\n    \u251c\u2500\u2500 5. Trading_With_SLTP/           &lt;- Trading with SL/TP (~4 files)\n    \u2502   \u251c\u2500\u2500 buy_market_with_sltp.md     &lt;- Buy with SL/TP\n    \u2502   \u251c\u2500\u2500 sell_market_with_sltp.md    &lt;- Sell with SL/TP\n    \u2502   \u2514\u2500\u2500 ...                        &lt;- And other orders with SL/TP\n    \u2502\n    \u251c\u2500\u2500 6. Position_Management/         &lt;- Position management (~6 files)\n    \u2502   \u251c\u2500\u2500 close_position.md           &lt;- Close position\n    \u2502   \u251c\u2500\u2500 close_all_positions.md      &lt;- Close all positions\n    \u2502   \u251c\u2500\u2500 modify_position_sltp.md     &lt;- Modify SL/TP\n    \u2502   \u2514\u2500\u2500 ...                        &lt;- And other management methods\n    \u2502\n    \u251c\u2500\u2500 7. Position_Information/        &lt;- Position information (~7 files)\n    \u2502   \u251c\u2500\u2500 has_open_position.md        &lt;- Has open position\n    \u2502   \u251c\u2500\u2500 count_open_positions.md     &lt;- Count positions\n    \u2502   \u251c\u2500\u2500 get_position_by_ticket.md   &lt;- Get position by ticket\n    \u2502   \u2514\u2500\u2500 ...                        &lt;- And other information methods\n    \u2502\n    \u251c\u2500\u2500 8. History_Statistics/          &lt;- History and statistics (~3 files)\n    \u2502   \u251c\u2500\u2500 get_deals.md                &lt;- Get deals\n    \u2502   \u251c\u2500\u2500 get_profit.md               &lt;- Get profit\n    \u2502   \u251c\u2500\u2500 get_daily_stats.md          &lt;- Daily statistics\n    \u2502   \u2514\u2500\u2500 ...                        &lt;- And other history methods\n    \u2502\n    \u251c\u2500\u2500 9. Symbol_Information/          &lt;- Symbol information (~4 files)\n    \u2502   \u251c\u2500\u2500 get_symbol_info.md          &lt;- Complete symbol information\n    \u2502   \u251c\u2500\u2500 get_all_symbols.md          &lt;- All available symbols\n    \u2502   \u2514\u2500\u2500 ...                        &lt;- And other symbol methods\n    \u2502\n    \u2514\u2500\u2500 10. Risk_Management/            &lt;- Risk management (~4 files)\n        \u251c\u2500\u2500 calculate_position_size.md  &lt;- Calculate position size\n        \u251c\u2500\u2500 can_open_position.md        &lt;- Can open position\n        \u2514\u2500\u2500 ...                        &lt;- And other risk methods\n</code></pre> <p>Structure:</p> <ul> <li>Each method has its own <code>.md</code> file with examples</li> <li>Overview files (<code>*.Overview.md</code>, <code>*.Master.Overview.md</code>) provide navigation</li> <li><code>HOW_IT_WORK/</code> folders explain algorithms step by step</li> <li>Links between related methods</li> <li>Usage examples in each file</li> </ul> <p>\ud83d\udd25 Important about MT5Account:</p> <ul> <li>FOUNDATION OF EVERYTHING - all methods here are the foundation</li> <li>Each documentation example is linked with real code</li> <li>Understanding MT5Account is critical for effective use of MT5Service and MT5Sugar</li> </ul>"},{"location":"All_Guides/PROJECT_MAP/#grpc-proto-python-packages","title":"\ud83d\udd0c gRPC &amp; Proto (Python packages)","text":"<p>What: Protocol Buffer and gRPC libraries for communication with MT5 terminal.</p> <p>User interaction: \ud83d\udccb Reference only - managed via pip.</p> <p>Key dependencies:</p> <ul> <li><code>grpcio</code> - gRPC client</li> <li><code>grpcio-tools</code> - gRPC tools for Python</li> <li><code>protobuf</code> - Protocol Buffers runtime</li> </ul> <p>Package structure:</p> <pre><code>package/\n\u2514\u2500\u2500 MetaRpcMT5/\n    \u251c\u2500\u2500 helpers/\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 mt5_account.py      &lt;- Layer 1 implementation\n    \u2502   \u2514\u2500\u2500 errors.py           &lt;- Error handling utilities\n    \u2502\n    \u251c\u2500\u2500 __init__.py             &lt;- Package initialization\n    \u251c\u2500\u2500 *_pb2.py                &lt;- Generated protobuf code\n    \u251c\u2500\u2500 *_grpc_pb2.py           &lt;- Generated gRPC stubs\n    \u2514\u2500\u2500 mt5_term_api_*.py       &lt;- MT5 API protocol definitions\n</code></pre> <p>How it works:</p> <ol> <li><code>package/</code> is an independent Python package</li> <li>Contains both proto-generated code and MT5Account implementation</li> <li>Can be imported separately as a package</li> <li>MT5Service and MT5Sugar import from package</li> <li>All layers use proto-generated types from package</li> </ol> <p>Proto-generated types:</p> <ul> <li><code>mt5_term_api_*</code> - Trading API types</li> <li>Request/Response message types</li> <li>Enum definitions</li> <li>Service contracts</li> </ul> <p>Purpose:</p> <ul> <li>Define gRPC service contracts</li> <li>Type-safe communication with MT5 terminal</li> <li>Used by MT5Account layer</li> <li>Hidden by MT5Service and MT5Sugar layers</li> </ul>"},{"location":"All_Guides/PROJECT_MAP/#component-interaction-diagram","title":"\ud83d\udcca Component Interaction Diagram","text":"<pre><code>YOUR CODE (User)\n  \u251c\u2500 Orchestrators (strategy implementations)\n  \u2514\u2500 Examples (learning materials)\n                  \u2502\n                  \u2502 uses\n                  \u2193\nMT5Sugar (Layer 3 - Convenience)\n  \ud83d\udccd Location: src/pymt5/mt5_sugar.py\n  \u251c\u2500 Auto-normalization\n  \u251c\u2500 Risk management\n  \u251c\u2500 Points-based methods\n  \u2514\u2500 Batch operations\n                  \u2502\n                  \u2502 uses\n                  \u2193\nMT5Service (Layer 2 - Wrappers)\n  \ud83d\udccd Location: src/pymt5/mt5_service.py\n  \u251c\u2500 Direct data return\n  \u251c\u2500 Type conversion\n  \u2514\u2500 Simplified signatures\n                  \u2502\n                  \u2502 uses\n                  \u2193\nMT5Account (Layer 1 - Low level) \ud83d\udd25 FOUNDATION\n  \ud83d\udccd Location: package/MetaRpcMT5/helpers/mt5_account.py\n  \u251c\u2500 Proto Request/Response\n  \u251c\u2500 gRPC communication\n  \u251c\u2500 Connection management\n  \u251c\u2500 Auto-reconnection\n  \u2514\u2500 Independent Python package (portable)\n                  \u2502\n                  \u2502 gRPC\n                  \u2193\nMT5 Gateway (mt5term) or MT5 Terminal\n  \u2514\u2500 MetaTrader 5 with gRPC server\n</code></pre>"},{"location":"All_Guides/PROJECT_MAP/#file-naming-conventions","title":"\ud83d\udd0d File Naming Conventions","text":""},{"location":"All_Guides/PROJECT_MAP/#core-api-multi-location","title":"Core API (Multi-location)","text":"<p>Layer 1 (Foundation):</p> <ul> <li><code>package/MetaRpcMT5/helpers/mt5_account.py</code> - Low-level gRPC (independent package)</li> <li><code>package/MetaRpcMT5/helpers/errors.py</code> - Error handling utilities</li> </ul> <p>Protobuf (Generated):</p> <ul> <li><code>package/MetaRpcMT5/*_pb2.py</code> - Protobuf message definitions</li> <li><code>package/MetaRpcMT5/*_pb2_grpc.py</code> - gRPC service stubs</li> </ul> <p>Layers 2-3 (High-level wrappers):</p> <ul> <li><code>src/pymt5/mt5_service.py</code> - Wrapper methods</li> <li><code>src/pymt5/mt5_sugar.py</code> - Convenience API</li> </ul> <p>Package configuration:</p> <ul> <li><code>package/pyproject.toml</code> - Package dependencies and metadata</li> </ul>"},{"location":"All_Guides/PROJECT_MAP/#user-code-examples","title":"User Code (examples/)","text":"<ul> <li><code>NN_name.py</code> - Numbered examples and strategies</li> <li><code>main.py</code> - Entry point and command router</li> <li><code>*_helpers.py</code> - Utilities (demo_helpers, progress_bar)</li> <li><code>settings.json</code> - Configuration</li> </ul>"},{"location":"All_Guides/PROJECT_MAP/#documentation-docs_1","title":"Documentation (docs/)","text":"<ul> <li><code>*.Master.Overview.md</code> - Complete category overviews</li> <li><code>*.Overview.md</code> - Section overviews</li> <li><code>MethodName.md</code> - Individual method documentation</li> <li><code>*_HOW.md</code> - Algorithm explanations</li> </ul>"},{"location":"All_Guides/PROJECT_MAP/#what-to-modify-vs-what-to-leave-alone","title":"\ud83d\udcc1 What to Modify vs What to Leave Alone","text":""},{"location":"All_Guides/PROJECT_MAP/#modify-user-code","title":"\u2705 MODIFY (User Code)","text":"<p>Recommended starting point: <pre><code>examples/5_usercode/17_usercode.py  &lt;- \ud83d\udd25 SANDBOX - start writing your code here!\n                                       All 3 API levels already initialized and ready.\n                                       Run: python main.py 17\n</code></pre></p> <p>Other files for modification: <pre><code>examples/4_orchestrators/     &lt;- Copy and customize for your strategies\nexamples/1_lowlevel/          &lt;- Add your low-level examples\nexamples/2_service/           &lt;- Add your service examples\nexamples/3_sugar/             &lt;- Add your sugar examples\nexamples/5_usercode/          &lt;- Create your custom files alongside 17_usercode.py\nexamples/0_common/settings.json  &lt;- Configure for your MT5 terminal/gateway\nexamples/main.py              &lt;- Add new command routing if needed\nREADME.md                     &lt;- Update with your changes\n</code></pre></p>"},{"location":"All_Guides/PROJECT_MAP/#read-core-api","title":"\ud83d\udcd6 READ (Core API)","text":"<pre><code>package/MetaRpcMT5/helpers/mt5_account.py  &lt;- Use but don't modify (import and call) \ud83d\udd25 FOUNDATION\npackage/MetaRpcMT5/helpers/errors.py       &lt;- Use but don't modify\nsrc/pymt5/mt5_service.py        &lt;- Use but don't modify\nsrc/pymt5/mt5_sugar.py          &lt;- Use but don't modify\ndocs/                           &lt;- Reference documentation\n</code></pre>"},{"location":"All_Guides/PROJECT_MAP/#leave-alone-generatedbuild","title":"\ud83d\udd12 LEAVE ALONE (Generated/Build)","text":"<pre><code>.vscode/                       &lt;- VS Code settings\npackage/MetaRpcMT5/*_pb2.py    &lt;- Auto-generated protobuf code\npackage/MetaRpcMT5/*_pb2_grpc.py  &lt;- Auto-generated gRPC stubs\ndocs/site/                     &lt;- Built documentation (auto-generated by MkDocs)\ndocs/styles/                   &lt;- Documentation theme (don't change without understanding)\ndocs/javascripts/              &lt;- Documentation scripts (don't change without understanding)\n__pycache__/                   &lt;- Python bytecode cache (auto-generated)\n*.pyc                          &lt;- Python compiled files (auto-generated)\n</code></pre>"},{"location":"All_Guides/PROJECT_MAP/#project-philosophy","title":"\ud83d\udc64 Project Philosophy","text":"<p>Goal: Make MT5 trading automation accessible through progressive complexity.</p> <p>Three-tier design:</p> <ol> <li>Low level (MT5Account): Full control, proto/gRPC \ud83d\udd25 FOUNDATION OF EVERYTHING</li> <li>Wrappers (MT5Service): Simplified method calls</li> <li>Convenience (MT5Sugar): Auto-everything, batteries included</li> </ol> <p>User code:</p> <ul> <li>Orchestrators: Ready-made strategy templates</li> <li>Examples: Learning materials at all levels</li> </ul>"},{"location":"All_Guides/PROJECT_MAP/#troubleshooting","title":"\ud83d\udee0\ufe0f Troubleshooting","text":""},{"location":"All_Guides/PROJECT_MAP/#installation-issues","title":"Installation Issues","text":"<pre><code># Clean and reinstall\npip uninstall MetaRpcMT5\npip install --upgrade pip\n\n# Install package in development mode\npip install -e package/\n\n# Or install specific dependencies\npip install grpcio grpcio-tools protobuf\n\n# Check Python version\npython --version   # Should be 3.8 or higher\n</code></pre>"},{"location":"All_Guides/PROJECT_MAP/#runtime-issues","title":"Runtime Issues","text":"<pre><code>1. Always test on demo account first\n2. Check return codes (10009 = success, 10031 = connection error)\n3. Monitor console output for errors\n4. Use retry logic for intermittent issues\n5. Verify broker allows your strategy type (hedging, etc.)\n6. Check that MT5 terminal is running and gRPC server is active\n</code></pre>"},{"location":"All_Guides/PROJECT_MAP/#common-errors","title":"Common Errors","text":"<pre><code># Connection error\nError: ConnectExceptionMT5\nFix: Check MT5 terminal is running, verify settings.json\n\n# Import error\nError: ModuleNotFoundError: No module named 'MetaRpcMT5'\nFix: pip install -e package/ (from project root)\n\n# Return code 10004 (invalid request)\nFix: Check order parameters (volume, price, symbol)\n\n# Return code 10031 (connection timeout)\nFix: Check network, verify grpc_server in settings.json\n</code></pre>"},{"location":"All_Guides/PROJECT_MAP/#performance-considerations","title":"\ud83d\udcca Performance Considerations","text":""},{"location":"All_Guides/PROJECT_MAP/#connection-management","title":"Connection Management","text":"<ul> <li>Single gRPC connection shared across operations</li> <li>Built-in auto-reconnection handles temporary failures</li> <li>Retry logic with exponential backoff (1s \u2192 2s \u2192 4s)</li> </ul>"},{"location":"All_Guides/PROJECT_MAP/#rate-limiting","title":"Rate Limiting","text":"<ul> <li>3-second delays between order placements (demo examples)</li> <li>Gateway may enforce additional rate limits</li> <li>Adjust delays based on broker requirements</li> </ul>"},{"location":"All_Guides/PROJECT_MAP/#resource-usage","title":"Resource Usage","text":"<ul> <li>Async/await everywhere for non-blocking I/O</li> <li>Proper cleanup in try/finally blocks</li> <li>Context managers for resource management</li> </ul>"},{"location":"All_Guides/PROJECT_MAP/#best-practices","title":"\ud83d\udccb Best Practices","text":""},{"location":"All_Guides/PROJECT_MAP/#code-organization","title":"Code Organization","text":"<pre><code>\u2705 DO: Separate concerns (analysis, execution, monitoring)\n\u2705 DO: Add comprehensive error handling\n\u2705 DO: Document your strategy logic clearly\n\u2705 DO: Use progress bars for long operations\n\u2705 DO: Use async/await for concurrent operations\n\n\u274c DON'T: Mix strategy logic with API calls\n\u274c DON'T: Use time.sleep without context\n\u274c DON'T: Ignore return codes\n\u274c DON'T: Test on live accounts without extensive demo testing\n</code></pre>"},{"location":"All_Guides/PROJECT_MAP/#strategy-development","title":"Strategy Development","text":"<pre><code>\u2705 DO: Start with existing orchestrator as template\n\u2705 DO: Test each component separately\n\u2705 DO: Log all trading decisions and outcomes\n\u2705 DO: Use demo accounts for development\n\u2705 DO: Implement proper risk management\n\n\u274c DON'T: Over-optimize on limited data\n\u274c DON'T: Ignore edge cases and failures\n\u274c DON'T: Use fixed lots without risk calculation\n\u274c DON'T: Deploy without backtesting and forward testing\n</code></pre>"},{"location":"All_Guides/PROJECT_MAP/#python-specific-best-practices","title":"Python-Specific Best Practices","text":"<pre><code>\u2705 DO: Use type hints for better IDE support\n\u2705 DO: Follow PEP 8 style guidelines\n\u2705 DO: Use dataclasses for data structures\n\u2705 DO: Use f-strings for string formatting\n\u2705 DO: Use pathlib for file paths\n\n\u274c DON'T: Use mutable default arguments\n\u274c DON'T: Catch Exception without re-raising\n\u274c DON'T: Use global variables in strategies\n\u274c DON'T: Forget to close streams and connections\n</code></pre>"},{"location":"All_Guides/PROJECT_MAP/#project-file-tree","title":"\ud83d\udce6 Project File Tree","text":"<pre><code>PyMT5/\n\u2502\n\u251c\u2500\u2500 .github/                           &lt;- GitHub configuration\n\u251c\u2500\u2500 .vscode/                           &lt;- VS Code settings\n\u2502   \u251c\u2500\u2500 launch.json\n\u2502   \u2514\u2500\u2500 settings.json\n\u2502\n\u251c\u2500\u2500 docs/                              &lt;- Documentation (see Documentation section above)\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 mkdocs.yml\n\u2502   \u251c\u2500\u2500 All_Guides/\n\u2502   \u251c\u2500\u2500 API_Reference/\n\u2502   \u251c\u2500\u2500 MT5Account/\n\u2502   \u251c\u2500\u2500 MT5Service/\n\u2502   \u251c\u2500\u2500 MT5Sugar/\n\u2502   \u251c\u2500\u2500 Guide_Images/\n\u2502   \u251c\u2500\u2500 includes/\n\u2502   \u251c\u2500\u2500 javascripts/\n\u2502   \u2514\u2500\u2500 styles/\n\u2502\n\u251c\u2500\u2500 examples/                          &lt;- Examples and user code (see Examples section above)\n\u2502   \u251c\u2500\u2500 0_common/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 settings.json              &lt;- \ud83d\udd25 Connection configuration\n\u2502   \u2502   \u251c\u2500\u2500 demo_helpers.py\n\u2502   \u2502   \u251c\u2500\u2500 progress_bar.py\n\u2502   \u2502   \u2514\u2500\u2500 16_protobuf_inspector.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 1_lowlevel/                    &lt;- \ud83d\udd25 FOUNDATION examples\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 01_general_operations.py\n\u2502   \u2502   \u251c\u2500\u2500 02_trading_operations.py\n\u2502   \u2502   \u2514\u2500\u2500 03_streaming_methods.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 2_service/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 04_service_demo.py\n\u2502   \u2502   \u2514\u2500\u2500 05_service_streaming.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 3_sugar/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 06_sugar_basics.py\n\u2502   \u2502   \u251c\u2500\u2500 07_sugar_trading.py\n\u2502   \u2502   \u251c\u2500\u2500 08_sugar_positions.py\n\u2502   \u2502   \u251c\u2500\u2500 09_sugar_history.py\n\u2502   \u2502   \u2514\u2500\u2500 10_sugar_advanced.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 4_orchestrators/\n\u2502   \u2502   \u251c\u2500\u2500 11_trailing_stop.py\n\u2502   \u2502   \u251c\u2500\u2500 12_position_scaler.py\n\u2502   \u2502   \u251c\u2500\u2500 13_grid_trader.py\n\u2502   \u2502   \u251c\u2500\u2500 14_risk_manager.py\n\u2502   \u2502   \u2514\u2500\u2500 15_portfolio_rebalancer.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 5_usercode/\n\u2502   \u2502   \u2514\u2500\u2500 17_usercode.py             &lt;- \ud83d\udd25 START HERE for your code\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 main.py                        &lt;- \ud83d\udd25 Main entry point\n\u2502\n\u251c\u2500\u2500 package/                           &lt;- Core package (portable)\n\u2502   \u2514\u2500\u2500 MetaRpcMT5/                    &lt;- Package root\n\u2502       \u251c\u2500\u2500 helpers/\n\u2502       \u2502   \u251c\u2500\u2500 __init__.py\n\u2502       \u2502   \u251c\u2500\u2500 mt5_account.py         &lt;- \ud83d\udd25 FOUNDATION - Layer 1\n\u2502       \u2502   \u2514\u2500\u2500 errors.py              &lt;- Error handling\n\u2502       \u2502\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 *_pb2.py                   &lt;- Generated protobuf code (11 files)\n\u2502       \u2514\u2500\u2500 *_pb2_grpc.py              &lt;- Generated gRPC stubs (11 files)\n\u2502                 \n\u2502\n\u251c\u2500\u2500 src/                               &lt;- High-level API layers\n\u2502   \u2514\u2500\u2500 pymt5/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 mt5_service.py             &lt;- Layer 2 - Wrappers\n\u2502       \u2514\u2500\u2500 mt5_sugar.py               &lt;- Layer 3 - Convenience\n\u2502\n\u251c\u2500\u2500 .gitignore                         &lt;- Git ignore patterns\n\u251c\u2500\u2500 mkdocs.yml                         &lt;- MkDocs configuration\n\u2514\u2500\u2500 README.md                          &lt;- Project readme\n</code></pre> <p>\ud83d\udca1 Remember: This is an educational project. All orchestrators are demonstration examples, not production-ready trading systems. Always test on demo accounts, thoroughly understand the code, and implement proper risk management before considering live trading.</p> <p>\"Trade safely, code cleanly, and may your gRPC connections always be stable.\"</p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/","title":"Protobuf Inspector - Interactive Type Explorer","text":"<p>Interactive developer utility for exploring MT5 protobuf types, fields, enums, and data structures from the MT5 gRPC API</p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#what-this-tool-does","title":"\ud83c\udfdb\ufe0f What This Tool Does","text":"<p>The Protobuf Inspector is an interactive command-line tool that helps you explore the structure of the MT5 gRPC API:</p> <ul> <li>Interactive search for types, fields, and enums</li> <li>Real-time inspection of protobuf message structures</li> <li>Field-level discovery - find which types contain specific fields</li> <li>Field type discovery - find fields by their data type (double, string, enum, etc.)</li> <li>Enum value exploration - see all possible enum values</li> <li>Enum usage tracking - find where specific enums are used</li> <li>Type browsing with filters - list types by category</li> <li>JSON export - export type structures for documentation</li> <li>Statistics analysis - field types, enum counts, comprehensive metrics</li> </ul>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#getting-started","title":"\ud83c\udfc1 Getting Started","text":""},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#running-the-inspector","title":"Running the Inspector","text":"<pre><code>cd examples\npython main.py inspect\n</code></pre> <p>You will see an interactive prompt:</p> <pre><code>===========================================================\nMT5 PROTOBUF TYPES INSPECTOR\n===========================================================\n\n  Discovered 163 protobuf message types\n  Discovered 60 enum types\n\n  Type 'help' to see available commands\n  Type 'list' to see all types\n===========================================================\n\n&gt;\n</code></pre>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#available-commands","title":"\ud83e\uddf0 Available Commands","text":"Command Description Example <code>list</code> or <code>ls</code> Show all available protobuf types <code>list</code> <code>list --request</code> Show only Request types <code>list --request</code> <code>list --reply</code> Show only Reply types <code>list --reply</code> <code>list --data</code> Show only Data types <code>list --data</code> <code>list --info</code> Show only Info types <code>list --info</code> <code>&lt;TypeName&gt;</code> Inspect specific type structure <code>PositionInfo</code> <code>search &lt;text&gt;</code> or <code>find &lt;text&gt;</code> Search for types containing text <code>search Order</code> <code>field &lt;name&gt;</code> Find all types with a specific field <code>field ticket</code> <code>findtype &lt;type&gt;</code> Find all fields of a specific type <code>findtype double</code> <code>enum &lt;name&gt;</code> Show all enum values <code>enum ENUM_ORDER_TYPE_TF</code> <code>whereenum &lt;name&gt;</code> Find where enum is used <code>whereenum ENUM_ORDER_TYPE_TF</code> <code>export &lt;TypeName&gt;</code> Export type structure to JSON <code>export PositionInfo</code> <code>stats</code> Show detailed statistics <code>stats</code> <code>help</code> or <code>?</code> Show help message <code>help</code> <code>exit</code> or <code>quit</code> Exit the inspector <code>exit</code>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#practical-examples","title":"Practical Examples","text":""},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#example-1-find-out-what-fields-positioninfo-has","title":"Example 1: Find out what fields PositionInfo has","text":"<p>Command: <pre><code>&gt; PositionInfo\n</code></pre></p> <p>Output: <pre><code>===========================================================\nTYPE: PositionInfo\n===========================================================\nFIELDS (20):\n-----------------------------------------------------------\n  #  1 index                         : uint32\n  #  2 ticket                        : uint64\n  #  3 open_time                     : Timestamp\n  #  4 volume                        : double\n  #  5 price_open                    : double\n  #  6 stop_loss                     : double\n  #  7 take_profit                   : double\n  #  8 price_current                 : double\n  #  9 swap                          : double\n  # 10 profit                        : double\n  # 11 last_update_time              : Timestamp\n  # 12 type                          : ENUM_ORDER_TYPE_TF\n  # 13 magic_number                  : int64\n  # 14 identifier                    : int64\n  # 15 reason                        : ENUM_POSITION_REASON_TYPE\n  # 16 symbol                        : string\n  # 17 comment                       : string\n  # 18 external_id                   : string\n  # 19 position_commission           : double\n  # 20 account_login                 : int64\n</code></pre></p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#example-2-find-which-types-have-the-ticket-field","title":"Example 2: Find which types have the \"ticket\" field","text":"<p>Command: <pre><code>&gt; field ticket\n</code></pre></p> <p>Output: <pre><code>EXACT MATCH: field 'ticket' found in:\n-----------------------------------------------------------\n    1. DealInfo\n    2. HistoryDealsGetByTicketRequest\n    3. HistoryOrdersGetByTicketRequest\n    4. OrderCloseRequest\n    5. OrderInfo\n    6. OrderModifyRequest\n    7. PositionCloseRequest\n    8. PositionInfo\n    9. PositionModifyRequest\n   10. TradeTransactionInfo\n</code></pre></p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#example-3-see-all-order_type-enum-values","title":"Example 3: See all ORDER_TYPE enum values","text":"<p>Command: <pre><code>&gt; enum ENUM_ORDER_TYPE_TF\n</code></pre></p> <p>Output: <pre><code>ENUM: ENUM_ORDER_TYPE_TF\n===========================================================\n  ORDER_TYPE_TF_BUY                        = 0\n  ORDER_TYPE_TF_SELL                       = 1\n  ORDER_TYPE_TF_BUY_LIMIT                  = 2\n  ORDER_TYPE_TF_SELL_LIMIT                 = 3\n  ORDER_TYPE_TF_BUY_STOP                   = 4\n  ORDER_TYPE_TF_SELL_STOP                  = 5\n  ORDER_TYPE_TF_BUY_STOP_LIMIT             = 6\n  ORDER_TYPE_TF_SELL_STOP_LIMIT            = 7\n  ORDER_TYPE_TF_CLOSE_BY                   = 8\n</code></pre></p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#example-3a-see-streaming-event-order_type-enum-new","title":"Example 3a: See streaming event ORDER_TYPE enum (NEW)","text":"<p>Command: <pre><code>&gt; enum SUB_ENUM_ORDER_TYPE\n</code></pre></p> <p>Output: <pre><code>ENUM: SUB_ENUM_ORDER_TYPE\n===========================================================\n  SUB_ORDER_TYPE_BUY                       = 0\n  SUB_ORDER_TYPE_SELL                      = 1\n  SUB_ORDER_TYPE_BUY_LIMIT                 = 2\n  SUB_ORDER_TYPE_SELL_LIMIT                = 3\n  SUB_ORDER_TYPE_BUY_STOP                  = 4\n  SUB_ORDER_TYPE_SELL_STOP                 = 5\n  SUB_ORDER_TYPE_BUY_STOP_LIMIT            = 6\n  SUB_ORDER_TYPE_SELL_STOP_LIMIT           = 7\n  SUB_ORDER_TYPE_CLOSE_BY                  = 8\n</code></pre></p> <p>Note: Use <code>SUB_ENUM_*</code> enums for streaming events (on_trade, on_trade_transaction, etc.), and <code>ENUM_*_TF</code> enums for trading functions (order_send, order_modify, etc.).</p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#example-4-find-all-types-related-to-position","title":"Example 4: Find all types related to \"Position\"","text":"<p>Command: <pre><code>&gt; search Position\n</code></pre></p> <p>Output: <pre><code>FOUND 12 TYPES MATCHING 'Position':\n-----------------------------------------------------------\n    1. ClosedPositionsGetRequest\n    2. ClosedPositionsGetRequestReply\n    3. ENUM_POSITION_REASON_TYPE\n    4. OpenedPositionsGetRequest\n    5. OpenedPositionsGetRequestReply\n    6. PositionCloseRequest\n    7. PositionCloseRequestReply\n    8. PositionInfo\n    9. PositionModifyRequest\n   10. PositionModifyRequestReply\n   11. PositionProfitCallbackInfo\n   12. PositionsTicketsCallbackInfo\n</code></pre></p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#example-5-show-all-available-types","title":"Example 5: Show all available types","text":"<p>Command: <pre><code>&gt; list\n</code></pre></p> <p>Output: <pre><code>AVAILABLE PROTOBUF TYPES (163)\n-----------------------------------------------------------\n\n[Request] (47 types):\n    1. AccountInfoDoubleGetRequest\n    2. AccountInfoIntegerGetRequest\n    3. AccountInfoStringGetRequest\n    ...\n\n[Reply] (44 types):\n    1. AccountInfoDoubleGetRequestReply\n    2. AccountInfoIntegerGetRequestReply\n    ...\n\n[Data] (47 types):\n    1. AccountSummaryData\n    2. MarketBookData\n    3. OnSymbolTickData\n    4. OnTradeData\n    5. OnTradeTransactionData\n    ...\n\n[Info] (10 types):\n    1. DealInfo\n    2. OnEventAccountInfo\n    3. OnTradeHistoryDealInfo\n    4. OnTradeOrderInfo\n    5. OnTradePositionInfo\n    ...\n\n[Other] (15 types):\n    ...\n</code></pre></p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#example-6-find-all-double-fields-new","title":"Example 6: Find all double fields (NEW)","text":"<p>Command: <pre><code>&gt; findtype double\n</code></pre></p> <p>Output: <pre><code>FIELDS OF TYPE 'double' (120+ fields):\n===========================================================\n\n  AccountInfoDoubleGetRequestReply:\n    - value\n\n  AccountSummaryData:\n    - account_balance\n    - account_equity\n    - account_margin\n    - account_freemargin\n    - account_profit\n\n  DealInfo:\n    - commission\n    - fee\n    - price\n    - profit\n    - swap\n    - volume\n\n  PositionInfo:\n    - position_commission\n    - price_current\n    - price_open\n    - profit\n    - stop_loss\n    - swap\n    - take_profit\n    - volume\n\n  SymbolInfo:\n    - ask\n    - bid\n    - point\n    - swap_long\n    - swap_short\n    - volume_max\n    - volume_min\n    - volume_step\n\n  ... (and more)\n</code></pre></p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#example-7-find-where-enum-is-used-new","title":"Example 7: Find where enum is used (NEW)","text":"<p>Command: <pre><code>&gt; whereenum ENUM_ORDER_TYPE_TF\n</code></pre></p> <p>Output: <pre><code>ENUM 'ENUM_ORDER_TYPE_TF' USED IN (8 fields):\n===========================================================\n\n  DealInfo:\n    - type\n\n  MqlTradeRequest:\n    - type\n\n  OrderInfo:\n    - type\n\n  OrderSendRequest:\n    - operation\n\n  PositionInfo:\n    - type\n\n  TradeTransactionInfo:\n    - order_type\n    - type\n\n  ... (and more)\n</code></pre></p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#example-8-export-type-to-json-new","title":"Example 8: Export type to JSON (NEW)","text":"<p>Command: <pre><code>&gt; export PositionInfo\n</code></pre></p> <p>Output: <pre><code>TYPE: PositionInfo (JSON export)\n===========================================================\n{\n  \"type_name\": \"PositionInfo\",\n  \"full_name\": \"mt5.PositionInfo\",\n  \"fields\": [\n    {\n      \"number\": 1,\n      \"name\": \"index\",\n      \"type\": \"uint32\",\n      \"label\": \"optional\"\n    },\n    {\n      \"number\": 2,\n      \"name\": \"ticket\",\n      \"type\": \"uint64\",\n      \"label\": \"optional\"\n    },\n    {\n      \"number\": 12,\n      \"name\": \"type\",\n      \"type\": \"ENUM_ORDER_TYPE_TF\",\n      \"label\": \"optional\",\n      \"enum_name\": \"ENUM_ORDER_TYPE_TF\",\n      \"enum_values\": {\n        \"ORDER_TYPE_TF_BUY\": 0,\n        \"ORDER_TYPE_TF_SELL\": 1,\n        \"ORDER_TYPE_TF_BUY_LIMIT\": 2,\n        \"ORDER_TYPE_TF_SELL_LIMIT\": 3,\n        ...\n      }\n    },\n    ...\n  ]\n}\n</code></pre></p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#example-9-show-statistics-new","title":"Example 9: Show statistics (NEW)","text":"<p>Command: <pre><code>&gt; stats\n</code></pre></p> <p>Output: <pre><code>PROTOBUF INSPECTOR STATISTICS\n===========================================================\n\nMessage Types: 163 total\n-----------------------------------------------------------\n  Request         :  47 types\n  Reply           :  44 types\n  Data            :  47 types\n  Info            :  10 types\n  Other           :  15 types\n\nEnum Types: 60 total\n-----------------------------------------------------------\n  Total enum values  : 644\n\n  Top 5 largest enums:\n    BMT5_ENUM_SYMBOL_INDUSTRY                : 152 values\n    SymbolInfoDoubleProperty                 :  60 values\n    SymbolInfoIntegerProperty                :  37 values\n    EnumOpenTerminalChartWithEaChatPeriod    :  22 values\n    BMT5_ENUM_DEAL_TYPE                      :  18 values\n\nField Types: 147 distinct types\n-----------------------------------------------------------\n  Top 10 most common field types:\n    double               : 209 fields\n    string               : 112 fields\n    int64                :  54 fields\n    error                :  45 fields\n    int32                :  44 fields\n    uint64               :  40 fields\n    timestamp            :  38 fields\n    bool                 :  28 fields\n    uint32               :  16 fields\n    sub_enum_order_type  :   4 fields\n\nTotal Fields: 771\n===========================================================\n</code></pre></p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#example-10-list-only-request-types-new","title":"Example 10: List only Request types (NEW)","text":"<p>Command: <pre><code>&gt; list --request\n</code></pre></p> <p>Output: <pre><code>REQUEST TYPES\n-----------------------------------------------------------\n\n[Request] (47 types):\n    1. AccountInfoDoubleGetRequest\n    2. AccountInfoIntegerGetRequest\n    3. AccountInfoStringGetRequest\n    4. AccountSummaryRequest\n    5. HistoryDealsGetByTicketRequest\n    6. HistoryDealsGetRequest\n    7. HistoryOrdersGetByTicketRequest\n    8. HistoryOrdersGetRequest\n    9. MarketBookGetRequest\n   10. OpenedOrdersGetRequest\n   11. OpenedPositionsGetRequest\n   12. OrderCalcMarginRequest\n   13. OrderCheckRequest\n   14. OrderCloseRequest\n   15. OrderModifyRequest\n   16. OrderSendRequest\n   17. PositionCloseRequest\n   18. PositionModifyRequest\n   19. SymbolExistRequest\n   20. SymbolInfoDoubleGetRequest\n   21. SymbolInfoIntegerGetRequest\n   22. SymbolInfoMarginRateGetRequest\n   23. SymbolInfoSessionQuoteGetRequest\n   24. SymbolInfoSessionTradeGetRequest\n   25. SymbolInfoStringGetRequest\n   26. SymbolInfoTickGetRequest\n   27. SymbolIsSynchronizedRequest\n   28. SymbolNameRequest\n   29. SymbolSelectRequest\n   30. SymbolsTotalRequest\n    ... (and more)\n</code></pre></p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#common-use-cases","title":"\ud83d\udce6 Common Use Cases","text":""},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#use-case-1-getting-field-not-found-error","title":"USE CASE 1: \"Getting 'field not found' error\"","text":"<p>Problem: Your code has <code>position.ballance</code> but it doesn't work</p> <p>Solution: <pre><code>&gt; field balance\n</code></pre></p> <p>Result: Shows the correct field name and which type has it <pre><code>EXACT MATCH: field 'balance' found in:\n  \" AccountSummaryData\n  \" AccountInfo\n</code></pre></p> <p>Fix: Use <code>account.balance</code>, not <code>position.balance</code></p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#use-case-2-what-fields-does-x-have","title":"USE CASE 2: \"What fields does X have?\"","text":"<p>Problem: Don't know what data is in <code>PositionInfo</code></p> <p>Solution: <pre><code>&gt; PositionInfo\n</code></pre></p> <p>Result: Shows all 20 fields (ticket, type, symbol, profit, etc.)</p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#use-case-3-what-are-valid-enum-values","title":"USE CASE 3: \"What are valid enum values?\"","text":"<p>Problem: Don't know what value to use for <code>order_type</code></p> <p>Solution: <pre><code>&gt; enum ENUM_ORDER_TYPE_TF\n</code></pre></p> <p>Result: Shows all values: <pre><code>ORDER_TYPE_TF_BUY = 0\nORDER_TYPE_TF_SELL = 1\nORDER_TYPE_TF_BUY_LIMIT = 2\nORDER_TYPE_TF_SELL_LIMIT = 3\n...\n</code></pre></p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#use-case-4-need-to-find-position-related-types","title":"USE CASE 4: \"Need to find position-related types\"","text":"<p>Problem: Exploring the API, need to see all position-related structures</p> <p>Solution: <pre><code>&gt; search Position\n</code></pre></p> <p>Result: Shows all 12 types with \"Position\" in the name</p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#use-case-5-want-to-browse-whats-available","title":"USE CASE 5: \"Want to browse what's available\"","text":"<p>Problem: New to the API, want to explore</p> <p>Solution: <pre><code>&gt; list\n</code></pre></p> <p>Result: Shows all available types, grouped by category</p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#use-case-6-need-all-price-fields-new","title":"USE CASE 6: \"Need all price fields\" (NEW)","text":"<p>Problem: Want to find all price-related fields in the API</p> <p>Solution: <pre><code>&gt; findtype double\n</code></pre></p> <p>Result: Shows all double fields (prices, volumes, profits, etc.) grouped by type</p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#use-case-7-where-is-this-enum-used-new","title":"USE CASE 7: \"Where is this enum used?\" (NEW)","text":"<p>Problem: Have an enum, need to know which types use it</p> <p>Solution: <pre><code>&gt; whereenum ENUM_ORDER_TYPE_TF\n</code></pre></p> <p>Result: Shows all types and fields that use this enum</p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#use-case-8-generate-documentation-new","title":"USE CASE 8: \"Generate documentation\" (NEW)","text":"<p>Problem: Need to document type structure for team or external tools</p> <p>Solution: <pre><code>&gt; export PositionInfo\n</code></pre></p> <p>Result: Gets complete JSON structure with field numbers, types, and enum values</p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#i-statistics","title":"\u2139\ufe0f Statistics","text":"<p>When you run the inspector, it provides complete coverage of:</p> <ul> <li>Total Message Types: 163 (all MT5 gRPC protobuf message types)</li> <li>Total Enums: 60 (with 644 enum values)</li> <li>Total Fields: 771 (across all types)</li> <li>Field Types: 147 distinct protobuf types</li> <li>Coverage: 100% of MT5 gRPC API</li> </ul>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#important-enums-frequently-used","title":"Important Enums (Frequently Used)","text":"Enum Name Description Common Values <code>ENUM_ORDER_TYPE_TF</code> Order types (trade functions) BUY, SELL, BUY_LIMIT, SELL_LIMIT, BUY_STOP, SELL_STOP (9 values) <code>SUB_ENUM_ORDER_TYPE</code> Order types (streaming events) SUB_ORDER_TYPE_BUY, SUB_ORDER_TYPE_SELL, etc. (9 values) <code>SUB_ENUM_POSITION_TYPE</code> Position types (streaming) SUB_POSITION_TYPE_BUY, SUB_POSITION_TYPE_SELL (2 values) <code>SUB_ENUM_DEAL_TYPE</code> Deal types (streaming) SUB_DEAL_TYPE_BUY, SUB_DEAL_TYPE_SELL, etc. (18 values) <code>SUB_ENUM_ORDER_STATE</code> Order states (streaming) STARTED, PLACED, CANCELED, FILLED, REJECTED (10 values) <code>MRPC_ENUM_ORDER_TYPE_FILLING</code> Fill policies FOK, IOC, Return, BOC (4 values) <code>MRPC_ENUM_ORDER_TYPE_TIME</code> Time in force GTC, Day, Specified, Specified_Day (4 values) <code>BMT5_ENUM_DEAL_REASON</code> Deal execution reason Client, Expert, SL, TP, Mobile (11 values) <code>BMT5_ENUM_DEAL_ENTRY_TYPE</code> Deal entry type In, Out, InOut, Out_By (4 values) <code>BMT5_ENUM_POSITION_REASON</code> Why position opened Client, Expert, Dealer, Mobile (7 values) <code>SymbolInfoDoubleProperty</code> Symbol price properties BID, ASK, POINT, SWAP_LONG, SWAP_SHORT (60 values) <code>SymbolInfoIntegerProperty</code> Symbol integer properties DIGITS, SPREAD, TRADE_MODE, etc. (37 values) <code>AccountInfoDoublePropertyType</code> Account double properties BALANCE, EQUITY, MARGIN, etc. (14 values) <p>Note: Enum names with prefixes (<code>MRPC_</code>, <code>BMT5_</code>, <code>SUB_</code>) indicate their usage context:</p> <ul> <li><code>MRPC_*</code> - MetaRpc protocol enums (trading operations)</li> <li><code>BMT5_*</code> - Base MT5 enums (historical data, reasons)</li> <li><code>SUB_*</code> - Subscription/streaming enums (real-time events)</li> </ul>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#features","title":"Features","text":"Feature Description Case-insensitive search <code>search Order</code> = <code>search order</code> Partial field matching <code>field profit</code> finds both <code>profit</code> and <code>take_profit</code> Type categorization Shows <code>[Request]</code>, <code>[Reply]</code>, <code>[Data]</code>, <code>[Info]</code> tags Category filtering <code>list --request</code>, <code>list --reply</code>, etc. Field type search <code>findtype double</code> finds all double fields Enum usage tracking <code>whereenum &lt;name&gt;</code> shows where enum is used JSON export <code>export &lt;TypeName&gt;</code> outputs structured JSON Detailed statistics <code>stats</code> shows comprehensive metrics Array indicators <code>[]</code> suffix for repeated/array fields Protobuf field numbers Shows field <code>#N</code> for each field Smart error messages Suggests alternatives when type not found"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#example-interactive-session","title":"Example Interactive Session","text":"<pre><code>$ cd examples\n$ python main.py inspect\n\n===========================================================\nMT5 PROTOBUF TYPES INSPECTOR\n===========================================================\n\n&gt; search Order\nFOUND 28 TYPES MATCHING 'Order':\n-----------------------------------------------------------\n    1. HistoryOrdersGetByTicketRequest\n    2. HistoryOrdersGetRequest\n    3. OpenedOrdersGetRequest\n    4. OrderCalcMarginRequest\n    5. OrderCheckRequest\n    6. OrderCloseRequest\n    7. OrderInfo\n    8. OrderModifyRequest\n    9. OrderSendRequest\n   ...\n\n&gt; OrderInfo\n===========================================================\nTYPE: OrderInfo\n===========================================================\nFIELDS (25):\n-----------------------------------------------------------\n  #  1 ticket                        : uint64\n  #  2 type                          : ENUM_ORDER_TYPE_TF\n  #  3 state                         : ENUM_ORDER_STATE_TYPE\n  #  4 type_filling                  : ENUM_ORDER_TYPE_FILLING\n  #  5 type_time                     : ENUM_ORDER_TYPE_TIME\n  #  6 magic_number                  : int64\n  #  7 position_id                   : int64\n  #  8 position_by_id                : int64\n  #  9 reason                        : ENUM_ORDER_REASON_TYPE\n  # 10 volume_initial                : double\n  # 11 volume_current                : double\n  # 12 price_open                    : double\n  # 13 stop_loss                     : double\n  # 14 take_profit                   : double\n  # 15 price_current                 : double\n  # 16 price_stoplimit               : double\n  # 17 symbol                        : string\n  # 18 comment                       : string\n  # 19 external_id                   : string\n  # 20 setup_time                    : Timestamp\n  # 21 expiration_time               : Timestamp\n  # 22 time_done                     : Timestamp\n  # 23 account_login                 : int64\n  # 24 index                         : uint32\n  # 25 last_update_time              : Timestamp\n\n&gt; field magic\nEXACT MATCH: field 'magic' found in:\n-----------------------------------------------------------\n    1. OrderInfo (magic_number)\n    2. PositionInfo (magic_number)\n    3. DealInfo (magic_number)\n    4. MqlTradeRequest (magic)\n    ...\n\nPARTIAL MATCHES (field contains 'magic'):\n-----------------------------------------------------------\n    1. OrderInfo (magic_number)\n    2. PositionInfo (magic_number)\n    3. DealInfo (magic_number)\n    ...\n\n&gt; enum ENUM_ORDER_STATE_TYPE\n===========================================================\nENUM: ENUM_ORDER_STATE_TYPE\n===========================================================\n  ORDER_STATE_TYPE_STARTED                 = 0\n  ORDER_STATE_TYPE_PLACED                  = 1\n  ORDER_STATE_TYPE_CANCELED                = 2\n  ORDER_STATE_TYPE_PARTIAL                 = 3\n  ORDER_STATE_TYPE_FILLED                  = 4\n  ORDER_STATE_TYPE_REJECTED                = 5\n  ORDER_STATE_TYPE_EXPIRED                 = 6\n  ORDER_STATE_TYPE_REQUEST_ADD             = 7\n  ORDER_STATE_TYPE_REQUEST_MODIFY          = 8\n  ORDER_STATE_TYPE_REQUEST_CANCEL          = 9\n\n&gt; findtype double\nFIELDS OF TYPE 'double' (120+ fields):\n===========================================================\n\n  AccountSummaryData:\n    - account_balance\n    - account_equity\n    - account_freemargin\n    - account_margin\n    - account_profit\n\n  DealInfo:\n    - commission\n    - fee\n    - price\n    - profit\n    - swap\n    - volume\n\n  OrderInfo:\n    - price_current\n    - price_open\n    - price_stoplimit\n    - stop_loss\n    - take_profit\n    - volume_current\n    - volume_initial\n\n  PositionInfo:\n    - position_commission\n    - price_current\n    - price_open\n    - profit\n    - stop_loss\n    - swap\n    - take_profit\n    - volume\n\n  SymbolInfo:\n    - ask\n    - bid\n    - point\n    - swap_long\n    - swap_short\n    - volume_max\n    - volume_min\n    - volume_step\n\n  ... (and more)\n\n&gt; whereenum ENUM_ORDER_TYPE_TF\nENUM 'ENUM_ORDER_TYPE_TF' USED IN (8 fields):\n===========================================================\n\n  DealInfo:\n    - type\n\n  MqlTradeRequest:\n    - type\n\n  OrderInfo:\n    - type\n\n  OrderSendRequest:\n    - operation\n\n  PositionInfo:\n    - type\n\n  TradeTransactionInfo:\n    - order_type\n    - type\n\n&gt; stats\nPROTOBUF INSPECTOR STATISTICS\n===========================================================\n\nMessage Types: 163 total\n-----------------------------------------------------------\n  Request         :  47 types\n  Reply           :  44 types\n  Data            :  47 types\n  Info            :  10 types\n  Other           :  15 types\n\nEnum Types: 60 total\n-----------------------------------------------------------\n  Total enum values  : 644\n\n  Top 5 largest enums:\n    BMT5_ENUM_SYMBOL_INDUSTRY                : 152 values\n    SymbolInfoDoubleProperty                 :  60 values\n    SymbolInfoIntegerProperty                :  37 values\n    EnumOpenTerminalChartWithEaChatPeriod    :  22 values\n    BMT5_ENUM_DEAL_TYPE                      :  18 values\n\nField Types: 147 distinct types\n-----------------------------------------------------------\n  Top 10 most common field types:\n    double               : 209 fields\n    string               : 112 fields\n    int64                :  54 fields\n    error                :  45 fields\n    int32                :  44 fields\n    uint64               :  40 fields\n    timestamp            :  38 fields\n    bool                 :  28 fields\n    uint32               :  16 fields\n    sub_enum_order_type  :   4 fields\n\nTotal Fields: 771\n===========================================================\n\n&gt; exit\n\n[+] Goodbye!\n</code></pre>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#implementation-details","title":"Implementation Details","text":"<p>The Protobuf Inspector uses Python reflection to:</p> <ol> <li>Register all protobuf types at startup</li> <li>Build in-memory indexes for:</li> <li>Field names \u201a\u00ac\u201e\u00a2 Types mapping</li> <li>Field types \u201a\u00ac\u201e\u00a2 Fields mapping</li> <li>Enum names \u201a\u00ac\u201e\u00a2 Usage mapping</li> <li>Provide instant search and lookup</li> <li>Format output with structure and clarity</li> <li>Export to JSON with complete metadata</li> </ol> <p>Source file: <code>examples/0_common/16_protobuf_inspector.py</code></p> <p>Modules scanned:</p> <ul> <li><code>mt5_term_api_account_helper_pb2</code></li> <li><code>mt5_term_api_account_information_pb2</code></li> <li><code>mt5_term_api_market_info_pb2</code></li> <li><code>mt5_term_api_trade_functions_pb2</code></li> <li><code>mt5_term_api_trading_helper_pb2</code></li> <li><code>mt5_term_api_subscriptions_pb2</code> (streaming events, SUB_ENUM_* enums)</li> <li><code>mt5_term_api_charts_pb2</code> (chart operations)</li> <li><code>mt5_term_api_connection_pb2</code> (connection management)</li> </ul>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#technical-notes","title":"Technical Notes","text":"<ul> <li>No MT5 connection required - This is a purely offline tool that inspects type definitions</li> <li>Complete coverage - All 163 types and 60 enums from the MT5 gRPC API</li> <li>Instant search - In-memory indexes for fast lookup</li> <li>Development only - Not intended for production use</li> <li>Python reflection - Uses protobuf DESCRIPTOR API for introspection</li> <li>JSON export - Compatible with external documentation tools</li> </ul>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#when-to-use-this-tool","title":"When to Use This Tool","text":"<p>Use the inspector when:</p> <ul> <li>Learning the MT5 gRPC API structure</li> <li>Debugging \"field not found\" errors</li> <li>Exploring available protobuf types</li> <li>Looking up enum values</li> <li>Finding the correct request/response types for API calls</li> <li>Understanding message structures before writing code</li> <li>Identifying all fields of a specific type (e.g., all double fields)</li> <li>Tracking enum usage across the API</li> <li>Generating documentation for types</li> <li>Analyzing API statistics</li> </ul> <p>Don't use for:</p> <ul> <li>Inspecting runtime data (use debugger instead)</li> <li>Production code (this is a development tool)</li> <li>Testing API connectivity (use demo connections instead)</li> </ul>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#tips-and-tricks","title":"Tips and Tricks","text":"<ol> <li>Start with search - If you know the general area, use <code>search &lt;keyword&gt;</code> first</li> <li>Use field search - When you see a field name but don't know which type, use <code>field &lt;name&gt;</code></li> <li>Explore enums early - Understanding enum values saves debugging time later</li> <li>List is your friend - When stuck, use <code>list</code> to browse available types</li> <li>Case doesn't matter - Type commands in lowercase, it's faster</li> <li>Use filters - <code>list --request</code> shows only what you need</li> <li>Find by type - <code>findtype double</code> to see all price/volume fields</li> <li>Track enum usage - <code>whereenum</code> shows relationships between types</li> <li>Export for docs - Use <code>export</code> to generate JSON for team documentation</li> <li>Check stats - Use <code>stats</code> to understand API structure overview</li> </ol>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#quick-start-workflow","title":"Quick Start Workflow","text":"<p>Beginner workflow for exploring the API:</p> <pre><code># 1. Start the inspector\ncd examples\npython main.py inspect\n\n# 2. Browse what's available\n&gt; list\n\n# 3. Search for what you need\n&gt; search Position\n\n# 4. Inspect a type\n&gt; PositionInfo\n\n# 5. Check enum values\n&gt; enum ENUM_ORDER_TYPE_TF\n\n# 6. Find related types\n&gt; field ticket\n\n# 7. Find fields by type\n&gt; findtype double\n\n# 8. Check enum usage\n&gt; whereenum ENUM_ORDER_TYPE_TF\n\n# 9. Get detailed stats\n&gt; stats\n\n# 10. Export to JSON\n&gt; export PositionInfo\n</code></pre>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#learning-session-example","title":"Learning Session Example","text":"<p>Goal: \"I want to close a position, what do I need?\"</p> <pre><code>&gt; search position close\nFOUND 2 TYPES MATCHING 'position close':\n  \" PositionCloseRequest\n  \" PositionCloseRequestReply\n\n&gt; PositionCloseRequest\nFIELDS (3):\n  #  1 ticket                        : uint64\n  #  2 deviation                     : uint64\n  #  3 comment                       : string\n\n&gt; PositionCloseRequestReply\nFIELDS (2):\n  #  1 returned_code                 : uint32\n  #  2 order_ticket                  : uint64\n\n&gt; field ticket\nEXACT MATCH: field 'ticket' found in:\n  \" PositionInfo\n  \" OrderInfo\n  \" DealInfo\n  \" PositionCloseRequest\n  \" HistoryDealsGetByTicketRequest\n  ...\n\n# Now you know:\n# - Use PositionCloseRequest with ticket field\n# - You'll get PositionCloseRequestReply back\n# - Check returned_code == 10009 for success (see RETURN_CODES_REFERENCE.md)\n</code></pre>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#troubleshooting","title":"Troubleshooting","text":"<p>Q: Type not found</p> <pre><code>&gt; MyType\n[!] Type not found: MyType\n    Did you mean: MqlTradeRequest, MqlTradeResult, ...\n</code></pre> <p>A: Use search with partial name to find similar types</p> <p>Q: Too many results</p> <pre><code>&gt; search data\nFOUND 156 TYPES...\n</code></pre> <p>A: Be more specific in your search query, or use filters like <code>list --data</code></p> <p>Q: What's the difference between OrderInfo and OrderSendRequest?</p> <p>A: Use the inspector:</p> <ul> <li><code>OrderInfo</code> - Information about an existing order (has 25 fields including state, times, etc.)</li> <li><code>OrderSendRequest</code> - Request to create a new order (has 15 fields for order parameters)</li> </ul> <p>Rule:</p> <ul> <li><code>*Request</code> - Input for API method (what you send)</li> <li><code>*Reply</code> - Output from API method (what you receive)</li> <li><code>*Info</code> - Structured data about entities (position, order, deal, symbol)</li> <li><code>*Data</code> - Helper data structures</li> </ul> <p>Q: Which fields are double vs int64?</p> <p>A: Use field type search:</p> <pre><code>&gt; findtype double    # All price/volume/profit fields\n&gt; findtype int64     # All ID/magic/ticket fields\n&gt; findtype string    # All text fields (symbol, comment, etc.)\n</code></pre> <p>Q: Where is enum X used?</p> <p>A: Use enum usage search:</p> <pre><code>&gt; whereenum ENUM_ORDER_TYPE_TF\n# Shows all types and fields that use this enum\n</code></pre>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#summary","title":"Summary","text":"<p>The Protobuf Inspector is your first stop when working with the MT5 gRPC API. Use it to:</p> <ol> <li>Discover available types and their structure</li> <li></li> <li>Learn message field names and types</li> <li></li> <li>Debug field name and type issues</li> <li></li> <li>Verify enum values and usage</li> <li></li> <li>Track relationships between types</li> <li></li> <li>Export documentation for your team</li> <li></li> <li>Analyze API structure and statistics</li> <li></li> <li>Speed up development workflow</li> </ol> <p>Remember: Type <code>help</code> at any time for command reference!</p>"},{"location":"All_Guides/PROTOBUF_INSPECTOR_GUIDE/#command-quick-reference","title":"Command Quick Reference","text":"<pre><code>BASIC COMMANDS:\n  list               - Show all types\n  list --request     - Show only Request types\n  &lt;TypeName&gt;         - Inspect type structure\n  search &lt;text&gt;      - Find types by name\n  field &lt;name&gt;       - Find types with field\n  enum &lt;name&gt;        - Show enum values\n\nNEW COMMANDS:\n  findtype &lt;type&gt;    - Find fields by type\n  whereenum &lt;name&gt;   - Find enum usage\n  export &lt;TypeName&gt;  - Export to JSON\n  stats              - Show statistics\n\nNAVIGATION:\n  help               - Show help\n  exit               - Exit inspector\n</code></pre> <p>Next Steps:</p> <ul> <li>Run <code>python main.py inspect</code> and explore!</li> <li>Check MT5Account Master Overview for complete API documentation</li> <li>Try the demo examples in <code>examples/</code></li> <li>See RETURN_CODES_REFERENCE.md for error codes</li> <li>See USERCODE_SANDBOX_GUIDE.md for coding examples</li> </ul>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/","title":"MT5 Return Codes (RetCodes) Reference - Python","text":""},{"location":"All_Guides/RETURN_CODES_REFERENCE/#what-is-retcode","title":"\ud83d\udee1\ufe0f What is RetCode?","text":"<p>RetCode (Return Code) is a status code that MT5 terminal returns after executing a trading operation. The code indicates success or the reason for failure.</p> <p>RetCodes appear only in trading methods because only trading operations go through the broker and can be rejected for various reasons (insufficient margin, invalid price, market closed, etc.).</p>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#quick-example-proper-retcode-handling","title":"Quick Example: Proper RetCode Handling","text":"<pre><code>from MetaRpcMT5.helpers.errors import TRADE_RETCODE_DONE, get_retcode_message\n\n# Place order\nresult = await service.place_order(request)\n\n# \u2705 ALWAYS check returned_code explicitly\nif result.returned_code == TRADE_RETCODE_DONE:\n    print(f\"\u2713 Trade successful! Order #{result.order}\")\nelse:\n    print(f\"\u2717 Trade failed: {get_retcode_message(result.returned_code)}\")\n    # Example: \"Insufficient funds\" (10019) or \"Market closed\" (10018)\n</code></pre> <p>Key point: No exception = API worked, but check RetCode to know if trade succeeded.</p>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#retcode-source","title":"RetCode Source","text":"<p>RetCodes are standard MQL5 codes defined in official MetaQuotes documentation:</p> <p>MQL5 Documentation: Trade Result Codes (ENUM_TRADE_RETCODE)</p> <p>These codes are:</p> <ul> <li>Unified across all languages (C#, Python, Java, Node.js, Go, PHP)</li> <li>Unified with MT5 terminal - returned directly from the trading server</li> <li>Defined in protobuf - returned as <code>uint32</code> field <code>returned_code</code> in trading result structures</li> <li>Available as Python constants - defined in <code>package/MetaRpcMT5/helpers/errors.py</code></li> </ul>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#where-is-retcode-used-in-the-api","title":"\ud83d\udce5 Where is RetCode Used in the API?","text":"<p>RetCode is returned in all trading operations that modify positions or orders:</p>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#1-ordersend-opening-orders","title":"1. OrderSend (Opening Orders)","text":"<pre><code>from MetaRpcMT5.helpers.errors import (\n    ApiError,\n    TRADE_RETCODE_DONE,\n    get_retcode_message,\n    is_retcode_success\n)\n\n# Using Sugar API\ntry:\n    ticket = await sugar.buy_market(\"EURUSD\", 0.01)\n    print(f\"[OK] Order opened: #{ticket}\")\nexcept ApiError as e:\n    # Check if it's a trade error with RetCode\n    retcode = e.mql_error_trade_int_code()\n    print(f\"RetCode: {retcode}\")\n    print(f\"Description: {e.mql_error_trade_description()}\")\n\n# Using Service API (mid-level)\nresult = await service.place_order(request)\nif result.returned_code == TRADE_RETCODE_DONE:\n    print(f\"[OK] Order opened! Ticket: {result.order}\")\nelse:\n    print(f\"[X] Order failed: {get_retcode_message(result.returned_code)}\")\n</code></pre>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#2-ordermodify-modifying-sltp","title":"2. OrderModify (Modifying SL/TP)","text":"<pre><code>from MetaRpcMT5.helpers.errors import TRADE_RETCODE_DONE, is_retcode_success, get_retcode_message\n\n# Using Sugar API\ntry:\n    await sugar.modify_position_sltp(ticket, sl=1.0850, tp=1.0950)\n    print(\"[OK] SL/TP modified successfully\")\nexcept ApiError as e:\n    print(f\"[X] Modification failed: {e.mql_error_trade_description()}\")\n\n# Using Service API\nresult = await service.modify_order(request)\nif is_retcode_success(result.returned_code):\n    print(\"[OK] SL/TP modified successfully\")\nelse:\n    print(f\"[X] Modification failed: {get_retcode_message(result.returned_code)}\")\n</code></pre>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#3-positionclose-closing-positions","title":"3. PositionClose (Closing Positions)","text":"<pre><code>from MetaRpcMT5.helpers.errors import ApiError, TRADE_RETCODE_DONE, TRADE_RETCODE_POSITION_CLOSED\n\n# Using Sugar API\ntry:\n    await sugar.close_position(ticket)\n    print(\"[OK] Position closed\")\nexcept ApiError as e:\n    if e.mql_error_trade_int_code() == TRADE_RETCODE_POSITION_CLOSED:\n        print(\"[WARN] Position already closed\")\n    else:\n        print(f\"[X] Close failed: {e}\")\n\n# Using Service API\nresult = await service.close_order(request)\nif result.returned_code == TRADE_RETCODE_DONE:\n    print(\"[OK] Position closed\")\n</code></pre>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#why-retcode-only-in-trading-methods","title":"\ud83d\udc41\ufe0f Why RetCode Only in Trading Methods?","text":"<p>Informational methods (getting prices, symbols, balance) DO NOT return RetCode because:</p> <ul> <li>They don't go through the broker</li> <li>They cannot be \"rejected\" - either data exists or there's a gRPC error</li> <li>They work with local terminal data</li> </ul> <p>Trading methods return RetCode because:</p> <ul> <li>Request is sent to broker via trading server</li> <li>Broker validates: margin, symbol rules, trading hours, limits</li> <li>Broker can reject request for dozens of reasons</li> <li>Each reason has its own unique code</li> </ul>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#complete-retcode-list","title":"Complete RetCode List","text":""},{"location":"All_Guides/RETURN_CODES_REFERENCE/#success-codes","title":"Success Codes","text":"Code Python Constant Description When Returned 10009 <code>TRADE_RETCODE_DONE</code> Request completed successfully Market order opened/closed 10010 <code>TRADE_RETCODE_DONE_PARTIAL</code> Partial execution Only part of volume executed 10008 <code>TRADE_RETCODE_PLACED</code> Pending order placed Limit/Stop order placed"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#requote-codes-retry-recommended","title":"Requote Codes (Retry Recommended)","text":"Code Python Constant Description Action 10004 <code>TRADE_RETCODE_REQUOTE</code> Requote Price changed, retry request 10020 <code>TRADE_RETCODE_PRICE_CHANGED</code> Price changed Similar to requote, retry <p>Helper function: <pre><code>from MetaRpcMT5.helpers.errors import is_retcode_requote\n\nif is_retcode_requote(retcode):\n    # Retry with updated price\n    pass\n</code></pre></p>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#request-validation-errors","title":"\u26a0\ufe0f Request Validation Errors","text":"Code Python Constant Description Common Cause 10013 <code>TRADE_RETCODE_INVALID_REQUEST</code> Invalid request Incorrect parameters 10014 <code>TRADE_RETCODE_INVALID_VOLUME</code> Invalid volume Volume &lt; MinVolume or &gt; MaxVolume 10015 <code>TRADE_RETCODE_INVALID_PRICE</code> Invalid price Price doesn't match symbol rules 10016 <code>TRADE_RETCODE_INVALID_STOPS</code> Invalid stops SL/TP too close to price (check StopLevel) 10022 <code>TRADE_RETCODE_INVALID_EXPIRATION</code> Invalid expiration Expiration time incorrect 10030 <code>TRADE_RETCODE_INVALID_FILL</code> Invalid order filling type Fill type not allowed 10035 <code>TRADE_RETCODE_INVALID_ORDER</code> Invalid order type Order type prohibited for symbol 10038 <code>TRADE_RETCODE_INVALID_CLOSE_VOLUME</code> Invalid close volume Close volume exceeds position volume"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#trading-restrictions","title":"\ud83d\udeab Trading Restrictions","text":"Code Python Constant Description Reason 10017 <code>TRADE_RETCODE_TRADE_DISABLED</code> Trading disabled Trading disabled for symbol 10018 <code>TRADE_RETCODE_MARKET_CLOSED</code> Market closed Outside trading hours 10026 <code>TRADE_RETCODE_SERVER_DISABLES_AT</code> Autotrading disabled by server Server disabled auto-trading 10027 <code>TRADE_RETCODE_CLIENT_DISABLES_AT</code> Autotrading disabled by client Terminal disabled auto-trading 10032 <code>TRADE_RETCODE_ONLY_REAL</code> Only real accounts Action unavailable on demo 10042 <code>TRADE_RETCODE_LONG_ONLY</code> Only long positions allowed Short positions prohibited 10043 <code>TRADE_RETCODE_SHORT_ONLY</code> Only short positions allowed Long positions prohibited 10044 <code>TRADE_RETCODE_CLOSE_ONLY</code> Only position closing allowed Opening new positions prohibited 10045 <code>TRADE_RETCODE_FIFO_CLOSE</code> Position close only by FIFO rule FIFO rule enforced 10046 <code>TRADE_RETCODE_HEDGE_PROHIBITED</code> Opposite positions prohibited Hedging disabled"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#resource-limits","title":"\ud83d\udcb0 Resource Limits","text":"Code Python Constant Description Solution 10019 <code>TRADE_RETCODE_NO_MONEY</code> Insufficient funds Check free margin 10033 <code>TRADE_RETCODE_LIMIT_ORDERS</code> Pending orders limit Close some pending orders 10034 <code>TRADE_RETCODE_LIMIT_VOLUME</code> Volume limit Reduce position volume 10040 <code>TRADE_RETCODE_LIMIT_POSITIONS</code> Positions limit Close some positions"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#technical-issues-retryable","title":"\ud83d\udd04 Technical Issues (Retryable)","text":"Code Python Constant Description Retryable 10011 <code>TRADE_RETCODE_ERROR</code> Processing error No 10012 <code>TRADE_RETCODE_TIMEOUT</code> Request timeout Yes 10021 <code>TRADE_RETCODE_NO_QUOTES</code> No quotes Yes 10024 <code>TRADE_RETCODE_TOO_MANY_REQUESTS</code> Rate limiting Yes (with delay) 10028 <code>TRADE_RETCODE_LOCKED</code> Request locked for processing Yes 10029 <code>TRADE_RETCODE_FROZEN</code> Order or position frozen Yes 10031 <code>TRADE_RETCODE_NO_CONNECTION</code> No connection Yes <p>Helper function: <pre><code>from MetaRpcMT5.helpers.errors import is_retcode_retryable\nimport asyncio\n\nif is_retcode_retryable(retcode):\n    # Safe to retry with exponential backoff\n    await asyncio.sleep(2)\n    # Retry operation...\n</code></pre></p>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#state-management","title":"State Management","text":"Code Python Constant Description Meaning 10023 <code>TRADE_RETCODE_ORDER_CHANGED</code> Order state changed Order already modified/closed 10025 <code>TRADE_RETCODE_NO_CHANGES</code> No changes New parameters = current parameters 10036 <code>TRADE_RETCODE_POSITION_CLOSED</code> Position closed Position doesn't exist 10039 <code>TRADE_RETCODE_CLOSE_ORDER_EXIST</code> Close order exists Cannot close more than position volume"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#rejection-codes","title":"\u274c Rejection Codes","text":"Code Python Constant Description Reason 10006 <code>TRADE_RETCODE_REJECT</code> Request rejected Broker rejected 10007 <code>TRADE_RETCODE_CANCEL</code> Request canceled Canceled by trader 10041 <code>TRADE_RETCODE_REJECT_CANCEL</code> Pending order activation rejected Activation rejected and canceled"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#centralized-error-handler-packagemetarpcmt5helperserrorspy","title":"Centralized Error Handler (<code>package/MetaRpcMT5/helpers/errors.py</code>)","text":"<p>PyMT5 provides a centralized error handling module that simplifies working with RetCodes.</p> <p>Instead of manually checking return codes and writing your own error messages, you can use the built-in helper functions from <code>package/MetaRpcMT5/helpers/errors.py</code>:</p>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#whats-inside","title":"What's Inside","text":"<p>The module contains:</p> <ul> <li> <p>All RetCode constants (e.g., <code>TRADE_RETCODE_DONE</code>, <code>TRADE_RETCODE_NO_MONEY</code>)</p> </li> <li> <p>Helper functions to check return codes (<code>is_retcode_success</code>, <code>is_retcode_requote</code>, etc.)</p> </li> <li> <p>Human-readable error messages for all RetCodes</p> </li> <li> <p>Pre-built error handling logic for common scenarios</p> </li> </ul>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#why-use-it","title":"Why Use It?","text":"<p>\u2705 No magic numbers - Use named constants instead of <code>10009</code>, <code>10019</code></p> <p>\u2705 Automatic error descriptions - Get human-readable messages for any RetCode</p> <p>\u2705 Smart categorization - Easily identify requotes, retryable errors, etc.</p> <p>\u2705 Consistent error handling - Use the same logic across your entire project</p>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#when-to-explicitly-check-retcode","title":"When to Explicitly Check RetCode","text":"<p>CRITICAL: You MUST explicitly check <code>returned_code</code> after every trading operation:</p> <pre><code># \u274c WRONG - Only catching exceptions is NOT enough!\ntry:\n    result = await service.place_order(request)\n    print(f\"Order placed: {result.order}\")  # \u2190 This doesn't mean success!\nexcept ApiError as e:\n    print(f\"Error: {e}\")\n\n# \u2705 CORRECT - Always check returned_code\ntry:\n    result = await service.place_order(request)\n\n    # MUST check RetCode explicitly\n    if result.returned_code == TRADE_RETCODE_DONE:\n        print(f\"\u2713 Order placed: {result.order}\")\n    else:\n        print(f\"\u2717 Order failed: {get_retcode_message(result.returned_code)}\")\n\nexcept ApiError as e:\n    print(f\"API Error: {e}\")\n</code></pre> <p>Why? Because:</p> <ul> <li> <p>No exception means the API call succeeded (connection OK, terminal responded)</p> </li> <li> <p>But it does NOT mean the trade succeeded (broker may have rejected it)</p> </li> <li> <p>You need to check <code>returned_code</code> to know the actual trade result</p> </li> </ul>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#python-helper-functions","title":"Python Helper Functions","text":"<p>The <code>package/MetaRpcMT5/helpers/errors.py</code> module provides helper functions for working with RetCodes:</p>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#is_retcode_success","title":"is_retcode_success()","text":"<p>Checks if the RetCode indicates successful trade execution.</p> <pre><code>from MetaRpcMT5.helpers.errors import is_retcode_success, TRADE_RETCODE_DONE\n\n# Usage\nif is_retcode_success(result.returned_code):\n    print(\"Trade successful!\")\n\n# Returns True only for retcode == 10009 (TRADE_RETCODE_DONE)\n</code></pre>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#is_retcode_requote","title":"is_retcode_requote()","text":"<p>Checks if the RetCode indicates a price change (requote) - safe to retry immediately.</p> <pre><code>from MetaRpcMT5.helpers.errors import is_retcode_requote, TRADE_RETCODE_REQUOTE, TRADE_RETCODE_PRICE_CHANGED\n\n# Usage\nif is_retcode_requote(result.returned_code):\n    print(\"Price changed, retrying...\")\n    # Retry with updated price\n\n# Returns True for 10004 or 10020\n</code></pre>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#is_retcode_retryable","title":"is_retcode_retryable()","text":"<p>Checks if the RetCode indicates a temporary error - safe to retry with delay.</p> <pre><code>from MetaRpcMT5.helpers.errors import (\n    is_retcode_retryable,\n    TRADE_RETCODE_TIMEOUT,\n    TRADE_RETCODE_NO_CONNECTION,\n    TRADE_RETCODE_FROZEN\n)\nimport asyncio\n\n# Usage\nif is_retcode_retryable(result.returned_code):\n    # These errors are temporary, retry with delay\n    await asyncio.sleep(2)\n    # Retry operation\n\n# Returns True for: Timeout, NoConnection, Frozen, Locked, TooManyRequests, NoQuotes\n</code></pre>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#get_retcode_message","title":"get_retcode_message()","text":"<p>Returns a human-readable description for any RetCode.</p> <pre><code>from MetaRpcMT5.helpers.errors import get_retcode_message, TRADE_RETCODE_DONE\n\n# Usage\nif result.returned_code != TRADE_RETCODE_DONE:\n    print(f\"Error: {get_retcode_message(result.returned_code)}\")\n\n# Returns human-readable description for any RetCode\n</code></pre>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#check_retcode","title":"check_retcode()","text":"<p>Prints formatted message with hints and returns <code>True</code> if successful.</p> <pre><code>from MetaRpcMT5.helpers.errors import check_retcode, TRADE_RETCODE_DONE\n\n# Usage\nresult = await service.place_order(request)\nif check_retcode(result.returned_code, \"Order placement\"):\n    print(f\"Order ticket: {result.order}\")\n\n# Prints formatted message and helpful hints for common errors\n</code></pre>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#usage-examples","title":"Usage Examples","text":""},{"location":"All_Guides/RETURN_CODES_REFERENCE/#example-1-basic-order-placement-with-retcode-check","title":"Example 1: Basic Order Placement with RetCode Check","text":"<pre><code>import asyncio\nfrom uuid import uuid4\nfrom MetaRpcMT5 import MT5Account\nfrom pymt5.mt5_service import MT5Service\nfrom pymt5.mt5_sugar import MT5Sugar\nfrom MetaRpcMT5.helpers.errors import TRADE_RETCODE_DONE, get_retcode_message\nfrom MetaRpcMT5.mt5_term_api_trading_helper_pb2 import OrderSendRequest\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as pb_trading\n\nasync def main():\n    # Create MT5Account instance\n    account = MT5Account(\n        user=12345678,\n        password=\"your_password\",\n        grpc_server=\"127.0.0.1:9999\",\n        id_=uuid4()\n    )\n\n    # Connect to MT5 server\n    await account.connect_by_server_name(\n        server_name=\"MetaQuotes-Demo\",\n        base_chart_symbol=\"EURUSD\",\n        timeout_seconds=120\n    )\n\n    try:\n        # Create service and sugar\n        service = MT5Service(account)\n        sugar = MT5Sugar(service, default_symbol=\"EURUSD\")\n\n        # Place buy market order\n        request = OrderSendRequest(\n            symbol=\"EURUSD\",\n            volume=0.01,\n            operation=pb_trading.TMT5_ORDER_TYPE_BUY,\n            price=0.0  # Market order\n        )\n\n        result = await service.place_order(request)\n\n        # Check RetCode\n        if result.returned_code == TRADE_RETCODE_DONE:\n            print(f\"[OK] Order opened successfully!\")\n            print(f\"   Ticket: #{result.order}\")\n            print(f\"   Volume: {result.volume:.2f} lots\")\n            print(f\"   Price: {result.price:.5f}\")\n        else:\n            print(f\"[X] Order failed!\")\n            print(f\"   RetCode: {result.returned_code}\")\n            print(f\"   Description: {get_retcode_message(result.returned_code)}\")\n\n    finally:\n        await account.disconnect()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#example-2-handling-common-errors-ifelif-statement","title":"Example 2: Handling Common Errors (if/elif Statement)","text":"<pre><code>from MetaRpcMT5.helpers.errors import (\n    ApiError,\n    TRADE_RETCODE_NO_MONEY,\n    TRADE_RETCODE_MARKET_CLOSED,\n    TRADE_RETCODE_INVALID_STOPS,\n    TRADE_RETCODE_INVALID_VOLUME,\n    TRADE_RETCODE_REQUOTE,\n    TRADE_RETCODE_PRICE_CHANGED\n)\nimport asyncio\n\ntry:\n    ticket = await sugar.buy_market(\"GBPUSD\", 0.5)\n    print(f\"[OK] Order #{ticket} opened\")\n\nexcept ApiError as e:\n    retcode = e.mql_error_trade_int_code()\n\n    if retcode == TRADE_RETCODE_NO_MONEY:\n        print(\"[WARN] Insufficient funds!\")\n        print(\"   Solution: Reduce volume or add margin\")\n\n    elif retcode == TRADE_RETCODE_MARKET_CLOSED:\n        print(\"[WARN] Market closed\")\n        print(\"   Solution: Try during trading hours\")\n\n    elif retcode == TRADE_RETCODE_INVALID_STOPS:\n        print(\"[WARN] SL/TP too close to market price\")\n        print(\"   Solution: Increase distance (check StopLevel)\")\n\n    elif retcode == TRADE_RETCODE_INVALID_VOLUME:\n        print(\"[WARN] Invalid volume\")\n        # Get symbol limits\n        symbol_info = await sugar.get_symbol_info(\"GBPUSD\")\n        print(f\"   Min: {symbol_info.volume_min:.2f}, \"\n              f\"Max: {symbol_info.volume_max:.2f}, \"\n              f\"Step: {symbol_info.volume_step:.2f}\")\n\n    elif retcode in (TRADE_RETCODE_REQUOTE, TRADE_RETCODE_PRICE_CHANGED):\n        print(\"[WARN] Price changed, retrying...\")\n        await asyncio.sleep(0.1)\n        # Retry order\n\n    else:\n        print(f\"[X] Error: {e.mql_error_trade_description()}\")\n</code></pre>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#example-3-retry-logic-for-temporary-errors","title":"Example 3: Retry Logic for Temporary Errors","text":"<pre><code>import asyncio\nfrom MetaRpcMT5.helpers.errors import (\n    ApiError,\n    is_retcode_requote,\n    is_retcode_retryable\n)\n\nasync def place_order_with_retry(\n    sugar,\n    symbol: str,\n    volume: float,\n    max_retries: int = 3\n):\n    \"\"\"Place order with automatic retry logic.\"\"\"\n\n    for attempt in range(1, max_retries + 1):\n        try:\n            ticket = await sugar.buy_market(symbol, volume)\n            # Success\n            return ticket\n\n        except ApiError as e:\n            retcode = e.mql_error_trade_int_code()\n\n            # Requote - retry immediately\n            if is_retcode_requote(retcode):\n                print(f\"Requote on attempt {attempt}, retrying...\")\n                await asyncio.sleep(0.1)\n                continue\n\n            # Retryable error - exponential backoff\n            if is_retcode_retryable(retcode):\n                wait_time = attempt  # 1s, 2s, 3s\n                print(f\"Temporary error on attempt {attempt}, \"\n                      f\"waiting {wait_time}s...\")\n                await asyncio.sleep(wait_time)\n                continue\n\n            # Permanent error - stop retrying\n            raise RuntimeError(\n                f\"Permanent error: {e.mql_error_trade_description()}\"\n            )\n\n        except Exception as e:\n            # Other error (network, etc.)\n            raise\n\n    raise RuntimeError(f\"Failed after {max_retries} attempts\")\n\n# Usage\ntry:\n    ticket = await place_order_with_retry(sugar, \"EURUSD\", 0.01, max_retries=3)\n    print(f\"Order placed: #{ticket}\")\nexcept Exception as e:\n    print(f\"Failed to place order: {e}\")\n</code></pre>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#example-4-using-check_retcode","title":"Example 4: Using check_retcode()","text":"<pre><code>from MetaRpcMT5.helpers.errors import check_retcode\n\nresult = await service.place_order(request)\n\n# check_retcode prints formatted message and returns True on success\nif check_retcode(result.returned_code, \"Order placement\"):\n    print(f\"Order ticket: {result.order}\")\n\n# Output on success:\n#   [OK] Order placement successful (RetCode: 10009)\n\n# Output on failure (e.g., market closed):\n#   [FAIL] Order placement failed (RetCode: 10018)\n#      Market is closed\n#      Hint: Market is closed - check trading hours\n</code></pre>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#example-5-modifying-sltp-with-validation","title":"Example 5: Modifying SL/TP with Validation","text":"<pre><code>from MetaRpcMT5.helpers.errors import (\n    TRADE_RETCODE_DONE,\n    TRADE_RETCODE_NO_CHANGES,\n    TRADE_RETCODE_POSITION_CLOSED,\n    TRADE_RETCODE_INVALID_STOPS,\n    get_retcode_message\n)\n\ntry:\n    await sugar.modify_position_sltp(123456, sl=1.0850, tp=1.0950)\n    print(\"[OK] SL/TP updated successfully\")\n\nexcept ApiError as e:\n    retcode = e.mql_error_trade_int_code()\n\n    if retcode == TRADE_RETCODE_NO_CHANGES:\n        print(\"[WARN] New SL/TP same as current - no action taken\")\n\n    elif retcode == TRADE_RETCODE_POSITION_CLOSED:\n        print(\"[WARN] Position already closed by SL/TP or manually\")\n\n    elif retcode == TRADE_RETCODE_INVALID_STOPS:\n        print(\"[X] Invalid SL/TP distance\")\n        # Get symbol stop level\n        symbol_info = await sugar.get_symbol_info(\"EURUSD\")\n        print(f\"   Minimum distance: {symbol_info.spread} points\")\n\n    else:\n        print(f\"[X] Modification failed: {get_retcode_message(retcode)}\")\n</code></pre>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#best-practices","title":"Best Practices","text":""},{"location":"All_Guides/RETURN_CODES_REFERENCE/#do","title":"DO:","text":"<ol> <li> <p>Always check returned_code after trading operations    <pre><code>if result.returned_code == TRADE_RETCODE_DONE:\n    # Success\n    pass\n</code></pre></p> </li> <li> <p>Use helper functions for cleaner code    <pre><code>if is_retcode_success(retcode): ...\nif is_retcode_requote(retcode): ...\n</code></pre></p> </li> <li> <p>Retry requotes (10004, 10020)    <pre><code>if is_retcode_requote(retcode):\n    # Retry with updated price\n    pass\n</code></pre></p> </li> <li> <p>Check margin before trading to avoid 10019    <pre><code>free_margin = await sugar.get_free_margin()\nrequired_margin = await sugar.calculate_required_margin(\"EURUSD\", 0.01)\nif free_margin &lt; required_margin:\n    print(\"Insufficient margin!\")\n</code></pre></p> </li> </ol>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#dont","title":"\u274c DON'T:","text":"<ol> <li> <p>Don't ignore returned_code - catching only exceptions is NOT enough!    <pre><code># \u274c WRONG - Dangerous! This looks like success but trade might have failed!\ntry:\n    result = await service.place_order(request)\n    print(f\"Order: {result.order}\")  # \u2190 NO! This might be 0 if trade failed\n    # Missing RetCode check = silent failures!\nexcept ApiError:\n    pass\n\n# \u2705 CORRECT - Always check returned_code\ntry:\n    result = await service.place_order(request)\n    if result.returned_code == TRADE_RETCODE_DONE:\n        # Now we KNOW trade succeeded\n        print(f\"Order: {result.order}\")\n    else:\n        # Trade failed - handle the error\n        print(f\"Failed: {get_retcode_message(result.returned_code)}\")\nexcept ApiError as e:\n    # Handle API/connection error\n    print(f\"API Error: {e}\")\n</code></pre></p> </li> <li> <p>Don't use magic numbers - use constants    <pre><code># WRONG:\nif retcode == 10009: ...\n\n# CORRECT:\nif retcode == TRADE_RETCODE_DONE: ...\n</code></pre></p> </li> <li> <p>Don't retry permanent errors (insufficient margin, market closed)    <pre><code># Use is_retcode_retryable() to check\nif is_retcode_retryable(retcode):\n    # Safe to retry\n    pass\n</code></pre></p> </li> <li> <p>Don't assume no exception = success <pre><code># Need to check both exception AND RetCode\ntry:\n    result = await service.place_order(request)\n    if result.returned_code != TRADE_RETCODE_DONE:\n        raise RuntimeError(f\"Trade failed: {get_retcode_message(result.returned_code)}\")\nexcept Exception as e:\n    # Handle error\n    pass\n</code></pre></p> </li> </ol>"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#i-quick-reference-table","title":"\u2139\ufe0f Quick Reference Table","text":"Category RetCodes Action Success 10008, 10009, 10010 Continue normally Requote 10004, 10020 Retry immediately Temporary 10012, 10021, 10024, 10028, 10029, 10031 Retry with delay Validation 10013-10016, 10022, 10030, 10035, 10038 Fix parameters Restrictions 10017, 10018, 10026, 10027, 10032, 10042-10046 Check trading conditions Limits 10019, 10033, 10034, 10040 Reduce volume/positions State 10023, 10025, 10036, 10039 Check current state Rejection 10006, 10007, 10041 Check request Technical 10011 Contact support"},{"location":"All_Guides/RETURN_CODES_REFERENCE/#constants-reference","title":"Constants Reference","text":"<p>All RetCode constants are defined in <code>package/MetaRpcMT5/helpers/errors.py</code>:</p> <pre><code># Success codes\nTRADE_RETCODE_SUCCESS = 0           # Success (generic, rarely used - prefer DONE)\nTRADE_RETCODE_DONE = 10009          # Request completed successfully\nTRADE_RETCODE_DONE_PARTIAL = 10010  # Only part of the request was completed\nTRADE_RETCODE_PLACED = 10008        # Order placed (pending order activated)\n\n# Requote codes\nTRADE_RETCODE_REQUOTE = 10004       # Requote (price changed, need to retry)\nTRADE_RETCODE_PRICE_CHANGED = 10020 # Prices changed (same as requote)\n\n# Request rejection codes\nTRADE_RETCODE_REJECT = 10006        # Request rejected by server\nTRADE_RETCODE_CANCEL = 10007        # Request canceled by trader\nTRADE_RETCODE_INVALID_REQUEST = 10013       # Invalid request\nTRADE_RETCODE_INVALID_VOLUME = 10014        # Invalid volume in the request\nTRADE_RETCODE_INVALID_PRICE = 10015         # Invalid price in the request\nTRADE_RETCODE_INVALID_STOPS = 10016         # Invalid stops (SL/TP too close to price)\nTRADE_RETCODE_INVALID_EXPIRATION = 10022    # Invalid order expiration date\nTRADE_RETCODE_INVALID_FILL = 10030          # Invalid order filling type\nTRADE_RETCODE_INVALID_ORDER = 10035         # Incorrect or prohibited order type\nTRADE_RETCODE_INVALID_CLOSE_VOLUME = 10038  # Invalid close volume\n\n# Backward compatibility alias\nTRADE_RETCODE_INVALID = TRADE_RETCODE_INVALID_REQUEST\n\n# Trading restriction codes\nTRADE_RETCODE_TRADE_DISABLED = 10017    # Trading is disabled\nTRADE_RETCODE_MARKET_CLOSED = 10018     # Market is closed\nTRADE_RETCODE_SERVER_DISABLES_AT = 10026 # Autotrading disabled by server\nTRADE_RETCODE_CLIENT_DISABLES_AT = 10027 # Autotrading disabled by client terminal\nTRADE_RETCODE_ONLY_REAL = 10032         # Operation is allowed only for live accounts\nTRADE_RETCODE_LONG_ONLY = 10042         # Only long positions allowed\nTRADE_RETCODE_SHORT_ONLY = 10043        # Only short positions allowed\nTRADE_RETCODE_CLOSE_ONLY = 10044        # Only position close operations allowed\nTRADE_RETCODE_FIFO_CLOSE = 10045        # Position close only by FIFO rule\nTRADE_RETCODE_HEDGE_PROHIBITED = 10046  # Opposite positions prohibited (hedging disabled)\n\n# Resource limit codes\nTRADE_RETCODE_NO_MONEY = 10019          # Not enough money (insufficient margin)\nTRADE_RETCODE_LIMIT_ORDERS = 10033      # Number of pending orders reached the limit\nTRADE_RETCODE_LIMIT_VOLUME = 10034      # Volume of orders and positions reached the limit\nTRADE_RETCODE_LIMIT_POSITIONS = 10040   # Number of open positions reached the limit\n\n# Technical issue codes\nTRADE_RETCODE_ERROR = 10011             # Request processing error\nTRADE_RETCODE_TIMEOUT = 10012           # Request canceled by timeout\nTRADE_RETCODE_NO_QUOTES = 10021         # No quotes to process the request\nTRADE_RETCODE_TOO_MANY_REQUESTS = 10024 # Too frequent requests\nTRADE_RETCODE_LOCKED = 10028            # Request locked for processing\nTRADE_RETCODE_FROZEN = 10029            # Order or position frozen\nTRADE_RETCODE_NO_CONNECTION = 10031     # No connection with the trade server\n\n# Backward compatibility aliases\nTRADE_RETCODE_PRICE_OFF = TRADE_RETCODE_NO_QUOTES\nTRADE_RETCODE_CONNECTION = TRADE_RETCODE_NO_CONNECTION\n\n# State management codes\nTRADE_RETCODE_ORDER_CHANGED = 10023     # Order state changed during request\nTRADE_RETCODE_NO_CHANGES = 10025        # No changes in request\nTRADE_RETCODE_POSITION_CLOSED = 10036   # Position with specified ID already closed\nTRADE_RETCODE_CLOSE_ORDER_EXIST = 10039 # A close order already exists for position\nTRADE_RETCODE_REJECT_CANCEL = 10041     # Pending order activation rejected and canceled\n</code></pre>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/","title":"User Code Sandbox Guide","text":""},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#what-is-this","title":"What is this?","text":"<p>This is your sandbox for writing custom MT5 trading code in Python. Connection setup is already done - you only need to add your trading logic!</p>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#quick-start","title":"\ud83c\udfc1 Quick Start","text":"<ol> <li>Case already active in main.py</li> <li>Open <code>examples/main.py</code></li> <li> <p>Case \"18\" for user code sandbox is ready to use</p> </li> <li> <p>Open <code>examples/6_usercode/18_usercode.py</code></p> </li> <li> <p>Write your code or uncomment examples</p> </li> <li> <p>Run: <pre><code>cd examples\npython main.py usercode\n</code></pre></p> </li> </ol> <p>That's it! Your code will execute with full MT5 connection.</p>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#how-to-use","title":"How to use","text":""},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#option-1-uncomment-examples","title":"Option 1: Uncomment examples","text":"<p>The file contains 5 ready-to-use examples:</p> <pre><code># Example 1: Get account balance (Sugar - easiest)\n# balance = await sugar.get_balance()\n# print(f\"Balance: {balance:.2f}\")\n</code></pre> <p>Just remove <code>#</code> to activate!</p>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#option-2-write-your-own-code","title":"Option 2: Write your own code","text":"<p>Add your logic between the markers:</p> <pre><code># =================================================================\n# YOUR CODE HERE\n# =================================================================\n\n# Your trading strategy here...\n\n# TODO: Write your trading logic here\n</code></pre>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#available-commands","title":"Available commands","text":"<p>Run your code with:</p> <pre><code># From examples directory\npython main.py usercode\npython main.py 18\npython main.py user\npython main.py sandbox\n</code></pre>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#whats-already-configured","title":"What's already configured","text":"<ul> <li> <p>Connection - MT5 terminal connected via gRPC</p> </li> <li> <p>Configuration - Loaded from <code>examples/0_common/settings.json</code></p> </li> <li> <p>account - Low-level gRPC client (MT5Account)</p> </li> <li> <p>service - Mid-level wrapper (MT5Service)</p> </li> <li> <p>sugar - High-level Sugar API (MT5Sugar)</p> </li> <li> <p>async/await - All methods are asynchronous</p> </li> </ul>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#can-i-mix-api-levels","title":"\ud83e\udde9 Can I mix API levels?","text":"<p>Yes! You can use all three levels in the same file:</p> <pre><code># Low-level (direct gRPC protobuf)\nsummary = await account.account_summary()\nbalance_pb = summary.account_balance\n\n# Mid-level (MT5Service)\naccount_info = await service.get_account_summary()\nbalance_svc = account_info.balance\n\n# High-level (MT5Sugar)\nbalance_sugar = await sugar.get_balance()\n</code></pre> <p>All three variables are available simultaneously:</p> <ul> <li><code>account</code> - for full control (gRPC protobuf)</li> <li><code>service</code> - for convenient methods (Service layer)</li> <li><code>sugar</code> - for simplest usage (Sugar API)</li> </ul>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#quick-reference","title":"Quick reference","text":""},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#get-account-information","title":"Get account information","text":"<pre><code># Sugar API (easiest)\nbalance = await sugar.get_balance()\nprint(f\"Balance: {balance:.2f}\")\n\n# Service API (more details)\naccount_info = await service.get_account_summary()\nprint(f\"Balance: {account_info.balance:.2f} {account_info.currency}\")\nprint(f\"Equity:  {account_info.equity:.2f}\")\n\n# Account API (full control)\nsummary = await account.account_summary()\nprint(f\"Balance: {summary.account_balance:.2f}\")\n</code></pre>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#get-current-price","title":"Get current price","text":"<pre><code># Sugar API\nbid = await sugar.get_bid(\"EURUSD\")\nask = await sugar.get_ask(\"EURUSD\")\nprint(f\"EURUSD: Bid={bid:.5f}, Ask={ask:.5f}\")\n\n# Service API\ntick = await service.get_symbol_tick(\"EURUSD\")\nprint(f\"EURUSD Bid: {tick.bid:.5f}, Ask: {tick.ask:.5f}\")\n</code></pre>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#open-market-order","title":"Open market order","text":"<pre><code># Sugar API (easiest)\ntry:\n    ticket = await sugar.buy_market(\"EURUSD\", 0.01)\n    print(f\"Order opened: #{ticket}\")\nexcept Exception as e:\n    print(f\"Order failed: {e}\")\n\n# With SL/TP in pips\nticket = await sugar.buy_market_with_pips(\"EURUSD\", 0.01, sl_pips=20, tp_pips=30)\n\n# Calculate position size based on risk (2% with 50 pip SL)\nlot_size = await sugar.calculate_position_size(\"EURUSD\", risk_percent=2.0, sl_pips=50)\nticket = await sugar.buy_market_with_pips(\"EURUSD\", lot_size, sl_pips=50, tp_pips=100)\n</code></pre>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#place-pending-order","title":"Place pending order","text":"<pre><code># Buy Limit with absolute price and SL/TP in pips\nticket = await sugar.buy_limit_with_sltp(\"EURUSD\", 0.01, price=1.0850,\n                                          sl_pips=20, tp_pips=30)\n\n# Buy Stop with absolute price\nticket = await sugar.buy_stop(\"EURUSD\", 0.01, price=1.0950)\n\n# Sell Limit with absolute price and SL/TP\nticket = await sugar.sell_limit_with_sltp(\"EURUSD\", 0.01, price=1.1050,\n                                           sl=1.1070, tp=1.1030)\n</code></pre>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#get-open-positions","title":"Get open positions","text":"<pre><code># Sugar API\npositions = await sugar.get_open_positions()\nprint(f\"Open positions: {len(positions)}\")\nfor pos in positions:\n    print(f\"  #{pos.ticket} {pos.symbol} {pos.volume:.2f} lot, \"\n          f\"Profit: {pos.profit:.2f}\")\n\n# Service API with filters\nopened_data = await service.get_opened_orders()\npositions = opened_data.position_infos\n</code></pre>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#close-positions","title":"Close positions","text":"<pre><code># Close specific position\nawait sugar.close_position(ticket)\n\n# Close all positions for symbol\nawait sugar.close_all_positions(\"EURUSD\")\n\n# Close all positions (all symbols)\nawait sugar.close_all_positions()\n</code></pre>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#modify-position","title":"Modify position","text":"<pre><code># Modify SL/TP\nawait sugar.modify_position_sltp(ticket, sl=1.0850, tp=1.0950)\n\n# Modify only Stop Loss\nawait sugar.modify_position_sl(ticket, sl=1.0850)\n\n# Modify only Take Profit\nawait sugar.modify_position_tp(ticket, tp=1.0950)\n</code></pre>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#calculate-position-size","title":"Calculate position size","text":"<pre><code># Calculate position size based on risk\nvolume = await sugar.calculate_position_size(\"EURUSD\", risk_percent=2.0, sl_pips=20)\nprint(f\"Volume for 2% risk with 20 pip SL: {volume:.2f} lot\")\n\n# Then use calculated volume\nticket = await sugar.buy_market(\"EURUSD\", volume)\n</code></pre>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#return-codes-retcodes","title":"Return Codes (RetCodes)","text":"<p>Always check returned_code after trading operations!</p> <pre><code>from MetaRpcMT5.mt5_term_api_trading_helper_pb2 import OrderSendRequest\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as pb_trading\n\n# Build request\nrequest = OrderSendRequest(\n    symbol=\"EURUSD\",\n    volume=0.01,\n    operation=pb_trading.TMT5_ORDER_TYPE_BUY,\n    price=0.0,  # Market order (price will be filled by broker)\n    # ... other fields\n)\n\nresult = await service.place_order(request)\n\n# Check RetCode\nif result.returned_code == 10009:  # Success for market orders\n    print(f\"[OK] Order opened: #{result.order}\")\nelif result.returned_code == 10008:  # Success for pending orders\n    print(f\"[OK] Pending order placed: #{result.order}\")\nelse:\n    print(f\"[X] Order failed: {result.comment} (code {result.returned_code})\")\n</code></pre> <p>Common RetCodes:</p> <ul> <li><code>10009</code> - Market order executed successfully</li> <li><code>10008</code> - Pending order placed successfully</li> <li><code>10019</code> - Insufficient money (insufficient margin)</li> <li><code>10016</code> - Invalid stops (SL/TP too close to price)</li> <li><code>10018</code> - Market closed</li> </ul> <p>Full list: RETURN_CODES_REFERENCE.md</p>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#i-error-handling","title":"\u2139\ufe0f Error handling","text":"<p>PyMT5 uses Python exceptions for error handling:</p>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#1-connectionnetwork-errors","title":"1. Connection/Network errors","text":"<pre><code>try:\n    result = await service.place_order(request)\nexcept Exception as e:\n    print(f\"Connection or network error: {e}\")\n    return\n</code></pre>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#2-trading-operation-errors-retcode","title":"2. Trading operation errors (RetCode)","text":"<pre><code>result = await service.place_order(request)\nif result.returned_code != 10009:\n    print(f\"Trade rejected: {result.comment}\")\n</code></pre> <p>Always check BOTH!</p>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#recommended-pattern","title":"Recommended pattern:","text":"<pre><code>try:\n    result = await service.place_order(request)\n\n    if result.returned_code == 10009:\n        print(f\"[OK] Success: Order #{result.order}\")\n    else:\n        print(f\"[X] Failed: {result.comment} (code: {result.returned_code})\")\n\nexcept Exception as e:\n    print(f\"[X] Error: {e}\")\n</code></pre>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>MT5Account Master Overview - Complete API reference (40 methods)</li> <li>MT5Service Overview - Mid-level wrapper (36 methods)</li> <li>MT5Sugar Master Overview - High-level Sugar API (62+ methods)</li> <li>ENUMS Usage Reference - All ENUMs in one place</li> </ul>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#configuration","title":"\ud83d\udd11 Configuration","text":""},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#method-1-settingsjson-recommended","title":"Method 1: settings.json (Recommended)","text":"<p>Create <code>examples/0_common/settings.json</code>:</p> <pre><code>{\n  \"user\": 591129415,\n  \"password\": \"YourPassword\",\n  \"grpc_server\": \"127.0.0.1:9999\",\n  \"mt_cluster\": \"MetaQuotes-Demo\",\n  \"test_symbol\": \"EURUSD\",\n  \"test_volume\": 0.01\n}\n</code></pre>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#method-2-environment-variables","title":"Method 2: Environment variables","text":"<pre><code># Linux/Mac\nexport MT5_USER=591129415\nexport MT5_PASSWORD=\"YourPassword\"\nexport MT5_GRPC_SERVER=\"127.0.0.1:9999\"\nexport MT5_CLUSTER=\"MetaQuotes-Demo\"\n\n# Windows PowerShell\n$env:MT5_USER=\"591129415\"\n$env:MT5_PASSWORD=\"YourPassword\"\n$env:MT5_GRPC_SERVER=\"127.0.0.1:9999\"\n</code></pre> <p>See demo_helpers.py for details.</p>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#tips","title":"Tips","text":"<ol> <li> <p>Start simple - Uncomment one example at a time</p> </li> <li> <p>Use Sugar API - Methods like <code>buy_market_with_pips()</code> and  <code>calculate_position_size()</code> are easier than low-level</p> </li> <li> <p>Check returned_code - Always validate trading operations (10009 = success)</p> </li> <li> <p>Test on demo - Make sure you're using demo account first!</p> </li> <li> <p>Read documentation - RETURN_CODES_REFERENCE.md explains all error codes</p> </li> <li> <p>Use async/await - All methods are asynchronous</p> </li> <li> <p>Type hints - Use IDE autocomplete for better development experience</p> </li> <li> <p>Check examples - See <code>examples/</code> folder for 15+ working examples</p> </li> </ol>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#common-mistakes","title":"Common mistakes","text":"<p>[X] Forgot to use await <pre><code>balance = sugar.get_balance()  # DON'T forget await!\n</code></pre></p> <p>[+] Always use await <pre><code>balance = await sugar.get_balance()\n</code></pre></p> <p>[X] Not checking exceptions <pre><code>ticket = await sugar.buy_market(\"EURUSD\", 0.01)  # No try/except!\n</code></pre></p> <p>[+] Always handle exceptions <pre><code>try:\n    ticket = await sugar.buy_market(\"EURUSD\", 0.01)\n    print(f\"Order opened: #{ticket}\")\nexcept Exception as e:\n    print(f\"Error: {e}\")\n</code></pre></p> <p>[X] Not checking returned_code <pre><code>result = await service.place_order(request)\n# Assuming it's success!\n</code></pre></p> <p>[+] Check returned_code for trading operations <pre><code>result = await service.place_order(request)\nif result.returned_code != 10009:\n    print(f\"Trade failed: {result.comment}\")\n    return\n</code></pre></p>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#getting-help","title":"Getting help","text":"<ul> <li>Protobuf types: Check <code>package/MetaRpcMT5/</code> folder for all protobuf definitions</li> <li>Error codes: See RETURN_CODES_REFERENCE.md</li> <li>Examples: Check <code>examples/</code> folder for working code</li> <li>API documentation: See docs folder for complete reference</li> </ul>"},{"location":"All_Guides/USERCODE_SANDBOX_GUIDE/#example-complete-trading-strategy","title":"Example: Complete trading strategy","text":"<p>Here's a complete example demonstrating proper error handling:</p> <pre><code>async def run_user_code():\n    \"\"\"Your sandbox function - write your code here!\"\"\"\n\n    try:\n        # Load configuration\n        config = load_settings()\n    except Exception as e:\n        print(f\"Config error: {e}\")\n        return\n\n    try:\n        # Connect to MT5\n        account = await create_and_connect_mt5(config)\n    except Exception as e:\n        print(f\"Connection error: {e}\")\n        return\n\n    # Create service and sugar wrappers\n    service = MT5Service(account)\n    sugar = MT5Sugar(service, default_symbol=config.get('test_symbol', 'EURUSD'))\n\n    # Get account information\n    try:\n        balance = await sugar.get_balance()\n        print(f\"Balance: {balance:.2f}\")\n    except Exception as e:\n        print(f\"Balance error: {e}\")\n        return\n\n    # Calculate position size based on risk (1% with 50 pip SL)\n    try:\n        volume = await sugar.calculate_position_size(\"EURUSD\",\n                                                      risk_percent=1.0,\n                                                      sl_pips=50)\n    except Exception as e:\n        print(f\"Position size error: {e}\")\n        return\n\n    # Open position with calculated volume\n    try:\n        ticket = await sugar.buy_market_with_pips(\"EURUSD\", volume,\n                                                   sl_pips=50, tp_pips=100)\n        print(f\"[OK] Position opened: #{ticket} with {volume:.2f} lot\")\n    except Exception as e:\n        print(f\"Order error: {e}\")\n        return\n\n    print(\"Strategy execution completed!\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(run_user_code())\n</code></pre> <p>Happy trading!</p>"},{"location":"All_Guides/Your_First_Project/","title":"Your First Project in 10 Minutes","text":"<p>Practice Before Theory - create a working trading project with MT5 before diving into the documentation</p>"},{"location":"All_Guides/Your_First_Project/#why-this-guide","title":"Why This Guide?","text":"<p>I want to show you with a simple example how easy it is to use our gRPC gateway to work with MetaTrader 5.</p> <p>Before diving into the fundamentals and core concepts of the project - let's create your first project.</p> <p>We will install one Python package <code>MetaRpcMT5</code>, which contains:</p> <ul> <li>\u2705 Protobuf definitions of all MT5 methods</li> <li>\u2705 MT5Account - ready-to-use gRPC client</li> <li>\u2705 Error handler - ApiError types and return codes</li> <li>\u2705 Everything needed to get started</li> </ul> <p>This is the foundation for your future algorithmic trading system.</p> <p>\ud83d\udca1 After getting your first results, proceed to MT5Account.Master.Overview.md for a deep understanding of the SDK architecture.</p>"},{"location":"All_Guides/Your_First_Project/#step-1-install-python-38-or-higher","title":"Step 1: Install Python 3.8 or Higher","text":"<p>If you don't have Python installed yet:</p> <p>Download and install:</p> <ul> <li>Python Download</li> </ul> <p>Verify installation:</p> <pre><code>python --version\n# Should show: Python 3.8.x or higher\n</code></pre> <p>On Windows you may need: <pre><code>py --version\n# or\npython3 --version\n</code></pre></p>"},{"location":"All_Guides/Your_First_Project/#step-2-create-a-new-python-project","title":"Step 2: Create a New Python Project","text":"<p>Open a terminal (command prompt) and execute:</p> <pre><code># Create project folder\nmkdir MyMT5Project\ncd MyMT5Project\n\n# Create virtual environment (recommended)\npython -m venv venv\n\n# Activate virtual environment\n# On Windows:\nvenv\\Scripts\\activate\n\n# On Linux/Mac:\nsource venv/bin/activate\n</code></pre> <p>What happened:</p> <ul> <li>\u2705 Created <code>MyMT5Project</code> folder</li> <li>\u2705 Created <code>venv</code> virtual environment - isolated Python environment</li> <li>\u2705 Activated environment - now you can install packages</li> </ul>"},{"location":"All_Guides/Your_First_Project/#step-3-install-metarpcmt5-package","title":"Step 3: Install MetaRpcMT5 Package","text":"<p>This is the most important step - installing the single package that contains everything you need:</p> <pre><code>pip install git+https://github.com/MetaRPC/PyMT5.git#subdirectory=package\n</code></pre> <p>\ud83d\udccc Important: The package will be installed in the <code>venv/</code> virtual environment of your project (not globally on the computer).</p> <p>How to verify installation?</p> <p>Choose any method:</p> <pre><code># Method 1: Full package information\npip show MetaRpcMT5\n\n# Method 2: Import check\npython -c \"from MetaRpcMT5 import MT5Account; print('\u2705 OK')\"\n\n# Method 3: Package list (Windows PowerShell)\npip list | Select-String \"MetaRpcMT5\"\n\n# Method 3: Package list (Linux/Mac)\npip list | grep MetaRpcMT5\n</code></pre> <p>If you see package information - installation successful! \u2705</p>"},{"location":"All_Guides/Your_First_Project/#step-4-create-configuration-file-settingsjson","title":"Step 4: Create Configuration File settings.json","text":"<p>You have two ways to store connection settings:</p>"},{"location":"All_Guides/Your_First_Project/#method-1-json-file-recommended-for-beginners","title":"Method 1: JSON file (recommended for beginners)","text":"<p>Create a <code>settings.json</code> file in the project root:</p> <p>Basic variant (minimum parameters): <pre><code>{\n  \"user\": 591129415,\n  \"password\": \"YourPassword123\",\n  \"grpc_server\": \"mt5.mrpc.pro:443\",\n  \"mt_cluster\": \"YourBroker-MT5 Demo\",\n  \"test_symbol\": \"EURUSD\"\n}\n</code></pre></p> <p>Extended variant (all parameters): <pre><code>{\n  \"user\": 591129415,\n  \"password\": \"YourPassword123\",\n  \"host\": \"mt5.mrpc.pro\",\n  \"port\": 443,\n  \"grpc_server\": \"mt5.mrpc.pro:443\",\n  \"mt_cluster\": \"YourBroker-MT5 Demo\",\n  \"test_symbol\": \"EURUSD\",\n  \"test_volume\": 0.01\n}\n</code></pre></p> <p>Parameter explanation:</p> Parameter Required Description user \u2705 Yes Your MT5 account number (login) password \u2705 Yes Master password for MT5 account grpc_server \u2705 Yes gRPC gateway address: <code>mt5.mrpc.pro:443</code> mt_cluster \u2705 Yes Broker cluster name (server name in MT5) test_symbol \u2705 Yes Trading symbol: <code>EURUSD</code>, <code>GBPUSD</code>, etc. host \u26aa No gRPC server host separately: <code>mt5.mrpc.pro</code> port \u26aa No gRPC server port: <code>443</code> test_volume \u26aa No Volume for test orders: <code>0.01</code>"},{"location":"All_Guides/Your_First_Project/#method-2-environment-variables-for-production","title":"Method 2: Environment variables (for production)","text":"<p>Instead of JSON, you can use environment variables:</p> <p>Windows (PowerShell):</p> <pre><code>$env:MT5_USER=\"591129415\"\n$env:MT5_PASSWORD=\"YourPassword123\"\n$env:MT5_GRPC_SERVER=\"mt5.mrpc.pro:443\"\n$env:MT5_CLUSTER=\"YourBroker-MT5 Demo\"\n$env:MT5_TEST_SYMBOL=\"EURUSD\"\n</code></pre> <p>Linux/Mac (Bash):</p> <pre><code>export MT5_USER=\"591129415\"\nexport MT5_PASSWORD=\"YourPassword123\"\nexport MT5_GRPC_SERVER=\"mt5.mrpc.pro:443\"\nexport MT5_CLUSTER=\"YourBroker-MT5 Demo\"\nexport MT5_TEST_SYMBOL=\"EURUSD\"\n</code></pre> <p>\ud83d\udca1 Tip: For this guide, use Method 1 (JSON) - it's simpler for beginners</p>"},{"location":"All_Guides/Your_First_Project/#step-5-write-code-to-connect-and-get-account-information","title":"Step 5: Write Code to Connect and Get Account Information","text":"<p>Create a <code>main.py</code> file in the project root:</p> <pre><code>\"\"\"\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nYOUR FIRST PROJECT WITH MT5\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nThis script demonstrates:\n  - Creating MT5Account\n  - Connecting to MT5 via gRPC\n  - Getting account information\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\"\"\"\n\nimport asyncio\nimport json\nimport sys\nfrom uuid import uuid4\nfrom datetime import datetime\n\n# Import MetaRpcMT5\nfrom MetaRpcMT5 import MT5Account\n\n\ndef load_settings():\n    \"\"\"Load settings from settings.json\"\"\"\n    with open('settings.json', 'r', encoding='utf-8') as f:\n        return json.load(f)\n\n\nasync def main():\n    \"\"\"Main function\"\"\"\n\n    print(\"\u2550\" * 80)\n    print(\"          WELCOME TO YOUR FIRST PROJECT WITH MT5\")\n    print(\"\u2550\" * 80)\n    print()\n\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    # STEP 1: LOAD CONFIGURATION\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    print(\"\ud83d\udccb Loading configuration...\")\n\n    try:\n        config = load_settings()\n    except FileNotFoundError:\n        print(\"\u274c Error: settings.json file not found!\")\n        print(\"   Create settings.json with your MT5 credentials\")\n        sys.exit(1)\n    except json.JSONDecodeError as e:\n        print(f\"\u274c Error: invalid JSON in settings.json: {e}\")\n        sys.exit(1)\n\n    print(\"\u2705 Configuration loaded:\")\n    print(f\"   User:           {config['user']}\")\n    print(f\"   Cluster:        {config['mt_cluster']}\")\n    print(f\"   gRPC Server:    {config['grpc_server']}\")\n    print(f\"   Test Symbol:    {config['test_symbol']}\")\n    print()\n\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    # STEP 2: CREATE MT5ACCOUNT\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    print(\"\ud83d\udd0c Creating MT5Account instance...\")\n\n    # Generate unique UUID for this terminal\n    terminal_guid = uuid4()\n\n    # Create MT5Account with credentials\n    account = MT5Account(\n        user=config['user'],\n        password=config['password'],\n        grpc_server=config['grpc_server'],\n        id_=terminal_guid\n    )\n\n    print(f\"\u2705 MT5Account created (UUID: {terminal_guid})\")\n    print()\n\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    # STEP 3: CONNECT TO MT5\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    print(\"\ud83d\udd17 Connecting to MT5 terminal...\")\n    print(f\"   Waiting for response (timeout: 120 seconds)...\")\n    print()\n\n    try:\n        # Connect to MT5 using server name\n        # This is the RECOMMENDED method - simpler than ConnectEx\n        await account.connect_by_server_name(\n            server_name=config['mt_cluster'],\n            base_chart_symbol=config['test_symbol'],\n            timeout_seconds=120\n        )\n\n        print(f\"\u2705 Successfully connected!\")\n        print(f\"   Terminal GUID: {account.id}\")\n        print()\n\n    except Exception as e:\n        print(f\"\u274c Connection error: {e}\")\n        print(\"   Check:\")\n        print(\"   - Correct login/password\")\n        print(\"   - gRPC server availability\")\n        print(\"   - Correct cluster name\")\n        await account.channel.close()\n        sys.exit(1)\n\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    # STEP 4: GET ACCOUNT INFORMATION\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    print(\"\ud83d\udcca Getting account information...\")\n    print()\n\n    try:\n        # Request full account information in one call\n        summary_data = await account.account_summary()\n\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # STEP 5: OUTPUT RESULTS\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n        print()\n        print(\"\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\")\n        print(\"\u2551              ACCOUNT INFORMATION                               \u2551\")\n        print(\"\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\")\n        print()\n        print(f\"   Login:              {summary_data.account_login}\")\n        print(f\"   User name:          {summary_data.account_user_name}\")\n        print(f\"   Company:            {summary_data.account_company_name}\")\n        print(f\"   Currency:           {summary_data.account_currency}\")\n        print()\n        print(f\"\ud83d\udcb0 Balance:            {summary_data.account_balance:.2f} {summary_data.account_currency}\")\n        print(f\"\ud83d\udc8e Equity:             {summary_data.account_equity:.2f} {summary_data.account_currency}\")\n        print()\n        print(f\"   Credit:             {summary_data.account_credit:.2f} {summary_data.account_currency}\")\n        print(f\"   Leverage:           1:{summary_data.account_leverage}\")\n        print(f\"   Trade mode:         {summary_data.account_trade_mode}\")\n        print()\n\n        # Server time - protobuf Timestamp, needs conversion\n        if summary_data.server_time:\n            server_time = summary_data.server_time.ToDatetime()\n            print(f\"   Server time:        {server_time.strftime('%Y-%m-%d %H:%M:%S')}\")\n\n        # UTC offset: server time offset from UTC in minutes\n        # Example: 120 minutes = UTC+2 (server is 2 hours ahead of UTC)\n        utc_shift = summary_data.utc_timezone_server_time_shift_minutes\n        print(f\"   UTC offset:         {utc_shift} minutes (UTC{utc_shift/60:+.1f})\")\n\n        print()\n        print(\"\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\")\n\n    except Exception as e:\n        print(f\"\u274c Error getting account data: {e}\")\n        await account.channel.close()\n        sys.exit(1)\n\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    # STEP 6: DISCONNECT FROM MT5\n    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    print()\n    print(\"\ud83d\udd0c Disconnecting from MT5...\")\n\n    try:\n        await account.channel.close()\n        print(\"\u2705 Successfully disconnected!\")\n    except Exception as e:\n        print(f\"\u26a0\ufe0f  Disconnect warning: {e}\")\n\n    print()\n    print(\"\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\")\n    print(\"\u2551   \ud83c\udf89 CONGRATULATIONS! YOUR FIRST PROJECT WORKS! \ud83c\udf89             \u2551\")\n    print(\"\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\")\n    print()\n\n\nif __name__ == \"__main__\":\n    # Run async function\n    asyncio.run(main())\n</code></pre>"},{"location":"All_Guides/Your_First_Project/#step-6-run-the-project","title":"Step 6: Run the Project","text":"<p>Save all files and execute:</p> <pre><code>python main.py\n</code></pre> <p>Expected output:</p> <pre><code>\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n          WELCOME TO YOUR FIRST PROJECT WITH MT5\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n\ud83d\udccb Loading configuration...\n\u2705 Configuration loaded:\n   User:           591129415\n   Cluster:        FxPro-MT5 Demo\n   gRPC Server:    mt5.mrpc.pro:443\n   Test Symbol:    EURUSD\n\n\ud83d\udd0c Creating MT5Account instance...\n\u2705 MT5Account created (UUID: 12345678-90ab-cdef-1234-567890abcdef)\n\n\ud83d\udd17 Connecting to MT5 terminal...\n   Waiting for response (timeout: 120 seconds)...\n\n\u2705 Successfully connected!\n   Terminal GUID: 12345678-90ab-cdef-1234-567890abcdef\n\n\ud83d\udcca Getting account information...\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n             ACCOUNT INFORMATION                               \n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n   Login:              591129415\n   User name:          Demo User\n   Company:            FxPro Financial Services Ltd\n   Currency:           USD\n\n\ud83d\udcb0 Balance:            10000.00 USD\n\ud83d\udc8e Equity:             10000.00 USD\n\n   Credit:             0.00 USD\n   Leverage:           1:100\n   Trade mode:         0\n\n   Server time:        2026-02-04 15:30:45\n   UTC offset:         120 minutes (UTC+2.0)\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n\ud83d\udd0c Disconnecting from MT5...\n\u2705 Successfully disconnected!\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n   \ud83c\udf89 CONGRATULATIONS! YOUR FIRST PROJECT WORKS! \ud83c\udf89            \n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n</code></pre>"},{"location":"All_Guides/Your_First_Project/#congratulations-you-did-it","title":"\ud83c\udf89 Congratulations! You Did It!","text":"<p>You just:</p> <p>\u2705 Created a new Python project from scratch</p> <p>\u2705 Integrated the single Python package <code>MetaRpcMT5</code> to work with MT5</p> <p>\u2705 Configured connection parameters</p> <p>\u2705 Connected to MT5 terminal via gRPC</p> <p>\u2705 Retrieved full account information programmatically</p> <p>This was a low-level approach using <code>MT5Account</code> and protobuf directly.</p>"},{"location":"All_Guides/Your_First_Project/#your-project-structure","title":"\ud83d\udcc1 Your Project Structure","text":"<p>After completing all steps, the project structure should look like this:</p> <pre><code>MyMT5Project/\n\u251c\u2500\u2500 venv/                # Python virtual environment\n\u251c\u2500\u2500 settings.json        # MT5 connection configuration\n\u251c\u2500\u2500 main.py              # Main application code\n</code></pre> <p>requirements.txt contents (optional):</p> <p>If you want to save dependencies:</p> <pre><code>pip freeze &gt; requirements.txt\n</code></pre> <p>The content will be approximately:</p> <pre><code>MetaRpcMT5 @ git+https://github.com/MetaRPC/PyMT5.git@main#subdirectory=package\ngrpcio&gt;=1.60.0\ngrpcio-tools&gt;=1.60.0\ngoogleapis-common-protos&gt;=1.56.0\n</code></pre>"},{"location":"All_Guides/Your_First_Project/#whats-next","title":"\ud83d\ude80 What's Next?","text":"<p>Now that you have a working project, you can:</p>"},{"location":"All_Guides/Your_First_Project/#1-add-more-functionality","title":"1. Add More Functionality","text":"<p>Examples of what you can do:</p>"},{"location":"All_Guides/Your_First_Project/#get-current-quotes","title":"Get Current Quotes","text":"<pre><code># Get last tick for symbol\ntick_data = await account.symbol_info_tick(symbol=config['test_symbol'])\n\nprint(f\"Last tick for {config['test_symbol']}:\")\nprint(f\"  Bid: {tick_data.bid:.5f}\")\nprint(f\"  Ask: {tick_data.ask:.5f}\")\nprint(f\"  Last: {tick_data.last:.5f}\")\n</code></pre>"},{"location":"All_Guides/Your_First_Project/#get-all-open-positions","title":"Get All Open Positions","text":"<pre><code># Get all open orders and positions\nopened_data = await account.opened_orders()\n\nprint(f\"Open positions: {len(opened_data.position_infos)}\")\nfor pos in opened_data.position_infos:\n    print(f\"  #{pos.ticket} {pos.symbol} {pos.volume:.2f} lots, Profit: {pos.profit:.2f}\")\n</code></pre>"},{"location":"All_Guides/Your_First_Project/#open-market-order","title":"Open Market Order","text":"<pre><code>from MetaRpcMT5 import mt5_term_api_trading_helper_pb2 as trading_pb2\n\n# Create order request\norder_req = trading_pb2.OrderSendRequest(\n    symbol=config['test_symbol'],\n    operation=trading_pb2.TMT5_ORDER_TYPE_BUY,  # Buy\n    volume=0.01,  # 0.01 lot\n    comment=\"PyMT5 Test Order\"\n)\n\n# Send order\norder_result = await account.order_send(order_req)\n\nif order_result.retcode == 10009:  # TRADE_RETCODE_DONE\n    print(f\"\u2705 Order opened: Deal #{order_result.deal}, Order #{order_result.order}\")\nelse:\n    print(f\"\u274c Order error: code {order_result.retcode}\")\n</code></pre>"},{"location":"All_Guides/Your_First_Project/#data-streaming","title":"Data Streaming","text":"<pre><code># Subscribe to real-time ticks\n# The on_symbol_tick method accepts a list of symbols directly\ntick_stream = account.on_symbol_tick(\n    symbols=[config['test_symbol']]\n)\n\nprint(f\"\ud83d\udd04 Receiving tick stream for {config['test_symbol']}...\")\nprint(\"   (Press Ctrl+C to stop)\")\n\nevent_count = 0\ntry:\n    async for tick_event in tick_stream:\n        event_count += 1\n        tick = tick_event.symbol_tick\n        print(f\"[{event_count}] Bid: {tick.bid:.5f}, Ask: {tick.ask:.5f}\")\n\n        # Stop after 10 events (for example)\n        if event_count &gt;= 10:\n            break\n\nexcept KeyboardInterrupt:\n    print(f\"\\n\u2705 Received {event_count} events\")\n</code></pre>"},{"location":"All_Guides/Your_First_Project/#2-study-the-complete-sdk-architecture","title":"2. Study the Complete SDK Architecture","text":"<p>The PyMT5 repository has three API levels:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502  MT5Sugar (Level 3) - Convenient API\n\u2502  examples/3_sugar/\n\u2502  sugar.buy_market(\"EURUSD\", 0.01)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              \u2193 uses\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502  MT5Service (Level 2) - Wrappers\n\u2502  examples/2_service/\n\u2502  service.get_balance()\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n              \u2193 uses\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502  MT5Account (Level 1) - Base gRPC \u2b50\n\u2502  package/MetaRpcMT5/helpers/mt5_account.py\n\u2502  account.account_summary()\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n</code></pre> <p>You just used Level 1 (MT5Account) - this is the foundation of everything!</p> <p>To study levels 2 and 3:</p> <ul> <li>Explore examples in the <code>examples/</code> folder</li> <li>Read MT5Account.Master.Overview.md</li> <li>Check out ready-made demonstrations</li> </ul>"},{"location":"All_Guides/Your_First_Project/#3-explore-ready-made-examples","title":"3. Explore Ready-Made Examples","text":"<p>The PyMT5 repository contains many examples:</p> <ul> <li><code>examples/1_lowlevel/</code> - examples with MT5Account (what you used)</li> <li><code>examples/2_service/</code> - examples with MT5Service</li> <li><code>examples/3_sugar/</code> - examples with MT5Sugar</li> <li><code>examples/4_orchestrators/</code> - complex trading strategies</li> </ul> <p>Running examples:</p> <pre><code>cd examples\npython main.py\n# Select the desired example from the interactive menu\n</code></pre>"},{"location":"All_Guides/Your_First_Project/#4-read-the-documentation","title":"4. Read the Documentation","text":"<ul> <li>MT5Account API Reference - \u2b50 complete reference for the base level</li> <li>MT5Account.Master.Overview.md - project map and architecture</li> <li>GRPC_STREAM_MANAGEMENT.md - working with streaming data</li> <li>RETURN_CODES_REFERENCE.md - operation return codes</li> <li>ENUMS_USAGE_REFERENCE.md - using enumerations</li> </ul>"},{"location":"All_Guides/Your_First_Project/#frequently-asked-questions","title":"\u2753 Frequently Asked Questions","text":""},{"location":"All_Guides/Your_First_Project/#what-is-the-metarpcmt5-package","title":"What Is the MetaRpcMT5 Package?","text":"<p><code>MetaRpcMT5</code> is an independent Python package that contains:</p> <ul> <li>MT5Account (base gRPC client)</li> <li>All protobuf definitions of MT5 API</li> <li>gRPC stubs for all methods</li> <li>Helper types and structures</li> </ul> <p>It's a portable package - you can use it in any Python project!</p>"},{"location":"All_Guides/Your_First_Project/#how-to-work-with-environment-variables-instead-of-settingsjson","title":"How to Work with Environment Variables Instead of settings.json?","text":"<p>You can use environment variables:</p> <pre><code>import os\n\ndef load_settings_from_env():\n    \"\"\"Load settings from environment variables\"\"\"\n    return {\n        'user': int(os.getenv('MT5_USER')),\n        'password': os.getenv('MT5_PASSWORD'),\n        'grpc_server': os.getenv('MT5_GRPC_SERVER'),\n        'mt_cluster': os.getenv('MT5_CLUSTER'),\n        'test_symbol': os.getenv('MT5_TEST_SYMBOL', 'EURUSD')\n    }\n</code></pre> <p>Set variables:</p> <pre><code># Windows (PowerShell)\n$env:MT5_USER=\"591129415\"\n$env:MT5_PASSWORD=\"YourPassword123\"\n$env:MT5_GRPC_SERVER=\"mt5.mrpc.pro:443\"\n$env:MT5_CLUSTER=\"FxPro-MT5 Demo\"\n$env:MT5_TEST_SYMBOL=\"EURUSD\"\n\n# Linux/Mac\nexport MT5_USER=\"591129415\"\nexport MT5_PASSWORD=\"YourPassword123\"\nexport MT5_GRPC_SERVER=\"mt5.mrpc.pro:443\"\nexport MT5_CLUSTER=\"FxPro-MT5 Demo\"\nexport MT5_TEST_SYMBOL=\"EURUSD\"\n</code></pre>"},{"location":"All_Guides/Your_First_Project/#how-to-use-level-2-mt5service-and-level-3-mt5sugar","title":"How to Use Level 2 (MT5Service) and Level 3 (MT5Sugar)?","text":"<p>These levels are in the main PyMT5 repository:</p> <ol> <li>Clone the repository (or download files):</li> </ol> <pre><code>git clone https://github.com/MetaRPC/PyMT5.git\n</code></pre> <ol> <li> <p>Copy the necessary files to your project:</p> </li> <li> <p>From the <code>src/</code> folder (or corresponding)</p> </li> <li> <p>MT5Service and MT5Sugar classes</p> </li> <li> <p>Use convenient methods:</p> </li> </ol> <pre><code>from mt5_service import MT5Service\nfrom mt5_sugar import MT5Sugar\n\n# Level 2 - Service\nservice = MT5Service(account)\nbalance = await service.get_balance()\n\n# Level 3 - Sugar\nsugar = MT5Sugar(service)\nticket = await sugar.buy_market(\"EURUSD\", 0.01)\n</code></pre> <p>See details in MT5Account.Master.Overview.md</p>"},{"location":"All_Guides/Your_First_Project/#what-to-do-if-errors-occur","title":"What to Do If Errors Occur?","text":"<p>Connection error:</p> <ul> <li>Check correct login/password</li> <li>Make sure gRPC server is available</li> <li>Check cluster name (exact MT5 server name)</li> </ul> <p>Connection timeout:</p> <ul> <li>Increase <code>timeout_seconds</code> to 180 or 240</li> <li>Check internet connection</li> <li>Check firewall/antivirus</li> </ul> <p>Import errors:</p> <ul> <li>Make sure virtual environment is activated</li> <li>Reinstall package:</li> </ul> <p>Windows PowerShell:</p> <pre><code>pip uninstall MetaRpcMT5 -y\npip install git+https://github.com/MetaRPC/PyMT5.git#subdirectory=package\n</code></pre> <p>Linux/Mac/PowerShell 7+:</p> <pre><code>pip uninstall MetaRpcMT5 &amp;&amp; pip install git+https://github.com/MetaRPC/PyMT5.git#subdirectory=package\n</code></pre>"},{"location":"All_Guides/Your_First_Project/#summary-what-we-did","title":"\ud83d\udcdd Summary: What We Did","text":"<p>In this guide, you created a minimalist project that:</p> <ol> <li> <p>\u2705 Uses only Python modules - doesn't require cloning the repository</p> </li> <li> <p>\u2705 Imports MetaRpcMT5 package - the only dependency for MT5</p> </li> <li> <p>\u2705 Connects to MT5 via gRPC gateway</p> </li> <li> <p>\u2705 Reads configuration from <code>settings.json</code></p> </li> <li> <p>\u2705 Uses MT5Account (Level 1 - base level)</p> </li> <li> <p>\u2705 Gets account information and outputs to console</p> </li> </ol> <p>This is the foundation for any of your MT5 projects in Python.</p> <p>Good luck developing trading systems! \ud83d\ude80</p> <p>\"Trade safely, code cleanly, and may your gRPC connections always be stable.\"</p>"},{"location":"MT5Account/MT5Account.Master.Overview/","title":"MT5Account - Master Overview","text":"<p>One page to orient fast: what lives where, how to choose the right API, and jump links to every overview and method spec in this docs set.</p>"},{"location":"MT5Account/MT5Account.Master.Overview/#start-here-section-overviews","title":"\ud83d\udea6 Start here - Section Overviews","text":"<ul> <li> <p>1. Account Information - Overview   Account balance/equity/margin/leverage, complete snapshot or single properties.</p> </li> <li> <p>2. Symbol Information - Overview   Quotes, symbol properties, trading rules, Market Watch management.</p> </li> <li> <p>3. Positions &amp; Orders - Overview   Open positions, pending orders, historical deals, order history.</p> </li> <li> <p>4. Market Depth (DOM) - Overview   Level II quotes, order book data, market depth subscription.</p> </li> <li> <p>5. Trading Operations - Overview   Order execution, position management, margin calculations, trade validation.</p> </li> <li> <p>6. Streaming Methods - Overview   Real-time streams: ticks, trades, profit updates, transaction log.</p> </li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#how-to-pick-an-api","title":"\ud83e\udded How to pick an API","text":"If you need... Go to... Typical methods Account snapshot Account Information <code>account_summary()</code>, <code>account_info_double()</code>, <code>account_info_integer()</code> Quotes &amp; symbol properties Symbol Information <code>symbol_info_tick()</code>, <code>symbol_info_double()</code>, <code>symbols_total()</code> Current positions &amp; orders Positions &amp; Orders <code>positions_total()</code>, <code>opened_orders()</code>, <code>opened_orders_tickets()</code> Historical trades Positions &amp; Orders <code>order_history()</code>, <code>positions_history()</code> Tick values for P/L calculation Positions &amp; Orders <code>tick_value_with_size()</code> Level II / Order book Market Depth (DOM) <code>market_book_add()</code>, <code>market_book_get()</code>, <code>market_book_release()</code> Trading operations Trading Operations <code>order_send()</code>, <code>order_modify()</code>, <code>order_close()</code> Pre-trade calculations Trading Operations <code>order_calc_margin()</code>, <code>order_check()</code> Real-time updates Streaming Methods <code>on_symbol_tick()</code>, <code>on_trade()</code>, <code>on_position_profit()</code>"},{"location":"MT5Account/MT5Account.Master.Overview/#usage-pattern-python-asyncawait","title":"\ud83d\udd0c  Usage pattern (Python async/await)","text":"<p>Every method follows async pattern with gRPC under the hood:</p> <pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def main():\n    # Create MT5Account instance using create() - RECOMMENDED\n    account = MT5Account.create(\n        user=591129415,\n        password=\"IpoHj17tYu67@\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    # Connect to MT5 terminal\n    await account.connect_by_server_name(\n        server_name=\"FxPro-MT5 Demo\",\n        base_chart_symbol=\"EURUSD\",\n        timeout_seconds=120\n    )\n\n    try:\n        # Call async method - using account_summary() (RECOMMENDED)\n        summary = await account.account_summary()\n        print(f\"Balance: ${summary.account_balance:.2f}\")\n        print(f\"Equity:  ${summary.account_equity:.2f}\")\n\n    finally:\n        # Always close connection\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre> <p>Every method follows the same shape:</p> <ul> <li>Async/Await: All methods are <code>async</code> - use <code>await</code> to call them</li> <li>Automatic reconnection: Built-in <code>execute_with_reconnect</code> wrapper for resilience</li> <li>Protobuf messages: Request/Response use protobuf structures under the hood</li> <li>Return codes: Trading operations return status codes (10009 = success)</li> <li>Streaming methods: Use <code>async for</code> to consume real-time data streams</li> </ul> <p>Timestamps: Unix timestamps (seconds since epoch) or <code>datetime</code> objects.</p> <p>Streaming methods: Return async generators - use <code>async for</code> loop to receive updates.</p>"},{"location":"MT5Account/MT5Account.Master.Overview/#full-index-all-method-specs","title":"\ud83d\udcda Full Index - All Method Specs","text":""},{"location":"MT5Account/MT5Account.Master.Overview/#1-account-information","title":"\ud83d\udcc4 1. Account Information","text":"<ul> <li>Overview: Account_Information.Overview.md</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#complete-snapshot","title":"Complete Snapshot","text":"<ul> <li>account_summary.md - All account info at once (balance, equity, margin, etc.)</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#individual-properties","title":"Individual Properties","text":"<ul> <li>account_info_double.md - Single double value (balance, equity, margin, profit, etc.)</li> <li>account_info_integer.md - Single integer value (login, leverage, limit orders, etc.)</li> <li>account_info_string.md - Single string value (name, server, currency, company)</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#2-symbol-information","title":"\ud83d\udcca 2. Symbol Information","text":"<ul> <li>Overview: Symbol_Information.Overview.md</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#symbol-management","title":"Symbol Management","text":"<ul> <li>symbols_total.md - Count of available symbols</li> <li>symbol_exist.md - Check if symbol exists on platform</li> <li>symbol_name.md - Get symbol name by index position</li> <li>symbol_select.md - Add/remove symbol from Market Watch</li> <li>symbol_is_synchronized.md - Check if symbol data is synchronized</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#symbol-properties","title":"Symbol Properties","text":"<ul> <li>symbol_info_double.md - Single double property (BID, ASK, POINT, etc.)</li> <li>symbol_info_integer.md - Single integer property (DIGITS, SPREAD, etc.)</li> <li>symbol_info_string.md - Single string property (DESCRIPTION, CURRENCY_BASE, etc.)</li> <li>symbol_info_tick.md - Current tick data (BID, ASK, volume, time)</li> <li>symbol_params_many.md - All symbol parameters at once (RECOMMENDED)</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#trading-conditions","title":"Trading Conditions","text":"<ul> <li>symbol_info_margin_rate.md - Margin rates for symbol and order type</li> <li>symbol_info_session_quote.md - Quote session times for day of week</li> <li>symbol_info_session_trade.md - Trade session times for day of week</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#3-positions-orders","title":"\ud83d\udce6 3. Positions &amp; Orders","text":"<ul> <li>Overview: Positions_Orders.Overview.md</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#current-positions-orders","title":"Current Positions &amp; Orders","text":"<ul> <li>positions_total.md - Count of open positions (lightweight)</li> <li>opened_orders.md - Full details of all open orders/positions</li> <li>opened_orders_tickets.md - Ticket IDs only (lighter payload)</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#historical-data","title":"Historical Data","text":"<ul> <li>order_history.md - Historical orders/deals within time range</li> <li>positions_history.md - Historical closed positions</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#calculations","title":"Calculations","text":"<ul> <li>tick_value_with_size.md - Tick values and contract sizes for P/L calculation</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#4-market-depth-dom","title":"\ud83d\udcc8 4. Market Depth (DOM)","text":"<ul> <li>Overview: Market_Depth.Overview.md</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#level-ii-quotes","title":"Level II Quotes","text":"<ul> <li>market_book_add.md - Subscribe to Market Depth for symbol</li> <li>market_book_get.md - Get current order book data</li> <li>market_book_release.md - Unsubscribe from Market Depth</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#5-trading-operations","title":"\ud83d\udee0 5. Trading Operations","text":"<ul> <li>Overview: Trading_Operations.Overview.md</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#order-execution-management","title":"Order Execution &amp; Management","text":"<ul> <li>order_send.md - Place market or pending orders</li> <li>order_modify.md - Modify SL/TP or order parameters</li> <li>order_close.md - Close positions (full or partial)</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#pre-trade-calculations","title":"Pre-Trade Calculations","text":"<ul> <li>order_calc_margin.md - Calculate margin required for trade</li> <li>order_check.md - Validate trade request before execution</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#6-streaming-methods","title":"\ud83d\udce1 6. Streaming Methods","text":"<ul> <li>Overview: Streaming_Methods.Overview.md</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#real-time-price-updates","title":"Real-Time Price Updates","text":"<ul> <li>on_symbol_tick.md - Real-time tick stream for symbols</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#trading-events","title":"Trading Events","text":"<ul> <li>on_trade.md - Position/order changes (opened, closed, modified)</li> <li>on_trade_transaction.md - Detailed transaction log (complete audit trail)</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#position-monitoring","title":"Position Monitoring","text":"<ul> <li>on_position_profit.md - Periodic profit/loss updates</li> <li>on_positions_and_pending_orders_tickets.md - Periodic ticket lists (lightweight)</li> </ul>"},{"location":"MT5Account/MT5Account.Master.Overview/#quick-navigation-by-use-case","title":"\ud83c\udfaf Quick Navigation by Use Case","text":"I want to... Use this method ACCOUNT INFORMATION Get complete account snapshot account_summary Get account balance account_info_double (BALANCE) Get account equity account_info_double (EQUITY) Get account leverage account_info_integer (LEVERAGE) Get account currency account_info_string (CURRENCY) POSITIONS &amp; ORDERS Get count of open positions positions_total Get all open orders/positions opened_orders Get ticket IDs only opened_orders_tickets Get order history order_history Get closed positions history positions_history Get tick values for P/L calculation tick_value_with_size MARKET DEPTH Subscribe to Level II quotes market_book_add Get order book data market_book_get Unsubscribe from Level II market_book_release TRADING OPERATIONS Open market BUY position order_send (operation=0) Open market SELL position order_send (operation=1) Place BUY LIMIT order order_send (operation=2) Place SELL LIMIT order order_send (operation=3) Place BUY STOP order order_send (operation=4) Place SELL STOP order order_send (operation=5) Modify SL/TP of position order_modify Close a position order_close Calculate margin before trade order_calc_margin Validate trade before execution order_check REAL-TIME SUBSCRIPTIONS Stream live prices on_symbol_tick Monitor trade events on_trade Track profit changes on_position_profit Monitor ticket changes on_positions_and_pending_orders_tickets Detailed transaction log on_trade_transaction"},{"location":"MT5Account/MT5Account.Master.Overview/#key-concepts","title":"\ud83d\udca1 Key Concepts","text":""},{"location":"MT5Account/MT5Account.Master.Overview/#return-codes-trading-operations","title":"Return Codes (Trading Operations)","text":"<ul> <li>10009 = Success / DONE</li> <li>10004 = Requote</li> <li>10006 = Request rejected</li> <li>10013 = Invalid request</li> <li>10014 = Invalid volume</li> <li>10015 = Invalid price</li> <li>10016 = Invalid stops</li> <li>10018 = Market closed</li> <li>10019 = Not enough money</li> <li>10031 = No connection with trade server</li> </ul> <p>Always check <code>returned_code</code> field in trading operation results.</p>"},{"location":"MT5Account/MT5Account.Master.Overview/#important-notes","title":"Important Notes","text":"<ul> <li>Check return codes: Every trading operation returns status code (10009 = success)</li> <li>Validate parameters: Use <code>order_check()</code> before <code>order_send()</code></li> <li>Handle exceptions: Network/protocol errors can occur</li> <li>Async context: All methods must be called within async context</li> <li>Stream cleanup: Cancel streams properly using <code>cancellation_event</code></li> <li>UTC timestamps: All times are in UTC, not local time</li> <li>Broker limitations: Not all brokers support all features (DOM, hedging, etc.)</li> <li>Automatic reconnection: All methods have built-in reconnection logic</li> </ul> <p>\"Trade safe, code clean, and may your async streams always flow smoothly.\"</p>"},{"location":"MT5Account/1.%20Account_Information/Account_Information.Overview/","title":"MT5Account - Account Information - Overview","text":"<p>Account balance, equity, margin, leverage, currency, and other account properties. Use this page to choose the right API for accessing account state.</p>"},{"location":"MT5Account/1.%20Account_Information/Account_Information.Overview/#what-lives-here","title":"\ud83d\udcc1 What lives here","text":"<ul> <li>account_summary - all account info at once (balance, equity, leverage, credit, server time, etc.). RECOMMENDED</li> <li>account_info_double - single double value from account (balance, equity, margin, profit, credit, margin level, etc.).</li> <li>account_info_integer - single integer value from account (login, leverage, trade mode, limit orders, trade allowed, etc.).</li> <li>account_info_string - single string value from account (name, server, currency, company).</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/Account_Information.Overview/#step-by-step-tutorials","title":"\ud83d\udcda Step-by-step tutorials","text":"<p>Want detailed explanations with line-by-line code breakdown? Check these guides:</p> <ul> <li>account_summary - How it works</li> <li>account_info_double - How it works</li> <li>account_info_integer - How it works</li> <li>account_info_string - How it works</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/Account_Information.Overview/#plain-english","title":"\ud83e\udded Plain English","text":"<ul> <li>account_summary - the one-stop shop for complete account snapshot (balance, equity, leverage, currency, etc.).</li> <li>account_info_double - grab one numeric property when you need just balance or margin.</li> <li>account_info_integer - grab one integer property like login number or leverage.</li> <li>account_info_string - grab one text property like account name or currency.</li> </ul> <p>Rule of thumb: need full snapshot - <code>account_summary()</code>; need one specific value - <code>account_info_*</code> (double/integer/string).</p>"},{"location":"MT5Account/1.%20Account_Information/Account_Information.Overview/#quick-choose","title":"Quick choose","text":"If you need Use Returns Key inputs Complete account snapshot (all values) <code>account_summary</code> AccountSummaryData (none) One numeric value (balance, equity, margin, etc.) <code>account_info_double</code> Single <code>float</code> Property enum (BALANCE, EQUITY, etc.) One integer value (login, leverage, etc.) <code>account_info_integer</code> Single <code>int</code> Property enum (LOGIN, LEVERAGE, etc.) One text value (name, currency, server, etc.) <code>account_info_string</code> Single <code>str</code> Property enum (NAME, CURRENCY, etc.)"},{"location":"MT5Account/1.%20Account_Information/Account_Information.Overview/#i-cross-refs-gotchas","title":"\u2139\ufe0f Cross-refs &amp; gotchas","text":"<ul> <li>Margin Level - use <code>account_info_double(ACCOUNT_MARGIN_LEVEL)</code> to get as percentage.</li> <li>Free Margin - use <code>account_info_double(ACCOUNT_MARGIN_FREE)</code> for available margin.</li> <li>account_summary includes basic info (balance, equity, leverage); for margin use <code>account_info_double</code>.</li> <li>account_info_* methods are lighter if you only need one property.</li> <li>Currency affects how profits are calculated - always check account currency.</li> <li>Leverage determines margin requirements - higher leverage = less margin needed.</li> <li>Deadline/timeout - Remember to set appropriate deadline for async calls.</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/Account_Information.Overview/#minimal-snippets","title":"\ud83d\udfe2 Minimal snippets","text":"<pre><code>from MetaRpcMT5.mt5_account import MT5Account\nimport MetaRpcMT5.mt5_term_api_account_information_pb2 as account_info_pb2\nfrom datetime import datetime, timedelta\n\n# Get complete account snapshot\nsummary = await account.account_summary()\n\nprint(f\"Balance: ${summary.account_balance:.2f}, \"\n      f\"Equity: ${summary.account_equity:.2f}, \"\n      f\"Leverage: 1:{summary.account_leverage}\")\n</code></pre> <pre><code># Get single property - account balance\ndeadline = datetime.utcnow() + timedelta(seconds=3)\n\nbalance = await account.account_info_double(\n    property_id=account_info_pb2.ACCOUNT_BALANCE,\n    deadline=deadline\n)\n\nprint(f\"Balance: ${balance:.2f}\")\n</code></pre> <pre><code># Get account leverage\nleverage = await account.account_info_integer(\n    property_id=account_info_pb2.ACCOUNT_LEVERAGE\n)\n\nprint(f\"Leverage: 1:{leverage}\")\n</code></pre> <pre><code># Get account currency\ncurrency = await account.account_info_string(\n    property_id=account_info_pb2.ACCOUNT_CURRENCY\n)\n\nprint(f\"Currency: {currency}\")\n</code></pre> <pre><code># Check account health\nsummary = await account.account_summary()\n\n# Get margin level (account_summary doesn't include margin, need separate call)\nmargin_level = await account.account_info_double(\n    account_info_pb2.ACCOUNT_MARGIN_LEVEL\n)\n\nif margin_level &lt; 100:\n    print(\"[WARNING] Margin level critical!\")\nelif margin_level &lt; 200:\n    print(\"[WARNING] Low margin level\")\nelse:\n    print(\"[OK] Healthy margin level\")\n</code></pre> <pre><code># Validate account before trading\nsummary = await account.account_summary()\n\n# Check if trading is allowed\ntrade_allowed = await account.account_info_integer(\n    account_info_pb2.ACCOUNT_TRADE_ALLOWED\n)\n\nif not trade_allowed:\n    raise RuntimeError(\"Trading is disabled on this account\")\n\n# Check minimum balance\nif summary.account_balance &lt; 100:\n    raise ValueError(f\"Balance too low: ${summary.account_balance:.2f}\")\n\nprint(f\"[OK] Account ready to trade\")\nprint(f\"   Balance: ${summary.account_balance:.2f} {summary.account_currency}\")\nprint(f\"   Leverage: 1:{summary.account_leverage}\")\n</code></pre> <pre><code># Monitor account equity in real-time\nasync def monitor_equity(interval: float = 5.0):\n    \"\"\"Monitor equity every N seconds\"\"\"\n    while True:\n        summary = await account.account_summary()\n\n        floating_pnl = summary.account_equity - summary.account_balance\n\n        print(f\"[{datetime.now().strftime('%H:%M:%S')}] \"\n              f\"Equity: ${summary.account_equity:,.2f} | \"\n              f\"Floating P/L: ${floating_pnl:+,.2f}\")\n\n        await asyncio.sleep(interval)\n\n# await monitor_equity(interval=5.0)\n</code></pre> <pre><code># Get all account details for logging\nasync def log_account_details():\n    \"\"\"Log comprehensive account information\"\"\"\n    summary = await account.account_summary()\n\n    # Get additional margin info\n    margin_level = await account.account_info_double(\n        account_info_pb2.ACCOUNT_MARGIN_LEVEL\n    )\n\n    free_margin = await account.account_info_double(\n        account_info_pb2.ACCOUNT_MARGIN_FREE\n    )\n\n    mode_names = {0: \"DEMO\", 1: \"CONTEST\", 2: \"REAL\"}\n    mode = mode_names.get(summary.account_trade_mode, \"UNKNOWN\")\n\n    print(f\"{'='*60}\")\n    print(f\"ACCOUNT DETAILS\")\n    print(f\"{'='*60}\")\n    print(f\"Login:          #{summary.account_login}\")\n    print(f\"Name:           {summary.account_user_name}\")\n    print(f\"Broker:         {summary.account_company_name}\")\n    print(f\"Mode:           {mode}\")\n    print(f\"Currency:       {summary.account_currency}\")\n    print(f\"Leverage:       1:{summary.account_leverage}\")\n    print(f\"\")\n    print(f\"Balance:        ${summary.account_balance:,.2f}\")\n    print(f\"Equity:         ${summary.account_equity:,.2f}\")\n    print(f\"Credit:         ${summary.account_credit:,.2f}\")\n    print(f\"Free Margin:    ${free_margin:,.2f}\")\n    print(f\"Margin Level:   {margin_level:.2f}%\")\n    print(f\"{'='*60}\")\n\n# await log_account_details()\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/Account_Information.Overview/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>Symbol Information: Symbol_Information.Overview - get symbol/market data</li> <li>Positions &amp; Orders: Positions_Orders.Overview - manage positions and orders</li> <li>Trading: Trading_Operations.Overview - place and manage trades</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/","title":"Getting Account Double Properties","text":"<p>Request: specific double-type account property from MT5 terminal using property identifier.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.account_info_double(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.AccountInformation</code></li> <li>Proto definition: <code>AccountInfoDouble</code> (defined in <code>mt5-term-api-account-information.proto</code>)</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.AccountInformation</code></li> <li>Method: <code>AccountInfoDouble(AccountInfoDoubleRequest) -&gt; AccountInfoDoubleReply</code></li> <li>Low-level client (generated): <code>AccountInformationStub.AccountInfoDouble(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Retrieve a specific double-type account property by ID (balance, equity, margin, etc.).</li> <li>Why you need it. Get individual account metrics without fetching all data. Useful for focused checks.</li> <li>When to use. Use <code>account_summary()</code> for multiple properties. Use this method for single property queries.</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to query specific numeric account properties:</p> <ul> <li>Check account balance before trading</li> <li>Monitor margin usage and margin level</li> <li>Verify free margin availability</li> <li>Track floating profit/loss</li> <li>Monitor margin call and stop out levels</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; account_info_double - How it works</p>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#method-signature","title":"Method Signature","text":"<pre><code>async def account_info_double(\n    self,\n    property_id: account_info_pb2.AccountInfoDoublePropertyType,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; float\n</code></pre> <p>Request message:</p> <pre><code>message AccountInfoDoubleRequest {\n  AccountInfoDoublePropertyType property_id = 1;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message AccountInfoDoubleReply {\n  oneof response {\n    AccountInfoDoubleData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage AccountInfoDoubleData {\n  double requested_value = 1;\n}\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>property_id</code> <code>AccountInfoDoublePropertyType</code> (enum) Property identifier specifying which property to retrieve <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation <p>Deadline options:</p> <pre><code>from datetime import datetime, timedelta\nimport MetaRpcMT5.mt5_term_api_account_information_pb2 as account_info_pb2\n\n# 1. With deadline (recommended)\ndeadline = datetime.utcnow() + timedelta(seconds=3)\nvalue = await account.account_info_double(\n    property_id=account_info_pb2.ACCOUNT_BALANCE,\n    deadline=deadline\n)\n\n# 2. With cancellation event\ncancel_event = asyncio.Event()\nvalue = await account.account_info_double(\n    property_id=account_info_pb2.ACCOUNT_BALANCE,\n    cancellation_event=cancel_event\n)\n\n# Later: cancel_event.set()\n\n# 3. No deadline (uses default timeout if configured)\nvalue = await account.account_info_double(\n    property_id=account_info_pb2.ACCOUNT_BALANCE\n)\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#output","title":"\u2b06\ufe0f Output","text":"Field Type Python Type Description <code>requested_value</code> <code>double</code> <code>float</code> The value of the requested account property <p>Return value: The method directly returns <code>float</code> (extracted from <code>AccountInfoDoubleData.requested_value</code>).</p>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":"<p>\ud83d\udca1 Note: The tables show simplified constant names for readability. In Python code, you can use either the full or short form:</p> <p>Full format: <code>account_info_pb2.AccountInfoDoublePropertyType.ACCOUNT_BALANCE</code> Short format: <code>account_info_pb2.ACCOUNT_BALANCE</code></p> <p>Both forms are valid in Python protobuf. We recommend the short format for simplicity.</p>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#accountinfodoublepropertytype","title":"<code>AccountInfoDoublePropertyType</code>","text":"<p>Defined in <code>mt5-term-api-account-information.proto</code>.</p> Constant Value Description <code>ACCOUNT_BALANCE</code> 0 Account balance in the deposit currency <code>ACCOUNT_CREDIT</code> 1 Account credit in the deposit currency <code>ACCOUNT_PROFIT</code> 2 Current profit of an account in the deposit currency <code>ACCOUNT_EQUITY</code> 3 Account equity in the deposit currency <code>ACCOUNT_MARGIN</code> 4 Account margin used in the deposit currency <code>ACCOUNT_MARGIN_FREE</code> 5 Free margin of an account in the deposit currency <code>ACCOUNT_MARGIN_LEVEL</code> 6 Account margin level in percents <code>ACCOUNT_MARGIN_SO_CALL</code> 7 Margin call level (in % or deposit currency) <code>ACCOUNT_MARGIN_SO_SO</code> 8 Margin stop out level (in % or deposit currency) <code>ACCOUNT_MARGIN_INITIAL</code> 9 Initial margin (reserved for pending orders) <code>ACCOUNT_MARGIN_MAINTENANCE</code> 10 Maintenance margin (minimum equity reserved) <code>ACCOUNT_ASSETS</code> 11 Current assets of an account <code>ACCOUNT_LIABILITIES</code> 12 Current liabilities on an account <code>ACCOUNT_COMMISSION_BLOCKED</code> 13 Current blocked commission amount <p>Usage in Python: <pre><code>import MetaRpcMT5.mt5_term_api_account_information_pb2 as account_info_pb2\n\n# Access constants directly\nproperty_id = account_info_pb2.ACCOUNT_BALANCE  # = 0\n# or use full enum name\nproperty_id = account_info_pb2.AccountInfoDoublePropertyType.ACCOUNT_BALANCE  # = 0\n</code></pre></p>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>Property types: Margin call and stop out levels can be in percents or deposit currency depending on account settings.</li> <li>Thread safety: All async methods are safe to call concurrently from multiple asyncio tasks.</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/1.%20Account_Information/account_info_double/#1-get-account-balance","title":"1) Get account balance","text":"<pre><code>import asyncio\nfrom datetime import datetime, timedelta\nfrom MetaRpcMT5.mt5_account import MT5Account\nimport MetaRpcMT5.mt5_term_api_account_information_pb2 as account_info_pb2\n\nasync def main():\n    # Create account instance\n    account = MT5Account(\n        user=12345678,\n        password=\"your_password\",\n        grpc_server=\"your-server.com:443\"\n    )\n\n    # Connect first\n    await account.connect_by_host_port()\n\n    try:\n        # Set deadline\n        deadline = datetime.utcnow() + timedelta(seconds=3)\n\n        # Get balance\n        balance = await account.account_info_double(\n            property_id=account_info_pb2.ACCOUNT_BALANCE,\n            deadline=deadline\n        )\n\n        print(f\"Account Balance: ${balance:.2f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#2-get-current-equity","title":"2) Get current equity","text":"<pre><code>async def get_equity(account: MT5Account) -&gt; float:\n    \"\"\"Get current account equity\"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    equity = await account.account_info_double(\n        property_id=account_info_pb2.ACCOUNT_EQUITY,\n        deadline=deadline\n    )\n\n    return equity\n\n# Usage:\nequity = await get_equity(account)\nprint(f\"Current Equity: ${equity:.2f}\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#3-check-margin-level-before-trading","title":"3) Check margin level before trading","text":"<pre><code>async def check_margin_level(account: MT5Account, min_level: float = 200.0) -&gt; bool:\n    \"\"\"\n    Check if margin level is above minimum threshold.\n\n    Args:\n        account: MT5Account instance\n        min_level: Minimum required margin level (%)\n\n    Returns:\n        True if margin level is sufficient\n\n    Raises:\n        ValueError: If margin level is below minimum\n    \"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    margin_level = await account.account_info_double(\n        property_id=account_info_pb2.ACCOUNT_MARGIN_LEVEL,\n        deadline=deadline\n    )\n\n    print(f\"Margin Level: {margin_level:.2f}%\")\n\n    if margin_level &lt; min_level:\n        raise ValueError(\n            f\"Margin level {margin_level:.2f}% is below minimum {min_level:.2f}%\"\n        )\n\n    return True\n\n# Usage:\ntry:\n    await check_margin_level(account, min_level=200.0)\n    print(\"[OK] Safe to trade\")\nexcept ValueError as e:\n    print(f\"[ERROR] Cannot trade: {e}\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#4-get-free-margin","title":"4) Get free margin","text":"<pre><code>async def get_free_margin(account: MT5Account) -&gt; float:\n    \"\"\"Get available free margin\"\"\"\n    # No deadline - uses default timeout\n    free_margin = await account.account_info_double(\n        property_id=account_info_pb2.ACCOUNT_MARGIN_FREE\n    )\n\n    return free_margin\n\n# Usage:\nfree_margin = await get_free_margin(account)\nprint(f\"Free Margin: ${free_margin:.2f}\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#5-monitor-floating-profitloss","title":"5) Monitor floating profit/loss","text":"<pre><code>async def monitor_profit(account: MT5Account, interval: float = 5.0):\n    \"\"\"Monitor floating P/L every N seconds\"\"\"\n    while True:\n        try:\n            deadline = datetime.utcnow() + timedelta(seconds=3)\n\n            profit = await account.account_info_double(\n                property_id=account_info_pb2.ACCOUNT_PROFIT,\n                deadline=deadline\n            )\n\n            sign = \"+\" if profit &gt;= 0 else \"\"\n            timestamp = datetime.now().strftime(\"%H:%M:%S\")\n\n            print(f\"[{timestamp}] Floating P/L: {sign}${profit:.2f}\")\n\n        except Exception as e:\n            print(f\"Error: {e}\")\n\n        await asyncio.sleep(interval)\n\n# Usage:\n# await monitor_profit(account, interval=5.0)  # Update every 5 seconds\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#6-check-multiple-properties-sequentially","title":"6) Check multiple properties sequentially","text":"<pre><code>from dataclasses import dataclass\n\n@dataclass\nclass MarginInfo:\n    used_margin: float\n    free_margin: float\n    margin_level: float\n\nasync def get_margin_info(account: MT5Account) -&gt; MarginInfo:\n    \"\"\"Get comprehensive margin information\"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=10)\n\n    # Get used margin\n    used_margin = await account.account_info_double(\n        property_id=account_info_pb2.ACCOUNT_MARGIN,\n        deadline=deadline\n    )\n\n    # Get free margin\n    free_margin = await account.account_info_double(\n        property_id=account_info_pb2.ACCOUNT_MARGIN_FREE,\n        deadline=deadline\n    )\n\n    # Get margin level\n    margin_level = await account.account_info_double(\n        property_id=account_info_pb2.ACCOUNT_MARGIN_LEVEL,\n        deadline=deadline\n    )\n\n    return MarginInfo(\n        used_margin=used_margin,\n        free_margin=free_margin,\n        margin_level=margin_level\n    )\n\n# Usage:\ninfo = await get_margin_info(account)\nprint(f\"Margin Info:\")\nprint(f\"  Used: ${info.used_margin:.2f}\")\nprint(f\"  Free: ${info.free_margin:.2f}\")\nprint(f\"  Level: {info.margin_level:.2f}%\")\n\n# Note: For better performance, use account_summary() instead\n# to get all properties in one call\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#7-with-cancellation-event","title":"7) With cancellation event","text":"<pre><code>async def get_balance_cancellable(account: MT5Account, cancel_event: asyncio.Event) -&gt; float:\n    \"\"\"Get balance with cancellation support\"\"\"\n    try:\n        balance = await account.account_info_double(\n            property_id=account_info_pb2.ACCOUNT_BALANCE,\n            cancellation_event=cancel_event\n        )\n        return balance\n    except asyncio.CancelledError:\n        print(\"Operation cancelled\")\n        raise\n\n# Usage:\ncancel_event = asyncio.Event()\n\n# Start operation\ntask = asyncio.create_task(get_balance_cancellable(account, cancel_event))\n\n# Cancel after 1 second\nawait asyncio.sleep(1)\ncancel_event.set()\n\ntry:\n    balance = await task\nexcept asyncio.CancelledError:\n    print(\"Cancelled by user\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#common-patterns","title":"\ud83d\udd27 Common Patterns","text":""},{"location":"MT5Account/1.%20Account_Information/account_info_double/#safe-trading-check","title":"Safe trading check","text":"<pre><code>async def can_trade(account: MT5Account, required_margin: float) -&gt; bool:\n    \"\"\"\n    Check if account has enough free margin to trade.\n\n    Args:\n        account: MT5Account instance\n        required_margin: Required margin for the trade\n\n    Returns:\n        True if sufficient margin available\n    \"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    free_margin = await account.account_info_double(\n        property_id=account_info_pb2.ACCOUNT_MARGIN_FREE,\n        deadline=deadline\n    )\n\n    if free_margin &lt; required_margin:\n        print(f\"[ERROR] Insufficient margin: need ${required_margin:.2f}, have ${free_margin:.2f}\")\n        return False\n\n    print(f\"[OK] Sufficient margin: ${free_margin:.2f} available\")\n    return True\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#margin-level-warning-system","title":"Margin level warning system","text":"<pre><code>async def check_margin_warning(account: MT5Account):\n    \"\"\"Check margin level and warn if too low\"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    level = await account.account_info_double(\n        property_id=account_info_pb2.ACCOUNT_MARGIN_LEVEL,\n        deadline=deadline\n    )\n\n    if level &lt; 100:\n        print(f\"[CRITICAL] Margin level {level:.2f}% - Stop out imminent!\")\n    elif level &lt; 200:\n        print(f\"[WARNING] Margin level {level:.2f}% - Margin call zone\")\n    elif level &lt; 500:\n        print(f\"[CAUTION] Margin level {level:.2f}% - Monitor closely\")\n    else:\n        print(f\"[OK] Margin level {level:.2f}%\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#account-health-check","title":"Account health check","text":"<pre><code>async def check_account_health(account: MT5Account):\n    \"\"\"Comprehensive account health check\"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=5)\n\n    # Get all critical metrics\n    balance = await account.account_info_double(\n        account_info_pb2.ACCOUNT_BALANCE,\n        deadline\n    )\n\n    equity = await account.account_info_double(\n        account_info_pb2.ACCOUNT_EQUITY,\n        deadline\n    )\n\n    profit = await account.account_info_double(\n        account_info_pb2.ACCOUNT_PROFIT,\n        deadline\n    )\n\n    margin_level = await account.account_info_double(\n        account_info_pb2.ACCOUNT_MARGIN_LEVEL,\n        deadline\n    )\n\n    print(f\"Account Health Report:\")\n    print(f\"  Balance: ${balance:.2f}\")\n    print(f\"  Equity: ${equity:.2f}\")\n    print(f\"  Floating P/L: ${profit:+.2f}\")\n    print(f\"  Margin Level: {margin_level:.2f}%\")\n\n    # Health score\n    if margin_level &gt; 500 and equity &gt;= balance:\n        print(\"  Status: [HEALTHY]\")\n    elif margin_level &gt; 200:\n        print(\"  Status: [MODERATE]\")\n    else:\n        print(\"  Status: [RISKY]\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_double/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>account_summary - Get all account properties in one call (RECOMMENDED)</li> <li>account_info_integer - Get specific integer account properties</li> <li>account_info_string - Get specific string account properties</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/","title":"Getting Account Integer Properties","text":"<p>Request: specific integer-type account property from MT5 terminal using property identifier.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.account_info_integer(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.AccountInformation</code></li> <li>Proto definition: <code>AccountInfoInteger</code> (defined in <code>mt5-term-api-account-information.proto</code>)</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.AccountInformation</code></li> <li>Method: <code>AccountInfoInteger(AccountInfoIntegerRequest) -&gt; AccountInfoIntegerReply</code></li> <li>Low-level client (generated): <code>AccountInformationStub.AccountInfoInteger(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Retrieve a specific integer-type account property by ID (login, leverage, trade mode, etc.).</li> <li>Why you need it. Get individual account settings without fetching all data. Useful for configuration checks.</li> <li>When to use. Use <code>account_summary()</code> for multiple properties. Use this method for single property queries.</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to query specific integer account properties:</p> <ul> <li>Get account login number</li> <li>Check account leverage</li> <li>Verify trading permissions (trade allowed, expert allowed)</li> <li>Check account trade mode (demo/real/contest)</li> <li>Get maximum pending orders limit</li> <li>Verify margin calculation mode</li> <li>Check FIFO close and hedge settings</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; account_info_integer - How it works</p>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#method-signature","title":"Method Signature","text":"<pre><code>async def account_info_integer(\n    self,\n    property_id: account_info_pb2.AccountInfoIntegerPropertyType,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; int\n</code></pre> <p>Request message:</p> <pre><code>message AccountInfoIntegerRequest {\n  AccountInfoIntegerPropertyType property_id = 1;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message AccountInfoIntegerReply {\n  oneof response {\n    AccountInfoIntegerData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage AccountInfoIntegerData {\n  int64 requested_value = 1;\n}\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>property_id</code> <code>AccountInfoIntegerPropertyType</code> (enum) Property identifier specifying which property to retrieve <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation <p>Deadline options:</p> <pre><code>from datetime import datetime, timedelta\nimport MetaRpcMT5.mt5_term_api_account_information_pb2 as account_info_pb2\n\n# 1. With deadline (recommended)\ndeadline = datetime.utcnow() + timedelta(seconds=3)\nvalue = await account.account_info_integer(\n    property_id=account_info_pb2.ACCOUNT_LEVERAGE,\n    deadline=deadline\n)\n\n# 2. With cancellation event\ncancel_event = asyncio.Event()\nvalue = await account.account_info_integer(\n    property_id=account_info_pb2.ACCOUNT_LEVERAGE,\n    cancellation_event=cancel_event\n)\n\n# 3. No deadline (uses default timeout if configured)\nvalue = await account.account_info_integer(\n    property_id=account_info_pb2.ACCOUNT_LEVERAGE\n)\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#output","title":"\u2b06\ufe0f Output","text":"Field Type Python Type Description <code>requested_value</code> <code>int64</code> <code>int</code> The value of the requested account property <p>Return value: The method directly returns <code>int</code> (extracted from <code>AccountInfoIntegerData.requested_value</code>).</p>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":"<p>Note: The tables show simplified constant names for readability. In Python code, you can use either the full or short form:</p> <p>Full format: <code>account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_LEVERAGE</code> Short format: <code>account_info_pb2.ACCOUNT_LEVERAGE</code></p> <p>Both forms are valid in Python protobuf. We recommend the short format for simplicity.</p>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#accountinfointegerpropertytype","title":"<code>AccountInfoIntegerPropertyType</code>","text":"<p>Defined in <code>mt5-term-api-account-information.proto</code>.</p> Constant Value Description <code>ACCOUNT_LOGIN</code> 0 Account number <code>ACCOUNT_TRADE_MODE</code> 1 Account trade mode (demo/real/contest) <code>ACCOUNT_LEVERAGE</code> 2 Account leverage <code>ACCOUNT_LIMIT_ORDERS</code> 3 Maximum allowed number of active pending orders <code>ACCOUNT_MARGIN_SO_MODE</code> 4 Mode for setting the minimal allowed margin <code>ACCOUNT_TRADE_ALLOWED</code> 5 Allowed trade for the current account <code>ACCOUNT_TRADE_EXPERT</code> 6 Allowed trade for an Expert Advisor <code>ACCOUNT_MARGIN_MODE</code> 7 Margin calculation mode <code>ACCOUNT_CURRENCY_DIGITS</code> 8 Number of digits after decimal point for account currency <code>ACCOUNT_FIFO_CLOSE</code> 9 Flag that a position can be closed only by FIFO rule <code>ACCOUNT_HEDGE_ALLOWED</code> 10 Hedging is allowed <p>Usage in Python: <pre><code>import MetaRpcMT5.mt5_term_api_account_information_pb2 as account_info_pb2\n\n# Access constants directly\nproperty_id = account_info_pb2.ACCOUNT_LEVERAGE  # = 2\n# or use full enum name\nproperty_id = account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_LEVERAGE  # = 2\n</code></pre></p>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>Prefer account_summary: For multiple properties, use <code>account_summary()</code> instead to avoid multiple round-trips.</li> <li>Connection required: You must call <code>connect_by_host_port()</code> or <code>connect_by_server_name()</code> before using this method.</li> <li>Boolean values: Properties like <code>TRADE_ALLOWED</code>, <code>TRADE_EXPERT</code>, <code>FIFO_CLOSE</code>, <code>HEDGE_ALLOWED</code> return 1 (true) or 0 (false).</li> <li>Thread safety: All async methods are safe to call concurrently from multiple asyncio tasks.</li> <li>UUID handling: The terminal instance UUID is auto-generated by the server if not provided.    For explicit control (e.g., in streaming scenarios), pass <code>id_=uuid4()</code> to constructor.</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#1-get-account-leverage","title":"1) Get account leverage","text":"<pre><code>import asyncio\nfrom datetime import datetime, timedelta\nfrom MetaRpcMT5.mt5_account import MT5Account\nimport MetaRpcMT5.mt5_term_api_account_information_pb2 as account_info_pb2\n\nasync def main():\n    # Create account instance\n    account = MT5Account(\n        user=12345678,\n        password=\"your_password\",\n        grpc_server=\"your-server.com:443\"\n    )\n\n    # Connect first\n    await account.connect_by_host_port()\n\n    try:\n        # Set deadline\n        deadline = datetime.utcnow() + timedelta(seconds=3)\n\n        # Get leverage\n        leverage = await account.account_info_integer(\n            property_id=account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_LEVERAGE,\n            deadline=deadline\n        )\n\n        print(f\"Account Leverage: 1:{leverage}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#2-get-account-login-number","title":"2) Get account login number","text":"<pre><code>async def get_account_login(account: MT5Account) -&gt; int:\n    \"\"\"Get account login number\"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    login = await account.account_info_integer(\n        property_id=account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_LOGIN,\n        deadline=deadline\n    )\n\n    return login\n\n# Usage:\nlogin = await get_account_login(account)\nprint(f\"Account Login: {login}\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#3-check-if-trading-is-allowed","title":"3) Check if trading is allowed","text":"<pre><code>async def is_trading_allowed(account: MT5Account) -&gt; bool:\n    \"\"\"\n    Check if trading is allowed for this account.\n\n    Returns:\n        True if trading is allowed, False otherwise\n    \"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    trade_allowed = await account.account_info_integer(\n        property_id=account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_TRADE_ALLOWED,\n        deadline=deadline\n    )\n\n    # Returns 1 (true) or 0 (false)\n    is_allowed = bool(trade_allowed)\n\n    if is_allowed:\n        print(\"[OK] Trading is allowed\")\n    else:\n        print(\"[ERROR] Trading is disabled\")\n\n    return is_allowed\n\n# Usage:\nif await is_trading_allowed(account):\n    # Place orders\n    pass\nelse:\n    print(\"Cannot trade on this account\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#4-check-expert-advisor-permissions","title":"4) Check Expert Advisor permissions","text":"<pre><code>async def is_ea_allowed(account: MT5Account) -&gt; bool:\n    \"\"\"Check if Expert Advisors are allowed to trade\"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    ea_allowed = await account.account_info_integer(\n        property_id=account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_TRADE_EXPERT,\n        deadline=deadline\n    )\n\n    return bool(ea_allowed)\n\n# Usage:\nif await is_ea_allowed(account):\n    print(\"[OK] Expert Advisors can trade\")\nelse:\n    print(\"[ERROR] Expert Advisors are disabled\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#5-get-maximum-pending-orders-limit","title":"5) Get maximum pending orders limit","text":"<pre><code>async def get_max_pending_orders(account: MT5Account) -&gt; int:\n    \"\"\"Get maximum allowed number of pending orders\"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    limit = await account.account_info_integer(\n        property_id=account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_LIMIT_ORDERS,\n        deadline=deadline\n    )\n\n    return limit\n\n# Usage:\nmax_orders = await get_max_pending_orders(account)\nprint(f\"Maximum pending orders: {max_orders}\")\n\nif max_orders == 0:\n    print(\"[WARNING] No limit on pending orders (or unlimited)\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#6-check-account-type-demorealcontest","title":"6) Check account type (demo/real/contest)","text":"<pre><code>async def get_account_type(account: MT5Account) -&gt; str:\n    \"\"\"\n    Get account trade mode.\n\n    Returns:\n        \"DEMO\", \"CONTEST\", or \"REAL\"\n    \"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    trade_mode = await account.account_info_integer(\n        property_id=account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_TRADE_MODE,\n        deadline=deadline\n    )\n\n    # Map to readable names\n    mode_map = {\n        0: \"DEMO\",\n        1: \"CONTEST\",\n        2: \"REAL\"\n    }\n\n    mode_name = mode_map.get(trade_mode, f\"UNKNOWN ({trade_mode})\")\n    print(f\"Account Type: {mode_name}\")\n\n    return mode_name\n\n# Usage:\naccount_type = await get_account_type(account)\n\nif account_type == \"DEMO\":\n    print(\"[WARNING] Running on demo account\")\nelif account_type == \"REAL\":\n    print(\"[CRITICAL] Running on real account - be careful!\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#7-check-hedging-settings","title":"7) Check hedging settings","text":"<pre><code>async def check_hedging_settings(account: MT5Account):\n    \"\"\"Check if hedging and FIFO close are enabled\"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=5)\n\n    # Check if hedging is allowed\n    hedge_allowed = await account.account_info_integer(\n        property_id=account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_HEDGE_ALLOWED,\n        deadline=deadline\n    )\n\n    # Check FIFO close rule\n    fifo_close = await account.account_info_integer(\n        property_id=account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_FIFO_CLOSE,\n        deadline=deadline\n    )\n\n    print(f\"Hedging Settings:\")\n    print(f\"  Hedging allowed: {'Yes' if hedge_allowed else 'No'}\")\n    print(f\"  FIFO close: {'Enabled' if fifo_close else 'Disabled'}\")\n\n    return {\n        \"hedge_allowed\": bool(hedge_allowed),\n        \"fifo_close\": bool(fifo_close)\n    }\n\n# Usage:\nsettings = await check_hedging_settings(account)\n\nif settings[\"hedge_allowed\"]:\n    print(\"[OK] Can open opposite positions on same symbol\")\nelse:\n    print(\"[INFO] Cannot hedge - only netting mode\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#common-patterns","title":"Common Patterns","text":""},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#pre-trade-validation","title":"Pre-trade validation","text":"<pre><code>async def validate_account_for_trading(account: MT5Account) -&gt; bool:\n    \"\"\"\n    Validate account is ready for trading.\n\n    Returns:\n        True if account is ready to trade\n    \"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=5)\n\n    # Check trading is allowed\n    trade_allowed = await account.account_info_integer(\n        account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_TRADE_ALLOWED,\n        deadline\n    )\n\n    if not trade_allowed:\n        print(\"[ERROR] Trading is disabled on this account\")\n        return False\n\n    # Check leverage is reasonable\n    leverage = await account.account_info_integer(\n        account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_LEVERAGE,\n        deadline\n    )\n\n    if leverage &lt; 1:\n        print(\"[ERROR] Invalid leverage setting\")\n        return False\n\n    print(f\"[OK] Account ready to trade (Leverage: 1:{leverage})\")\n    return True\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#account-type-checker","title":"Account type checker","text":"<pre><code>async def require_demo_account(account: MT5Account):\n    \"\"\"Ensure we're running on demo account (safety check)\"\"\"\n    trade_mode = await account.account_info_integer(\n        account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_TRADE_MODE\n    )\n\n    if trade_mode != 0:  # 0 = DEMO\n        raise RuntimeError(\n            f\"[CRITICAL] This script requires DEMO account! Current mode: {trade_mode}\"\n        )\n\n    print(\"[OK] Confirmed: Running on DEMO account\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_integer/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>account_summary - Get all account properties in one call (RECOMMENDED)</li> <li>account_info_double - Get specific double account properties</li> <li>account_info_string - Get specific string account properties</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/","title":"Getting Account String Properties","text":"<p>Request: specific string-type account property from MT5 terminal using property identifier.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.account_info_string(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.AccountInformation</code></li> <li>Proto definition: <code>AccountInfoString</code> (defined in <code>mt5-term-api-account-information.proto</code>)</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.AccountInformation</code></li> <li>Method: <code>AccountInfoString(AccountInfoStringRequest) -&gt; AccountInfoStringReply</code></li> <li>Low-level client (generated): <code>AccountInformationStub.AccountInfoString(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Retrieve a specific string-type account property by ID (name, server, currency, company).</li> <li>Why you need it. Get individual account text properties without fetching all data. Useful for logging and configuration.</li> <li>When to use. Use <code>account_summary()</code> for multiple properties. Use this method for single property queries.</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to query specific string account properties:</p> <ul> <li>Get account owner name</li> <li>Get trading server name</li> <li>Get account currency (USD, EUR, etc.)</li> <li>Get broker/company name</li> <li>Verify server connection</li> <li>Log account details</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; account_info_string - How it works</p>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#method-signature","title":"Method Signature","text":"<pre><code>async def account_info_string(\n    self,\n    property_id: account_info_pb2.AccountInfoStringPropertyType,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; str\n</code></pre> <p>Request message:</p> <pre><code>message AccountInfoStringRequest {\n  AccountInfoStringPropertyType property_id = 1;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message AccountInfoStringReply {\n  oneof response {\n    AccountInfoStringData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage AccountInfoStringData {\n  string requested_value = 1;\n}\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>property_id</code> <code>AccountInfoStringPropertyType</code> (enum) Property identifier specifying which property to retrieve <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation <p>Deadline options:</p> <pre><code>from datetime import datetime, timedelta\nimport MetaRpcMT5.mt5_term_api_account_information_pb2 as account_info_pb2\n\n# 1. With deadline (recommended)\ndeadline = datetime.utcnow() + timedelta(seconds=3)\nvalue = await account.account_info_string(\n    property_id=account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_CURRENCY,\n    deadline=deadline\n)\n\n# 2. With cancellation event\ncancel_event = asyncio.Event()\nvalue = await account.account_info_string(\n    property_id=account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_CURRENCY,\n    cancellation_event=cancel_event\n)\n\n# 3. No deadline (uses default timeout if configured)\nvalue = await account.account_info_string(\n    property_id=account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_CURRENCY\n)\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#output","title":"\u2b06\ufe0f Output","text":"Field Type Python Type Description <code>requested_value</code> <code>string</code> <code>str</code> The value of the requested account property <p>Return value: The method directly returns <code>str</code> (extracted from <code>AccountInfoStringData.requested_value</code>).</p>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":"<p>Note: In Python code, you should use the full enum class path for type safety and clarity:</p> <p>Recommended: <code>account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_CURRENCY</code> Also valid: <code>account_info_pb2.ACCOUNT_CURRENCY</code> (direct access)</p> <p>We recommend the full format for better IDE support and to avoid confusion between different property types.</p>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#accountinfostringpropertytype","title":"<code>AccountInfoStringPropertyType</code>","text":"<p>Defined in <code>mt5-term-api-account-information.proto</code>.</p> Constant Value Description <code>ACCOUNT_NAME</code> 0 Client name <code>ACCOUNT_SERVER</code> 1 Trade server name <code>ACCOUNT_CURRENCY</code> 2 Account currency (USD, EUR, etc.) <code>ACCOUNT_COMPANY</code> 3 Name of a company that serves the account <p>Usage in Python: <pre><code>import MetaRpcMT5.mt5_term_api_account_information_pb2 as account_info_pb2\n\n# Recommended: use full enum class path\nproperty_id = account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_CURRENCY  # = 2\n\n# Also valid: direct access (but less clear)\nproperty_id = account_info_pb2.ACCOUNT_CURRENCY  # = 2\n</code></pre></p>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Prefer account_summary: For multiple properties, use <code>account_summary()</code> instead to avoid multiple round-trips.</li> <li>Connection required: You must call <code>connect_by_host_port()</code> or <code>connect_by_server_name()</code> before using this method.</li> <li>Currency format: Currency is returned as 3-letter code (USD, EUR, GBP, etc.).</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/1.%20Account_Information/account_info_string/#1-get-account-currency","title":"1) Get account currency","text":"<pre><code>import asyncio\nfrom datetime import datetime, timedelta\nfrom MetaRpcMT5.mt5_account import MT5Account\nimport MetaRpcMT5.mt5_term_api_account_information_pb2 as account_info_pb2\n\nasync def main():\n    # Create account instance\n    account = MT5Account(\n        user=12345678,\n        password=\"your_password\",\n        grpc_server=\"your-server.com:443\"\n    )\n\n    # Connect first\n    await account.connect_by_host_port()\n\n    try:\n        # Set deadline\n        deadline = datetime.utcnow() + timedelta(seconds=3)\n\n        # Get currency\n        currency = await account.account_info_string(\n            property_id=account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_CURRENCY,\n            deadline=deadline\n        )\n\n        print(f\"Account Currency: {currency}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#2-get-account-owner-name","title":"2) Get account owner name","text":"<pre><code>async def get_account_name(account: MT5Account) -&gt; str:\n    \"\"\"Get account owner name\"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    name = await account.account_info_string(\n        property_id=account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_NAME,\n        deadline=deadline\n    )\n\n    return name\n\n# Usage:\nname = await get_account_name(account)\nprint(f\"Account Name: {name}\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#3-get-trading-server-name","title":"3) Get trading server name","text":"<pre><code>async def get_server_name(account: MT5Account) -&gt; str:\n    \"\"\"Get trading server name\"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    server = await account.account_info_string(\n        property_id=account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_SERVER,\n        deadline=deadline\n    )\n\n    return server\n\n# Usage:\nserver = await get_server_name(account)\nprint(f\"Trading Server: {server}\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#4-get-broker-company-name","title":"4) Get broker company name","text":"<pre><code>async def get_broker_name(account: MT5Account) -&gt; str:\n    \"\"\"Get broker/company name\"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    company = await account.account_info_string(\n        property_id=account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_COMPANY,\n        deadline=deadline\n    )\n\n    return company\n\n# Usage:\nbroker = await get_broker_name(account)\nprint(f\"Broker: {broker}\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#5-log-account-details","title":"5) Log account details","text":"<pre><code>async def log_account_details(account: MT5Account):\n    \"\"\"Log all string account properties\"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=10)\n\n    # Get all string properties\n    name = await account.account_info_string(\n        account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_NAME,\n        deadline\n    )\n\n    server = await account.account_info_string(\n        account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_SERVER,\n        deadline\n    )\n\n    currency = await account.account_info_string(\n        account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_CURRENCY,\n        deadline\n    )\n\n    company = await account.account_info_string(\n        account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_COMPANY,\n        deadline\n    )\n\n    # Log details\n    print(f\"=\" * 50)\n    print(f\"Account Details:\")\n    print(f\"  Owner: {name}\")\n    print(f\"  Server: {server}\")\n    print(f\"  Currency: {currency}\")\n    print(f\"  Broker: {company}\")\n    print(f\"=\" * 50)\n\n# Usage:\nawait log_account_details(account)\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#6-verify-server-connection","title":"6) Verify server connection","text":"<pre><code>async def verify_server_connection(account: MT5Account, expected_server: str) -&gt; bool:\n    \"\"\"\n    Verify we're connected to the expected server.\n\n    Args:\n        account: MT5Account instance\n        expected_server: Expected server name\n\n    Returns:\n        True if connected to correct server\n    \"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    server = await account.account_info_string(\n        property_id=account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_SERVER,\n        deadline=deadline\n    )\n\n    if server.lower() != expected_server.lower():\n        print(f\"[WARNING] Connected to {server}, expected {expected_server}\")\n        return False\n\n    print(f\"[OK] Confirmed: Connected to {server}\")\n    return True\n\n# Usage:\nif not await verify_server_connection(account, \"MetaQuotes-Demo\"):\n    raise RuntimeError(\"Wrong server!\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#7-currency-based-formatting","title":"7) Currency-based formatting","text":"<pre><code>async def format_balance(account: MT5Account, balance: float) -&gt; str:\n    \"\"\"\n    Format balance with account currency symbol.\n\n    Args:\n        account: MT5Account instance\n        balance: Balance amount\n\n    Returns:\n        Formatted balance string\n    \"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    currency = await account.account_info_string(\n        account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_CURRENCY,\n        deadline\n    )\n\n    # Map currency codes to symbols\n    currency_symbols = {\n        \"USD\": \"$\",\n        \"EUR\": \"EUR\",\n        \"GBP\": \"GBP\",\n        \"JPY\": \"JPY\",\n        \"CHF\": \"CHF\",\n        \"AUD\": \"A$\",\n        \"CAD\": \"C$\"\n    }\n\n    symbol = currency_symbols.get(currency, currency + \" \")\n\n    # Format based on currency\n    if currency == \"JPY\":\n        # JPY doesn't use decimal places\n        return f\"{symbol}{balance:.0f}\"\n    else:\n        return f\"{symbol}{balance:.2f}\"\n\n# Usage:\nbalance = 10000.50\nformatted = await format_balance(account, balance)\nprint(f\"Balance: {formatted}\")  # Output: Balance: $10000.50\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#8-generate-session-header","title":"8) Generate session header","text":"<pre><code>from dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass SessionInfo:\n    timestamp: str\n    account_name: str\n    broker: str\n    server: str\n    currency: str\n\nasync def get_session_info(account: MT5Account) -&gt; SessionInfo:\n    \"\"\"Get comprehensive session information for logging\"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=10)\n\n    # Get all string properties\n    name = await account.account_info_string(\n        account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_NAME,\n        deadline\n    )\n\n    company = await account.account_info_string(\n        account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_COMPANY,\n        deadline\n    )\n\n    server = await account.account_info_string(\n        account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_SERVER,\n        deadline\n    )\n\n    currency = await account.account_info_string(\n        account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_CURRENCY,\n        deadline\n    )\n\n    return SessionInfo(\n        timestamp=datetime.now().isoformat(),\n        account_name=name,\n        broker=company,\n        server=server,\n        currency=currency\n    )\n\n# Usage:\nsession = await get_session_info(account)\nprint(f\"Session started: {session.timestamp}\")\nprint(f\"Account: {session.account_name}\")\nprint(f\"Broker: {session.broker} ({session.server})\")\nprint(f\"Currency: {session.currency}\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#common-patterns","title":"Common Patterns","text":""},{"location":"MT5Account/1.%20Account_Information/account_info_string/#account-identification","title":"Account identification","text":"<pre><code>async def get_account_identifier(account: MT5Account) -&gt; str:\n    \"\"\"\n    Generate unique account identifier for logging.\n\n    Returns:\n        Identifier string: \"name@server (broker)\"\n    \"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=5)\n\n    name = await account.account_info_string(\n        account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_NAME,\n        deadline\n    )\n\n    server = await account.account_info_string(\n        account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_SERVER,\n        deadline\n    )\n\n    company = await account.account_info_string(\n        account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_COMPANY,\n        deadline\n    )\n\n    identifier = f\"{name}@{server} ({company})\"\n    return identifier\n\n# Usage:\naccount_id = await get_account_identifier(account)\nprint(f\"Trading as: {account_id}\")\n# Output: Trading as: John Doe@MetaQuotes-Demo (MetaQuotes Software Corp.)\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#currency-validator","title":"Currency validator","text":"<pre><code>async def validate_account_currency(\n    account: MT5Account,\n    allowed_currencies: list[str]\n) -&gt; bool:\n    \"\"\"\n    Validate account currency is in allowed list.\n\n    Args:\n        account: MT5Account instance\n        allowed_currencies: List of allowed currency codes (e.g., [\"USD\", \"EUR\"])\n\n    Returns:\n        True if currency is allowed\n    \"\"\"\n    currency = await account.account_info_string(\n        account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_CURRENCY\n    )\n\n    if currency not in allowed_currencies:\n        print(f\"[ERROR] Currency {currency} not allowed. Allowed: {allowed_currencies}\")\n        return False\n\n    print(f\"[OK] Currency {currency} is valid\")\n    return True\n\n# Usage:\nif not await validate_account_currency(account, [\"USD\", \"EUR\"]):\n    raise ValueError(\"Account currency not supported\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#server-environment-checker","title":"Server environment checker","text":"<pre><code>async def get_environment(account: MT5Account) -&gt; str:\n    \"\"\"\n    Determine environment (production/demo) based on server name.\n\n    Returns:\n        \"PRODUCTION\", \"DEMO\", or \"UNKNOWN\"\n    \"\"\"\n    server = await account.account_info_string(\n        account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_SERVER\n    )\n\n    server_lower = server.lower()\n\n    if \"demo\" in server_lower:\n        return \"DEMO\"\n    elif \"real\" in server_lower or \"live\" in server_lower:\n        return \"PRODUCTION\"\n    else:\n        return \"UNKNOWN\"\n\n# Usage:\nenv = await get_environment(account)\nprint(f\"Environment: {env}\")\n\nif env == \"PRODUCTION\":\n    print(\"[WARNING] Trading on PRODUCTION server!\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_info_string/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>account_summary - Get all account properties in one call (RECOMMENDED)</li> <li>account_info_double - Get specific double account properties</li> <li>account_info_integer - Get specific integer account properties</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_summary/","title":"Getting Complete Account Summary","text":"<p>Request: complete account snapshot with all essential properties in a single call (balance, equity, leverage, currency, server time, etc.).</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.account_summary(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.AccountHelper</code></li> <li>Proto definition: <code>AccountSummary</code> (defined in <code>mt5-term-api-account-helper.proto</code>)</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.AccountHelper</code></li> <li>Method: <code>AccountSummary(AccountSummaryRequest) -&gt; AccountSummaryReply</code></li> <li>Low-level client (generated): <code>AccountHelperStub.AccountSummary(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Get complete account snapshot with all essential properties in one call.</li> <li>Why you need it. Most efficient way to get multiple account properties (balance, equity, leverage, etc.).</li> <li>When to use. Use this for general account info. Use <code>account_info_*</code> methods only for single specific properties.</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to get comprehensive account information:</p> <ul> <li>RECOMMENDED method for getting account overview</li> <li>Get balance, equity, credit in one call</li> <li>Check account login, name, server, company</li> <li>Get leverage and trade mode (demo/real)</li> <li>Get account currency</li> <li>Get server time with UTC offset</li> <li>Efficient - one round-trip instead of multiple calls</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; account_summary - How it works</p>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#method-signature","title":"Method Signature","text":"<pre><code>async def account_summary(\n    self,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n)\n</code></pre> <p>Request message:</p> <pre><code>message AccountSummaryRequest {\n  // Empty - no parameters needed\n}\n</code></pre> <p>Reply message:</p> <pre><code>message AccountSummaryReply {\n  oneof response {\n    AccountSummaryData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage AccountSummaryData {\n  int64 account_login = 1;\n  double account_balance = 2;\n  double account_equity = 3;\n  string account_user_name = 4;\n  int64 account_leverage = 5;\n  MrpcEnumAccountTradeMode account_trade_mode = 6;\n  string account_company_name = 7;\n  string account_currency = 8;\n  google.protobuf.Timestamp server_time = 9;\n  int64 utc_timezone_server_time_shift_minutes = 10;\n  double account_credit = 11;\n}\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation <p>No property_id required - this method returns all available properties.</p> <p>Deadline options:</p> <pre><code>from datetime import datetime, timedelta\n\n# 1. With deadline (recommended)\ndeadline = datetime.utcnow() + timedelta(seconds=3)\nsummary = await account.account_summary(deadline=deadline)\n\n# 2. With cancellation event\ncancel_event = asyncio.Event()\nsummary = await account.account_summary(cancellation_event=cancel_event)\n\n# 3. No deadline (uses default timeout if configured)\nsummary = await account.account_summary()\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#output-accountsummarydata","title":"\u2b06\ufe0f Output - <code>AccountSummaryData</code>","text":"Field Type Python Type Description <code>account_login</code> <code>int64</code> <code>int</code> Account number <code>account_balance</code> <code>double</code> <code>float</code> Account balance in deposit currency <code>account_equity</code> <code>double</code> <code>float</code> Account equity (balance + floating profit/loss) <code>account_user_name</code> <code>string</code> <code>str</code> Account owner name <code>account_leverage</code> <code>int64</code> <code>int</code> Account leverage (e.g., 100 for 1:100) <code>account_trade_mode</code> <code>MrpcEnumAccountTradeMode</code> <code>int</code> Trade mode: 0=DEMO, 1=CONTEST, 2=REAL <code>account_company_name</code> <code>string</code> <code>str</code> Broker/company name <code>account_currency</code> <code>string</code> <code>str</code> Account currency (USD, EUR, etc.) <code>server_time</code> <code>google.protobuf.Timestamp</code> <code>Timestamp</code> Current server time <code>utc_timezone_server_time_shift_minutes</code> <code>int64</code> <code>int</code> Server timezone offset from UTC (in minutes) <code>account_credit</code> <code>double</code> <code>float</code> Account credit in deposit currency <p>Return value: The method returns <code>AccountSummaryData</code> object with all fields accessible as attributes.</p>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":"<p>Note: The tables show simplified constant names for readability. In Python code, use the full enum path from the account_helper module.</p>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#mrpcenumaccounttrademode","title":"<code>MrpcEnumAccountTradeMode</code>","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>.</p> Constant Value Description <code>MRPC_ACCOUNT_TRADE_MODE_DEMO</code> 0 Demo account <code>MRPC_ACCOUNT_TRADE_MODE_CONTEST</code> 1 Contest account <code>MRPC_ACCOUNT_TRADE_MODE_REAL</code> 2 Real account <p>Usage in Python: <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\n# Access constants\nmode = account_helper_pb2.MRPC_ACCOUNT_TRADE_MODE_DEMO  # = 0\n# Check account mode\nif summary.account_trade_mode == account_helper_pb2.MRPC_ACCOUNT_TRADE_MODE_REAL:\n    print(\"Real account - be careful!\")\n</code></pre></p>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>RECOMMENDED method: This is the most efficient way to get account information - use it instead of multiple <code>account_info_*</code> calls.</li> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>Connection required: You must call <code>connect_by_host_port()</code> or <code>connect_by_server_name()</code> before using this method.</li> <li>No margin info: This method doesn't include margin/margin level - use <code>account_info_double()</code> for those.</li> <li>Server time: The <code>server_time</code> field is a protobuf Timestamp - convert with <code>.ToDatetime()</code> or <code>.seconds</code>.</li> </ul>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/1.%20Account_Information/account_summary/#1-get-complete-account-summary","title":"1) Get complete account summary","text":"<pre><code>import asyncio\nfrom datetime import datetime, timedelta\nfrom MetaRpcMT5.mt5_account import MT5Account\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\nasync def main():\n    # Create account instance\n    account = MT5Account(\n        user=12345678,\n        password=\"your_password\",\n        grpc_server=\"your-server.com:443\"\n    )\n\n    # Connect first\n    await account.connect_by_host_port()\n\n    try:\n        # Set deadline\n        deadline = datetime.utcnow() + timedelta(seconds=3)\n\n        # Get summary\n        summary = await account.account_summary(deadline=deadline)\n\n        # Access fields\n        print(f\"Account Summary:\")\n        print(f\"  Login: {summary.account_login}\")\n        print(f\"  Name: {summary.account_user_name}\")\n        print(f\"  Balance: ${summary.account_balance:.2f}\")\n        print(f\"  Equity: ${summary.account_equity:.2f}\")\n        print(f\"  Credit: ${summary.account_credit:.2f}\")\n        print(f\"  Currency: {summary.account_currency}\")\n        print(f\"  Leverage: 1:{summary.account_leverage}\")\n        print(f\"  Broker: {summary.account_company_name}\")\n\n        # Trade mode\n        mode_names = {0: \"DEMO\", 1: \"CONTEST\", 2: \"REAL\"}\n        mode = mode_names.get(summary.account_trade_mode, \"UNKNOWN\")\n        print(f\"  Mode: {mode}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#2-print-formatted-account-info","title":"2) Print formatted account info","text":"<pre><code>async def print_account_info(account: MT5Account):\n    \"\"\"Print nicely formatted account information\"\"\"\n    summary = await account.account_summary()\n\n    # Determine account type\n    mode_names = {\n        0: \"DEMO\",\n        1: \"CONTEST\",\n        2: \"REAL\"\n    }\n    mode = mode_names.get(summary.account_trade_mode, \"UNKNOWN\")\n\n    # Calculate floating P/L\n    floating_pnl = summary.account_equity - summary.account_balance\n\n    print(f\"\\n{'='*60}\")\n    print(f\"ACCOUNT INFORMATION\")\n    print(f\"{'='*60}\")\n    print(f\"Account:     #{summary.account_login} ({summary.account_user_name})\")\n    print(f\"Type:        {mode}\")\n    print(f\"Broker:      {summary.account_company_name}\")\n    print(f\"Currency:    {summary.account_currency}\")\n    print(f\"Leverage:    1:{summary.account_leverage}\")\n    print(f\"\")\n    print(f\"Balance:     ${summary.account_balance:,.2f}\")\n    print(f\"Credit:      ${summary.account_credit:,.2f}\")\n    print(f\"Equity:      ${summary.account_equity:,.2f}\")\n    print(f\"Floating:    ${floating_pnl:+,.2f}\")\n    print(f\"{'='*60}\\n\")\n\n# Usage:\nawait print_account_info(account)\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#3-check-account-health","title":"3) Check account health","text":"<pre><code>async def check_account_health(account: MT5Account) -&gt; dict:\n    \"\"\"\n    Comprehensive account health check.\n\n    Returns:\n        Dictionary with health metrics and status\n    \"\"\"\n    summary = await account.account_summary()\n\n    # Calculate metrics\n    balance = summary.account_balance\n    equity = summary.account_equity\n    floating_pnl = equity - balance\n    pnl_percent = (floating_pnl / balance * 100) if balance &gt; 0 else 0\n\n    # Determine health status\n    if summary.account_trade_mode == 0:\n        account_type = \"DEMO\"\n    elif summary.account_trade_mode == 2:\n        account_type = \"REAL\"\n    else:\n        account_type = \"CONTEST\"\n\n    # Health assessment\n    if equity &gt; balance and pnl_percent &gt; 5:\n        status = \"EXCELLENT\"\n    elif equity &gt; balance:\n        status = \"HEALTHY\"\n    elif abs(pnl_percent) &lt; 5:\n        status = \"NEUTRAL\"\n    elif pnl_percent &lt; -10:\n        status = \"CRITICAL\"\n    else:\n        status = \"WARNING\"\n\n    health = {\n        \"status\": status,\n        \"account_type\": account_type,\n        \"balance\": balance,\n        \"equity\": equity,\n        \"floating_pnl\": floating_pnl,\n        \"pnl_percent\": pnl_percent,\n        \"leverage\": summary.account_leverage,\n        \"currency\": summary.account_currency\n    }\n\n    print(f\"Account Health: {status}\")\n    print(f\"  Balance: ${balance:,.2f}\")\n    print(f\"  Equity: ${equity:,.2f}\")\n    print(f\"  P/L: ${floating_pnl:+,.2f} ({pnl_percent:+.2f}%)\")\n\n    return health\n\n# Usage:\nhealth = await check_account_health(account)\nif \"CRITICAL\" in health[\"status\"]:\n    print(\"[WARNING] Account needs attention!\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#4-get-server-time","title":"4) Get server time","text":"<pre><code>async def get_server_time(account: MT5Account):\n    \"\"\"Get server time and timezone info\"\"\"\n    summary = await account.account_summary()\n\n    # Convert protobuf Timestamp to datetime\n    server_time = summary.server_time.ToDatetime()\n\n    # Get timezone offset\n    tz_offset_minutes = summary.utc_timezone_server_time_shift_minutes\n    tz_offset_hours = tz_offset_minutes / 60\n\n    print(f\"Server Time: {server_time}\")\n    print(f\"UTC Offset: {tz_offset_hours:+.1f} hours\")\n\n    # Calculate local time\n    from datetime import timedelta\n    utc_time = datetime.utcnow()\n    server_time_calculated = utc_time + timedelta(minutes=tz_offset_minutes)\n\n    print(f\"UTC Time: {utc_time}\")\n    print(f\"Server Time (calculated): {server_time_calculated}\")\n\n    return server_time\n\n# Usage:\nserver_time = await get_server_time(account)\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#5-validate-account-before-trading","title":"5) Validate account before trading","text":"<pre><code>async def validate_for_trading(account: MT5Account) -&gt; bool:\n    \"\"\"\n    Validate account is ready for trading.\n\n    Returns:\n        True if account passes all checks\n    \"\"\"\n    summary = await account.account_summary()\n\n    # Check 1: Minimum balance\n    min_balance = 100\n    if summary.account_balance &lt; min_balance:\n        print(f\"[ERROR] Balance too low: ${summary.account_balance:.2f} &lt; ${min_balance}\")\n        return False\n\n    # Check 2: Equity &gt; Balance (no heavy losses)\n    if summary.account_equity &lt; summary.account_balance * 0.5:\n        pnl = summary.account_equity - summary.account_balance\n        print(f\"[ERROR] Heavy losses: ${pnl:.2f}\")\n        return False\n\n    # Check 3: Reasonable leverage\n    if summary.account_leverage &lt; 10 or summary.account_leverage &gt; 500:\n        print(f\"[WARNING] Unusual leverage: 1:{summary.account_leverage}\")\n\n    # Check 4: Supported currency\n    supported_currencies = [\"USD\", \"EUR\", \"GBP\"]\n    if summary.account_currency not in supported_currencies:\n        print(f\"[WARNING] Unsupported currency: {summary.account_currency}\")\n\n    print(f\"[OK] Account validation passed:\")\n    print(f\"   Balance: ${summary.account_balance:.2f}\")\n    print(f\"   Equity: ${summary.account_equity:.2f}\")\n    print(f\"   Leverage: 1:{summary.account_leverage}\")\n\n    return True\n\n# Usage:\nif await validate_for_trading(account):\n    # Start trading\n    pass\nelse:\n    print(\"Cannot trade on this account\")\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#6-log-session-start","title":"6) Log session start","text":"<pre><code>import logging\nfrom datetime import datetime\n\nasync def log_session_start(account: MT5Account):\n    \"\"\"Log session start with full account details\"\"\"\n    summary = await account.account_summary()\n\n    # Setup logging\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s - %(levelname)s - %(message)s'\n    )\n\n    # Get mode name\n    mode_names = {0: \"DEMO\", 1: \"CONTEST\", 2: \"REAL\"}\n    mode = mode_names.get(summary.account_trade_mode, \"UNKNOWN\")\n\n    # Log session info\n    logging.info(\"=\" * 60)\n    logging.info(\"TRADING SESSION STARTED\")\n    logging.info(f\"Account: #{summary.account_login} ({summary.account_user_name})\")\n    logging.info(f\"Broker: {summary.account_company_name}\")\n    logging.info(f\"Mode: {mode}\")\n    logging.info(f\"Balance: {summary.account_balance:.2f} {summary.account_currency}\")\n    logging.info(f\"Leverage: 1:{summary.account_leverage}\")\n\n    # Server time\n    server_time = summary.server_time.ToDatetime()\n    logging.info(f\"Server Time: {server_time}\")\n    logging.info(\"=\" * 60)\n\n# Usage:\nawait log_session_start(account)\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#7-monitor-account-equity","title":"7) Monitor account equity","text":"<pre><code>async def monitor_equity(account: MT5Account, interval: float = 10.0):\n    \"\"\"\n    Monitor account equity changes.\n\n    Args:\n        account: MT5Account instance\n        interval: Update interval in seconds\n    \"\"\"\n    previous_equity = None\n\n    while True:\n        try:\n            summary = await account.account_summary()\n\n            equity = summary.account_equity\n            balance = summary.account_balance\n            floating = equity - balance\n\n            # Calculate change\n            if previous_equity is not None:\n                change = equity - previous_equity\n                change_pct = (change / previous_equity * 100) if previous_equity &gt; 0 else 0\n\n                print(f\"[{datetime.now().strftime('%H:%M:%S')}] \"\n                      f\"Equity: ${equity:,.2f} | \"\n                      f\"Floating: ${floating:+,.2f} | \"\n                      f\"Change: ${change:+.2f} ({change_pct:+.2f}%)\")\n            else:\n                print(f\"[{datetime.now().strftime('%H:%M:%S')}] \"\n                      f\"Equity: ${equity:,.2f} | \"\n                      f\"Floating: ${floating:+,.2f}\")\n\n            previous_equity = equity\n\n        except Exception as e:\n            print(f\"Error: {e}\")\n\n        await asyncio.sleep(interval)\n\n# Usage:\n# await monitor_equity(account, interval=10.0)  # Update every 10 seconds\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#8-compare-multiple-accounts","title":"8) Compare multiple accounts","text":"<pre><code>from dataclasses import dataclass\n\n@dataclass\nclass AccountSummary:\n    login: int\n    name: str\n    balance: float\n    equity: float\n    leverage: int\n    currency: str\n    mode: str\n\nasync def compare_accounts(accounts: list[MT5Account]) -&gt; list[AccountSummary]:\n    \"\"\"\n    Get summaries for multiple accounts.\n\n    Args:\n        accounts: List of MT5Account instances\n\n    Returns:\n        List of AccountSummary objects\n    \"\"\"\n    mode_names = {0: \"DEMO\", 1: \"CONTEST\", 2: \"REAL\"}\n    summaries = []\n\n    for account in accounts:\n        summary = await account.account_summary()\n\n        summaries.append(AccountSummary(\n            login=summary.account_login,\n            name=summary.account_user_name,\n            balance=summary.account_balance,\n            equity=summary.account_equity,\n            leverage=summary.account_leverage,\n            currency=summary.account_currency,\n            mode=mode_names.get(summary.account_trade_mode, \"UNKNOWN\")\n        ))\n\n    # Print comparison\n    print(\"\\nAccount Comparison:\")\n    print(\"-\" * 80)\n    for s in summaries:\n        pnl = s.equity - s.balance\n        print(f\"#{s.login:10} | {s.name:20} | {s.mode:8} | \"\n              f\"${s.balance:10,.2f} | ${s.equity:10,.2f} | ${pnl:+10,.2f}\")\n    print(\"-\" * 80)\n\n    return summaries\n\n# Usage:\n# account1 = MT5Account(...)\n# account2 = MT5Account(...)\n# summaries = await compare_accounts([account1, account2])\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#common-patterns","title":"Common Patterns","text":""},{"location":"MT5Account/1.%20Account_Information/account_summary/#account-initialization-check","title":"Account initialization check","text":"<pre><code>async def initialize_account(account: MT5Account):\n    \"\"\"Initialize and validate account connection\"\"\"\n    # Connect\n    await account.connect_by_host_port()\n\n    # Get summary to verify connection\n    summary = await account.account_summary()\n\n    print(f\"[OK] Connected to account #{summary.account_login}\")\n    print(f\"   Balance: ${summary.account_balance:.2f} {summary.account_currency}\")\n\n    # Return summary for further use\n    return summary\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#risk-assessment","title":"Risk assessment","text":"<pre><code>async def assess_trading_risk(account: MT5Account) -&gt; str:\n    \"\"\"Assess trading risk level\"\"\"\n    summary = await account.account_summary()\n\n    # Calculate risk factors\n    balance = summary.account_balance\n    equity = summary.account_equity\n    leverage = summary.account_leverage\n\n    # Risk score\n    if leverage &gt; 200:\n        risk = \"HIGH\"\n    elif leverage &gt; 100:\n        risk = \"MEDIUM\"\n    else:\n        risk = \"LOW\"\n\n    # Check current losses\n    if equity &lt; balance * 0.9:\n        risk = \"HIGH\"\n\n    print(f\"Risk Assessment: {risk}\")\n    print(f\"  Leverage: 1:{leverage}\")\n    print(f\"  Balance: ${balance:.2f}\")\n    print(f\"  Equity: ${equity:.2f}\")\n\n    return risk\n</code></pre>"},{"location":"MT5Account/1.%20Account_Information/account_summary/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>account_info_double - Get specific double account properties (margin, etc.)</li> <li>account_info_integer - Get specific integer account properties</li> <li>account_info_string - Get specific string account properties</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/Symbol_Information.Overview/","title":"MT5Account - Symbol Information - Overview","text":"<p>Symbol prices, properties, parameters, and trading conditions. Query individual properties or get complete symbol data.</p>"},{"location":"MT5Account/2.%20Symbol_Information/Symbol_Information.Overview/#what-lives-here","title":"\ud83d\udcc1 What lives here","text":"<ul> <li>symbols_total - count of available symbols.</li> <li>symbol_exist - check if symbol exists on platform.</li> <li>symbol_name - get symbol name by index position.</li> <li>symbol_select - add/remove symbol from Market Watch.</li> <li>symbol_is_synchronized - check if symbol data is synchronized.</li> <li>symbol_info_double - single double property (BID, ASK, POINT, etc.).</li> <li>symbol_info_integer - single integer property (DIGITS, SPREAD, etc.).</li> <li>symbol_info_string - single string property (DESCRIPTION, CURRENCY_BASE, etc.).</li> <li>symbol_info_tick - current tick data (BID, ASK, volume, time).</li> <li>symbol_info_margin_rate - margin rates for symbol and order type.</li> <li>symbol_info_session_quote - quote session times for day of week.</li> <li>symbol_info_session_trade - trade session times for day of week.</li> <li>symbol_params_many - all symbol parameters at once (RECOMMENDED for multiple properties).</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/Symbol_Information.Overview/#step-by-step-tutorials","title":"\ud83d\udcda Step-by-step tutorials","text":"<p>Want detailed explanations with line-by-line code breakdown? Check these guides:</p> <ul> <li>symbols_total - How it works</li> <li>symbol_exist - How it works</li> <li>symbol_name - How it works</li> <li>symbol_select - How it works</li> <li>symbol_is_synchronized - How it works</li> <li>symbol_info_double - How it works</li> <li>symbol_info_integer - How it works</li> <li>symbol_info_string - How it works</li> <li>symbol_info_tick - How it works</li> <li>symbol_info_margin_rate - How it works</li> <li>symbol_info_session_quote - How it works</li> <li>symbol_info_session_trade - How it works</li> <li>symbol_params_many - How it works</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/Symbol_Information.Overview/#plain-english","title":"\ud83e\udded Plain English","text":"<ul> <li>symbols_total - how many symbols are available (all or Market Watch only).</li> <li>symbol_exist - check if symbol name is valid.</li> <li>symbol_name - get symbol name by position number.</li> <li>symbol_select - show/hide symbol in Market Watch.</li> <li>symbol_is_synchronized - verify symbol data is up-to-date.</li> <li>symbol_info_double - get one numeric value (price, spread, etc.).</li> <li>symbol_info_integer - get one integer value (digits, spread points, etc.).</li> <li>symbol_info_string - get one text value (description, currency, etc.).</li> <li>symbol_info_tick - get current price snapshot.</li> <li>symbol_info_margin_rate - get margin requirements.</li> <li>symbol_info_session_quote/trade - get trading hours.</li> <li>symbol_params_many - get ALL properties in one call (most efficient).</li> </ul> <p>Rule of thumb: need all properties - <code>symbol_params_many()</code> (RECOMMENDED); need one property - <code>symbol_info_*</code>; need current price - <code>symbol_info_tick()</code>.</p>"},{"location":"MT5Account/2.%20Symbol_Information/Symbol_Information.Overview/#quick-choose","title":"Quick choose","text":"If you need Use Returns Key inputs Count of symbols <code>symbols_total</code> SymbolsTotalData (count) selected_only (bool) Check symbol exists <code>symbol_exist</code> SymbolExistData (bool) symbol name Symbol name by position <code>symbol_name</code> SymbolNameData (string) index, selected Add/remove from Market Watch <code>symbol_select</code> SymbolSelectData (bool) symbol, select Check data synchronized <code>symbol_is_synchronized</code> SymbolIsSynchronizedData symbol name Single double value <code>symbol_info_double</code> SymbolInfoDoubleData symbol, property enum Single integer value <code>symbol_info_integer</code> SymbolInfoIntegerData symbol, property enum Single string value <code>symbol_info_string</code> SymbolInfoStringData symbol, property enum Current tick (BID/ASK/volume) <code>symbol_info_tick</code> MrpcMqlTick symbol name Margin rates <code>symbol_info_margin_rate</code> SymbolInfoMarginRateData symbol, order_type Quote session times <code>symbol_info_session_quote</code> SymbolInfoSessionQuoteData symbol, day, session_index Trade session times <code>symbol_info_session_trade</code> SymbolInfoSessionTradeData symbol, day, session_index ALL symbol parameters (RECOMMENDED) <code>symbol_params_many</code> SymbolParamsManyData symbol_name (optional), pagination"},{"location":"MT5Account/2.%20Symbol_Information/Symbol_Information.Overview/#i-cross-refs-gotchas","title":"\u2139\ufe0f Cross-refs &amp; gotchas","text":"<ul> <li>symbol_params_many - RECOMMENDED for getting multiple properties (single call instead of many).</li> <li>BID vs ASK - BID is sell price, ASK is buy price. Spread = ASK - BID.</li> <li>DIGITS - number of decimal places for symbol (e.g., 5 for EURUSD = 1.12345).</li> <li>SPREAD - current spread in points, not pips (for 5-digit: 1 pip = 10 points).</li> <li>Market Watch - symbols must be in Market Watch to get prices.</li> <li>Synchronization - check <code>symbol_is_synchronized()</code> before trading.</li> <li>Session times - returned in seconds from midnight (convert to hours:minutes).</li> <li>Tick data - use <code>symbol_info_tick()</code> for real-time price snapshot.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/Symbol_Information.Overview/#minimal-snippets","title":"\ud83d\udfe2 Minimal snippets","text":"<pre><code>from MetaRpcMT5.mt5_account import MT5Account\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\n# Get complete symbol parameters (RECOMMENDED)\nrequest = account_helper_pb2.SymbolParamsManyRequest(symbol_name=\"EURUSD\")\ndata = await account.symbol_params_many(request=request)\nif data.symbol_infos:\n    info = data.symbol_infos[0]\n    print(f\"BID: {info.bid}, ASK: {info.ask}\")\n    print(f\"Spread: {info.spread}, Digits: {info.digits}\")\n    print(f\"Contract Size: {info.trade_contract_size}\")\n</code></pre> <pre><code># Get current tick\ntick = await account.symbol_info_tick(symbol=\"EURUSD\")\nprint(f\"BID: {tick.bid}, ASK: {tick.ask}\")\nprint(f\"Spread: {tick.ask - tick.bid}\")\n</code></pre> <pre><code># Get specific properties\nimport MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nbid_data = await account.symbol_info_double(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_BID\n)\n\ndigits_data = await account.symbol_info_integer(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_DIGITS\n)\n\nprint(f\"BID: {bid_data.value:.{digits_data.value}f}\")\n</code></pre> <pre><code># Check if symbol exists\ndata = await account.symbol_exist(symbol=\"EURUSD\")\nif data.exists:\n    print(f\"[OK] EURUSD exists ({'custom' if data.is_custom else 'standard'})\")\n</code></pre> <pre><code># Get all Market Watch symbols\ncount_data = await account.symbols_total(selected_only=True)\n\nsymbols = []\nfor i in range(count_data.total):\n    name_data = await account.symbol_name(index=i, selected=True)\n    symbols.append(name_data.name)\n\nprint(f\"Market Watch symbols: {symbols}\")\n</code></pre> <pre><code># Add symbol to Market Watch\nresult = await account.symbol_select(symbol=\"EURUSD\", select=True)\nif result.success:\n    print(\"[OK] Symbol added to Market Watch\")\n</code></pre> <pre><code># Calculate spread in pips\nimport MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\ntick = await account.symbol_info_tick(symbol=\"EURUSD\")\ndigits_data = await account.symbol_info_integer(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_DIGITS\n)\n\ndigits = digits_data.value\nspread_points = (tick.ask - tick.bid) * (10 ** digits)\nspread_pips = spread_points / 10 if digits == 5 else spread_points\n\nprint(f\"Spread: {spread_pips:.1f} pips\")\n</code></pre> <pre><code># Get all symbols with parameters\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\nrequest = account_helper_pb2.SymbolParamsManyRequest(items_per_page=100)\ndata = await account.symbol_params_many(request=request)\n\nprint(f\"Total symbols: {data.symbols_total}\")\nfor info in data.symbol_infos:\n    print(f\"{info.name}: BID={info.bid}, ASK={info.ask}, Spread={info.spread}\")\n</code></pre> <pre><code># Get margin rates\nimport MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nrates = await account.symbol_info_margin_rate(\n    symbol=\"EURUSD\",\n    order_type=market_info_pb2.ORDER_TYPE_BUY\n)\n\nprint(f\"Initial margin: {rates.initial_margin_rate}\")\nprint(f\"Maintenance margin: {rates.maintenance_margin_rate}\")\n</code></pre> <pre><code># Check trading hours\nimport MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nsession = await account.symbol_info_session_trade(\n    symbol=\"EURUSD\",\n    day_of_week=market_info_pb2.MONDAY,\n    session_index=0\n)\n\nfrom_hours = session.from.seconds // 3600\nfrom_mins = (session.from.seconds % 3600) // 60\nto_hours = session.to.seconds // 3600\nto_mins = (session.to.seconds % 3600) // 60\n\nprint(f\"Monday trading: {from_hours:02d}:{from_mins:02d} - {to_hours:02d}:{to_mins:02d}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/Symbol_Information.Overview/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>Account Information: Account_Information.Overview - get account balance, equity, leverage</li> <li>Positions &amp; Orders: Positions_Orders.Overview - manage open positions and orders</li> <li>Trading Operations: Trading_Operations.Overview - place and manage trades</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/","title":"Check if Symbol Exists","text":"<p>Request: check if a symbol with specified name exists on the trading platform.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.symbol_exist(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>SymbolExist</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>SymbolExist(SymbolExistRequest) -&gt; SymbolExistReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.SymbolExist(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Check if a symbol exists and whether it's standard or custom.</li> <li>Why you need it. Validate symbol names before trading or querying data.</li> <li>When to use. Use this before trading or subscribing to symbol data.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to validate symbols:</p> <ul> <li>Check if symbol exists on platform</li> <li>Identify standard vs custom symbols</li> <li>Validate user input</li> <li>Prevent errors when querying non-existent symbols</li> <li>Pre-trade validation</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; symbol_exist - How it works</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_exist(\n    self,\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n)\n</code></pre> <p>Request message:</p> <pre><code>message SymbolExistRequest {\n  string name = 1;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message SymbolExistReply {\n  oneof response {\n    SymbolExistData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage SymbolExistData {\n  bool exists = 1;\n  bool is_custom = 2;\n}\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> (required) Symbol name to check <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#output-symbolexistdata","title":"\u2b06\ufe0f Output - <code>SymbolExistData</code>","text":"Field Type Python Type Description <code>exists</code> <code>bool</code> <code>bool</code> True if symbol exists <code>is_custom</code> <code>bool</code> <code>bool</code> True if symbol is custom (not standard)"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: Built-in protection against transient gRPC errors.</li> <li>Case sensitive: Symbol names are case-sensitive.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#1-check-if-symbol-exists","title":"1) Check if symbol exists","text":"<pre><code>async def main():\n    account = MT5Account(...)\n    await account.connect_by_host_port()\n\n    data = await account.symbol_exist(symbol=\"EURUSD\")\n\n    if data.exists:\n        symbol_type = \"custom\" if data.is_custom else \"standard\"\n        print(f\"[OK] EURUSD exists ({symbol_type})\")\n    else:\n        print(\"[ERROR] EURUSD does not exist\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#2-validate-symbol-before-trading","title":"2) Validate symbol before trading","text":"<pre><code>async def validate_symbol(account: MT5Account, symbol: str) -&gt; bool:\n    \"\"\"Validate symbol exists before trading\"\"\"\n    data = await account.symbol_exist(symbol=symbol)\n\n    if not data.exists:\n        print(f\"[ERROR] Symbol {symbol} does not exist\")\n        return False\n\n    print(f\"[OK] Symbol {symbol} validated\")\n    return True\n\n# Usage:\nif await validate_symbol(account, \"EURUSD\"):\n    # Place trade\n    pass\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#3-check-multiple-symbols","title":"3) Check multiple symbols","text":"<pre><code>async def check_symbols(account: MT5Account, symbols: list[str]):\n    \"\"\"Check which symbols exist\"\"\"\n    results = {}\n\n    for symbol in symbols:\n        data = await account.symbol_exist(symbol=symbol)\n        results[symbol] = data.exists\n\n    # Print results\n    for symbol, exists in results.items():\n        status = \"[OK]\" if exists else \"[ERROR]\"\n        print(f\"{status} {symbol}: {'exists' if exists else 'not found'}\")\n\n    return results\n\n# Usage:\nsymbols = [\"EURUSD\", \"GBPUSD\", \"INVALID\"]\nawait check_symbols(account, symbols)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#4-filter-valid-symbols","title":"4) Filter valid symbols","text":"<pre><code>async def filter_valid_symbols(\n    account: MT5Account,\n    symbols: list[str]\n) -&gt; list[str]:\n    \"\"\"Filter out non-existent symbols\"\"\"\n    valid_symbols = []\n\n    for symbol in symbols:\n        data = await account.symbol_exist(symbol=symbol)\n        if data.exists:\n            valid_symbols.append(symbol)\n\n    print(f\"[OK] {len(valid_symbols)} of {len(symbols)} symbols are valid\")\n    return valid_symbols\n\n# Usage:\nsymbols = [\"EURUSD\", \"GBPUSD\", \"INVALID_SYMBOL\"]\nvalid = await filter_valid_symbols(account, symbols)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#5-identify-custom-symbols","title":"5) Identify custom symbols","text":"<pre><code>async def get_symbol_type(account: MT5Account, symbol: str) -&gt; str:\n    \"\"\"Get symbol type (standard/custom/not found)\"\"\"\n    data = await account.symbol_exist(symbol=symbol)\n\n    if not data.exists:\n        return \"not_found\"\n    return \"custom\" if data.is_custom else \"standard\"\n\n# Usage:\nsymbol_type = await get_symbol_type(account, \"EURUSD\")\nprint(f\"EURUSD type: {symbol_type}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#common-patterns","title":"Common Patterns","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#quick-existence-check","title":"Quick existence check","text":"<pre><code>async def symbol_exists(account: MT5Account, symbol: str) -&gt; bool:\n    \"\"\"Quick check if symbol exists\"\"\"\n    data = await account.symbol_exist(symbol=symbol)\n    return data.exists\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_exist/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>symbols_total - Get total symbol count</li> <li>symbol_name - Get symbol name by index</li> <li>symbol_select - Add/remove symbol from Market Watch</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/","title":"Get Symbol Double Property","text":"<p>Request: retrieve double-type property value for a symbol.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.symbol_info_double(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>SymbolInfoDouble</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>SymbolInfoDouble(SymbolInfoDoubleRequest) -&gt; SymbolInfoDoubleReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.SymbolInfoDouble(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Retrieve a single double-type property value for a symbol (BID, ASK, VOLUME, etc.).</li> <li>Why you need it. Get specific numeric symbol properties without fetching all symbol data.</li> <li>When to use. Use <code>symbol_params_many()</code> for multiple properties. Use this method for single property queries.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to query specific double symbol properties:</p> <ul> <li>Get current BID/ASK prices</li> <li>Check trading volumes</li> <li>Retrieve margin requirements</li> <li>Get swap rates</li> <li>Query tick values and contract sizes</li> <li>Monitor session prices and limits</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; symbol_info_double - How it works</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_info_double(\n    self,\n    symbol: str,\n    property: market_info_pb2.SymbolInfoDoubleProperty,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n)\n</code></pre> <p>Request message:</p> <pre><code>message SymbolInfoDoubleRequest {\n  string symbol = 1;\n  SymbolInfoDoubleProperty type = 2;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message SymbolInfoDoubleReply {\n  oneof response {\n    SymbolInfoDoubleData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage SymbolInfoDoubleData {\n  double value = 1;\n}\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> (required) Symbol name <code>property</code> <code>SymbolInfoDoubleProperty</code> (enum) Property to retrieve (BID, ASK, etc.) <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#output-symbolinfodoubledata","title":"\u2b06\ufe0f Output - <code>SymbolInfoDoubleData</code>","text":"Field Type Python Type Description <code>value</code> <code>double</code> <code>float</code> The value of the requested property <p>Return value: The method returns <code>SymbolInfoDoubleData</code> object. Access the numeric value via the <code>.value</code> attribute.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":"<p>Note: In Python code, use the full enum path from the market_info module.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#symbolinfodoubleproperty","title":"<code>SymbolInfoDoubleProperty</code>","text":"<p>Defined in <code>mt5-term-api-market-info.proto</code>.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#price-properties","title":"Price Properties","text":"Constant Value Description <code>SYMBOL_BID</code> 0 Current Bid price <code>SYMBOL_BIDHIGH</code> 1 Maximal Bid for the day <code>SYMBOL_BIDLOW</code> 2 Minimal Bid for the day <code>SYMBOL_ASK</code> 3 Current Ask price <code>SYMBOL_ASKHIGH</code> 4 Maximal Ask for the day <code>SYMBOL_ASKLOW</code> 5 Minimal Ask for the day <code>SYMBOL_LAST</code> 6 Last deal price <code>SYMBOL_LASTHIGH</code> 7 Maximal Last for the day <code>SYMBOL_LASTLOW</code> 8 Minimal Last for the day"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#volume-properties","title":"Volume Properties","text":"Constant Value Description <code>SYMBOL_VOLUME_REAL</code> 9 Real volume of the day <code>SYMBOL_VOLUMEHIGH_REAL</code> 10 Maximum real volume of the day <code>SYMBOL_VOLUMELOW_REAL</code> 11 Minimum real volume of the day <code>SYMBOL_VOLUME_MIN</code> 22 Minimal volume for a deal <code>SYMBOL_VOLUME_MAX</code> 23 Maximal volume for a deal <code>SYMBOL_VOLUME_STEP</code> 24 Minimal volume change step <code>SYMBOL_VOLUME_LIMIT</code> 25 Maximum allowed aggregate volume"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#trading-properties","title":"Trading Properties","text":"Constant Value Description <code>SYMBOL_POINT</code> 13 Symbol point value <code>SYMBOL_TRADE_TICK_VALUE</code> 14 Calculated tick price for position <code>SYMBOL_TRADE_TICK_VALUE_PROFIT</code> 15 Calculated tick price for profit <code>SYMBOL_TRADE_TICK_VALUE_LOSS</code> 16 Calculated tick price for loss <code>SYMBOL_TRADE_TICK_SIZE</code> 17 Minimal price change <code>SYMBOL_TRADE_CONTRACT_SIZE</code> 18 Trade contract size <code>SYMBOL_TRADE_ACCRUED_INTEREST</code> 19 Accrued interest <code>SYMBOL_TRADE_FACE_VALUE</code> 20 Face value <code>SYMBOL_TRADE_LIQUIDITY_RATE</code> 21 Liquidity rate"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#swap-rates","title":"Swap Rates","text":"Constant Value Description <code>SYMBOL_SWAP_LONG</code> 26 Long swap value <code>SYMBOL_SWAP_SHORT</code> 27 Short swap value <code>SYMBOL_SWAP_SUNDAY</code> 28 Swap value for Sunday <code>SYMBOL_SWAP_MONDAY</code> 29 Swap value for Monday <code>SYMBOL_SWAP_TUESDAY</code> 30 Swap value for Tuesday <code>SYMBOL_SWAP_WEDNESDAY</code> 31 Swap value for Wednesday <code>SYMBOL_SWAP_THURSDAY</code> 32 Swap value for Thursday <code>SYMBOL_SWAP_FRIDAY</code> 33 Swap value for Friday <code>SYMBOL_SWAP_SATURDAY</code> 34 Swap value for Saturday"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#margin-requirements","title":"Margin Requirements","text":"Constant Value Description <code>SYMBOL_MARGIN_INITIAL</code> 35 Initial margin <code>SYMBOL_MARGIN_MAINTENANCE</code> 36 Maintenance margin <code>SYMBOL_MARGIN_HEDGED</code> 48 Hedged margin"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#session-properties","title":"Session Properties","text":"Constant Value Description <code>SYMBOL_SESSION_VOLUME</code> 37 Summary volume of the current session <code>SYMBOL_SESSION_TURNOVER</code> 38 Summary turnover of the current session <code>SYMBOL_SESSION_INTEREST</code> 39 Summary open interest <code>SYMBOL_SESSION_BUY_ORDERS_VOLUME</code> 40 Current volume of buy orders <code>SYMBOL_SESSION_SELL_ORDERS_VOLUME</code> 41 Current volume of sell orders <code>SYMBOL_SESSION_OPEN</code> 42 Open price of the current session <code>SYMBOL_SESSION_CLOSE</code> 43 Close price of the current session <code>SYMBOL_SESSION_AW</code> 44 Average weighted price <code>SYMBOL_SESSION_PRICE_SETTLEMENT</code> 45 Settlement price of the current session <code>SYMBOL_SESSION_PRICE_LIMIT_MIN</code> 46 Minimal price of the current session <code>SYMBOL_SESSION_PRICE_LIMIT_MAX</code> 47 Maximal price of the current session"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#price-analytics-options","title":"Price Analytics &amp; Options","text":"Constant Value Description <code>SYMBOL_OPTION_STRIKE</code> 12 Option strike price <code>SYMBOL_PRICE_CHANGE</code> 49 Change of price in % <code>SYMBOL_PRICE_VOLATILITY</code> 50 Price volatility in % <code>SYMBOL_PRICE_THEORETICAL</code> 51 Theoretical option price <code>SYMBOL_PRICE_DELTA</code> 52 Option/warrant delta <code>SYMBOL_PRICE_THETA</code> 53 Option/warrant theta <code>SYMBOL_PRICE_GAMMA</code> 54 Option/warrant gamma <code>SYMBOL_PRICE_VEGA</code> 55 Option/warrant vega <code>SYMBOL_PRICE_RHO</code> 56 Option/warrant rho <code>SYMBOL_PRICE_OMEGA</code> 57 Option/warrant omega <code>SYMBOL_PRICE_SENSITIVITY</code> 58 Option/warrant sensitivity <code>SYMBOL_COUNT</code> 59 Total count of properties <p>Usage in Python: <pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Access price constants\nbid_property = market_info_pb2.SYMBOL_BID  # = 0\nask_property = market_info_pb2.SYMBOL_ASK  # = 3\n\n# Use in method call\nbid_data = await account.symbol_info_double(\"EURUSD\", market_info_pb2.SYMBOL_BID)\nprint(f\"BID: {bid_data.value}\")\n</code></pre></p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: Built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>Property availability: Not all properties are available for all symbols. Check broker documentation for symbol-specific properties.</li> <li>Tick values: Use <code>SYMBOL_TRADE_TICK_VALUE</code> properties for accurate profit/loss calculations.</li> <li>Volume limits: Always check <code>SYMBOL_VOLUME_MIN</code>, <code>SYMBOL_VOLUME_MAX</code>, and <code>SYMBOL_VOLUME_STEP</code> before placing orders.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#1-get-bid-and-ask-prices","title":"1) Get BID and ASK prices","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get BID price (short format - recommended)\nbid_data = await account.symbol_info_double(\"EURUSD\", market_info_pb2.SYMBOL_BID)\nprint(f\"BID: {bid_data.value}\")\n\n# Get ASK price\nask_data = await account.symbol_info_double(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_ASK\n)\nprint(f\"ASK: {ask_data.value}\")\n\n# Calculate spread\nspread = ask_data.value - bid_data.value\nprint(f\"Spread: {spread:.5f}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#2-get-volume-limits-for-trading","title":"2) Get volume limits for trading","text":"<pre><code>async def get_volume_limits(account: MT5Account, symbol: str):\n    \"\"\"Get volume constraints for a symbol\"\"\"\n\n    # Get minimum volume\n    min_vol_data = await account.symbol_info_double(\n        symbol,\n        market_info_pb2.SYMBOL_VOLUME_MIN\n    )\n\n    # Get maximum volume\n    max_vol_data = await account.symbol_info_double(\n        symbol,\n        market_info_pb2.SYMBOL_VOLUME_MAX\n    )\n\n    # Get volume step\n    step_data = await account.symbol_info_double(\n        symbol,\n        market_info_pb2.SYMBOL_VOLUME_STEP\n    )\n\n    print(f\"Volume limits for {symbol}:\")\n    print(f\"  Min: {min_vol_data.value:.2f} lots\")\n    print(f\"  Max: {max_vol_data.value:.2f} lots\")\n    print(f\"  Step: {step_data.value:.2f} lots\")\n\n    return {\n        \"min\": min_vol_data.value,\n        \"max\": max_vol_data.value,\n        \"step\": step_data.value\n    }\n\n# Usage:\nlimits = await get_volume_limits(account, \"EURUSD\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#3-get-swap-rates","title":"3) Get swap rates","text":"<pre><code>async def get_swap_info(account: MT5Account, symbol: str):\n    \"\"\"Get long and short swap rates\"\"\"\n\n    # Get long swap\n    long_swap_data = await account.symbol_info_double(\n        symbol,\n        market_info_pb2.SYMBOL_SWAP_LONG\n    )\n\n    # Get short swap\n    short_swap_data = await account.symbol_info_double(\n        symbol,\n        market_info_pb2.SYMBOL_SWAP_SHORT\n    )\n\n    print(f\"Swap for {symbol}:\")\n    print(f\"  Long: {long_swap_data.value:.2f}\")\n    print(f\"  Short: {short_swap_data.value:.2f}\")\n\n    return {\n        \"long\": long_swap_data.value,\n        \"short\": short_swap_data.value\n    }\n\n# Usage:\nswaps = await get_swap_info(account, \"GBPUSD\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#4-get-tick-size-and-contract-size","title":"4) Get tick size and contract size","text":"<pre><code>async def get_trading_specs(account: MT5Account, symbol: str):\n    \"\"\"Get tick size and contract size for precise calculations\"\"\"\n\n    # Get tick size (minimal price change)\n    tick_size_data = await account.symbol_info_double(\n        symbol,\n        market_info_pb2.SYMBOL_TRADE_TICK_SIZE\n    )\n\n    # Get contract size\n    contract_size_data = await account.symbol_info_double(\n        symbol,\n        market_info_pb2.SYMBOL_TRADE_CONTRACT_SIZE\n    )\n\n    # Get point value\n    point_data = await account.symbol_info_double(\n        symbol,\n        market_info_pb2.SYMBOL_POINT\n    )\n\n    print(f\"Trading specs for {symbol}:\")\n    print(f\"  Tick size: {tick_size_data.value}\")\n    print(f\"  Contract size: {contract_size_data.value}\")\n    print(f\"  Point value: {point_data.value}\")\n\n    return {\n        \"tick_size\": tick_size_data.value,\n        \"contract_size\": contract_size_data.value,\n        \"point\": point_data.value\n    }\n\n# Usage:\nspecs = await get_trading_specs(account, \"EURUSD\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#5-check-if-price-is-within-session-limits","title":"5) Check if price is within session limits","text":"<pre><code>async def check_price_limits(account: MT5Account, symbol: str, price: float) -&gt; bool:\n    \"\"\"Check if price is within current session limits\"\"\"\n\n    # Get session price limits\n    min_price_data = await account.symbol_info_double(\n        symbol,\n        market_info_pb2.SYMBOL_SESSION_PRICE_LIMIT_MIN\n    )\n\n    max_price_data = await account.symbol_info_double(\n        symbol,\n        market_info_pb2.SYMBOL_SESSION_PRICE_LIMIT_MAX\n    )\n\n    min_price = min_price_data.value\n    max_price = max_price_data.value\n\n    if min_price &lt;= price &lt;= max_price:\n        print(f\"[OK] Price {price} is within limits [{min_price}, {max_price}]\")\n        return True\n    else:\n        print(f\"[ERROR] Price {price} is outside limits [{min_price}, {max_price}]\")\n        return False\n\n# Usage:\nis_valid = await check_price_limits(account, \"EURUSD\", 1.08500)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#common-patterns","title":"Common Patterns","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#validate-volume-before-order","title":"Validate volume before order","text":"<pre><code>async def validate_volume(account: MT5Account, symbol: str, volume: float) -&gt; bool:\n    \"\"\"Validate volume meets symbol requirements\"\"\"\n\n    min_data = await account.symbol_info_double(symbol, market_info_pb2.SYMBOL_VOLUME_MIN)\n    max_data = await account.symbol_info_double(symbol, market_info_pb2.SYMBOL_VOLUME_MAX)\n    step_data = await account.symbol_info_double(symbol, market_info_pb2.SYMBOL_VOLUME_STEP)\n\n    min_vol = min_data.value\n    max_vol = max_data.value\n    step = step_data.value\n\n    # Check range\n    if volume &lt; min_vol or volume &gt; max_vol:\n        print(f\"[ERROR] Volume {volume} outside range [{min_vol}, {max_vol}]\")\n        return False\n\n    # Check step\n    if (volume - min_vol) % step != 0:\n        print(f\"[ERROR] Volume {volume} doesn't match step {step}\")\n        return False\n\n    return True\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#get-current-market-price","title":"Get current market price","text":"<pre><code>async def get_market_price(account: MT5Account, symbol: str, side: str) -&gt; float:\n    \"\"\"Get current market price for buy or sell\"\"\"\n\n    if side.upper() == \"BUY\":\n        # For buy orders, use ASK price\n        data = await account.symbol_info_double(symbol, market_info_pb2.SYMBOL_ASK)\n    else:\n        # For sell orders, use BID price\n        data = await account.symbol_info_double(symbol, market_info_pb2.SYMBOL_BID)\n\n    return data.value\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_double/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>symbol_info_integer - Get integer properties</li> <li>symbol_info_string - Get string properties</li> <li>symbol_params_many - Get all symbol parameters at once</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/","title":"Get Symbol Integer Property","text":"<p>Request: retrieve integer-type property value for a symbol.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.symbol_info_integer(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>SymbolInfoInteger</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>SymbolInfoInteger(SymbolInfoIntegerRequest) -&gt; SymbolInfoIntegerReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.SymbolInfoInteger(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Retrieve a single integer-type property value for a symbol (DIGITS, SPREAD, TRADE_MODE, etc.).</li> <li>Why you need it. Get specific integer symbol properties without fetching all symbol data.</li> <li>When to use. Use <code>symbol_params_many()</code> for multiple properties. Use this method for single property queries.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to query specific integer symbol properties:</p> <ul> <li>Get symbol digits (decimal places)</li> <li>Check current spread in points</li> <li>Query trading modes and execution modes</li> <li>Get timestamps (start time, expiration)</li> <li>Check volume parameters</li> <li>Retrieve trade stops and freeze levels</li> <li>Query swap rollover settings</li> <li>Monitor order and filling modes</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; symbol_info_integer - How it works</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_info_integer(\n    self,\n    symbol: str,\n    property: market_info_pb2.SymbolInfoIntegerProperty,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; market_info_pb2.SymbolInfoIntegerData\n</code></pre> <p>Request message:</p> <pre><code>message SymbolInfoIntegerRequest {\n  string symbol = 1;\n  SymbolInfoIntegerProperty type = 2;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message SymbolInfoIntegerReply {\n  oneof response {\n    SymbolInfoIntegerData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage SymbolInfoIntegerData {\n  int64 value = 1;\n}\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> (required) Symbol name <code>property</code> <code>SymbolInfoIntegerProperty</code> (enum) Property to retrieve (DIGITS, SPREAD, etc.) <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#output","title":"\u2b06\ufe0f Output","text":"Field Type Python Type Description <code>value</code> <code>int64</code> <code>int</code> The integer value of the property <p>Return value: The method returns <code>SymbolInfoIntegerData</code> object with <code>value</code> field containing the requested property.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":"<p>Note: In Python code, use the full enum path from the market_info module.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#symbolinfointegerproperty","title":"<code>SymbolInfoIntegerProperty</code>","text":"<p>Defined in <code>mt5-term-api-market-info.proto</code>.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#symbol-status-display","title":"Symbol Status &amp; Display","text":"Constant Value Description <code>SYMBOL_EXIST</code> 6 Symbol exists flag <code>SYMBOL_SELECT</code> 7 Symbol selected in MarketWatch <code>SYMBOL_VISIBLE</code> 8 Symbol visible in MarketWatch <code>SYMBOL_SUBSCRIPTION_DELAY</code> 0 Subscription delay <code>SYMBOL_CUSTOM</code> 3 Custom symbol flag <code>SYMBOL_BACKGROUND_COLOR</code> 4 Background color <code>SYMBOL_CHART_MODE</code> 5 Chart mode"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#classification","title":"Classification","text":"Constant Value Description <code>SYMBOL_SECTOR</code> 1 Sector <code>SYMBOL_INDUSTRY</code> 2 Industry"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#time-precision","title":"Time &amp; Precision","text":"Constant Value Description <code>SYMBOL_TIME</code> 15 Time of last quote <code>SYMBOL_TIME_MSC</code> 16 Time of last quote in milliseconds <code>SYMBOL_DIGITS</code> 17 Digits after decimal point <code>SYMBOL_START_TIME</code> 23 Symbol start time <code>SYMBOL_EXPIRATION_TIME</code> 24 Symbol expiration time"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#spread-volume","title":"Spread &amp; Volume","text":"Constant Value Description <code>SYMBOL_SPREAD</code> 19 Spread value in points <code>SYMBOL_SPREAD_FLOAT</code> 18 Floating spread flag <code>SYMBOL_VOLUME</code> 12 Last deal volume <code>SYMBOL_VOLUMEHIGH</code> 13 Maximum volume for the day <code>SYMBOL_VOLUMELOW</code> 14 Minimum volume for the day <code>SYMBOL_TICKS_BOOKDEPTH</code> 20 Maximal number of requests shown in DOM"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#session-data","title":"Session Data","text":"Constant Value Description <code>SYMBOL_SESSION_DEALS</code> 9 Number of deals in current session <code>SYMBOL_SESSION_BUY_ORDERS</code> 10 Number of buy orders <code>SYMBOL_SESSION_SELL_ORDERS</code> 11 Number of sell orders"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#trading-properties","title":"Trading Properties","text":"Constant Value Description <code>SYMBOL_TRADE_CALC_MODE</code> 21 Contract price calculation mode <code>SYMBOL_TRADE_MODE</code> 22 Order execution type <code>SYMBOL_TRADE_STOPS_LEVEL</code> 25 Minimal distance of stops <code>SYMBOL_TRADE_FREEZE_LEVEL</code> 26 Distance to freeze trading operations <code>SYMBOL_TRADE_EXEMODE</code> 27 Deal execution mode"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#order-expiration-modes","title":"Order &amp; Expiration Modes","text":"Constant Value Description <code>SYMBOL_EXPIRATION_MODE</code> 31 Flags of allowed expiration modes <code>SYMBOL_FILLING_MODE</code> 32 Flags of allowed filling modes <code>SYMBOL_ORDER_MODE</code> 33 Flags of allowed order types <code>SYMBOL_ORDER_GTC_MODE</code> 34 Expiration of pending orders GTC mode"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#swap-margin","title":"Swap &amp; Margin","text":"Constant Value Description <code>SYMBOL_SWAP_MODE</code> 28 Swap calculation model <code>SYMBOL_SWAP_ROLLOVER3DAYS</code> 29 Day of week to charge 3 days swap <code>SYMBOL_MARGIN_HEDGED_USE_LEG</code> 30 Calculating hedged margin using larger leg"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#options","title":"Options","text":"Constant Value Description <code>SYMBOL_OPTION_MODE</code> 35 Option type <code>SYMBOL_OPTION_RIGHT</code> 36 Option right (Call/Put) <p>Usage in Python: <pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get symbol digits\ndigits_data = await account.symbol_info_integer(\"EURUSD\", market_info_pb2.SYMBOL_DIGITS)\nprint(f\"Digits: {digits_data.value}\")\n\n# Check spread\nspread_data = await account.symbol_info_integer(\"EURUSD\", market_info_pb2.SYMBOL_SPREAD)\nprint(f\"Spread: {spread_data.value} points\")\n</code></pre></p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: Built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>Access the value: The returned <code>SymbolInfoIntegerData</code> object has a <code>.value</code> field containing the integer.</li> <li>Trading modes: Mode properties return integer flags - refer to MT5 documentation for flag meanings.</li> <li>Timestamps: TIME and TIME_MSC properties return Unix timestamps (seconds or milliseconds).</li> <li>Spread units: SYMBOL_SPREAD returns spread in points, not pips.</li> <li>Boolean flags: Properties like SYMBOL_EXIST, SYMBOL_SELECT, SYMBOL_VISIBLE return 0 or 1.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#1-get-symbol-digits-and-spread","title":"1) Get symbol digits and spread","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get digits (decimal places)\nresult = await account.symbol_info_integer(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_DIGITS\n)\nprint(f\"Digits: {result.value}\")  # Output: Digits: 5\n\n# Get spread in points\nspread_result = await account.symbol_info_integer(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_SPREAD\n)\nprint(f\"Spread: {spread_result.value} points\")  # Output: Spread: 10 points\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#2-check-if-symbol-is-selected-in-marketwatch","title":"2) Check if symbol is selected in MarketWatch","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nresult = await account.symbol_info_integer(\n    symbol=\"GBPUSD\",\n    property=market_info_pb2.SYMBOL_SELECT\n)\n\nif result.value:\n    print(\"Symbol is in MarketWatch\")\nelse:\n    print(\"Symbol is NOT in MarketWatch\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#3-get-trade-mode","title":"3) Get trade mode","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nresult = await account.symbol_info_integer(\n    symbol=\"XAUUSD\",\n    property=market_info_pb2.SYMBOL_TRADE_MODE\n)\n\n# Map to trade mode names\ntrade_modes = {\n    0: \"DISABLED\",\n    1: \"LONG_ONLY\",\n    2: \"SHORT_ONLY\",\n    3: \"CLOSE_ONLY\",\n    4: \"FULL\"\n}\n\nmode_name = trade_modes.get(result.value, \"UNKNOWN\")\nprint(f\"Trade mode: {mode_name} (value: {result.value})\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#4-get-last-quote-timestamp","title":"4) Get last quote timestamp","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nfrom datetime import datetime\n\n# Get timestamp in seconds\nresult = await account.symbol_info_integer(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_TIME\n)\n\n# Convert to datetime\nquote_time = datetime.utcfromtimestamp(result.value)\nprint(f\"Last quote time: {quote_time}\")\n\n# Or get milliseconds timestamp\nresult_msc = await account.symbol_info_integer(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_TIME_MSC\n)\nquote_time_msc = datetime.utcfromtimestamp(result_msc.value / 1000)\nprint(f\"Last quote time (ms precision): {quote_time_msc}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#5-check-stops-level-before-placing-order","title":"5) Check stops level before placing order","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nresult = await account.symbol_info_integer(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_TRADE_STOPS_LEVEL\n)\n\nstops_level = result.value\nprint(f\"Minimum stops level: {stops_level} points\")\nprint(f\"SL/TP must be at least {stops_level} points away from current price\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#6-get-freeze-level","title":"6) Get freeze level","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nresult = await account.symbol_info_integer(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_TRADE_FREEZE_LEVEL\n)\n\nfreeze_level = result.value\nif freeze_level &gt; 0:\n    print(f\"Freeze level: {freeze_level} points\")\n    print(f\"Orders cannot be modified when price is within {freeze_level} points\")\nelse:\n    print(\"No freeze level set\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#7-check-allowed-order-types","title":"7) Check allowed order types","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nresult = await account.symbol_info_integer(\n    symbol=\"BTCUSD\",\n    property=market_info_pb2.SYMBOL_ORDER_MODE\n)\n\n# ORDER_MODE is a bitfield\norder_flags = result.value\n\n# Check specific order types (example flag values)\nif order_flags &amp; 1:\n    print(\"Market orders allowed\")\nif order_flags &amp; 2:\n    print(\"Limit orders allowed\")\nif order_flags &amp; 4:\n    print(\"Stop orders allowed\")\nif order_flags &amp; 8:\n    print(\"Stop Limit orders allowed\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_integer/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>symbol_info_double - Get double properties</li> <li>symbol_info_string - Get string properties</li> <li>symbol_params_many - Get all symbol parameters at once</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/","title":"Get Symbol Margin Rates","text":"<p>Request: retrieve margin rates for symbol and order type.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.symbol_info_margin_rate(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>SymbolInfoMarginRate</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>SymbolInfoMarginRate(SymbolInfoMarginRateRequest) -&gt; SymbolInfoMarginRateReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.SymbolInfoMarginRate(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Retrieve initial and maintenance margin rates for a specific symbol and order type.</li> <li>Why you need it. Calculate margin requirements before placing orders, understand leverage conditions.</li> <li>When to use. Use before trading to estimate margin needs, especially for different order types (BUY/SELL).</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to query margin requirements:</p> <ul> <li>Calculate required margin before opening positions</li> <li>Understand margin differences between BUY and SELL orders</li> <li>Estimate leverage impact on margin</li> <li>Validate available margin before trading</li> <li>Compare margin requirements across symbols</li> <li>Plan position sizing based on margin availability</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; symbol_info_margin_rate - How it works</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_info_margin_rate(\n    self,\n    symbol: str,\n    order_type: market_info_pb2.ENUM_ORDER_TYPE,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; market_info_pb2.SymbolInfoMarginRateData\n</code></pre> <p>Request message:</p> <pre><code>message SymbolInfoMarginRateRequest {\n  string symbol = 1;\n  ENUM_ORDER_TYPE order_type = 2;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message SymbolInfoMarginRateReply {\n  oneof response {\n    SymbolInfoMarginRateData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage SymbolInfoMarginRateData {\n  double maintenance_margin_rate = 1;\n  double initial_margin_rate = 2;\n}\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> (required) Symbol name <code>order_type</code> <code>ENUM_ORDER_TYPE</code> (enum) Order type (BUY, SELL, etc.) <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#output","title":"\u2b06\ufe0f Output","text":"Field Type Python Type Description <code>initial_margin_rate</code> <code>double</code> <code>float</code> Initial margin rate <code>maintenance_margin_rate</code> <code>double</code> <code>float</code> Maintenance margin rate <p>Return value: The method returns <code>SymbolInfoMarginRateData</code> object with margin rate fields.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":"<p>Note: In Python code, use the full enum path from the market_info module.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#enum_order_type","title":"<code>ENUM_ORDER_TYPE</code>","text":"<p>Defined in <code>mt5-term-api-market-info.proto</code>.</p> Constant Value Description <code>ORDER_TYPE_BUY</code> 0 Buy market order <code>ORDER_TYPE_SELL</code> 1 Sell market order <code>ORDER_TYPE_BUY_LIMIT</code> 2 Buy Limit pending order <code>ORDER_TYPE_SELL_LIMIT</code> 3 Sell Limit pending order <code>ORDER_TYPE_BUY_STOP</code> 4 Buy Stop pending order <code>ORDER_TYPE_SELL_STOP</code> 5 Sell Stop pending order <code>ORDER_TYPE_BUY_STOP_LIMIT</code> 6 Buy Stop Limit pending order <code>ORDER_TYPE_SELL_STOP_LIMIT</code> 7 Sell Stop Limit pending order <code>ORDER_TYPE_CLOSE_BY</code> 8 Close by opposite order <p>Usage in Python: <pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get margin rates for BUY orders\nrates = await account.symbol_info_margin_rate(\n    symbol=\"EURUSD\",\n    order_type=market_info_pb2.ORDER_TYPE_BUY\n)\nprint(f\"Initial margin rate: {rates.initial_margin_rate}\")\nprint(f\"Maintenance margin rate: {rates.maintenance_margin_rate}\")\n</code></pre></p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: Built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>Margin rates meaning:</li> <li>Initial margin rate: The rate used when opening a position (multiplied by contract value)</li> <li>Maintenance margin rate: The rate used for maintaining an open position</li> <li>Rate differences: BUY and SELL orders may have different margin rates for the same symbol.</li> <li>Hedge accounts: On hedge accounts, margin rates are typically the same for BUY and SELL.</li> <li>Netting accounts: On netting accounts, margin calculations may differ based on position direction.</li> <li>Calculation: Required margin = (Contract Size \u00d7 Volume \u00d7 Price) \u00d7 Margin Rate</li> <li>UUID handling: The terminal instance UUID is auto-generated by the server if not provided.    For explicit control (e.g., in streaming scenarios), pass <code>id_=uuid4()</code> to constructor.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#1-get-margin-rates-for-buy-order","title":"1) Get margin rates for BUY order","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get margin rates for BUY order\nrates = await account.symbol_info_margin_rate(\n    symbol=\"EURUSD\",\n    order_type=market_info_pb2.ORDER_TYPE_BUY\n)\n\nprint(f\"BUY Order Margin Rates:\")\nprint(f\"  Initial: {rates.initial_margin_rate}\")\nprint(f\"  Maintenance: {rates.maintenance_margin_rate}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#2-compare-buy-vs-sell-margin-rates","title":"2) Compare BUY vs SELL margin rates","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get BUY margin rates\nbuy_rates = await account.symbol_info_margin_rate(\n    symbol=\"XAUUSD\",\n    order_type=market_info_pb2.ORDER_TYPE_BUY\n)\n\n# Get SELL margin rates\nsell_rates = await account.symbol_info_margin_rate(\n    symbol=\"XAUUSD\",\n    order_type=market_info_pb2.ORDER_TYPE_SELL\n)\n\nprint(f\"XAUUSD Margin Rates:\")\nprint(f\"  BUY  - Initial: {buy_rates.initial_margin_rate}, Maintenance: {buy_rates.maintenance_margin_rate}\")\nprint(f\"  SELL - Initial: {sell_rates.initial_margin_rate}, Maintenance: {sell_rates.maintenance_margin_rate}\")\n\nif buy_rates.initial_margin_rate == sell_rates.initial_margin_rate:\n    print(\"  Same margin rates for both directions (hedge account)\")\nelse:\n    print(\"  Different margin rates (check account type)\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#3-calculate-required-margin-before-trading","title":"3) Calculate required margin before trading","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def calculate_required_margin(\n    account,\n    symbol: str,\n    volume: float,\n    order_type: int = market_info_pb2.ORDER_TYPE_BUY\n) -&gt; float:\n    \"\"\"Calculate required margin for opening a position\"\"\"\n\n    # Get margin rates\n    rates = await account.symbol_info_margin_rate(\n        symbol=symbol,\n        order_type=order_type\n    )\n\n    # Get contract size\n    contract_size_data = await account.symbol_info_double(\n        symbol=symbol,\n        property=market_info_pb2.SYMBOL_TRADE_CONTRACT_SIZE\n    )\n\n    # Get current price (ASK for BUY, BID for SELL)\n    if order_type in [market_info_pb2.ORDER_TYPE_BUY, market_info_pb2.ORDER_TYPE_BUY_LIMIT, market_info_pb2.ORDER_TYPE_BUY_STOP]:\n        price_data = await account.symbol_info_double(symbol=symbol, property=market_info_pb2.SYMBOL_ASK)\n    else:\n        price_data = await account.symbol_info_double(symbol=symbol, property=market_info_pb2.SYMBOL_BID)\n\n    # Calculate margin\n    contract_value = contract_size_data.value * volume * price_data.value\n    required_margin = contract_value * rates.initial_margin_rate\n\n    return required_margin\n\n# Usage\nmargin = await calculate_required_margin(\n    account=account,\n    symbol=\"EURUSD\",\n    volume=1.0,\n    order_type=market_info_pb2.ORDER_TYPE_BUY\n)\n\nprint(f\"Required margin for 1.0 lot EURUSD BUY: ${margin:.2f}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#4-check-if-sufficient-margin-available","title":"4) Check if sufficient margin available","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nimport MetaRpcMT5.mt5_term_api_account_information_pb2 as account_info_pb2\n\nasync def can_open_position(\n    account,\n    symbol: str,\n    volume: float,\n    order_type: int = market_info_pb2.ORDER_TYPE_BUY\n) -&gt; bool:\n    \"\"\"Check if account has sufficient margin to open position\"\"\"\n\n    # Calculate required margin (from previous example)\n    required_margin = await calculate_required_margin(account, symbol, volume, order_type)\n\n    # Get free margin\n    free_margin = await account.account_info_double(\n        property_id=account_info_pb2.ACCOUNT_MARGIN_FREE\n    )\n\n    # Check if sufficient\n    if free_margin &gt;= required_margin:\n        print(f\"[OK] Sufficient margin:\")\n        print(f\"  Required: ${required_margin:.2f}\")\n        print(f\"  Available: ${free_margin:.2f}\")\n        return True\n    else:\n        print(f\"[ERROR] Insufficient margin:\")\n        print(f\"  Required: ${required_margin:.2f}\")\n        print(f\"  Available: ${free_margin:.2f}\")\n        print(f\"  Deficit: ${required_margin - free_margin:.2f}\")\n        return False\n\n# Usage\nif await can_open_position(account, \"EURUSD\", 2.0):\n    print(\"Safe to open 2.0 lot position\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#5-get-margin-rates-with-timeout","title":"5) Get margin rates with timeout","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nfrom datetime import datetime, timedelta\n\n# Set deadline\ndeadline = datetime.utcnow() + timedelta(seconds=3)\n\ntry:\n    rates = await account.symbol_info_margin_rate(\n        symbol=\"GBPUSD\",\n        order_type=market_info_pb2.ORDER_TYPE_BUY,\n        deadline=deadline\n    )\n    print(f\"Margin rates retrieved: {rates.initial_margin_rate}\")\nexcept Exception as e:\n    print(f\"Timeout or error: {e}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#6-compare-margin-requirements-across-symbols","title":"6) Compare margin requirements across symbols","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def compare_symbol_margins(account, symbols: list[str]):\n    \"\"\"Compare margin requirements for multiple symbols\"\"\"\n\n    print(f\"{'Symbol':&lt;10} {'Initial Rate':&lt;15} {'Maintenance Rate':&lt;20}\")\n    print(\"=\" * 45)\n\n    for symbol in symbols:\n        try:\n            rates = await account.symbol_info_margin_rate(\n                symbol=symbol,\n                order_type=market_info_pb2.ORDER_TYPE_BUY\n            )\n            print(f\"{symbol:&lt;10} {rates.initial_margin_rate:&lt;15.4f} {rates.maintenance_margin_rate:&lt;20.4f}\")\n        except Exception as e:\n            print(f\"{symbol:&lt;10} ERROR: {e}\")\n\n# Usage\nawait compare_symbol_margins(account, [\"EURUSD\", \"GBPUSD\", \"USDJPY\", \"XAUUSD\"])\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_margin_rate/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>symbol_info_double - Get symbol double properties (contract size, prices)</li> <li>order_calc_margin - Calculate margin for specific order parameters</li> <li>account_info_double - Get account margin information</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/","title":"Get Symbol Quote Session Times","text":"<p>Request: retrieve quote session start and end times for symbol.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.symbol_info_session_quote(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>SymbolInfoSessionQuote</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>SymbolInfoSessionQuote(SymbolInfoSessionQuoteRequest) -&gt; SymbolInfoSessionQuoteReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.SymbolInfoSessionQuote(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Retrieve quote session start and end times for a symbol on a specific day of the week.</li> <li>Why you need it. Know when you can receive price quotes for symbols, understand market hours.</li> <li>When to use. Use to check symbol quote availability, plan automated trading schedules, validate market open times.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to query quote session schedules:</p> <ul> <li>Get symbol quote session hours for each day</li> <li>Check when price updates are available</li> <li>Validate market open/close times</li> <li>Plan quote monitoring schedules</li> <li>Understand session breaks</li> <li>Coordinate with trading sessions</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; symbol_info_session_quote - How it works</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_info_session_quote(\n    self,\n    symbol: str,\n    day_of_week: market_info_pb2.DayOfWeek,\n    session_index: int,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; market_info_pb2.SymbolInfoSessionQuoteData\n</code></pre> <p>Request message:</p> <pre><code>message SymbolInfoSessionQuoteRequest {\n  string symbol = 1;\n  DayOfWeek day_of_week = 2;\n  uint32 session_index = 3;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message SymbolInfoSessionQuoteReply {\n  oneof response {\n    SymbolInfoSessionQuoteData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage SymbolInfoSessionQuoteData {\n  google.protobuf.Timestamp from = 1;\n  google.protobuf.Timestamp to = 2;\n}\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> (required) Symbol name <code>day_of_week</code> <code>DayOfWeek</code> (enum) Day of week (SUNDAY, MONDAY, etc.) <code>session_index</code> <code>int</code> (required) Session index (usually 0 for main session) <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#output","title":"\u2b06\ufe0f Output","text":"Field Type Python Type Description <code>from</code> <code>Timestamp</code> <code>Timestamp</code> Session start time (google.protobuf.Timestamp) <code>to</code> <code>Timestamp</code> <code>Timestamp</code> Session end time (google.protobuf.Timestamp) <p>Return value: The method returns <code>SymbolInfoSessionQuoteData</code> object with <code>from</code> and <code>to</code> Timestamp fields.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":"<p>Note: In Python code, use constants directly from the market_info module.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#dayofweek","title":"<code>DayOfWeek</code>","text":"<p>Defined in <code>mt5-term-api-market-info.proto</code>.</p> Constant Value Description <code>SUNDAY</code> 0 Sunday <code>MONDAY</code> 1 Monday <code>TUESDAY</code> 2 Tuesday <code>WEDNESDAY</code> 3 Wednesday <code>THURSDAY</code> 4 Thursday <code>FRIDAY</code> 5 Friday <code>SATURDAY</code> 6 Saturday <p>Usage in Python: <pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get Monday quote session\nsession = await account.symbol_info_session_quote(\n    symbol=\"EURUSD\",\n    day_of_week=market_info_pb2.MONDAY,\n    session_index=0\n)\nprint(f\"From: {session.from.seconds}s, To: {session.to.seconds}s\")\n</code></pre></p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: Built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>Timestamp format: The <code>from</code> and <code>to</code> fields are <code>google.protobuf.Timestamp</code> objects with <code>seconds</code> and <code>nanos</code> attributes.</li> <li>Time interpretation: Times represent seconds from midnight (00:00) for the specified day.</li> <li>Session index: Most symbols have one main session (index 0). Some may have multiple sessions (lunch breaks, etc.).</li> <li>Multiple sessions: If a symbol has multiple quote sessions per day, use different session_index values (0, 1, 2...).</li> <li>Timezone: Times are in the broker's server timezone, not UTC.</li> <li>No session: If a session doesn't exist, the method may return an error or zero timestamps.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#1-get-monday-quote-session","title":"1) Get Monday quote session","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get Monday quote session\nsession = await account.symbol_info_session_quote(\n    symbol=\"EURUSD\",\n    day_of_week=market_info_pb2.MONDAY,\n    session_index=0\n)\n\nprint(f\"Monday Quote Session:\")\nprint(f\"  From: {session.from.seconds}s ({session.from.seconds // 3600}h:{(session.from.seconds % 3600) // 60}m)\")\nprint(f\"  To: {session.to.seconds}s ({session.to.seconds // 3600}h:{(session.to.seconds % 3600) // 60}m)\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#2-get-all-weekly-quote-sessions","title":"2) Get all weekly quote sessions","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\ndays = {\n    market_info_pb2.SUNDAY: \"Sunday\",\n    market_info_pb2.MONDAY: \"Monday\",\n    market_info_pb2.TUESDAY: \"Tuesday\",\n    market_info_pb2.WEDNESDAY: \"Wednesday\",\n    market_info_pb2.THURSDAY: \"Thursday\",\n    market_info_pb2.FRIDAY: \"Friday\",\n    market_info_pb2.SATURDAY: \"Saturday\"\n}\n\nprint(\"EURUSD Quote Sessions:\")\nfor day_enum, day_name in days.items():\n    try:\n        session = await account.symbol_info_session_quote(\n            symbol=\"EURUSD\",\n            day_of_week=day_enum,\n            session_index=0\n        )\n\n        from_hours = session.from.seconds // 3600\n        from_mins = (session.from.seconds % 3600) // 60\n        to_hours = session.to.seconds // 3600\n        to_mins = (session.to.seconds % 3600) // 60\n\n        print(f\"  {day_name:10s} {from_hours:02d}:{from_mins:02d} - {to_hours:02d}:{to_mins:02d}\")\n    except Exception as e:\n        print(f\"  {day_name:10s} No session\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#3-convert-timestamp-to-readable-time","title":"3) Convert timestamp to readable time","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nfrom datetime import time\n\ndef timestamp_to_time(timestamp) -&gt; time:\n    \"\"\"Convert protobuf Timestamp to datetime.time\"\"\"\n    total_seconds = timestamp.seconds\n    hours = total_seconds // 3600\n    minutes = (total_seconds % 3600) // 60\n    seconds = total_seconds % 60\n    return time(hour=hours, minute=minutes, second=seconds)\n\n# Get session\nsession = await account.symbol_info_session_quote(\n    symbol=\"EURUSD\",\n    day_of_week=market_info_pb2.MONDAY,\n    session_index=0\n)\n\n# Convert to time objects\nfrom_time = timestamp_to_time(session.from)\nto_time = timestamp_to_time(session.to)\n\nprint(f\"Quote session: {from_time} - {to_time}\")\n# Output: Quote session: 00:00:00 - 23:59:59\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#4-check-if-symbol-has-quote-session-on-specific-day","title":"4) Check if symbol has quote session on specific day","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def has_quote_session(account, symbol: str, day_of_week: int) -&gt; bool:\n    \"\"\"Check if symbol has quote session on specified day\"\"\"\n    try:\n        session = await account.symbol_info_session_quote(\n            symbol=symbol,\n            day_of_week=day_of_week,\n            session_index=0\n        )\n\n        # Check if session has valid times (not zero)\n        if session.from.seconds &gt; 0 or session.to.seconds &gt; 0:\n            return True\n        return False\n    except Exception:\n        return False\n\n# Usage\nif await has_quote_session(account, \"EURUSD\", market_info_pb2.SATURDAY):\n    print(\"EURUSD has quotes on Saturday\")\nelse:\n    print(\"EURUSD has NO quotes on Saturday\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#5-get-session-with-timeout","title":"5) Get session with timeout","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nfrom datetime import datetime, timedelta\n\ndeadline = datetime.utcnow() + timedelta(seconds=3)\n\ntry:\n    session = await account.symbol_info_session_quote(\n        symbol=\"GBPUSD\",\n        day_of_week=market_info_pb2.FRIDAY,\n        session_index=0,\n        deadline=deadline\n    )\n    print(f\"Session retrieved successfully\")\nexcept Exception as e:\n    print(f\"Timeout or error: {e}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#6-check-for-multiple-sessions-lunch-breaks","title":"6) Check for multiple sessions (lunch breaks)","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def get_all_sessions(account, symbol: str, day_of_week: int):\n    \"\"\"Get all quote sessions for a symbol on a specific day\"\"\"\n    sessions = []\n    session_index = 0\n\n    while session_index &lt; 10:  # Max 10 sessions\n        try:\n            session = await account.symbol_info_session_quote(\n                symbol=symbol,\n                day_of_week=day_of_week,\n                session_index=session_index\n            )\n\n            # Check if session is valid\n            if session.from.seconds == 0 and session.to.seconds == 0:\n                break\n\n            sessions.append({\n                'index': session_index,\n                'from': session.from.seconds,\n                'to': session.to.seconds\n            })\n            session_index += 1\n        except Exception:\n            break\n\n    return sessions\n\n# Usage\nsessions = await get_all_sessions(account, \"NIKKEI\", market_info_pb2.MONDAY)\nprint(f\"Found {len(sessions)} quote session(s):\")\nfor s in sessions:\n    from_h = s['from'] // 3600\n    from_m = (s['from'] % 3600) // 60\n    to_h = s['to'] // 3600\n    to_m = (s['to'] % 3600) // 60\n    print(f\"  Session {s['index']}: {from_h:02d}:{from_m:02d} - {to_h:02d}:{to_m:02d}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_quote/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>symbol_info_session_trade - Get trading session times</li> <li>symbol_info_integer - Get other symbol integer properties</li> <li>symbol_info_double - Get symbol double properties</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/","title":"Get Symbol Trade Session Times","text":"<p>Request: retrieve trade session start and end times for symbol.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.symbol_info_session_trade(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>SymbolInfoSessionTrade</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>SymbolInfoSessionTrade(SymbolInfoSessionTradeRequest) -&gt; SymbolInfoSessionTradeReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.SymbolInfoSessionTrade(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Retrieve trade session start and end times for a symbol on a specific day of the week.</li> <li>Why you need it. Know when you can place trades for symbols, understand trading hours vs quote hours.</li> <li>When to use. Use to check when trading is allowed, validate order placement times, plan automated trading schedules.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to query trade session schedules:</p> <ul> <li>Get symbol trade session hours for each day</li> <li>Check when order placement is allowed</li> <li>Validate trading hours vs quote hours</li> <li>Plan automated trading schedules</li> <li>Understand session breaks</li> <li>Coordinate with market hours</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; symbol_info_session_trade - How it works</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_info_session_trade(\n    self,\n    symbol: str,\n    day_of_week: market_info_pb2.DayOfWeek,\n    session_index: int,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; market_info_pb2.SymbolInfoSessionTradeData\n</code></pre> <p>Request message:</p> <pre><code>message SymbolInfoSessionTradeRequest {\n  string symbol = 1;\n  DayOfWeek day_of_week = 2;\n  uint32 session_index = 3;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message SymbolInfoSessionTradeReply {\n  oneof response {\n    SymbolInfoSessionTradeData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage SymbolInfoSessionTradeData {\n  google.protobuf.Timestamp from = 1;\n  google.protobuf.Timestamp to = 2;\n}\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> (required) Symbol name <code>day_of_week</code> <code>DayOfWeek</code> (enum) Day of week (SUNDAY, MONDAY, etc.) <code>session_index</code> <code>int</code> (required) Session index (usually 0 for main session) <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#output","title":"\u2b06\ufe0f Output","text":"Field Type Python Type Description <code>from</code> <code>Timestamp</code> <code>Timestamp</code> Session start time (google.protobuf.Timestamp) <code>to</code> <code>Timestamp</code> <code>Timestamp</code> Session end time (google.protobuf.Timestamp) <p>Return value: The method returns <code>SymbolInfoSessionTradeData</code> object with <code>from</code> and <code>to</code> Timestamp fields.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":"<p>Note: In Python code, use constants directly from the market_info module.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#dayofweek","title":"<code>DayOfWeek</code>","text":"<p>Defined in <code>mt5-term-api-market-info.proto</code>.</p> Constant Value Description <code>SUNDAY</code> 0 Sunday <code>MONDAY</code> 1 Monday <code>TUESDAY</code> 2 Tuesday <code>WEDNESDAY</code> 3 Wednesday <code>THURSDAY</code> 4 Thursday <code>FRIDAY</code> 5 Friday <code>SATURDAY</code> 6 Saturday <p>Usage in Python: <pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get Monday trading session\nsession = await account.symbol_info_session_trade(\n    symbol=\"EURUSD\",\n    day_of_week=market_info_pb2.MONDAY,\n    session_index=0\n)\nprint(f\"Trading hours: {session.from.seconds}s - {session.to.seconds}s\")\n</code></pre></p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: Built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>Timestamp format: The <code>from</code> and <code>to</code> fields are <code>google.protobuf.Timestamp</code> objects with <code>seconds</code> and <code>nanos</code> attributes.</li> <li>Time interpretation: Times represent seconds from midnight (00:00) for the specified day.</li> <li>Session index: Most symbols have one main session (index 0). Some may have multiple sessions (lunch breaks, etc.).</li> <li>Multiple sessions: If a symbol has multiple trade sessions per day, use different session_index values (0, 1, 2...).</li> <li>Timezone: Times are in the broker's server timezone, not UTC.</li> <li>No session: If a session doesn't exist, the method may return an error or zero timestamps.</li> <li>Trade vs Quote sessions: Trade sessions (when orders can be placed) may differ from quote sessions (when prices update). Use both methods to understand full market schedule.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#1-get-monday-trade-session","title":"1) Get Monday trade session","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get Monday trade session\nsession = await account.symbol_info_session_trade(\n    symbol=\"EURUSD\",\n    day_of_week=market_info_pb2.MONDAY,\n    session_index=0\n)\n\nprint(f\"Monday Trade Session:\")\nprint(f\"  From: {session.from.seconds}s ({session.from.seconds // 3600}h:{(session.from.seconds % 3600) // 60}m)\")\nprint(f\"  To: {session.to.seconds}s ({session.to.seconds // 3600}h:{(session.to.seconds % 3600) // 60}m)\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#2-get-all-weekly-trade-sessions","title":"2) Get all weekly trade sessions","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\ndays = {\n    market_info_pb2.SUNDAY: \"Sunday\",\n    market_info_pb2.MONDAY: \"Monday\",\n    market_info_pb2.TUESDAY: \"Tuesday\",\n    market_info_pb2.WEDNESDAY: \"Wednesday\",\n    market_info_pb2.THURSDAY: \"Thursday\",\n    market_info_pb2.FRIDAY: \"Friday\",\n    market_info_pb2.SATURDAY: \"Saturday\"\n}\n\nprint(\"EURUSD Trade Sessions:\")\nfor day_enum, day_name in days.items():\n    try:\n        session = await account.symbol_info_session_trade(\n            symbol=\"EURUSD\",\n            day_of_week=day_enum,\n            session_index=0\n        )\n\n        from_hours = session.from.seconds // 3600\n        from_mins = (session.from.seconds % 3600) // 60\n        to_hours = session.to.seconds // 3600\n        to_mins = (session.to.seconds % 3600) // 60\n\n        print(f\"  {day_name:10s} {from_hours:02d}:{from_mins:02d} - {to_hours:02d}:{to_mins:02d}\")\n    except Exception as e:\n        print(f\"  {day_name:10s} No session\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#3-compare-trade-vs-quote-sessions","title":"3) Compare trade vs quote sessions","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get trade session\ntrade_session = await account.symbol_info_session_trade(\n    symbol=\"XAUUSD\",\n    day_of_week=market_info_pb2.MONDAY,\n    session_index=0\n)\n\n# Get quote session\nquote_session = await account.symbol_info_session_quote(\n    symbol=\"XAUUSD\",\n    day_of_week=market_info_pb2.MONDAY,\n    session_index=0\n)\n\nprint(f\"XAUUSD Monday Sessions:\")\nprint(f\"  Trade: {trade_session.from.seconds // 3600:02d}:{(trade_session.from.seconds % 3600) // 60:02d} - {trade_session.to.seconds // 3600:02d}:{(trade_session.to.seconds % 3600) // 60:02d}\")\nprint(f\"  Quote: {quote_session.from.seconds // 3600:02d}:{(quote_session.from.seconds % 3600) // 60:02d} - {quote_session.to.seconds // 3600:02d}:{(quote_session.to.seconds % 3600) // 60:02d}\")\n\nif trade_session.from.seconds != quote_session.from.seconds:\n    print(\"  Trade and quote sessions differ!\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#4-check-if-trading-is-allowed-now","title":"4) Check if trading is allowed now","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nfrom datetime import datetime\n\nasync def is_trading_allowed(account, symbol: str) -&gt; bool:\n    \"\"\"Check if trading is allowed at current time\"\"\"\n    now = datetime.utcnow()\n    day_of_week = now.weekday() + 1  # Monday=1 in datetime, Monday=1 in enum\n    if day_of_week == 7:  # Sunday\n        day_of_week = 0\n\n    try:\n        session = await account.symbol_info_session_trade(\n            symbol=symbol,\n            day_of_week=day_of_week,\n            session_index=0\n        )\n\n        # Current time in seconds from midnight\n        current_seconds = now.hour * 3600 + now.minute * 60 + now.second\n\n        # Check if within trading session\n        if session.from.seconds &lt;= current_seconds &lt;= session.to.seconds:\n            return True\n        return False\n    except Exception:\n        return False\n\n# Usage\nif await is_trading_allowed(account, \"EURUSD\"):\n    print(\"Trading is ALLOWED\")\nelse:\n    print(\"Trading is CLOSED\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#5-get-all-sessions-for-a-day-multiple-sessions","title":"5) Get all sessions for a day (multiple sessions)","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def get_all_trade_sessions(account, symbol: str, day_of_week: int):\n    \"\"\"Get all trade sessions for a symbol on a specific day\"\"\"\n    sessions = []\n    session_index = 0\n\n    while session_index &lt; 10:  # Max 10 sessions\n        try:\n            session = await account.symbol_info_session_trade(\n                symbol=symbol,\n                day_of_week=day_of_week,\n                session_index=session_index\n            )\n\n            # Check if session is valid\n            if session.from.seconds == 0 and session.to.seconds == 0:\n                break\n\n            sessions.append({\n                'index': session_index,\n                'from': session.from.seconds,\n                'to': session.to.seconds\n            })\n            session_index += 1\n        except Exception:\n            break\n\n    return sessions\n\n# Usage\nsessions = await get_all_trade_sessions(account, \"NIKKEI\", market_info_pb2.MONDAY)\nprint(f\"Found {len(sessions)} trade session(s):\")\nfor s in sessions:\n    from_h = s['from'] // 3600\n    from_m = (s['from'] % 3600) // 60\n    to_h = s['to'] // 3600\n    to_m = (s['to'] % 3600) // 60\n    print(f\"  Session {s['index']}: {from_h:02d}:{from_m:02d} - {to_h:02d}:{to_m:02d}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#6-get-session-with-timeout","title":"6) Get session with timeout","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nfrom datetime import datetime, timedelta\n\ndeadline = datetime.utcnow() + timedelta(seconds=3)\n\ntry:\n    session = await account.symbol_info_session_trade(\n        symbol=\"GBPUSD\",\n        day_of_week=market_info_pb2.FRIDAY,\n        session_index=0,\n        deadline=deadline\n    )\n    print(f\"Session retrieved successfully\")\nexcept Exception as e:\n    print(f\"Timeout or error: {e}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_session_trade/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>symbol_info_session_quote - Get quote session times</li> <li>symbol_info_integer - Get other symbol integer properties</li> <li>symbol_info_double - Get symbol double properties</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/","title":"Get Symbol String Property","text":"<p>Request: retrieve string-type property value for a symbol.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.symbol_info_string(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>SymbolInfoString</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>SymbolInfoString(SymbolInfoStringRequest) -&gt; SymbolInfoStringReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.SymbolInfoString(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Retrieve a single string-type property value for a symbol (DESCRIPTION, CURRENCY_BASE, PATH, etc.).</li> <li>Why you need it. Get specific text symbol properties like currency codes, descriptions, and metadata.</li> <li>When to use. Use <code>symbol_params_many()</code> for multiple properties. Use this method for single property queries.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to query specific string symbol properties:</p> <ul> <li>Get symbol description and display names</li> <li>Retrieve currency codes (base, profit, margin)</li> <li>Check symbol path and categorization</li> <li>Get exchange and ISIN information</li> <li>Query symbol formula and metadata</li> <li>Check bank and country information</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; symbol_info_string - How it works</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_info_string(\n    self,\n    symbol: str,\n    property: market_info_pb2.SymbolInfoStringProperty,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; market_info_pb2.SymbolInfoStringData\n</code></pre> <p>Request message:</p> <pre><code>message SymbolInfoStringRequest {\n  string symbol = 1;\n  SymbolInfoStringProperty type = 2;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message SymbolInfoStringReply {\n  oneof response {\n    SymbolInfoStringData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage SymbolInfoStringData {\n  string value = 1;\n}\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> (required) Symbol name <code>property</code> <code>SymbolInfoStringProperty</code> (enum) Property to retrieve (DESCRIPTION, PATH, etc.) <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#output","title":"\u2b06\ufe0f Output","text":"Field Type Python Type Description <code>value</code> <code>string</code> <code>str</code> The string value of the property <p>Return value: The method returns <code>SymbolInfoStringData</code> object with <code>value</code> field containing the requested property.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":"<p>Note: In Python code, use the full enum path from the market_info module.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#symbolinfostringproperty","title":"<code>SymbolInfoStringProperty</code>","text":"<p>Defined in <code>mt5-term-api-market-info.proto</code>.</p> Constant Value Description <code>SYMBOL_BASIS</code> 0 Symbol basis <code>SYMBOL_CATEGORY</code> 1 Symbol category <code>SYMBOL_COUNTRY</code> 2 Symbol country <code>SYMBOL_SECTOR_NAME</code> 3 Sector name <code>SYMBOL_INDUSTRY_NAME</code> 4 Industry name <code>SYMBOL_CURRENCY_BASE</code> 5 Base currency <code>SYMBOL_CURRENCY_PROFIT</code> 6 Profit currency <code>SYMBOL_CURRENCY_MARGIN</code> 7 Margin currency <code>SYMBOL_BANK</code> 8 Feeder bank <code>SYMBOL_DESCRIPTION</code> 9 Symbol description <code>SYMBOL_EXCHANGE</code> 10 Exchange name <code>SYMBOL_FORMULA</code> 11 Formula for custom symbols <code>SYMBOL_ISIN</code> 12 ISIN code <code>SYMBOL_PAGE</code> 13 Web page URL <code>SYMBOL_PATH</code> 14 Symbol path in symbol tree <p>Usage in Python: <pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get symbol description\ndesc = await account.symbol_info_string(\"EURUSD\", market_info_pb2.SYMBOL_DESCRIPTION)\nprint(f\"Description: {desc.value}\")\n\n# Get currency pair\nbase = await account.symbol_info_string(\"EURUSD\", market_info_pb2.SYMBOL_CURRENCY_BASE)\nprofit = await account.symbol_info_string(\"EURUSD\", market_info_pb2.SYMBOL_CURRENCY_PROFIT)\nprint(f\"Pair: {base.value}/{profit.value}\")\n</code></pre></p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: Built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>Access the value: The returned <code>SymbolInfoStringData</code> object has a <code>.value</code> field containing the string.</li> <li>Currency properties: CURRENCY_BASE, CURRENCY_PROFIT, and CURRENCY_MARGIN are essential for margin and profit calculations.</li> <li>Path format: SYMBOL_PATH uses backslash separators (e.g., \"Forex\\Majors\\EURUSD\").</li> <li>Empty values: Some properties may return empty strings if not set by the broker.</li> <li>ISIN codes: Only available for securities like stocks and bonds.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#1-get-symbol-description","title":"1) Get symbol description","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get symbol description\nresult = await account.symbol_info_string(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_DESCRIPTION\n)\nprint(f\"Description: {result.value}\")  # Output: Description: Euro vs US Dollar\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#2-get-currency-triplet-base-profit-margin","title":"2) Get currency triplet (base, profit, margin)","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get all three currency codes\nbase = await account.symbol_info_string(\n    symbol=\"XAUUSD\",\n    property=market_info_pb2.SYMBOL_CURRENCY_BASE\n)\n\nprofit = await account.symbol_info_string(\n    symbol=\"XAUUSD\",\n    property=market_info_pb2.SYMBOL_CURRENCY_PROFIT\n)\n\nmargin = await account.symbol_info_string(\n    symbol=\"XAUUSD\",\n    property=market_info_pb2.SYMBOL_CURRENCY_MARGIN\n)\n\nprint(f\"XAUUSD Currencies:\")\nprint(f\"  Base: {base.value}\")      # XAU (Gold)\nprint(f\"  Profit: {profit.value}\")  # USD\nprint(f\"  Margin: {margin.value}\")  # USD\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#3-get-symbol-path-and-parse-hierarchy","title":"3) Get symbol path and parse hierarchy","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nresult = await account.symbol_info_string(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_PATH\n)\n\n# Parse path hierarchy\npath = result.value\nfolders = path.split(\"\\\\\")\n\nprint(f\"Symbol Path: {path}\")\nprint(f\"Hierarchy: {' &gt; '.join(folders)}\")\n# Output: Hierarchy: Forex &gt; Majors &gt; EURUSD\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#4-get-isin-code-for-stocks","title":"4) Get ISIN code for stocks","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nresult = await account.symbol_info_string(\n    symbol=\"AAPL\",\n    property=market_info_pb2.SYMBOL_ISIN\n)\n\nif result.value:\n    print(f\"AAPL ISIN: {result.value}\")\nelse:\n    print(\"ISIN not available\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#5-get-exchange-name","title":"5) Get exchange name","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nresult = await account.symbol_info_string(\n    symbol=\"BTCUSD\",\n    property=market_info_pb2.SYMBOL_EXCHANGE\n)\n\nprint(f\"Exchange: {result.value}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#6-display-symbol-metadata","title":"6) Display symbol metadata","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def display_symbol_metadata(account, symbol: str):\n    \"\"\"Display comprehensive string metadata for a symbol\"\"\"\n\n    # Get description\n    desc = await account.symbol_info_string(\n        symbol=symbol,\n        property=market_info_pb2.SYMBOL_DESCRIPTION\n    )\n\n    # Get path\n    path = await account.symbol_info_string(\n        symbol=symbol,\n        property=market_info_pb2.SYMBOL_PATH\n    )\n\n    # Get currencies\n    base_curr = await account.symbol_info_string(\n        symbol=symbol,\n        property=market_info_pb2.SYMBOL_CURRENCY_BASE\n    )\n\n    profit_curr = await account.symbol_info_string(\n        symbol=symbol,\n        property=market_info_pb2.SYMBOL_CURRENCY_PROFIT\n    )\n\n    print(f\"Symbol Metadata: {symbol}\")\n    print(f\"  Description: {desc.value}\")\n    print(f\"  Path: {path.value}\")\n    print(f\"  Base Currency: {base_curr.value}\")\n    print(f\"  Profit Currency: {profit_curr.value}\")\n\n# Usage\nawait display_symbol_metadata(account, \"EURUSD\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#7-get-symbol-with-timeout","title":"7) Get symbol with timeout","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nfrom datetime import datetime, timedelta\n\ndeadline = datetime.utcnow() + timedelta(seconds=3)\n\ntry:\n    result = await account.symbol_info_string(\n        symbol=\"GBPUSD\",\n        property=market_info_pb2.SYMBOL_DESCRIPTION,\n        deadline=deadline\n    )\n    print(f\"Description: {result.value}\")\nexcept Exception as e:\n    print(f\"Timeout or error: {e}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_string/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>symbol_info_double - Get double properties</li> <li>symbol_info_integer - Get integer properties</li> <li>symbol_params_many - Get all symbol parameters at once</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/","title":"Get Symbol Current Tick","text":"<p>Request: retrieve current tick data for a symbol (bid, ask, last, volume, time).</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.symbol_info_tick(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>SymbolInfoTick</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>SymbolInfoTick(SymbolInfoTickRequest) -&gt; SymbolInfoTickRequestReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.SymbolInfoTick(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Retrieve the latest tick snapshot for a symbol with bid/ask prices, volume, and timestamps.</li> <li>Why you need it. Get real-time price data for quotes, spread calculation, freshness checks before trading.</li> <li>When to use. Use for single tick queries. For continuous updates, use streaming method <code>on_symbol_tick()</code>.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to get current market data:</p> <ul> <li>Display live bid/ask prices in UI</li> <li>Calculate current spread</li> <li>Check quote freshness (tick age)</li> <li>Get last trade price and volumes</li> <li>Validate market data before order placement</li> <li>Monitor tick timestamps for latency</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; symbol_info_tick - How it works</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_info_tick(\n    self,\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; market_info_pb2.MrpcMqlTick\n</code></pre> <p>Request message:</p> <pre><code>message SymbolInfoTickRequest {\n  string symbol = 1;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message SymbolInfoTickRequestReply {\n  oneof response {\n    MrpcMqlTick data = 1;\n    Error error = 2;\n  }\n}\n\nmessage MrpcMqlTick {\n  int64 time = 1;\n  double bid = 2;\n  double ask = 3;\n  double last = 4;\n  uint64 volume = 5;\n  int64 time_msc = 6;\n  uint32 flags = 7;\n  double volume_real = 8;\n}\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> (required) Symbol name <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#output","title":"\u2b06\ufe0f Output","text":"Field Type Python Type Description <code>time</code> <code>int64</code> <code>int</code> Tick time in seconds since epoch (UTC) <code>bid</code> <code>double</code> <code>float</code> Current best bid price <code>ask</code> <code>double</code> <code>float</code> Current best ask price <code>last</code> <code>double</code> <code>float</code> Last deal price (if applicable) <code>volume</code> <code>uint64</code> <code>int</code> Tick volume (number of ticks) <code>time_msc</code> <code>int64</code> <code>int</code> Tick time in milliseconds since epoch (UTC) <code>flags</code> <code>uint32</code> <code>int</code> Tick flags bitmask (MT5 tick flags) <code>volume_real</code> <code>double</code> <code>float</code> Real volume (if provided by broker) <p>Return value: The method returns <code>MrpcMqlTick</code> object with all tick data fields.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: Built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>Symbol synchronization: Symbol must be selected and synchronized for valid data. If bid/ask are zero, call <code>symbol_select()</code> and <code>symbol_is_synchronized()</code> first.</li> <li>Time fields: <code>time</code> is in seconds, <code>time_msc</code> is in milliseconds. Both represent Unix epoch UTC timestamps.</li> <li>Spread calculation: Spread = <code>ask - bid</code>. Mid price = <code>(ask + bid) / 2</code>.</li> <li>Volume fields: <code>volume</code> is tick count (uint64), <code>volume_real</code> is actual traded volume (double).</li> <li>Flags field: Bitmask indicating tick properties (bid change, ask change, last change, volume change).</li> <li>Freshness check: Compare <code>time</code> with current timestamp to detect stale data.</li> <li>Zero values: If tick data is zeros, symbol may not be synchronized or selected.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#1-get-current-bidask-and-spread","title":"1) Get current bid/ask and spread","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get current tick\ntick = await account.symbol_info_tick(symbol=\"EURUSD\")\n\nprint(f\"Symbol: EURUSD\")\nprint(f\"  Bid: {tick.bid}\")\nprint(f\"  Ask: {tick.ask}\")\nprint(f\"  Spread: {tick.ask - tick.bid}\")\nprint(f\"  Mid: {(tick.bid + tick.ask) / 2}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#2-check-tick-freshness","title":"2) Check tick freshness","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nfrom datetime import datetime, timezone\n\n# Get tick and check age\ntick = await account.symbol_info_tick(symbol=\"XAUUSD\")\n\nif tick.time &gt; 0:\n    current_time = datetime.now(timezone.utc).timestamp()\n    age_seconds = int(current_time - tick.time)\n\n    print(f\"Tick age: {age_seconds} seconds\")\n\n    if age_seconds &gt; 5:\n        print(\"Warning: Tick data may be stale!\")\n    else:\n        print(\"Tick data is fresh\")\nelse:\n    print(\"No tick time available\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#3-ensure-symbol-is-synchronized-before-getting-tick","title":"3) Ensure symbol is synchronized before getting tick","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nsymbol = \"BTCUSD\"\n\n# Check if symbol is synchronized\nsync_status = await account.symbol_is_synchronized(symbol)\n\nif not sync_status.is_synchronized:\n    print(f\"Symbol {symbol} not synchronized, selecting...\")\n\n    # Select symbol\n    await account.symbol_select(symbol, True)\n\n    # Wait for synchronization\n    sync_status = await account.symbol_is_synchronized(symbol)\n    print(f\"Synchronized: {sync_status.is_synchronized}\")\n\n# Now get tick\ntick = await account.symbol_info_tick(symbol)\nprint(f\"{symbol} - Bid: {tick.bid}, Ask: {tick.ask}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#4-display-volume-information","title":"4) Display volume information","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Get tick with volume data\ntick = await account.symbol_info_tick(symbol=\"EURUSD\")\n\nprint(f\"Volume Information:\")\nprint(f\"  Tick volume (count): {tick.volume}\")\nprint(f\"  Real volume: {tick.volume_real}\")\nprint(f\"  Last trade price: {tick.last}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#5-convert-timestamps-to-readable-format","title":"5) Convert timestamps to readable format","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nfrom datetime import datetime, timezone\n\n# Get tick\ntick = await account.symbol_info_tick(symbol=\"GBPUSD\")\n\n# Convert timestamps\nif tick.time &gt; 0:\n    time_dt = datetime.fromtimestamp(tick.time, tz=timezone.utc)\n    print(f\"Tick time: {time_dt.isoformat()}\")\n\nif tick.time_msc &gt; 0:\n    time_msc_dt = datetime.fromtimestamp(tick.time_msc / 1000, tz=timezone.utc)\n    print(f\"Tick time (ms): {time_msc_dt.isoformat()}\")\n    print(f\"Milliseconds precision: {tick.time_msc % 1000}ms\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#6-get-tick-with-timeout","title":"6) Get tick with timeout","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nfrom datetime import datetime, timedelta, timezone\nimport asyncio\n\n# Create cancellation event\ncancel_event = asyncio.Event()\n\n# Set deadline\ndeadline = datetime.now(timezone.utc) + timedelta(seconds=3)\n\ntry:\n    tick = await account.symbol_info_tick(\n        symbol=\"EURUSD\",\n        deadline=deadline,\n        cancellation_event=cancel_event\n    )\n    print(f\"Tick retrieved: Bid={tick.bid}, Ask={tick.ask}\")\nexcept Exception as e:\n    print(f\"Timeout or error: {e}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#7-validate-tick-data-before-trading","title":"7) Validate tick data before trading","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nfrom datetime import datetime, timezone\n\nasync def validate_tick(account, symbol: str) -&gt; bool:\n    \"\"\"Validate that tick data is fresh and valid for trading\"\"\"\n    try:\n        tick = await account.symbol_info_tick(symbol)\n\n        # Check bid/ask are non-zero\n        if tick.bid &lt;= 0 or tick.ask &lt;= 0:\n            print(f\"Invalid prices: bid={tick.bid}, ask={tick.ask}\")\n            return False\n\n        # Check spread is reasonable (not zero, not too wide)\n        spread = tick.ask - tick.bid\n        if spread &lt;= 0:\n            print(f\"Invalid spread: {spread}\")\n            return False\n\n        # Check tick freshness (less than 10 seconds old)\n        if tick.time &gt; 0:\n            current_time = datetime.now(timezone.utc).timestamp()\n            age = current_time - tick.time\n\n            if age &gt; 10:\n                print(f\"Tick too old: {age} seconds\")\n                return False\n\n        print(f\"Tick validation passed\")\n        return True\n\n    except Exception as e:\n        print(f\"Validation error: {e}\")\n        return False\n\n# Usage\nif await validate_tick(account, \"EURUSD\"):\n    print(\"Ready to place order\")\nelse:\n    print(\"Tick validation failed, cannot trade\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_info_tick/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>symbol_is_synchronized - Check symbol synchronization status</li> <li>symbol_select - Select/deselect symbol in Market Watch</li> <li>on_symbol_tick - Subscribe to real-time tick updates</li> <li>symbol_info_double - Get symbol double properties</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/","title":"Check if Symbol is Synchronized","text":"<p>Request: check if symbol data is synchronized with the server.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.symbol_is_synchronized(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>SymbolIsSynchronized</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>SymbolIsSynchronized(SymbolIsSynchronizedRequest) -&gt; SymbolIsSynchronizedReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.SymbolIsSynchronized(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Check if a symbol's market data is currently synchronized with the broker's server.</li> <li>Why you need it. Ensure symbol has valid, up-to-date data before querying prices or placing orders.</li> <li>When to use. After selecting a symbol, before reading tick data, or when validating symbol availability.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to verify symbol data availability:</p> <ul> <li>Check symbol synchronization status before trading</li> <li>Validate symbol data after calling <code>symbol_select()</code></li> <li>Ensure tick data is current and valid</li> <li>Diagnose missing or stale market data</li> <li>Implement retry logic for symbol selection</li> <li>Verify symbol connectivity before operations</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; symbol_is_synchronized - How it works</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_is_synchronized(\n    self,\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; market_info_pb2.SymbolIsSynchronizedData\n</code></pre> <p>Request message:</p> <pre><code>message SymbolIsSynchronizedRequest {\n  string symbol = 1;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message SymbolIsSynchronizedReply {\n  oneof response {\n    SymbolIsSynchronizedData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage SymbolIsSynchronizedData {\n  bool synchronized = 1;\n}\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> (required) Symbol name to check <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#output","title":"\u2b06\ufe0f Output","text":"Field Type Python Type Description <code>synchronized</code> <code>bool</code> <code>bool</code> True if symbol data is synchronized <p>Return value: The method returns <code>SymbolIsSynchronizedData</code> object with <code>synchronized</code> boolean field.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: Built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>Access the value: The returned object has a <code>.synchronized</code> field (not <code>.is_synchronized</code>).</li> <li>Symbol selection: If <code>synchronized</code> is <code>False</code>, call <code>symbol_select(symbol, True)</code> to add symbol to Market Watch.</li> <li>Synchronization delay: After selecting a symbol, synchronization may take 1-2 seconds.</li> <li>Retry logic: Implement polling with delays when waiting for synchronization.</li> <li>Tick data dependency: If not synchronized, <code>symbol_info_tick()</code> may return zero or stale values.</li> <li>Not an error: Returning <code>False</code> is a normal state, not an error condition.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#1-check-if-symbol-is-synchronized","title":"1) Check if symbol is synchronized","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Check synchronization status\nresult = await account.symbol_is_synchronized(symbol=\"EURUSD\")\n\nif result.synchronized:\n    print(\"Symbol is synchronized\")\nelse:\n    print(\"Symbol is NOT synchronized\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#2-ensure-symbol-is-synchronized-before-getting-tick","title":"2) Ensure symbol is synchronized before getting tick","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def get_synchronized_tick(account, symbol: str):\n    \"\"\"Get tick data only if symbol is synchronized\"\"\"\n\n    # Check synchronization\n    sync_status = await account.symbol_is_synchronized(symbol)\n\n    if not sync_status.synchronized:\n        print(f\"Symbol {symbol} not synchronized, selecting...\")\n\n        # Select symbol\n        await account.symbol_select(symbol, True)\n\n        # Wait a moment for synchronization\n        import asyncio\n        await asyncio.sleep(1)\n\n        # Re-check\n        sync_status = await account.symbol_is_synchronized(symbol)\n\n        if not sync_status.synchronized:\n            raise RuntimeError(f\"Failed to synchronize {symbol}\")\n\n    # Now safe to get tick\n    tick = await account.symbol_info_tick(symbol)\n    return tick\n\n# Usage\ntick = await get_synchronized_tick(account, \"EURUSD\")\nprint(f\"Bid: {tick.bid}, Ask: {tick.ask}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#3-wait-for-synchronization-with-timeout","title":"3) Wait for synchronization with timeout","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nimport asyncio\n\nasync def wait_for_synchronization(\n    account,\n    symbol: str,\n    timeout: float = 10.0,\n    check_interval: float = 0.5\n) -&gt; bool:\n    \"\"\"Wait for symbol to synchronize with timeout\"\"\"\n\n    start_time = asyncio.get_event_loop().time()\n\n    while True:\n        # Check current status\n        result = await account.symbol_is_synchronized(symbol)\n\n        if result.synchronized:\n            print(f\"{symbol} synchronized\")\n            return True\n\n        # Check timeout\n        elapsed = asyncio.get_event_loop().time() - start_time\n        if elapsed &gt;= timeout:\n            print(f\"Timeout waiting for {symbol} synchronization\")\n            return False\n\n        # Wait before next check\n        await asyncio.sleep(check_interval)\n\n# Usage\nif await wait_for_synchronization(account, \"BTCUSD\", timeout=10):\n    print(\"Ready to trade\")\nelse:\n    print(\"Symbol not available\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#4-batch-check-multiple-symbols","title":"4) Batch check multiple symbols","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def check_symbols_sync(account, symbols: list[str]):\n    \"\"\"Check synchronization status for multiple symbols\"\"\"\n\n    results = {}\n\n    for symbol in symbols:\n        try:\n            sync_status = await account.symbol_is_synchronized(symbol)\n            results[symbol] = sync_status.synchronized\n        except Exception as e:\n            print(f\"Error checking {symbol}: {e}\")\n            results[symbol] = False\n\n    # Display results\n    print(f\"{'Symbol':&lt;10} {'Status':&lt;15}\")\n    print(\"=\" * 25)\n    for symbol, is_synced in results.items():\n        status = \"Synchronized\" if is_synced else \"Not synced\"\n        print(f\"{symbol:&lt;10} {status:&lt;15}\")\n\n    return results\n\n# Usage\nsymbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\", \"XAUUSD\"]\nsync_results = await check_symbols_sync(account, symbols)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#5-select-and-wait-for-synchronization","title":"5) Select and wait for synchronization","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nimport asyncio\n\nasync def ensure_symbol_synchronized(\n    account,\n    symbol: str,\n    max_retries: int = 5\n) -&gt; bool:\n    \"\"\"Select symbol and wait for synchronization\"\"\"\n\n    # First check if already synchronized\n    result = await account.symbol_is_synchronized(symbol)\n    if result.synchronized:\n        print(f\"{symbol} already synchronized\")\n        return True\n\n    # Select symbol\n    print(f\"Selecting {symbol}...\")\n    await account.symbol_select(symbol, True)\n\n    # Retry with exponential backoff\n    for attempt in range(max_retries):\n        await asyncio.sleep(0.5 * (attempt + 1))  # 0.5s, 1s, 1.5s, 2s, 2.5s\n\n        result = await account.symbol_is_synchronized(symbol)\n        if result.synchronized:\n            print(f\"{symbol} synchronized after {attempt + 1} attempt(s)\")\n            return True\n\n        print(f\"Attempt {attempt + 1}/{max_retries}: still waiting...\")\n\n    print(f\"Failed to synchronize {symbol} after {max_retries} attempts\")\n    return False\n\n# Usage\nif await ensure_symbol_synchronized(account, \"EURUSD\"):\n    tick = await account.symbol_info_tick(\"EURUSD\")\n    print(f\"Tick: {tick.bid}/{tick.ask}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#6-check-synchronization-with-timeout-parameter","title":"6) Check synchronization with timeout parameter","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nfrom datetime import datetime, timedelta\n\n# Set deadline for the call\ndeadline = datetime.utcnow() + timedelta(seconds=3)\n\ntry:\n    result = await account.symbol_is_synchronized(\n        symbol=\"GBPUSD\",\n        deadline=deadline\n    )\n\n    if result.synchronized:\n        print(\"Symbol is synchronized\")\n    else:\n        print(\"Symbol needs synchronization\")\nexcept Exception as e:\n    print(f\"Timeout or error: {e}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#7-validate-before-trading-operation","title":"7) Validate before trading operation","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nimport asyncio\n\nasync def validate_symbol_ready(account, symbol: str) -&gt; bool:\n    \"\"\"\n    Comprehensive check that symbol is ready for trading.\n    Returns True only if symbol exists, is selected, and synchronized.\n    \"\"\"\n\n    # Step 1: Check if symbol exists\n    exists = await account.symbol_exist(symbol)\n    if not exists.exists:\n        print(f\"Symbol {symbol} does not exist\")\n        return False\n    print(f\"Symbol exists\")\n\n    # Step 2: Check if selected\n    select_status = await account.symbol_info_integer(\n        symbol=symbol,\n        property=market_info_pb2.SYMBOL_SELECT\n    )\n\n    if not select_status.value:\n        print(f\"Symbol not selected, adding to Market Watch...\")\n        await account.symbol_select(symbol, True)\n        await asyncio.sleep(1)\n\n    # Step 3: Check synchronization\n    sync_status = await account.symbol_is_synchronized(symbol)\n    if not sync_status.synchronized:\n        print(f\"Waiting for synchronization...\")\n\n        # Wait up to 5 seconds\n        for i in range(10):\n            await asyncio.sleep(0.5)\n            sync_status = await account.symbol_is_synchronized(symbol)\n            if sync_status.synchronized:\n                break\n\n        if not sync_status.synchronized:\n            print(f\"Symbol {symbol} failed to synchronize\")\n            return False\n\n    print(f\"Symbol {symbol} is ready for trading\")\n    return True\n\n# Usage\nif await validate_symbol_ready(account, \"EURUSD\"):\n    # Safe to place orders\n    print(\"Proceeding with trade...\")\nelse:\n    print(\"Cannot trade - symbol not ready\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_is_synchronized/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>symbol_select - Select/deselect symbol in Market Watch</li> <li>symbol_exist - Check if symbol exists</li> <li>symbol_info_tick - Get current tick data (requires synchronized symbol)</li> <li>symbol_info_integer - Get symbol integer properties</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/","title":"Get Symbol Name by Index","text":"<p>Request: retrieve symbol name by index position.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.symbol_name(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>SymbolName</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>SymbolName(SymbolNameRequest) -&gt; SymbolNameReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.SymbolName(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Retrieve symbol name by its numerical index position in the symbol list.</li> <li>Why you need it. Enumerate symbols sequentially, iterate through available symbols programmatically.</li> <li>When to use. Use with <code>symbols_total()</code> to iterate all symbols or Market Watch symbols.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to enumerate symbols:</p> <ul> <li>Iterate through all available symbols</li> <li>Get Market Watch symbols by position</li> <li>Build symbol lists programmatically</li> <li>Implement symbol selection UI</li> <li>Discover available trading instruments</li> <li>Map index positions to symbol names</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; symbol_name - How it works</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_name(\n    self,\n    index: int,\n    selected: bool,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; market_info_pb2.SymbolNameData\n</code></pre> <p>Request message:</p> <pre><code>message SymbolNameRequest {\n  uint32 index = 1;\n  bool selected = 2;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message SymbolNameReply {\n  oneof response {\n    SymbolNameData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage SymbolNameData {\n  string name = 1;\n}\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>index</code> <code>int</code> (required) Symbol index (zero-based, starting at 0) <code>selected</code> <code>bool</code> (required) True = Market Watch only, False = all available symbols <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#output","title":"\u2b06\ufe0f Output","text":"Field Type Python Type Description <code>name</code> <code>string</code> <code>str</code> Symbol name at the specified index <p>Return value: The method returns <code>SymbolNameData</code> object with <code>name</code> field containing the symbol name.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: Built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>Access the value: The returned object has a <code>.name</code> field containing the symbol name string.</li> <li>Index range: Valid indices are 0 to <code>symbols_total() - 1</code>. Out-of-range indices will raise an error.</li> <li>Selected vs all: Use <code>selected=True</code> for Market Watch symbols, <code>selected=False</code> for all broker symbols.</li> <li>Order dependency: Symbol order may change between calls if Market Watch is modified.</li> <li>Zero-based indexing: First symbol is at index 0, not 1.</li> <li>Combine with symbols_total: Always call <code>symbols_total()</code> first to get the valid index range.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#1-get-all-market-watch-symbols","title":"1) Get all Market Watch symbols","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def get_all_market_watch_symbols(account) -&gt; list[str]:\n    \"\"\"Get list of all symbols in Market Watch\"\"\"\n\n    # Get total count of Market Watch symbols\n    count_data = await account.symbols_total(selected_only=True)\n    total = count_data.total\n\n    print(f\"Found {total} symbols in Market Watch\")\n\n    # Iterate and collect all symbol names\n    symbols = []\n    for i in range(total):\n        symbol_data = await account.symbol_name(index=i, selected=True)\n        symbols.append(symbol_data.name)\n\n    return symbols\n\n# Usage\nmw_symbols = await get_all_market_watch_symbols(account)\nprint(f\"Market Watch symbols: {mw_symbols}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#2-get-all-available-symbols-from-broker","title":"2) Get all available symbols from broker","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def get_all_broker_symbols(account) -&gt; list[str]:\n    \"\"\"Get list of ALL symbols available from broker\"\"\"\n\n    # Get total count of all symbols\n    count_data = await account.symbols_total(selected_only=False)\n    total = count_data.total\n\n    print(f\"Found {total} total symbols from broker\")\n\n    # Iterate and collect all symbol names\n    symbols = []\n    for i in range(total):\n        symbol_data = await account.symbol_name(index=i, selected=False)\n        symbols.append(symbol_data.name)\n\n    return symbols\n\n# Usage\nall_symbols = await get_all_broker_symbols(account)\nprint(f\"Total symbols available: {len(all_symbols)}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#3-print-first-10-market-watch-symbols","title":"3) Print first 10 Market Watch symbols","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def print_first_symbols(account, count: int = 10):\n    \"\"\"Display first N symbols from Market Watch\"\"\"\n\n    print(f\"First {count} Market Watch symbols:\")\n    print(\"=\" * 40)\n\n    for i in range(count):\n        try:\n            symbol_data = await account.symbol_name(index=i, selected=True)\n            print(f\"{i+1:3d}. {symbol_data.name}\")\n        except Exception as e:\n            print(f\"[ERROR] Index {i}: {e}\")\n            break\n\n# Usage\nawait print_first_symbols(account, count=10)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#4-find-symbols-matching-pattern","title":"4) Find symbols matching pattern","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def find_symbols_by_pattern(account, pattern: str, selected_only: bool = True) -&gt; list[str]:\n    \"\"\"Find symbols matching a text pattern\"\"\"\n\n    # Get total count\n    count_data = await account.symbols_total(selected_only=selected_only)\n    total = count_data.total\n\n    # Search for matching symbols\n    matching_symbols = []\n    for i in range(total):\n        symbol_data = await account.symbol_name(index=i, selected=selected_only)\n\n        if pattern.upper() in symbol_data.name.upper():\n            matching_symbols.append(symbol_data.name)\n\n    return matching_symbols\n\n# Usage\nusd_symbols = await find_symbols_by_pattern(account, \"USD\")\nprint(f\"Found {len(usd_symbols)} symbols containing 'USD': {usd_symbols}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#5-compare-market-watch-vs-all-available-symbols","title":"5) Compare Market Watch vs all available symbols","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def compare_symbol_lists(account):\n    \"\"\"Compare Market Watch symbols with all available symbols\"\"\"\n\n    # Get Market Watch symbols\n    mw_count = await account.symbols_total(selected_only=True)\n    mw_total = mw_count.total\n\n    # Get all broker symbols\n    all_count = await account.symbols_total(selected_only=False)\n    all_total = all_count.total\n\n    print(f\"Symbol Statistics:\")\n    print(f\"  Market Watch: {mw_total} symbols\")\n    print(f\"  Available from broker: {all_total} symbols\")\n    print(f\"  Not in Market Watch: {all_total - mw_total} symbols\")\n\n# Usage\nawait compare_symbol_lists(account)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#6-get-symbols-with-error-handling","title":"6) Get symbols with error handling","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def get_symbols_safe(account, selected_only: bool = True) -&gt; list[str]:\n    \"\"\"Get symbols with robust error handling\"\"\"\n\n    symbols = []\n\n    try:\n        # Get total count\n        count_data = await account.symbols_total(selected_only=selected_only)\n        total = count_data.total\n\n        # Iterate with error handling\n        for i in range(total):\n            try:\n                symbol_data = await account.symbol_name(index=i, selected=selected_only)\n                symbols.append(symbol_data.name)\n            except Exception as e:\n                print(f\"Error getting symbol at index {i}: {e}\")\n                # Continue with next symbol\n                continue\n\n        print(f\"Successfully retrieved {len(symbols)} out of {total} symbols\")\n\n    except Exception as e:\n        print(f\"Error getting symbol count: {e}\")\n\n    return symbols\n\n# Usage\nsymbols = await get_symbols_safe(account, selected_only=True)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#7-get-symbol-name-with-timeout","title":"7) Get symbol name with timeout","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\nfrom datetime import datetime, timedelta\n\n# Set deadline\ndeadline = datetime.utcnow() + timedelta(seconds=3)\n\ntry:\n    symbol_data = await account.symbol_name(\n        index=0,\n        selected=True,\n        deadline=deadline\n    )\n    print(f\"First symbol: {symbol_data.name}\")\nexcept Exception as e:\n    print(f\"Timeout or error: {e}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#8-build-symbol-dictionary-with-metadata","title":"8) Build symbol dictionary with metadata","text":"<pre><code>import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def build_symbol_dict(account) -&gt; dict:\n    \"\"\"Build dictionary mapping indices to symbol info\"\"\"\n\n    count_data = await account.symbols_total(selected_only=True)\n    total = count_data.total\n\n    symbol_dict = {}\n\n    for i in range(total):\n        symbol_data = await account.symbol_name(index=i, selected=True)\n        symbol_name = symbol_data.name\n\n        # Get additional info\n        digits_data = await account.symbol_info_integer(\n            symbol=symbol_name,\n            property=market_info_pb2.SYMBOL_DIGITS\n        )\n\n        symbol_dict[i] = {\n            'name': symbol_name,\n            'index': i,\n            'digits': digits_data.value\n        }\n\n    return symbol_dict\n\n# Usage\nsymbols_info = await build_symbol_dict(account)\nfor idx, info in symbols_info.items():\n    print(f\"{idx}: {info['name']} (digits={info['digits']})\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_name/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>symbols_total - Get total symbol count (use before calling symbol_name)</li> <li>symbol_exist - Check if specific symbol exists</li> <li>symbol_select - Add/remove symbols from Market Watch</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/","title":"Get Comprehensive Symbol Parameters","text":"<p>Request: retrieve all symbol parameters at once (RECOMMENDED for getting multiple properties efficiently).</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.symbol_params_many(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.AccountHelper</code></li> <li>Proto definition: <code>SymbolParamsMany</code> (defined in <code>mt5-term-api-account-helper.proto</code>)</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.AccountHelper</code></li> <li>Method: <code>SymbolParamsMany(SymbolParamsManyRequest) -&gt; SymbolParamsManyReply</code></li> <li>Low-level client (generated): <code>AccountHelperStub.SymbolParamsMany(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Get comprehensive symbol parameters in one call (100+ fields: prices, spreads, margins, swaps, volumes).</li> <li>Why you need it. Most efficient method to get multiple symbol properties - single call instead of dozens of <code>symbol_info_*</code> calls.</li> <li>When to use. Use this for getting complete symbol information. Use <code>symbol_info_*</code> only for single specific properties.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to efficiently retrieve symbol data:</p> <ul> <li>Get all symbol parameters in a single efficient call</li> <li>Retrieve data for one specific symbol or all symbols</li> <li>Build comprehensive symbol comparison tables</li> <li>Calculate trading costs and margins efficiently</li> <li>Filter and sort symbols by various criteria</li> <li>Paginate through large symbol lists</li> <li>Avoid multiple RPC calls for the same symbol</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; symbol_params_many - How it works</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_params_many(\n    self,\n    request: account_helper_pb2.SymbolParamsManyRequest,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; account_helper_pb2.SymbolParamsManyData\n</code></pre> <p>Request message:</p> <pre><code>message SymbolParamsManyRequest {\n  optional string symbol_name = 1;\n  optional AH_SYMBOL_PARAMS_MANY_SORT_TYPE sort_type = 2;\n  optional int32 page_number = 3;\n  optional int32 items_per_page = 4;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message SymbolParamsManyReply {\n  oneof response {\n    SymbolParamsManyData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage SymbolParamsManyData {\n  repeated SymbolParameters symbol_infos = 1;\n  int32 symbols_total = 2;\n  optional int32 page_number = 3;\n  optional int32 items_per_page = 4;\n}\n</code></pre> <p>SymbolParameters structure:</p> <p>The <code>SymbolParameters</code> message contains 112 fields grouped by category:</p> <p>1. Price Data (9 fields)</p> <ul> <li><code>bid</code>, <code>ask</code>, <code>last</code> - Current prices</li> <li><code>bid_high</code>, <code>bid_low</code> - Bid price range</li> <li><code>ask_high</code>, <code>ask_low</code> - Ask price range</li> <li><code>last_high</code>, <code>last_low</code> - Last price range</li> </ul> <p>2. Volume Data (10 fields)</p> <ul> <li><code>volume</code>, <code>volume_high</code>, <code>volume_low</code> - Volume in lots</li> <li><code>volume_real</code>, <code>volume_high_real</code>, <code>volume_low_real</code> - Real volume</li> <li><code>volume_min</code>, <code>volume_max</code>, <code>volume_step</code>, <code>volume_limit</code> - Volume constraints</li> </ul> <p>3. Spread &amp; Precision (4 fields)</p> <ul> <li><code>spread</code> - Current spread in points</li> <li><code>spread_float</code> - Floating spread flag</li> <li><code>digits</code> - Decimal digits</li> <li><code>point</code> - Point value</li> </ul> <p>4. Contract &amp; Trade Parameters (9 fields)</p> <ul> <li><code>trade_contract_size</code> - Contract size</li> <li><code>trade_tick_size</code> - Tick size</li> <li> <p><code>trade_tick_value</code>, <code>trade_tick_value_profit</code>, <code>trade_tick_value_loss</code> - Tick values</p> </li> <li> <p><code>trade_accrued_interest</code> - Accrued interest</p> </li> <li><code>trade_face_value</code> - Face value</li> <li><code>trade_liquidity_rate</code> - Liquidity rate</li> <li><code>trade_stops_level</code>, <code>trade_freeze_level</code> - Stop levels</li> </ul> <p>5. Margin Requirements (4 fields)</p> <ul> <li><code>margin_initial</code>, <code>margin_maintenance</code> - Initial and maintenance margins</li> <li><code>margin_hedged</code> - Hedged margin</li> <li><code>margin_hedged_use_leg</code> - Use leg for hedged margin</li> </ul> <p>6. Swap Data (12 fields)</p> <ul> <li><code>swap_long</code>, <code>swap_short</code> - Long/short swap</li> <li><code>swap_sunday</code>, <code>swap_monday</code>, <code>swap_tuesday</code>, <code>swap_wednesday</code>, <code>swap_thursday</code>, <code>swap_friday</code>, <code>swap_saturday</code> - Daily swaps</li> <li><code>swap_mode</code> - Swap calculation mode</li> <li><code>swap_rollover_3days</code> - Triple swap day</li> </ul> <p>7. Session Statistics (16 fields)</p> <ul> <li><code>session_volume</code>, <code>session_turnover</code>, <code>session_interest</code> - Session totals</li> <li><code>session_buy_orders_volume</code>, <code>session_sell_orders_volume</code> - Order volumes</li> <li><code>session_open</code>, <code>session_close</code>, <code>session_aw</code> - Session prices</li> <li><code>session_price_settlement</code> - Settlement price</li> <li><code>session_price_limit_min</code>, <code>session_price_limit_max</code> - Price limits</li> <li><code>session_deals</code> - Number of deals</li> <li><code>session_buy_orders</code>, <code>session_sell_orders</code> - Order counts</li> </ul> <p>8. Options Data (3 fields)</p> <ul> <li><code>option_strike</code> - Strike price</li> <li><code>option_mode</code> - Option mode</li> <li><code>option_right</code> - Option right (call/put)</li> </ul> <p>9. Greeks &amp; Pricing (8 fields)</p> <ul> <li><code>price_theoretical</code> - Theoretical price</li> <li><code>price_delta</code>, <code>price_theta</code>, <code>price_gamma</code>, <code>price_vega</code>, <code>price_rho</code>, <code>price_omega</code> - Greeks</li> <li><code>price_sensitivity</code> - Price sensitivity</li> </ul> <p>10. Market Statistics (2 fields)</p> <ul> <li><code>price_change</code> - Price change</li> <li><code>price_volatility</code> - Volatility</li> </ul> <p>11. Timestamps (4 fields)</p> <ul> <li><code>time</code>, <code>time_msc</code> - Last update time</li> <li><code>start_time</code> - Trading start time</li> <li><code>expiration_time</code> - Expiration time</li> </ul> <p>12. Trading Modes (10 fields)</p> <ul> <li><code>trade_calc_mode</code> - Calculation mode</li> <li><code>trade_mode</code> - Trading mode</li> <li><code>trade_exe_mode</code> - Execution mode</li> <li><code>expiration_mode</code> - Order expiration mode</li> <li><code>filling_mode</code> - Order filling mode</li> <li><code>order_mode</code> - Order mode</li> <li><code>order_gtc_mode</code> - GTC mode</li> <li><code>chart_mode</code> - Chart mode</li> <li><code>ticks_book_depth</code> - Book depth</li> </ul> <p>13. Identifiers &amp; Description (11 fields)</p> <ul> <li><code>name</code> - Symbol name</li> <li><code>sym_description</code> - Symbol description (note: field name is <code>sym_description</code> not <code>description</code>)</li> <li><code>path</code> - Symbol path</li> <li><code>currency_base</code>, <code>currency_profit</code>, <code>currency_margin</code> - Currencies</li> <li><code>isin</code> - ISIN code</li> <li><code>basis</code> - Basis</li> <li><code>category</code> - Category</li> <li><code>page</code> - Page</li> <li><code>formula</code> - Formula</li> </ul> <p>14. Classification (6 fields)</p> <ul> <li><code>sector</code>, <code>sector_name</code> - Sector</li> <li><code>industry</code>, <code>industry_name</code> - Industry</li> <li><code>country</code> - Country</li> <li><code>bank</code> - Bank</li> </ul> <p>15. Display &amp; Status (6 fields)</p> <ul> <li><code>exist</code> - Symbol exists</li> <li><code>select</code> - Symbol selected</li> <li><code>visible</code> - Symbol visible</li> <li><code>subscription_delay</code> - Subscription delay</li> <li><code>background_color</code> - Background color</li> <li><code>custom</code> - Custom data</li> </ul> <p>16. Exchange (1 field)</p> <ul> <li><code>exchange</code> - Exchange name</li> </ul> <p>Total: 112 fields providing comprehensive symbol information in a single efficient call.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>request</code> <code>SymbolParamsManyRequest</code> (required) Request object with filter/pagination parameters <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#request-fields","title":"Request Fields:","text":"Field Type Description <code>symbol_name</code> <code>string</code> (optional) Filter by symbol name (omit or empty = all symbols) <code>sort_type</code> <code>AH_SYMBOL_PARAMS_MANY_SORT_TYPE</code> (optional) Sort order for results <code>page_number</code> <code>int32</code> (optional) Page number for pagination (0-based, default 0) <code>items_per_page</code> <code>int32</code> (optional) Items per page (0 or omit = all items)"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#output","title":"\u2b06\ufe0f Output","text":"Field Type Python Type Description <code>symbol_infos</code> <code>repeated SymbolParameters</code> <code>list[SymbolParameters]</code> List of symbol parameter objects <code>symbols_total</code> <code>int32</code> <code>int</code> Total number of symbols <code>page_number</code> <code>int32</code> (optional) <code>int</code> Current page number <code>items_per_page</code> <code>int32</code> (optional) <code>int</code> Items per page <p>Return value: The method returns <code>SymbolParamsManyData</code> object with list of symbol parameters and pagination info.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":"<p>Note: All enums are accessed from <code>mt5_term_api_account_helper_pb2</code> module. This method uses 14 enums with 231 total constants.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#ah_symbol_params_many_sort_type-request-parameter","title":"<code>AH_SYMBOL_PARAMS_MANY_SORT_TYPE</code> (request parameter)","text":"Constant Value Description <code>AH_PARAMS_MANY_SORT_TYPE_SYMBOL_NAME_ASC</code> 0 Symbol name ascending (A-Z) <code>AH_PARAMS_MANY_SORT_TYPE_SYMBOL_NAME_DESC</code> 1 Symbol name descending (Z-A) <code>AH_PARAMS_MANY_SORT_TYPE_MQL_INDEX_ASC</code> 2 MQL index ascending <code>AH_PARAMS_MANY_SORT_TYPE_MQL_INDEX_DESC</code> 3 MQL index descending"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#bmt5_enum_symbol_chart_mode-for-field-chart_mode","title":"<code>BMT5_ENUM_SYMBOL_CHART_MODE</code> (for field <code>chart_mode</code>)","text":"Constant Value Description <code>BMT5_SYMBOL_CHART_MODE_BID</code> 0 Bars based on Bid prices <code>BMT5_SYMBOL_CHART_MODE_LAST</code> 1 Bars based on Last prices"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#bmt5_enum_order_type_filling-for-field-filling_mode","title":"<code>BMT5_ENUM_ORDER_TYPE_FILLING</code> (for field <code>filling_mode</code>)","text":"Constant Value Description <code>BMT5_ORDER_FILLING_FOK</code> 0 Fill or Kill - fill completely or cancel <code>BMT5_ORDER_FILLING_IOC</code> 1 Immediate or Cancel - fill available volume <code>BMT5_ORDER_FILLING_RETURN</code> 2 Return execution mode <code>BMT5_ORDER_FILLING_BOC</code> 3 Book or Cancel - place order in book"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#bmt5_enum_symbol_industry-for-field-industry","title":"<code>BMT5_ENUM_SYMBOL_INDUSTRY</code> (for field <code>industry</code>)","text":"Constant Value Description <code>BMT5_INDUSTRY_UNDEFINED</code> 0 Undefined <code>BMT5_INDUSTRY_AGRICULTURAL_INPUTS</code> 1 Agricultural Inputs <code>BMT5_INDUSTRY_ALUMINIUM</code> 2 Aluminium <code>BMT5_INDUSTRY_BUILDING_MATERIALS</code> 3 Building Materials <code>BMT5_INDUSTRY_CHEMICALS</code> 4 Chemicals <code>BMT5_INDUSTRY_COKING_COAL</code> 5 Coking Coal <code>BMT5_INDUSTRY_COPPER</code> 6 Copper <code>BMT5_INDUSTRY_GOLD</code> 7 Gold <code>BMT5_INDUSTRY_LUMBER_WOOD</code> 8 Lumber &amp; Wood <code>BMT5_INDUSTRY_INDUSTRIAL_METALS</code> 9 Industrial Metals <code>BMT5_INDUSTRY_PRECIOUS_METALS</code> 10 Precious Metals <code>BMT5_INDUSTRY_PAPER</code> 11 Paper <code>BMT5_INDUSTRY_SILVER</code> 12 Silver <code>BMT5_INDUSTRY_SPECIALTY_CHEMICALS</code> 13 Specialty Chemicals <code>BMT5_INDUSTRY_STEEL</code> 14 Steel <code>BMT5_INDUSTRY_ADVERTISING</code> 15 Advertising <code>BMT5_INDUSTRY_BROADCASTING</code> 16 Broadcasting <code>BMT5_INDUSTRY_GAMING_MULTIMEDIA</code> 17 Gaming &amp; Multimedia <code>BMT5_INDUSTRY_ENTERTAINMENT</code> 18 Entertainment <code>BMT5_INDUSTRY_INTERNET_CONTENT</code> 19 Internet Content <code>BMT5_INDUSTRY_PUBLISHING</code> 20 Publishing <code>BMT5_INDUSTRY_TELECOM</code> 21 Telecommunications <code>BMT5_INDUSTRY_APPAREL_MANUFACTURING</code> 22 Apparel Manufacturing <code>BMT5_INDUSTRY_APPAREL_RETAIL</code> 23 Apparel Retail <code>BMT5_INDUSTRY_AUTO_MANUFACTURERS</code> 24 Auto Manufacturers <code>BMT5_INDUSTRY_AUTO_PARTS</code> 25 Auto Parts <code>BMT5_INDUSTRY_AUTO_DEALERSHIP</code> 26 Auto Dealerships <code>BMT5_INDUSTRY_DEPARTMENT_STORES</code> 27 Department Stores <code>BMT5_INDUSTRY_FOOTWEAR_ACCESSORIES</code> 28 Footwear &amp; Accessories <code>BMT5_INDUSTRY_FURNISHINGS</code> 29 Furnishings <code>BMT5_INDUSTRY_GAMBLING</code> 30 Gambling <code>BMT5_INDUSTRY_HOME_IMPROV_RETAIL</code> 31 Home Improvement Retail <code>BMT5_INDUSTRY_INTERNET_RETAIL</code> 32 Internet Retail <code>BMT5_INDUSTRY_LEISURE</code> 33 Leisure <code>BMT5_INDUSTRY_LODGING</code> 34 Lodging <code>BMT5_INDUSTRY_LUXURY_GOODS</code> 35 Luxury Goods <code>BMT5_INDUSTRY_PACKAGING_CONTAINERS</code> 36 Packaging &amp; Containers <code>BMT5_INDUSTRY_PERSONAL_SERVICES</code> 37 Personal Services <code>BMT5_INDUSTRY_RECREATIONAL_VEHICLES</code> 38 Recreational Vehicles <code>BMT5_INDUSTRY_RESIDENT_CONSTRUCTION</code> 39 Residential Construction <code>BMT5_INDUSTRY_RESORTS_CASINOS</code> 40 Resorts &amp; Casinos <code>BMT5_INDUSTRY_RESTAURANTS</code> 41 Restaurants <code>BMT5_INDUSTRY_SPECIALTY_RETAIL</code> 42 Specialty Retail <code>BMT5_INDUSTRY_TEXTILE_MANUFACTURING</code> 43 Textile Manufacturing <code>BMT5_INDUSTRY_TRAVEL_SERVICES</code> 44 Travel Services <code>BMT5_INDUSTRY_BEVERAGES_BREWERS</code> 45 Beverages - Brewers <code>BMT5_INDUSTRY_BEVERAGES_NON_ALCO</code> 46 Beverages - Non-Alcoholic <code>BMT5_INDUSTRY_BEVERAGES_WINERIES</code> 47 Beverages - Wineries <code>BMT5_INDUSTRY_CONFECTIONERS</code> 48 Confectioners <code>BMT5_INDUSTRY_DISCOUNT_STORES</code> 49 Discount Stores <code>BMT5_INDUSTRY_EDUCATION_TRAINIG</code> 50 Education &amp; Training <code>BMT5_INDUSTRY_FARM_PRODUCTS</code> 51 Farm Products <code>BMT5_INDUSTRY_FOOD_DISTRIBUTION</code> 52 Food Distribution <code>BMT5_INDUSTRY_GROCERY_STORES</code> 53 Grocery Stores <code>BMT5_INDUSTRY_HOUSEHOLD_PRODUCTS</code> 54 Household Products <code>BMT5_INDUSTRY_PACKAGED_FOODS</code> 55 Packaged Foods <code>BMT5_INDUSTRY_TOBACCO</code> 56 Tobacco <code>BMT5_INDUSTRY_OIL_GAS_DRILLING</code> 57 Oil &amp; Gas Drilling <code>BMT5_INDUSTRY_OIL_GAS_EP</code> 58 Oil &amp; Gas E&amp;P <code>BMT5_INDUSTRY_OIL_GAS_EQUIPMENT</code> 59 Oil &amp; Gas Equipment <code>BMT5_INDUSTRY_OIL_GAS_INTEGRATED</code> 60 Oil &amp; Gas Integrated <code>BMT5_INDUSTRY_OIL_GAS_MIDSTREAM</code> 61 Oil &amp; Gas Midstream <code>BMT5_INDUSTRY_OIL_GAS_REFINING</code> 62 Oil &amp; Gas Refining <code>BMT5_INDUSTRY_THERMAL_COAL</code> 63 Thermal Coal <code>BMT5_INDUSTRY_URANIUM</code> 64 Uranium <code>BMT5_INDUSTRY_EXCHANGE_TRADED_FUND</code> 65 Exchange Traded Fund <code>BMT5_INDUSTRY_ASSETS_MANAGEMENT</code> 66 Asset Management <code>BMT5_INDUSTRY_BANKS_DIVERSIFIED</code> 67 Banks - Diversified <code>BMT5_INDUSTRY_BANKS_REGIONAL</code> 68 Banks - Regional <code>BMT5_INDUSTRY_CAPITAL_MARKETS</code> 69 Capital Markets <code>BMT5_INDUSTRY_CLOSE_END_FUND_DEBT</code> 70 Closed-End Fund - Debt <code>BMT5_INDUSTRY_CLOSE_END_FUND_EQUITY</code> 71 Closed-End Fund - Equity <code>BMT5_INDUSTRY_CLOSE_END_FUND_FOREIGN</code> 72 Closed-End Fund - Foreign <code>BMT5_INDUSTRY_CREDIT_SERVICES</code> 73 Credit Services <code>BMT5_INDUSTRY_FINANCIAL_CONGLOMERATE</code> 74 Financial Conglomerate <code>BMT5_INDUSTRY_FINANCIAL_DATA_EXCHANGE</code> 75 Financial Data &amp; Exchanges <code>BMT5_INDUSTRY_INSURANCE_BROKERS</code> 76 Insurance Brokers <code>BMT5_INDUSTRY_INSURANCE_DIVERSIFIED</code> 77 Insurance - Diversified <code>BMT5_INDUSTRY_INSURANCE_LIFE</code> 78 Insurance - Life <code>BMT5_INDUSTRY_INSURANCE_PROPERTY</code> 79 Insurance - Property &amp; Casualty <code>BMT5_INDUSTRY_INSURANCE_REINSURANCE</code> 80 Insurance - Reinsurance <code>BMT5_INDUSTRY_INSURANCE_SPECIALTY</code> 81 Insurance - Specialty <code>BMT5_INDUSTRY_MORTGAGE_FINANCE</code> 82 Mortgage Finance <code>BMT5_INDUSTRY_SHELL_COMPANIES</code> 83 Shell Companies <code>BMT5_INDUSTRY_BIOTECHNOLOGY</code> 84 Biotechnology <code>BMT5_INDUSTRY_DIAGNOSTICS_RESEARCH</code> 85 Diagnostics &amp; Research <code>BMT5_INDUSTRY_DRUGS_MANUFACTURERS</code> 86 Drug Manufacturers - General <code>BMT5_INDUSTRY_DRUGS_MANUFACTURERS_SPEC</code> 87 Drug Manufacturers - Specialty <code>BMT5_INDUSTRY_HEALTHCARE_PLANS</code> 88 Healthcare Plans <code>BMT5_INDUSTRY_HEALTH_INFORMATION</code> 89 Health Information Services <code>BMT5_INDUSTRY_MEDICAL_FACILITIES</code> 90 Medical Care Facilities <code>BMT5_INDUSTRY_MEDICAL_DEVICES</code> 91 Medical Devices <code>BMT5_INDUSTRY_MEDICAL_DISTRIBUTION</code> 92 Medical Distribution <code>BMT5_INDUSTRY_MEDICAL_INSTRUMENTS</code> 93 Medical Instruments &amp; Supplies <code>BMT5_INDUSTRY_PHARM_RETAILERS</code> 94 Pharmaceutical Retailers <code>BMT5_INDUSTRY_AEROSPACE_DEFENSE</code> 95 Aerospace &amp; Defense <code>BMT5_INDUSTRY_AIRLINES</code> 96 Airlines <code>BMT5_INDUSTRY_AIRPORTS_SERVICES</code> 97 Airports &amp; Air Services <code>BMT5_INDUSTRY_BUILDING_PRODUCTS</code> 98 Building Products &amp; Equipment <code>BMT5_INDUSTRY_BUSINESS_EQUIPMENT</code> 99 Business Equipment &amp; Supplies <code>BMT5_INDUSTRY_CONGLOMERATES</code> 100 Conglomerates <code>BMT5_INDUSTRY_CONSULTING_SERVICES</code> 101 Consulting Services <code>BMT5_INDUSTRY_ELECTRICAL_EQUIPMENT</code> 102 Electrical Equipment &amp; Parts <code>BMT5_INDUSTRY_ENGINEERING_CONSTRUCTION</code> 103 Engineering &amp; Construction <code>BMT5_INDUSTRY_FARM_HEAVY_MACHINERY</code> 104 Farm &amp; Heavy Machinery <code>BMT5_INDUSTRY_INDUSTRIAL_DISTRIBUTION</code> 105 Industrial Distribution <code>BMT5_INDUSTRY_INFRASTRUCTURE_OPERATIONS</code> 106 Infrastructure Operations <code>BMT5_INDUSTRY_FREIGHT_LOGISTICS</code> 107 Freight &amp; Logistics Services <code>BMT5_INDUSTRY_MARINE_SHIPPING</code> 108 Marine Shipping <code>BMT5_INDUSTRY_METAL_FABRICATION</code> 109 Metal Fabrication <code>BMT5_INDUSTRY_POLLUTION_CONTROL</code> 110 Pollution &amp; Treatment Controls <code>BMT5_INDUSTRY_RAILROADS</code> 111 Railroads <code>BMT5_INDUSTRY_RENTAL_LEASING</code> 112 Rental &amp; Leasing Services <code>BMT5_INDUSTRY_SECURITY_PROTECTION</code> 113 Security &amp; Protection Services <code>BMT5_INDUSTRY_SPEALITY_BUSINESS_SERVICES</code> 114 Specialty Business Services <code>BMT5_INDUSTRY_SPEALITY_MACHINERY</code> 115 Specialty Industrial Machinery <code>BMT5_INDUSTRY_STUFFING_EMPLOYMENT</code> 116 Staffing &amp; Employment Services <code>BMT5_INDUSTRY_TOOLS_ACCESSORIES</code> 117 Tools &amp; Accessories <code>BMT5_INDUSTRY_TRUCKING</code> 118 Trucking <code>BMT5_INDUSTRY_WASTE_MANAGEMENT</code> 119 Waste Management <code>BMT5_INDUSTRY_REAL_ESTATE_DEVELOPMENT</code> 120 Real Estate - Development <code>BMT5_INDUSTRY_REAL_ESTATE_DIVERSIFIED</code> 121 Real Estate - Diversified <code>BMT5_INDUSTRY_REAL_ESTATE_SERVICES</code> 122 Real Estate Services <code>BMT5_INDUSTRY_REIT_DIVERSIFIED</code> 123 REIT - Diversified <code>BMT5_INDUSTRY_REIT_HEALTCARE</code> 124 REIT - Healthcare Facilities <code>BMT5_INDUSTRY_REIT_HOTEL_MOTEL</code> 125 REIT - Hotel &amp; Motel <code>BMT5_INDUSTRY_REIT_INDUSTRIAL</code> 126 REIT - Industrial <code>BMT5_INDUSTRY_REIT_MORTAGE</code> 127 REIT - Mortgage <code>BMT5_INDUSTRY_REIT_OFFICE</code> 128 REIT - Office <code>BMT5_INDUSTRY_REIT_RESIDENTAL</code> 129 REIT - Residential <code>BMT5_INDUSTRY_REIT_RETAIL</code> 130 REIT - Retail <code>BMT5_INDUSTRY_REIT_SPECIALITY</code> 131 REIT - Specialty <code>BMT5_INDUSTRY_COMMUNICATION_EQUIPMENT</code> 132 Communication Equipment <code>BMT5_INDUSTRY_COMPUTER_HARDWARE</code> 133 Computer Hardware <code>BMT5_INDUSTRY_CONSUMER_ELECTRONICS</code> 134 Consumer Electronics <code>BMT5_INDUSTRY_ELECTRONIC_COMPONENTS</code> 135 Electronic Components <code>BMT5_INDUSTRY_ELECTRONIC_DISTRIBUTION</code> 136 Electronics &amp; Computer Distribution <code>BMT5_INDUSTRY_IT_SERVICES</code> 137 Information Technology Services <code>BMT5_INDUSTRY_SCIENTIFIC_INSTRUMENTS</code> 138 Scientific &amp; Technical Instruments <code>BMT5_INDUSTRY_SEMICONDUCTOR_EQUIPMENT</code> 139 Semiconductor Equipment &amp; Materials <code>BMT5_INDUSTRY_SEMICONDUCTORS</code> 140 Semiconductors <code>BMT5_INDUSTRY_SOFTWARE_APPLICATION</code> 141 Software - Application <code>BMT5_INDUSTRY_SOFTWARE_INFRASTRUCTURE</code> 142 Software - Infrastructure <code>BMT5_INDUSTRY_SOLAR</code> 143 Solar <code>BMT5_INDUSTRY_UTILITIES_DIVERSIFIED</code> 144 Utilities - Diversified <code>BMT5_INDUSTRY_UTILITIES_POWERPRODUCERS</code> 145 Utilities - Independent Power Producers <code>BMT5_INDUSTRY_UTILITIES_RENEWABLE</code> 146 Utilities - Renewable <code>BMT5_INDUSTRY_UTILITIES_REGULATED_ELECTRIC</code> 147 Utilities - Regulated Electric <code>BMT5_INDUSTRY_UTILITIES_REGULATED_GAS</code> 148 Utilities - Regulated Gas <code>BMT5_INDUSTRY_UTILITIES_REGULATED_WATER</code> 149 Utilities - Regulated Water <code>BMT5_INDUSTRY_UTILITIES_FIRST</code> 150 Utilities First (range marker) <code>BMT5_INDUSTRY_UTILITIES_LAST</code> 151 Utilities Last (range marker)"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#bmt5_enum_symbol_option_mode-for-field-option_mode","title":"<code>BMT5_ENUM_SYMBOL_OPTION_MODE</code> (for field <code>option_mode</code>)","text":"<p>Python constants:</p> Constant Value Description <code>BMT5_SYMBOL_OPTION_MODE_EUROPEAN</code> 0 European option - exercise only at expiration <code>BMT5_SYMBOL_OPTION_MODE_AMERICAN</code> 1 American option - exercise any time"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#bmt5_enum_symbol_option_right-for-field-option_right","title":"<code>BMT5_ENUM_SYMBOL_OPTION_RIGHT</code> (for field <code>option_right</code>)","text":"<p>Python constants:</p> Constant Value Description <code>BMT5_SYMBOL_OPTION_RIGHT_CALL</code> 0 Call option - right to buy <code>BMT5_SYMBOL_OPTION_RIGHT_PUT</code> 1 Put option - right to sell"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#bmt5_enum_symbol_order_gtc_mode-for-field-order_gtc_mode","title":"<code>BMT5_ENUM_SYMBOL_ORDER_GTC_MODE</code> (for field <code>order_gtc_mode</code>)","text":"<p>Python constants:</p> Constant Value Description <code>BMT5_SYMBOL_ORDERS_GTC</code> 0 Good Till Cancelled orders allowed <code>BMT5_SYMBOL_ORDERS_DAILY</code> 1 Daily orders only <code>BMT5_SYMBOL_ORDERS_DAILY_EXCLUDING_STOPS</code> 2 Daily excluding stops"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#bmt5_enum_order_type-for-field-order_mode","title":"<code>BMT5_ENUM_ORDER_TYPE</code> (for field <code>order_mode</code>)","text":"<p>Python constants:</p> Constant Value Description <code>BMT5_ORDER_TYPE_BUY</code> 0 Market Buy order <code>BMT5_ORDER_TYPE_SELL</code> 1 Market Sell order <code>BMT5_ORDER_TYPE_BUY_LIMIT</code> 2 Buy Limit pending order <code>BMT5_ORDER_TYPE_SELL_LIMIT</code> 3 Sell Limit pending order <code>BMT5_ORDER_TYPE_BUY_STOP</code> 4 Buy Stop pending order <code>BMT5_ORDER_TYPE_SELL_STOP</code> 5 Sell Stop pending order <code>BMT5_ORDER_TYPE_BUY_STOP_LIMIT</code> 6 Buy Stop Limit pending order <code>BMT5_ORDER_TYPE_SELL_STOP_LIMIT</code> 7 Sell Stop Limit pending order <code>BMT5_ORDER_TYPE_CLOSE_BY</code> 8 Close By order"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#bmt5_enum_symbol_sector-for-field-sector","title":"<code>BMT5_ENUM_SYMBOL_SECTOR</code> (for field <code>sector</code>)","text":"<p>Python constants:</p> Constant Value Description <code>BMT5_SECTOR_UNDEFINED</code> 0 Undefined sector <code>BMT5_SECTOR_BASIC_MATERIALS</code> 1 Basic Materials <code>BMT5_SECTOR_COMMUNICATION_SERVICES</code> 2 Communication Services <code>BMT5_SECTOR_CONSUMER_CYCLICAL</code> 3 Consumer Cyclical <code>BMT5_SECTOR_CONSUMER_DEFENSIVE</code> 4 Consumer Defensive <code>BMT5_SECTOR_CURRENCY</code> 5 Currency <code>BMT5_SECTOR_CURRENCY_CRYPTO</code> 6 Cryptocurrency <code>BMT5_SECTOR_ENERGY</code> 7 Energy <code>BMT5_SECTOR_FINANCIAL</code> 8 Financial <code>BMT5_SECTOR_HEALTHCARE</code> 9 Healthcare <code>BMT5_SECTOR_INDUSTRIALS</code> 10 Industrials <code>BMT5_SECTOR_REAL_ESTATE</code> 11 Real Estate <code>BMT5_SECTOR_TECHNOLOGY</code> 12 Technology <code>BMT5_SECTOR_UTILITIES</code> 13 Utilities"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#bmt5_enum_symbol_swap_mode-for-field-swap_mode","title":"<code>BMT5_ENUM_SYMBOL_SWAP_MODE</code> (for field <code>swap_mode</code>)","text":"<p>Python constants:</p> Constant Value Description <code>BMT5_SYMBOL_SWAP_MODE_DISABLED</code> 0 No swaps <code>BMT5_SYMBOL_SWAP_MODE_POINTS</code> 1 Swaps in points <code>BMT5_SYMBOL_SWAP_MODE_CURRENCY_SYMBOL</code> 2 Swaps in symbol base currency <code>BMT5_SYMBOL_SWAP_MODE_CURRENCY_MARGIN</code> 3 Swaps in margin currency <code>BMT5_SYMBOL_SWAP_MODE_CURRENCY_DEPOSIT</code> 4 Swaps in deposit currency <code>BMT5_SYMBOL_SWAP_MODE_CURRENCY_PROFIT</code> 5 Swaps in profit currency <code>BMT5_SYMBOL_SWAP_MODE_INTEREST_CURRENT</code> 6 Annual interest from current price <code>BMT5_SYMBOL_SWAP_MODE_INTEREST_OPEN</code> 7 Annual interest from open price <code>BMT5_SYMBOL_SWAP_MODE_REOPEN_CURRENT</code> 8 Reopen by current price <code>BMT5_SYMBOL_SWAP_MODE_REOPEN_BID</code> 9 Reopen by Bid price"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#bmt5_enum_day_of_week-for-field-swap_rollover_3days","title":"<code>BMT5_ENUM_DAY_OF_WEEK</code> (for field <code>swap_rollover_3days</code>)","text":"<p>Python constants:</p> Constant Value Description <code>BMT5_SUNDAY</code> 0 Sunday <code>BMT5_MONDAY</code> 1 Monday <code>BMT5_TUESDAY</code> 2 Tuesday <code>BMT5_WEDNESDAY</code> 3 Wednesday <code>BMT5_THURSDAY</code> 4 Thursday <code>BMT5_FRIDAY</code> 5 Friday <code>BMT5_SATURDAY</code> 6 Saturday"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#bmt5_enum_symbol_calc_mode-for-field-trade_calc_mode","title":"<code>BMT5_ENUM_SYMBOL_CALC_MODE</code> (for field <code>trade_calc_mode</code>)","text":"<p>Python constants:</p> Constant Value Description <code>BMT5_SYMBOL_CALC_MODE_FOREX</code> 0 Forex mode <code>BMT5_SYMBOL_CALC_MODE_FOREX_NO_LEVERAGE</code> 1 Forex no leverage <code>BMT5_SYMBOL_CALC_MODE_FUTURES</code> 2 Futures <code>BMT5_SYMBOL_CALC_MODE_CFD</code> 3 CFD <code>BMT5_SYMBOL_CALC_MODE_CFDINDEX</code> 4 CFD index <code>BMT5_SYMBOL_CALC_MODE_CFDLEVERAGE</code> 5 CFD leverage <code>BMT5_SYMBOL_CALC_MODE_EXCH_STOCKS</code> 6 Exchange stocks <code>BMT5_SYMBOL_CALC_MODE_EXCH_FUTURES</code> 7 Exchange futures <code>BMT5_SYMBOL_CALC_MODE_EXCH_FUTURES_FORTS</code> 8 FORTS futures <code>BMT5_SYMBOL_CALC_MODE_EXCH_BONDS</code> 9 Exchange bonds <code>BMT5_SYMBOL_CALC_MODE_EXCH_STOCKS_MOEX</code> 10 MOEX stocks <code>BMT5_SYMBOL_CALC_MODE_EXCH_BONDS_MOEX</code> 11 MOEX bonds <code>BMT5_SYMBOL_CALC_MODE_SERV_COLLATERAL</code> 12 Service collateral"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#bmt5_enum_symbol_trade_execution-for-field-trade_exe_mode","title":"<code>BMT5_ENUM_SYMBOL_TRADE_EXECUTION</code> (for field <code>trade_exe_mode</code>)","text":"<p>Python constants:</p> Constant Value Description <code>BMT5_SYMBOL_TRADE_EXECUTION_REQUEST</code> 0 Execution by request <code>BMT5_SYMBOL_TRADE_EXECUTION_INSTANT</code> 1 Instant execution <code>BMT5_SYMBOL_TRADE_EXECUTION_MARKET</code> 2 Market execution <code>BMT5_SYMBOL_TRADE_EXECUTION_EXCHANGE</code> 3 Exchange execution"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#bmt5_enum_symbol_trade_mode-for-field-trade_mode","title":"<code>BMT5_ENUM_SYMBOL_TRADE_MODE</code> (for field <code>trade_mode</code>)","text":"<p>Python constants:</p> Constant Value Description <code>BMT5_SYMBOL_TRADE_MODE_DISABLED</code> 0 Trade disabled <code>BMT5_SYMBOL_TRADE_MODE_LONGONLY</code> 1 Long only allowed <code>BMT5_SYMBOL_TRADE_MODE_SHORTONLY</code> 2 Short only allowed <code>BMT5_SYMBOL_TRADE_MODE_CLOSEONLY</code> 3 Close only <code>BMT5_SYMBOL_TRADE_MODE_FULL</code> 4 Full trade mode"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: Built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>RECOMMENDED method: This is the most efficient way to get symbol data - single call returns 100+ fields.</li> <li>Performance: Getting all parameters in one call is significantly faster than multiple <code>symbol_info_*</code> calls.</li> <li>Request construction: Create <code>SymbolParamsManyRequest</code> object and set desired fields.</li> <li>Single symbol query: Set <code>symbol_name</code> in request to get data for one specific symbol.</li> <li>All symbols query: Leave <code>symbol_name</code> empty to get all symbols.</li> <li>Pagination: Use <code>page_number</code> and <code>items_per_page</code> for large symbol lists to control payload size.</li> <li>Sort order: Use <code>sort_type</code> to control ordering of results (alphabetical or by MQL index).</li> <li>Field access: Access fields directly from <code>SymbolParameters</code> objects (e.g., <code>info.bid</code>, <code>info.spread</code>).</li> <li>Comprehensive data: Each <code>SymbolParameters</code> contains 112 fields including prices, volumes, margins, swaps, session times, etc.</li> <li>Zero values: Some fields may be zero if not applicable to the symbol type.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#1-get-all-parameters-for-one-symbol-recommended","title":"1) Get all parameters for one symbol (RECOMMENDED)","text":"<pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\n# Create request for single symbol\nrequest = account_helper_pb2.SymbolParamsManyRequest()\nrequest.symbol_name = \"EURUSD\"\n\n# Get all EURUSD parameters\ndata = await account.symbol_params_many(request)\n\nif data.symbol_infos:\n    info = data.symbol_infos[0]\n\n    print(f\"Symbol: {info.name}\")\n    print(f\"Description: {info.sym_description}\")\n    print(f\"BID: {info.bid}\")\n    print(f\"ASK: {info.ask}\")\n    print(f\"Spread: {info.spread} points\")\n    print(f\"Digits: {info.digits}\")\n    print(f\"Contract Size: {info.trade_contract_size}\")\n    print(f\"Tick Value: {info.trade_tick_value}\")\n    print(f\"Min Volume: {info.volume_min}\")\n    print(f\"Max Volume: {info.volume_max}\")\n    print(f\"Volume Step: {info.volume_step}\")\n    print(f\"Swap Long: {info.swap_long}\")\n    print(f\"Swap Short: {info.swap_short}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#2-get-all-symbols-with-pagination","title":"2) Get all symbols with pagination","text":"<pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\n# Create request with pagination\nrequest = account_helper_pb2.SymbolParamsManyRequest()\nrequest.page_number = 0\nrequest.items_per_page = 100\nrequest.sort_type = account_helper_pb2.AH_PARAMS_MANY_SORT_TYPE_SYMBOL_NAME_ASC\n\n# Get first page\ndata = await account.symbol_params_many(request)\n\nprint(f\"Total symbols: {data.symbols_total}\")\nprint(f\"Retrieved: {len(data.symbol_infos)} symbols on page {data.page_number}\")\nprint(f\"Items per page: {data.items_per_page}\")\n\n# Display first 10 symbols\nfor info in data.symbol_infos[:10]:\n    print(f\"{info.name}: BID={info.bid}, ASK={info.ask}, Spread={info.spread}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#3-iterate-through-all-pages","title":"3) Iterate through all pages","text":"<pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\nasync def get_all_symbols(account):\n    \"\"\"Retrieve all symbols using pagination\"\"\"\n\n    all_symbols = []\n    page_number = 0\n    items_per_page = 100\n\n    while True:\n        # Create request for current page\n        request = account_helper_pb2.SymbolParamsManyRequest()\n        request.page_number = page_number\n        request.items_per_page = items_per_page\n\n        # Get page\n        data = await account.symbol_params_many(request)\n\n        # Add symbols to list\n        all_symbols.extend(data.symbol_infos)\n\n        print(f\"Page {page_number}: Retrieved {len(data.symbol_infos)} symbols\")\n\n        # Check if we got all symbols\n        if len(all_symbols) &gt;= data.symbols_total:\n            break\n\n        # Check if this page was empty\n        if len(data.symbol_infos) == 0:\n            break\n\n        page_number += 1\n\n    print(f\"Total symbols retrieved: {len(all_symbols)}\")\n    return all_symbols\n\n# Usage\nsymbols = await get_all_symbols(account)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#4-compare-spreads-across-symbols","title":"4) Compare spreads across symbols","text":"<pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\n# Get all symbols\nrequest = account_helper_pb2.SymbolParamsManyRequest()\ndata = await account.symbol_params_many(request)\n\n# Sort by spread (lowest first)\nsorted_symbols = sorted(data.symbol_infos, key=lambda x: x.spread)\n\nprint(\"Symbols with lowest spreads:\")\nprint(f\"{'Symbol':&lt;10} {'Spread':&lt;8} {'Bid':&lt;10} {'Ask':&lt;10}\")\nprint(\"=\" * 40)\n\nfor info in sorted_symbols[:20]:\n    print(f\"{info.name:&lt;10} {info.spread:&lt;8} {info.bid:&lt;10.5f} {info.ask:&lt;10.5f}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#5-find-tradeable-symbols-with-specific-criteria","title":"5) Find tradeable symbols with specific criteria","text":"<pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\n# Get all symbols\nrequest = account_helper_pb2.SymbolParamsManyRequest()\ndata = await account.symbol_params_many(request)\n\n# Filter by criteria\ntradeable = []\nfor info in data.symbol_infos:\n    # Check if symbol meets trading criteria\n    if (info.spread &lt; 50 and\n        info.volume_min &lt;= 0.01 and\n        info.volume_max &gt;= 1.0 and\n        info.trade_contract_size &gt; 0):\n\n        tradeable.append({\n            'name': info.name,\n            'spread': info.spread,\n            'min_volume': info.volume_min,\n            'max_volume': info.volume_max,\n            'contract_size': info.trade_contract_size\n        })\n\nprint(f\"Found {len(tradeable)} tradeable symbols:\")\nfor symbol in tradeable[:10]:\n    print(f\"{symbol['name']}: Spread={symbol['spread']}, \"\n          f\"MinVol={symbol['min_volume']}, MaxVol={symbol['max_volume']}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#6-build-symbol-comparison-table","title":"6) Build symbol comparison table","text":"<pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\n# Get specific symbols\nsymbols_to_compare = [\"EURUSD\", \"GBPUSD\", \"USDJPY\", \"XAUUSD\"]\n\nfor symbol in symbols_to_compare:\n    request = account_helper_pb2.SymbolParamsManyRequest()\n    request.symbol_name = symbol\n\n    data = await account.symbol_params_many(request)\n\n    if data.symbol_infos:\n        info = data.symbol_infos[0]\n\n        print(f\"\\n{info.name} - {info.sym_description}\")\n        print(f\"  Spread: {info.spread} points\")\n        print(f\"  Tick Value: {info.trade_tick_value}\")\n        print(f\"  Contract Size: {info.trade_contract_size}\")\n        print(f\"  Min/Max Volume: {info.volume_min} / {info.volume_max}\")\n        print(f\"  Swap Long/Short: {info.swap_long} / {info.swap_short}\")\n        print(f\"  Margin Initial: {info.margin_initial}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#7-get-symbols-with-timeout","title":"7) Get symbols with timeout","text":"<pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\nfrom datetime import datetime, timedelta\n\n# Create request\nrequest = account_helper_pb2.SymbolParamsManyRequest()\nrequest.symbol_name = \"EURUSD\"\n\n# Set deadline\ndeadline = datetime.utcnow() + timedelta(seconds=5)\n\ntry:\n    data = await account.symbol_params_many(\n        request,\n        deadline=deadline\n    )\n\n    if data.symbol_infos:\n        info = data.symbol_infos[0]\n        print(f\"{info.name}: Bid={info.bid}, Ask={info.ask}\")\n\nexcept Exception as e:\n    print(f\"Timeout or error: {e}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#8-calculate-trading-costs-from-symbol-parameters","title":"8) Calculate trading costs from symbol parameters","text":"<pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\nasync def calculate_trading_costs(account, symbol: str, volume: float):\n    \"\"\"Calculate spread cost and margin requirement\"\"\"\n\n    # Get symbol parameters\n    request = account_helper_pb2.SymbolParamsManyRequest()\n    request.symbol_name = symbol\n\n    data = await account.symbol_params_many(request)\n\n    if not data.symbol_infos:\n        print(f\"Symbol {symbol} not found\")\n        return\n\n    info = data.symbol_infos[0]\n\n    # Calculate spread cost\n    spread_points = info.spread\n    tick_value = info.trade_tick_value\n    spread_cost = spread_points * tick_value * volume\n\n    # Margin requirement\n    margin_initial = info.margin_initial\n\n    print(f\"\\n{symbol} Trading Costs (Volume: {volume}):\")\n    print(f\"  Spread: {spread_points} points\")\n    print(f\"  Spread Cost: ${spread_cost:.2f}\")\n    print(f\"  Initial Margin: ${margin_initial:.2f}\")\n    print(f\"  Tick Value: ${tick_value:.2f}\")\n    print(f\"  Contract Size: {info.trade_contract_size}\")\n    print(f\"  Currency: {info.currency_base}/{info.currency_profit}\")\n\n    return {\n        'spread_cost': spread_cost,\n        'margin': margin_initial,\n        'tick_value': tick_value\n    }\n\n# Usage\ncosts = await calculate_trading_costs(account, \"EURUSD\", 1.0)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_params_many/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>symbol_info_double - Get single double property</li> <li>symbol_info_integer - Get single integer property</li> <li>symbol_info_string - Get single string property</li> <li>symbol_info_tick - Get current tick data</li> <li>symbol_name - Get symbol name by index</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/","title":"Add or Remove Symbol from Market Watch","text":"<p>Request: add or remove symbol from Market Watch window to make it available for trading and data subscriptions.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.symbol_select(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>SymbolSelect</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>SymbolSelect(SymbolSelectRequest) -&gt; SymbolSelectReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.SymbolSelect(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Add or remove symbol from Market Watch window (makes symbol available/unavailable for trading and subscriptions).</li> <li>Why you need it. Required before trading or subscribing to symbol data - MT5 only allows operations on symbols in Market Watch.</li> <li>When to use. Before any trading operations or data subscriptions for a symbol; when cleaning up unused symbols.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to manage Market Watch:</p> <ul> <li>Add symbol to Market Watch before trading</li> <li>Enable symbol for quote subscriptions</li> <li>Remove unused symbols to reduce overhead</li> <li>Prepare trading environment programmatically</li> <li>Clean up Market Watch after trading session</li> <li>Verify symbol availability for operations</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; symbol_select - How it works</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_select(\n    self,\n    symbol: str,\n    select: bool,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; market_info_pb2.SymbolSelectData\n</code></pre> <p>Request message:</p> <pre><code>message SymbolSelectRequest {\n  string symbol = 1;\n  bool select = 2;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message SymbolSelectReply {\n  oneof response {\n    SymbolSelectData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage SymbolSelectData {\n  bool success = 1;\n}\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> (required) Symbol name (e.g., \"EURUSD\", \"BTCUSD\") <code>select</code> <code>bool</code> (required) <code>True</code> = add to Market Watch, <code>False</code> = remove <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#output","title":"\u2b06\ufe0f Output","text":"Field Type Python Type Description <code>success</code> <code>bool</code> <code>bool</code> <code>True</code> if operation succeeded, <code>False</code> if failed <p>Return value: The method returns <code>SymbolSelectData</code> object with success status.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#related-enums","title":"\ud83e\uddf1 Related enums","text":"<p>No enums used by this method.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Required before trading: Symbol MUST be in Market Watch before you can trade it or subscribe to its data.</li> <li>Idempotent operation: Adding already-selected symbol or removing already-removed symbol returns success.</li> <li>Non-existent symbols: Selecting non-existent symbol returns <code>success=False</code>.</li> <li>Market Watch management: Use this to programmatically manage which symbols are visible in MT5.</li> <li>Performance: Removing unused symbols from Market Watch can improve performance and reduce network traffic.</li> <li>Symbol groups: Some brokers organize symbols into groups - ensure symbol name is exact including suffixes.</li> <li>Case sensitive: Symbol names are case-sensitive (usually uppercase).</li> <li>Success indicator: Always check <code>data.success</code> to verify the operation completed successfully.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#1-add-symbol-to-market-watch-recommended","title":"1) Add symbol to Market Watch (RECOMMENDED)","text":"<pre><code>from MetaRpcMT5.mt5_account import MT5Account\n\nasync def add_to_market_watch(account: MT5Account, symbol: str):\n    \"\"\"Add symbol to Market Watch before trading\"\"\"\n\n    # Add symbol\n    data = await account.symbol_select(symbol=symbol, select=True)\n\n    if data.success:\n        print(f\"{symbol} added to Market Watch\")\n        return True\n    else:\n        print(f\"Failed to add {symbol} to Market Watch\")\n        return False\n\n# Usage\nsuccess = await add_to_market_watch(account, \"EURUSD\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#2-remove-symbol-from-market-watch","title":"2) Remove symbol from Market Watch","text":"<pre><code>async def remove_from_market_watch(account: MT5Account, symbol: str):\n    \"\"\"Remove symbol from Market Watch to clean up\"\"\"\n\n    # Remove symbol\n    data = await account.symbol_select(symbol=symbol, select=False)\n\n    if data.success:\n        print(f\"{symbol} removed from Market Watch\")\n        return True\n    else:\n        print(f\"Failed to remove {symbol}\")\n        return False\n\n# Usage\nawait remove_from_market_watch(account, \"GBPJPY\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#3-add-multiple-symbols-with-error-handling","title":"3) Add multiple symbols with error handling","text":"<pre><code>async def add_symbols_batch(account: MT5Account, symbols: list[str]):\n    \"\"\"Add multiple symbols to Market Watch\"\"\"\n\n    results = {'added': [], 'failed': []}\n\n    for symbol in symbols:\n        data = await account.symbol_select(symbol=symbol, select=True)\n\n        if data.success:\n            results['added'].append(symbol)\n            print(f\"{symbol}\")\n        else:\n            results['failed'].append(symbol)\n            print(f\"{symbol}\")\n\n    print(f\"\\nAdded: {len(results['added'])}, Failed: {len(results['failed'])}\")\n    return results\n\n# Usage\nsymbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\", \"XAUUSD\", \"BTCUSD\"]\nresults = await add_symbols_batch(account, symbols)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#4-setup-trading-environment","title":"4) Setup trading environment","text":"<pre><code>async def setup_trading_symbols(account: MT5Account):\n    \"\"\"Setup symbols before trading session\"\"\"\n\n    # Define required symbols\n    required_symbols = [\n        \"EURUSD\", \"GBPUSD\", \"USDJPY\",\n        \"AUDUSD\", \"USDCAD\", \"NZDUSD\"\n    ]\n\n    print(\"Setting up trading environment...\")\n\n    for symbol in required_symbols:\n        data = await account.symbol_select(symbol=symbol, select=True)\n\n        if data.success:\n            print(f\"  {symbol} ready\")\n        else:\n            print(f\"  {symbol} FAILED - check symbol name\")\n            return False\n\n    print(\"All symbols ready for trading!\")\n    return True\n\n# Usage\nif await setup_trading_symbols(account):\n    print(\"Starting trading strategy...\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#5-cleanup-unused-symbols","title":"5) Cleanup unused symbols","text":"<pre><code>async def cleanup_market_watch(account: MT5Account, keep_symbols: list[str]):\n    \"\"\"Remove all symbols except specified ones\"\"\"\n\n    # Get all symbols currently in Market Watch\n    import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_info_pb2\n\n    # Get total symbols\n    total_data = await account.symbols_total(selected_only=True)\n    total = total_data.total\n\n    removed = []\n    for i in range(total):\n        # Get symbol name by index\n        name_data = await account.symbol_name(index=i, selected=True)\n        symbol = name_data.name\n\n        # Remove if not in keep list\n        if symbol not in keep_symbols:\n            data = await account.symbol_select(symbol=symbol, select=False)\n            if data.success:\n                removed.append(symbol)\n                print(f\"Removed: {symbol}\")\n\n    print(f\"\\nRemoved {len(removed)} symbols from Market Watch\")\n    return removed\n\n# Usage\nkeep = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\nawait cleanup_market_watch(account, keep)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#6-verify-symbol-selection-with-timeout","title":"6) Verify symbol selection with timeout","text":"<pre><code>from datetime import datetime, timedelta\n\nasync def select_symbol_with_timeout(\n    account: MT5Account,\n    symbol: str,\n    select: bool,\n    timeout_seconds: int = 5\n):\n    \"\"\"Select symbol with timeout\"\"\"\n\n    # Calculate deadline\n    deadline = datetime.utcnow() + timedelta(seconds=timeout_seconds)\n\n    try:\n        data = await account.symbol_select(\n            symbol=symbol,\n            select=select,\n            deadline=deadline\n        )\n\n        action = \"added to\" if select else \"removed from\"\n        if data.success:\n            print(f\"{symbol} {action} Market Watch\")\n        else:\n            print(f\"Failed to {action.split()[0]} {symbol}\")\n\n        return data.success\n\n    except Exception as e:\n        print(f\"Timeout or error selecting {symbol}: {e}\")\n        return False\n\n# Usage\nsuccess = await select_symbol_with_timeout(account, \"EURUSD\", True, timeout_seconds=3)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#7-prepare-symbols-for-strategy","title":"7) Prepare symbols for strategy","text":"<pre><code>async def prepare_symbols_for_strategy(\n    account: MT5Account,\n    strategy_symbols: dict[str, bool]\n):\n    \"\"\"\n    Prepare Market Watch for trading strategy\n\n    Args:\n        strategy_symbols: Dict of {symbol: should_select}\n    \"\"\"\n\n    print(\"Configuring Market Watch for strategy...\")\n\n    success_count = 0\n    fail_count = 0\n\n    for symbol, should_select in strategy_symbols.items():\n        action = \"Adding\" if should_select else \"Removing\"\n\n        data = await account.symbol_select(\n            symbol=symbol,\n            select=should_select\n        )\n\n        if data.success:\n            status = \"success_count += 1\n        else:\n            status = \"fail_count += 1\n\n        action_word = \"to\" if should_select else \"from\"\n        print(f\"{status} {action} {symbol} {action_word} Market Watch\")\n\n    print(f\"\\nResults: {success_count} succeeded, {fail_count} failed\")\n\n    if fail_count &gt; 0:\n        print(\"WARNING: Some symbols failed - check symbol names\")\n        return False\n\n    return True\n\n# Usage\nstrategy_config = {\n    \"EURUSD\": True,   # Add\n    \"GBPUSD\": True,   # Add\n    \"USDJPY\": True,   # Add\n    \"XAUUSD\": False,  # Remove\n    \"BTCUSD\": False   # Remove\n}\n\nif await prepare_symbols_for_strategy(account, strategy_config):\n    print(\"Market Watch configured successfully!\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbol_select/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>symbol_exist - Check if symbol exists on server</li> <li>symbol_name - Get symbol name by index</li> <li>symbols_total - Get total number of symbols</li> <li>symbol_info_tick - Get symbol tick data (requires symbol to be selected first)</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/","title":"Get Total Number of Symbols","text":"<p>Request: total count of available symbols on the trading platform.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.symbols_total(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>SymbolsTotal</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>SymbolsTotal(SymbolsTotalRequest) -&gt; SymbolsTotalReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.SymbolsTotal(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Get the total count of symbols available on the platform.</li> <li>Why you need it. Check how many symbols are available, either all symbols or only Market Watch symbols.</li> <li>When to use. Use for quick symbol count. For symbol iteration, prefer <code>symbol_params_many()</code> (single call) over multiple <code>symbol_name()</code> calls.</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to get symbol count:</p> <ul> <li>Check total number of symbols on platform</li> <li>Count symbols in Market Watch</li> <li>Validate symbol availability</li> <li>Quick check before iterating symbols</li> <li>Monitor symbol list changes</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; symbols_total - How it works</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#method-signature","title":"Method Signature","text":"<pre><code>async def symbols_total(\n    self,\n    selected_only: bool,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; market_info_pb2.SymbolsTotalData\n</code></pre> <p>Request message:</p> <pre><code>message SymbolsTotalRequest {\n  bool mode = 1;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message SymbolsTotalReply {\n  oneof response {\n    SymbolsTotalData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage SymbolsTotalData {\n  int32 total = 1;\n}\n</code></pre> <p>Parameter mapping: - Python parameter <code>selected_only</code> maps to protobuf field <code>mode</code></p>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>selected_only</code> <code>bool</code> (required) True = count only Market Watch symbols, False = count all <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation <p>Usage:</p> <pre><code>from datetime import datetime, timedelta\n\n# Count all symbols\ndata = await account.symbols_total(selected_only=False)\n\n# Count only Market Watch symbols\ndata = await account.symbols_total(selected_only=True)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#output-symbolstotaldata","title":"\u2b06\ufe0f Output - <code>SymbolsTotalData</code>","text":"Field Type Python Type Description <code>total</code> <code>int32</code> <code>int</code> Total number of symbols <p>Return value: The method returns <code>SymbolsTotalData</code> object with <code>total</code> field.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":"<p>No enums used by this method.</p>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: Built-in protection against transient gRPC errors.</li> <li>Market Watch vs All: <code>selected_only=True</code> counts only symbols visible in Market Watch; <code>False</code> counts all available symbols.</li> <li>Connection required: Call <code>connect_by_host_port()</code> or <code>connect_by_server_name()</code> first.</li> <li>Thread safety: Safe to call concurrently from multiple asyncio tasks.</li> <li>Performance: This is a lightweight call - use it freely for validation before operations.</li> <li>Return type: The method returns <code>SymbolsTotalData</code> protobuf object (Python type matches field types).</li> </ul>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#1-get-total-symbols-count","title":"1) Get total symbols count","text":"<pre><code>import asyncio\nfrom datetime import datetime, timedelta\nfrom MetaRpcMT5.mt5_account import MT5Account\n\nasync def main():\n    account = MT5Account(\n        account_number=12345678,\n        password=\"your_password\",\n        host=\"your-server.com:443\"\n    )\n\n    await account.connect_by_host_port()\n\n    try:\n        # Count all symbols\n        data_all = await account.symbols_total(selected_only=False)\n        print(f\"Total symbols available: {data_all.total}\")\n\n        # Count Market Watch symbols\n        data_mw = await account.symbols_total(selected_only=True)\n        print(f\"Market Watch symbols: {data_mw.total}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#2-compare-market-watch-vs-all-symbols","title":"2) Compare Market Watch vs all symbols","text":"<pre><code>async def compare_symbol_counts(account: MT5Account):\n    \"\"\"Compare Market Watch vs all available symbols\"\"\"\n    # Get counts\n    all_symbols = await account.symbols_total(selected_only=False)\n    mw_symbols = await account.symbols_total(selected_only=True)\n\n    print(f\"\\nSymbol Statistics:\")\n    print(f\"  All available: {all_symbols.total}\")\n    print(f\"  Market Watch: {mw_symbols.total}\")\n    print(f\"  Not in Market Watch: {all_symbols.total - mw_symbols.total}\")\n\n    return {\n        \"all\": all_symbols.total,\n        \"market_watch\": mw_symbols.total,\n        \"hidden\": all_symbols.total - mw_symbols.total\n    }\n\n# Usage:\nstats = await compare_symbol_counts(account)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#3-check-if-symbols-available","title":"3) Check if symbols available","text":"<pre><code>async def has_symbols(account: MT5Account) -&gt; bool:\n    \"\"\"Check if any symbols are available\"\"\"\n    data = await account.symbols_total(selected_only=False)\n\n    if data.total &gt; 0:\n        print(f\"[OK] {data.total} symbols available\")\n        return True\n    else:\n        print(\"[WARNING] No symbols available\")\n        return False\n\n# Usage:\nif await has_symbols(account):\n    print(\"Ready to trade\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#4-monitor-symbol-count-changes","title":"4) Monitor symbol count changes","text":"<pre><code>async def monitor_symbol_count(account: MT5Account, interval: float = 60.0):\n    \"\"\"Monitor for changes in symbol count\"\"\"\n    previous_count = None\n\n    while True:\n        try:\n            data = await account.symbols_total(selected_only=True)\n            count = data.total\n\n            if previous_count is not None and count != previous_count:\n                if count &gt; previous_count:\n                    print(f\"[+] Symbol added to Market Watch: {count} total\")\n                else:\n                    print(f\"[-] Symbol removed from Market Watch: {count} total\")\n            else:\n                print(f\"[{datetime.now().strftime('%H:%M:%S')}] Market Watch: {count} symbols\")\n\n            previous_count = count\n\n        except Exception as e:\n            print(f\"[ERROR] {e}\")\n\n        await asyncio.sleep(interval)\n\n# Usage:\n# await monitor_symbol_count(account, interval=60.0)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#5-validate-before-iteration","title":"5) Validate before iteration","text":"<pre><code>async def iterate_symbols_safe(account: MT5Account):\n    \"\"\"Safely iterate through symbols with validation\"\"\"\n    # Check count first\n    data = await account.symbols_total(selected_only=True)\n\n    if data.total == 0:\n        print(\"[WARNING] No symbols in Market Watch\")\n        return []\n\n    print(f\"[OK] Found {data.total} symbols\")\n\n    # Now safe to iterate\n    symbols = []\n    for i in range(data.total):\n        symbol_name = await account.symbol_name(index=i, selected=True)\n        symbols.append(symbol_name.name)\n\n    return symbols\n\n# Usage:\nsymbols = await iterate_symbols_safe(account)\nprint(f\"Symbols: {symbols}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#6-calculate-market-watch-usage","title":"6) Calculate Market Watch usage","text":"<pre><code>async def calculate_mw_usage(account: MT5Account) -&gt; dict:\n    \"\"\"Calculate Market Watch usage statistics\"\"\"\n    all_data = await account.symbols_total(selected_only=False)\n    mw_data = await account.symbols_total(selected_only=True)\n\n    total = all_data.total\n    used = mw_data.total\n    usage_pct = (used / total * 100) if total &gt; 0 else 0\n\n    result = {\n        \"total_available\": total,\n        \"in_market_watch\": used,\n        \"usage_percent\": usage_pct\n    }\n\n    print(f\"\\nMarket Watch Usage:\")\n    print(f\"  Using {used} of {total} symbols ({usage_pct:.1f}%)\")\n\n    return result\n\n# Usage:\nusage = await calculate_mw_usage(account)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#7-wait-for-symbols-to-load","title":"7) Wait for symbols to load","text":"<pre><code>async def wait_for_symbols(\n    account: MT5Account,\n    min_symbols: int = 1,\n    timeout_seconds: int = 30,\n    check_interval: float = 1.0\n):\n    \"\"\"Wait until minimum number of symbols available\"\"\"\n    import time\n    start_time = time.time()\n\n    print(f\"Waiting for at least {min_symbols} symbol(s)...\")\n\n    while True:\n        # Check timeout\n        elapsed = time.time() - start_time\n        if elapsed &gt; timeout_seconds:\n            raise TimeoutError(f\"Timeout: symbols not loaded after {timeout_seconds}s\")\n\n        # Check symbol count\n        data = await account.symbols_total(selected_only=False)\n        count = data.total\n\n        if count &gt;= min_symbols:\n            print(f\"[OK] {count} symbols loaded\")\n            return count\n\n        print(f\"[INFO] Waiting... ({count} symbols)\")\n        await asyncio.sleep(check_interval)\n\n# Usage:\ntry:\n    count = await wait_for_symbols(account, min_symbols=10)\nexcept TimeoutError as e:\n    print(f\"[ERROR] {e}\")\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#8-log-symbol-statistics","title":"8) Log symbol statistics","text":"<pre><code>import logging\n\nasync def log_symbol_statistics(account: MT5Account):\n    \"\"\"Log comprehensive symbol statistics\"\"\"\n    logging.basicConfig(level=logging.INFO)\n\n    all_data = await account.symbols_total(selected_only=False)\n    mw_data = await account.symbols_total(selected_only=True)\n\n    logging.info(\"=\" * 60)\n    logging.info(\"SYMBOL STATISTICS\")\n    logging.info(\"=\" * 60)\n    logging.info(f\"Total symbols available: {all_data.total}\")\n    logging.info(f\"Market Watch symbols: {mw_data.total}\")\n    logging.info(f\"Hidden symbols: {all_data.total - mw_data.total}\")\n    logging.info(\"=\" * 60)\n\n# Usage:\nawait log_symbol_statistics(account)\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#common-patterns","title":"Common Patterns","text":""},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#quick-count-check","title":"Quick count check","text":"<pre><code>async def get_mw_symbol_count(account: MT5Account) -&gt; int:\n    \"\"\"Get Market Watch symbol count\"\"\"\n    data = await account.symbols_total(selected_only=True)\n    return data.total\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#validate-symbols-loaded","title":"Validate symbols loaded","text":"<pre><code>async def symbols_loaded(account: MT5Account) -&gt; bool:\n    \"\"\"Check if symbols are loaded\"\"\"\n    data = await account.symbols_total(selected_only=False)\n    return data.total &gt; 0\n</code></pre>"},{"location":"MT5Account/2.%20Symbol_Information/symbols_total/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>symbol_params_many - Get comprehensive parameters for all symbols (RECOMMENDED for iteration)</li> <li>symbol_name - Get symbol name by index</li> <li>symbol_exist - Check if specific symbol exists</li> <li>symbol_select - Add/remove symbol from Market Watch</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/Positions_Orders.Overview/","title":"MT5Account - Positions &amp; Orders - Overview","text":"<p>Manage open positions, pending orders, and historical trading data. Query tick values and analyze trading performance.</p>"},{"location":"MT5Account/3.%20Positions_Orders/Positions_Orders.Overview/#what-lives-here","title":"\ud83d\udcc1 What lives here","text":"<ul> <li>positions_total - count only of open positions (lightweight check).</li> <li>opened_orders - full details of all pending orders and open positions.</li> <li>opened_orders_tickets - ticket IDs only of opened orders/positions (lighter than full details).</li> <li>order_history - historical orders and deals within time range with pagination.</li> <li>positions_history - historical closed positions filtered by open time.</li> <li>tick_value_with_size - tick values and contract sizes for multiple symbols (for P/L calculation).</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/Positions_Orders.Overview/#step-by-step-tutorials","title":"\ud83d\udcda Step-by-step tutorials","text":"<p>Want detailed explanations with line-by-line code breakdown? Check these guides:</p> <ul> <li>positions_total - How it works</li> <li>opened_orders - How it works</li> <li>opened_orders_tickets - How it works</li> <li>order_history - How it works</li> <li>positions_history - How it works</li> <li>tick_value_with_size - How it works</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/Positions_Orders.Overview/#plain-english","title":"\ud83e\udded Plain English","text":"<ul> <li>positions_total - quick count of how many positions are open (no details).</li> <li>opened_orders - get complete snapshot of all pending orders and open positions.</li> <li>opened_orders_tickets - get just ticket IDs (more efficient than full details).</li> <li>order_history - get past orders/deals within a date range.</li> <li>positions_history - get closed positions with profit/loss data.</li> <li>tick_value_with_size - get tick values for calculating profit per pip.</li> </ul> <p>Rule of thumb: need count only - <code>positions_total()</code>; need ticket IDs - <code>opened_orders_tickets()</code>; need full details - <code>opened_orders()</code>; need history - <code>order_history()</code> or <code>positions_history()</code>.</p>"},{"location":"MT5Account/3.%20Positions_Orders/Positions_Orders.Overview/#quick-choose","title":"Quick choose","text":"If you need Use Returns Key inputs Count of open positions <code>positions_total</code> PositionsTotalData (count) (none) Full details of open orders/positions <code>opened_orders</code> OpenedOrdersData (lists) Sort mode (optional) Just ticket IDs of opened items <code>opened_orders_tickets</code> Lists of ticket IDs (none) Historical orders within time range <code>order_history</code> OrdersHistoryData from_dt, to_dt, sort mode, page Historical closed positions <code>positions_history</code> PositionsHistoryData sort_type, open time range, page Tick values and contract sizes <code>tick_value_with_size</code> TickValueWithSizeData List of symbol names"},{"location":"MT5Account/3.%20Positions_Orders/Positions_Orders.Overview/#i-cross-refs-gotchas","title":"\u2139\ufe0f Cross-refs &amp; gotchas","text":"<ul> <li>positions_total - fastest way to check if any positions exist (just count, no details).</li> <li>opened_orders vs opened_orders_tickets - use tickets version for lighter payload when you only need IDs.</li> <li>order_history vs positions_history - order_history gets orders/deals; positions_history gets closed positions.</li> <li>Pagination - order_history and positions_history support pagination for large datasets (use page and size parameters).</li> <li>Time filters - order_history uses close time; positions_history uses open time.</li> <li>Tick value - needed for calculating P/L per pip/tick; multiply by pip movement and lot size.</li> <li>Contract size - usually 100,000 for major forex pairs, 100 for metals (varies by symbol).</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/Positions_Orders.Overview/#minimal-snippets","title":"\ud83d\udfe2 Minimal snippets","text":"<pre><code>from MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\nfrom datetime import datetime, timedelta\nimport asyncio\n\n# Get count of open positions\ndata = await account.positions_total()\nprint(f\"Open positions: {data.total_positions}\")\n</code></pre> <pre><code># Get all open orders and positions\ndata = await account.opened_orders()\n\nprint(f\"Pending orders: {len(data.opened_orders)}\")\nprint(f\"Open positions: {len(data.position_infos)}\")\n\n# Show positions\nfor pos in data.position_infos:\n    print(f\"Position #{pos.ticket} {pos.symbol}: ${pos.profit:+.2f}\")\n</code></pre> <pre><code># Get just ticket IDs (lightweight)\ndata = await account.opened_orders_tickets()\n\nprint(f\"Order tickets: {data.opened_orders_tickets}\")\nprint(f\"Position tickets: {data.opened_position_tickets}\")\n</code></pre> <pre><code># Get last 7 days order history\nto_dt = datetime.utcnow()\nfrom_dt = to_dt - timedelta(days=7)\n\ndata = await account.order_history(\n    from_dt=from_dt,\n    to_dt=to_dt,\n    sort_mode=account_helper_pb2.BMT5_SORT_BY_CLOSE_TIME_DESC,\n    items_per_page=100\n)\n\nprint(f\"Total orders: {data.arrayTotal}\")\nfor item in data.history_data:\n    if item.history_deal:\n        print(f\"Deal: ${item.history_deal.profit:.2f}\")\n</code></pre> <pre><code># Get closed positions from last 30 days\nto_dt = datetime.utcnow()\nfrom_dt = to_dt - timedelta(days=30)\n\ndata = await account.positions_history(\n    sort_type=account_helper_pb2.AH_POSITION_OPEN_TIME_DESC,\n    open_from=from_dt,\n    open_to=to_dt\n)\n\ntotal_profit = sum(pos.profit for pos in data.history_positions)\nprint(f\"Closed positions: {len(data.history_positions)}\")\nprint(f\"Total profit: ${total_profit:+.2f}\")\n</code></pre> <pre><code># Get tick values for symbols\nsymbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\ndata = await account.tick_value_with_size(symbols=symbols)\n\nfor info in data.symbol_tick_size_infos:\n    print(f\"{info.Name}: Tick Value=${info.TradeTickValue:.2f}, \"\n          f\"Contract Size={info.TradeContractSize:.0f}\")\n</code></pre> <pre><code># Check if can open new position (position limit)\ndata = await account.positions_total()\n\nmax_positions = 10\nif data.total_positions &gt;= max_positions:\n    print(\"[WARNING] Position limit reached!\")\nelse:\n    print(f\"[OK] Can open {max_positions - data.total_positions} more position(s)\")\n</code></pre> <pre><code># Calculate total floating P/L\ndata = await account.opened_orders()\n\ntotal_profit = sum(pos.profit for pos in data.position_infos)\nprint(f\"Total floating P/L: ${total_profit:+.2f}\")\n\nif total_profit &lt; 0:\n    print(\"[WARNING] Account in drawdown\")\n</code></pre> <pre><code># Monitor for new positions\nasync def monitor_positions(interval: float = 5.0):\n    \"\"\"Monitor for position changes\"\"\"\n    previous_tickets = set()\n\n    while True:\n        data = await account.opened_orders_tickets()\n        current_tickets = set(data.opened_position_tickets)\n\n        new = current_tickets - previous_tickets\n        closed = previous_tickets - current_tickets\n\n        for ticket in new:\n            print(f\"[+] New position: #{ticket}\")\n        for ticket in closed:\n            print(f\"[-] Closed position: #{ticket}\")\n\n        previous_tickets = current_tickets\n        await asyncio.sleep(interval)\n\n# await monitor_positions()\n</code></pre> <pre><code># Analyze trading performance\nasync def analyze_performance(days: int = 30):\n    \"\"\"Analyze trading performance for last N days\"\"\"\n    to_dt = datetime.utcnow()\n    from_dt = to_dt - timedelta(days=days)\n\n    data = await account.positions_history(\n        sort_type=account_helper_pb2.AH_POSITION_OPEN_TIME_ASC,\n        open_from=from_dt,\n        open_to=to_dt\n    )\n\n    wins = sum(1 for pos in data.history_positions if pos.profit &gt; 0)\n    losses = sum(1 for pos in data.history_positions if pos.profit &lt; 0)\n    total = wins + losses\n\n    win_rate = (wins / total * 100) if total &gt; 0 else 0\n    total_profit = sum(pos.profit for pos in data.history_positions)\n\n    print(f\"\\nPerformance (last {days} days):\")\n    print(f\"  Total trades: {total}\")\n    print(f\"  Wins: {wins} ({win_rate:.1f}%)\")\n    print(f\"  Losses: {losses}\")\n    print(f\"  Net profit: ${total_profit:+.2f}\")\n\n# await analyze_performance(days=30)\n</code></pre> <pre><code># Calculate profit per pip for position sizing\nasync def calculate_position_size(\n    symbol: str,\n    risk_amount: float,\n    sl_pips: float\n) -&gt; float:\n    \"\"\"Calculate position size based on risk\"\"\"\n    # Get tick value\n    data = await account.tick_value_with_size(symbols=[symbol])\n    if not data.symbol_tick_size_infos:\n        raise ValueError(f\"Symbol {symbol} not found\")\n\n    info = data.symbol_tick_size_infos[0]\n\n    # Assuming 1 lot\n    profit_per_pip = info.TradeTickValue * 10  # 10 ticks per pip\n\n    # Calculate lot size\n    lots = risk_amount / (sl_pips * profit_per_pip)\n\n    print(f\"Position sizing for {symbol}:\")\n    print(f\"  Risk: ${risk_amount:.2f}\")\n    print(f\"  SL: {sl_pips} pips\")\n    print(f\"  Lot size: {lots:.2f}\")\n\n    return lots\n\n# Usage:\n# lot_size = await calculate_position_size(\"EURUSD\", risk_amount=100, sl_pips=50)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/Positions_Orders.Overview/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>Account Information: Account_Information.Overview - get account balance, equity, leverage</li> <li>Symbol Information: Symbol_Information.Overview - get symbol prices and parameters</li> <li>Trading Operations: Trading_Operations.Overview - place and manage trades</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/","title":"Get Currently Opened Orders and Positions","text":"<p>Request: complete snapshot of all currently opened orders and positions with full details.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.opened_orders(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.AccountHelper</code></li> <li>Proto definition: <code>OpenedOrders</code> (defined in <code>mt5-term-api-account-helper.proto</code>)</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.AccountHelper</code></li> <li>Method: <code>OpenedOrders(OpenedOrdersRequest) -&gt; OpenedOrdersReply</code></li> <li>Low-level client (generated): <code>AccountHelperStub.OpenedOrders(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Get comprehensive details of all pending orders and open positions.</li> <li>Why you need it. Complete overview of current trading state with full order/position details.</li> <li>When to use. Use this for full details. Use <code>positions_total()</code> for just counts, <code>opened_orders_tickets()</code> for ticket IDs only.</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to get detailed information about current orders and positions:</p> <ul> <li>Get all pending orders (Buy Limit, Sell Stop, etc.)</li> <li>Get all open positions (Buy/Sell with P/L)</li> <li>Monitor current trading state</li> <li>Implement position management logic</li> <li>Display current orders/positions in UI</li> <li>Calculate total exposure</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; opened_orders - How it works</p>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#method-signature","title":"Method Signature","text":"<pre><code>async def opened_orders(\n    self,\n    sort_mode: account_helper_pb2.BMT5_ENUM_OPENED_ORDER_SORT_TYPE = account_helper_pb2.BMT5_OPENED_ORDER_SORT_BY_OPEN_TIME_ASC,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; account_helper_pb2.OpenedOrdersData\n</code></pre> <p>Request message:</p> <pre><code>message OpenedOrdersRequest {\n  BMT5_ENUM_OPENED_ORDER_SORT_TYPE inputSortMode = 1;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message OpenedOrdersReply {\n  oneof response {\n    OpenedOrdersData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage OpenedOrdersData {\n  repeated OpenedOrderInfo opened_orders = 1;\n  repeated PositionInfo position_infos = 2;\n}\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>sort_mode</code> <code>BMT5_ENUM_OPENED_ORDER_SORT_TYPE</code> (enum) Sort mode for orders (by time or ticket ID) <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation <p>Deadline options:</p> <pre><code>from datetime import datetime, timedelta\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\n# With sort mode and deadline\ndeadline = datetime.utcnow() + timedelta(seconds=5)\ndata = await account.opened_orders(\n    sort_mode=account_helper_pb2.BMT5_OPENED_ORDER_SORT_BY_OPEN_TIME_ASC,\n    deadline=deadline\n)\n\n# Default sort (by open time ascending)\ndata = await account.opened_orders()\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#output-openedordersdata","title":"\u2b06\ufe0f Output - <code>OpenedOrdersData</code>","text":"Field Type Python Type Description <code>opened_orders</code> <code>repeated OpenedOrderInfo</code> <code>list[OpenedOrderInfo]</code> List of pending orders <code>position_infos</code> <code>repeated PositionInfo</code> <code>list[PositionInfo]</code> List of open positions <p>Return value: The method returns <code>OpenedOrdersData</code> object with both lists accessible as attributes.</p>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":"<p>Note: In Python code, you can use the enum from account_helper_pb2 module. This method uses 7 enums with 40 total constants.</p>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#bmt5_enum_opened_order_sort_type","title":"<code>BMT5_ENUM_OPENED_ORDER_SORT_TYPE</code>","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>.</p> Constant Value Description <code>BMT5_OPENED_ORDER_SORT_BY_OPEN_TIME_ASC</code> 0 Sort by open time (oldest first) <code>BMT5_OPENED_ORDER_SORT_BY_OPEN_TIME_DESC</code> 1 Sort by open time (newest first) <code>BMT5_OPENED_ORDER_SORT_BY_ORDER_TICKET_ID_ASC</code> 2 Sort by ticket ID (ascending) <code>BMT5_OPENED_ORDER_SORT_BY_ORDER_TICKET_ID_DESC</code> 3 Sort by ticket ID (descending) <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\ndata = await account.opened_orders(\n    sort_mode=pb2.BMT5_OPENED_ORDER_SORT_BY_OPEN_TIME_ASC\n)\n</code></pre></p>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#bmt5_enum_order_type-for-field-openedorderinfotype","title":"<code>BMT5_ENUM_ORDER_TYPE</code> (for field <code>OpenedOrderInfo.type</code>)","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>.</p> Constant Value Description <code>BMT5_ORDER_TYPE_BUY</code> 0 Market Buy order (long position) <code>BMT5_ORDER_TYPE_SELL</code> 1 Market Sell order (short position) <code>BMT5_ORDER_TYPE_BUY_LIMIT</code> 2 Buy Limit pending order <code>BMT5_ORDER_TYPE_SELL_LIMIT</code> 3 Sell Limit pending order <code>BMT5_ORDER_TYPE_BUY_STOP</code> 4 Buy Stop pending order <code>BMT5_ORDER_TYPE_SELL_STOP</code> 5 Sell Stop pending order <code>BMT5_ORDER_TYPE_BUY_STOP_LIMIT</code> 6 Buy Stop Limit order <code>BMT5_ORDER_TYPE_SELL_STOP_LIMIT</code> 7 Sell Stop Limit order <code>BMT5_ORDER_TYPE_CLOSE_BY</code> 8 Order to close by opposite position <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\n# Check order type\nfor order in data.opened_orders:\n    if order.type == pb2.BMT5_ORDER_TYPE_BUY_LIMIT:\n        print(f\"Buy Limit order: {order.ticket}\")\n</code></pre></p>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#bmt5_enum_order_state-for-field-openedorderinfostate","title":"<code>BMT5_ENUM_ORDER_STATE</code> (for field <code>OpenedOrderInfo.state</code>)","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>.</p> Constant Value Description <code>BMT5_ORDER_STATE_STARTED</code> 0 Order checked, but not yet accepted by broker <code>BMT5_ORDER_STATE_PLACED</code> 1 Order accepted <code>BMT5_ORDER_STATE_CANCELED</code> 2 Order canceled by client <code>BMT5_ORDER_STATE_PARTIAL</code> 3 Order partially executed <code>BMT5_ORDER_STATE_FILLED</code> 4 Order fully executed <code>BMT5_ORDER_STATE_REJECTED</code> 5 Order rejected <code>BMT5_ORDER_STATE_EXPIRED</code> 6 Order expired <code>BMT5_ORDER_STATE_REQUEST_ADD</code> 7 Order is being registered (placing to trading system) <code>BMT5_ORDER_STATE_REQUEST_MODIFY</code> 8 Order is being modified (changing parameters) <code>BMT5_ORDER_STATE_REQUEST_CANCEL</code> 9 Order is being deleted (deleting from trading system) <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\n# Check order state\nfor order in data.opened_orders:\n    if order.state == pb2.BMT5_ORDER_STATE_PLACED:\n        print(f\"Order {order.ticket} is active\")\n</code></pre></p>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#bmt5_enum_order_type_filling-for-field-openedorderinfotype_filling","title":"<code>BMT5_ENUM_ORDER_TYPE_FILLING</code> (for field <code>OpenedOrderInfo.type_filling</code>)","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>.</p> Constant Value Description <code>BMT5_ORDER_FILLING_FOK</code> 0 Fill or Kill - fill completely or cancel <code>BMT5_ORDER_FILLING_IOC</code> 1 Immediate or Cancel - fill available volume <code>BMT5_ORDER_FILLING_RETURN</code> 2 Return execution mode <code>BMT5_ORDER_FILLING_BOC</code> 3 Book or Cancel - place order in book <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\n# Check filling type\nfor order in data.opened_orders:\n    if order.type_filling == pb2.BMT5_ORDER_FILLING_FOK:\n        print(f\"Order {order.ticket} uses Fill-or-Kill\")\n</code></pre></p>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#bmt5_enum_order_type_time-for-field-openedorderinfotype_time","title":"<code>BMT5_ENUM_ORDER_TYPE_TIME</code> (for field <code>OpenedOrderInfo.type_time</code>)","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>.</p> Constant Value Description <code>BMT5_ORDER_TIME_GTC</code> 0 Good Till Cancelled <code>BMT5_ORDER_TIME_DAY</code> 1 Good Till Day (until end of day) <code>BMT5_ORDER_TIME_SPECIFIED</code> 2 Good Till Specified time <code>BMT5_ORDER_TIME_SPECIFIED_DAY</code> 3 Good Till Specified day (until end of specified day) <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\n# Check time type\nfor order in data.opened_orders:\n    if order.type_time == pb2.BMT5_ORDER_TIME_GTC:\n        print(f\"Order {order.ticket} is GTC\")\n</code></pre></p>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#bmt5_enum_position_type-for-field-positioninfotype","title":"<code>BMT5_ENUM_POSITION_TYPE</code> (for field <code>PositionInfo.type</code>)","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>.</p> Constant Value Description <code>BMT5_POSITION_TYPE_BUY</code> 0 Buy position (long) <code>BMT5_POSITION_TYPE_SELL</code> 1 Sell position (short) <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\n# Check position type\nfor pos in data.position_infos:\n    if pos.type == pb2.BMT5_POSITION_TYPE_BUY:\n        print(f\"Long position: {pos.ticket}\")\n</code></pre></p>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#bmt5_enum_position_reason-for-field-positioninforeason","title":"<code>BMT5_ENUM_POSITION_REASON</code> (for field <code>PositionInfo.reason</code>)","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>.</p> Constant Value Description <code>BMT5_POSITION_REASON_CLIENT</code> 0 Position opened manually by client <code>BMT5_POSITION_REASON_MOBILE</code> 1 Position opened via mobile application <code>BMT5_POSITION_REASON_WEB</code> 2 Position opened via web platform <code>BMT5_POSITION_REASON_EXPERT</code> 3 Position opened by Expert Advisor <code>ORDER_REASON_SL</code> 4 Position closed by Stop Loss <code>ORDER_REASON_TP</code> 5 Position closed by Take Profit <code>ORDER_REASON_SO</code> 6 Position closed by Stop Out <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\n# Check position reason\nfor pos in data.position_infos:\n    if pos.reason == pb2.BMT5_POSITION_REASON_EXPERT:\n        print(f\"Position {pos.ticket} opened by EA\")\n</code></pre></p>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>Two separate lists: Orders and positions are returned in separate lists - check both.</li> <li>Connection required: You must call <code>connect_by_host_port()</code> or <code>connect_by_server_name()</code> before using this method.</li> <li>Full details: This method returns complete order/position information - use <code>opened_orders_tickets()</code> for lighter payload.</li> <li>Thread safety: All async methods are safe to call concurrently from multiple asyncio tasks.</li> <li>UUID handling: The terminal instance UUID is auto-generated by the server if not provided. For explicit control (e.g., in streaming scenarios), pass <code>id_=uuid4()</code> to constructor.</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#1-get-all-opened-orders-and-positions","title":"1) Get all opened orders and positions","text":"<pre><code>import asyncio\nfrom datetime import datetime, timedelta\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\nasync def main():\n    account = MT5Account(\n        user=12345678,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        deadline = datetime.utcnow() + timedelta(seconds=5)\n\n        data = await account.opened_orders(\n            sort_mode=account_helper_pb2.BMT5_OPENED_ORDER_SORT_BY_OPEN_TIME_ASC,\n            deadline=deadline\n        )\n\n        print(f\"Pending orders: {len(data.opened_orders)}\")\n        print(f\"Open positions: {len(data.position_infos)}\")\n\n        # Show positions\n        for pos in data.position_infos:\n            print(f\"Position #{pos.ticket} {pos.symbol}: \"\n                  f\"{pos.volume} lots @ {pos.price_open}, P/L: ${pos.profit:.2f}\")\n\n        # Show orders\n        for order in data.opened_orders:\n            print(f\"Order #{order.ticket} {order.symbol}: \"\n                  f\"{order.volume_initial} lots @ {order.price_open}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#2-count-orders-and-positions-separately","title":"2) Count orders and positions separately","text":"<pre><code>async def get_opened_summary(account: MT5Account) -&gt; dict:\n    \"\"\"Get summary of opened orders and positions\"\"\"\n    data = await account.opened_orders()\n\n    summary = {\n        \"orders_count\": len(data.opened_orders),\n        \"positions_count\": len(data.position_infos),\n        \"total_count\": len(data.opened_orders) + len(data.position_infos)\n    }\n\n    print(f\"[OK] Pending orders: {summary['orders_count']}\")\n    print(f\"[OK] Open positions: {summary['positions_count']}\")\n    print(f\"[OK] Total: {summary['total_count']}\")\n\n    return summary\n\n# Usage:\nsummary = await get_opened_summary(account)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#3-calculate-total-floating-pl","title":"3) Calculate total floating P/L","text":"<pre><code>async def get_total_profit(account: MT5Account) -&gt; float:\n    \"\"\"Calculate total floating profit/loss from all positions\"\"\"\n    data = await account.opened_orders()\n\n    total_profit = sum(pos.profit for pos in data.position_infos)\n\n    print(f\"Total floating P/L: ${total_profit:+.2f}\")\n    return total_profit\n\n# Usage:\nprofit = await get_total_profit(account)\nif profit &lt; 0:\n    print(f\"[WARNING] Account in loss: ${profit:.2f}\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#4-find-positions-by-symbol","title":"4) Find positions by symbol","text":"<pre><code>async def get_positions_by_symbol(\n    account: MT5Account,\n    symbol: str\n) -&gt; list:\n    \"\"\"Get all open positions for specific symbol\"\"\"\n    data = await account.opened_orders()\n\n    positions = [\n        pos for pos in data.position_infos\n        if pos.symbol == symbol\n    ]\n\n    print(f\"[OK] Found {len(positions)} position(s) for {symbol}\")\n    return positions\n\n# Usage:\neurusd_positions = await get_positions_by_symbol(account, \"EURUSD\")\nfor pos in eurusd_positions:\n    print(f\"  #{pos.ticket}: {pos.volume} lots, P/L: ${pos.profit:.2f}\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#5-display-positions-with-details","title":"5) Display positions with details","text":"<pre><code>async def display_positions(account: MT5Account):\n    \"\"\"Display all positions with formatted output\"\"\"\n    data = await account.opened_orders()\n\n    if not data.position_infos:\n        print(\"[INFO] No open positions\")\n        return\n\n    print(f\"\\n{'='*80}\")\n    print(f\"OPEN POSITIONS ({len(data.position_infos)})\")\n    print(f\"{'='*80}\")\n    print(f\"{'Ticket':&lt;12} {'Symbol':&lt;10} {'Volume':&lt;8} {'Price':&lt;10} {'Current':&lt;10} {'Profit':&lt;12}\")\n    print(f\"{'-'*80}\")\n\n    for pos in data.position_infos:\n        type_str = \"BUY\" if pos.type == 0 else \"SELL\"\n        print(f\"{pos.ticket:&lt;12} {pos.symbol:&lt;10} {pos.volume:&lt;8.2f} \"\n              f\"{pos.price_open:&lt;10.5f} {pos.price_current:&lt;10.5f} ${pos.profit:+11.2f}\")\n\n    total = sum(pos.profit for pos in data.position_infos)\n    print(f\"{'-'*80}\")\n    print(f\"{'TOTAL:':&lt;62} ${total:+11.2f}\")\n    print(f\"{'='*80}\\n\")\n\n# Usage:\nawait display_positions(account)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#6-monitor-for-new-orderspositions","title":"6) Monitor for new orders/positions","text":"<pre><code>async def monitor_opened(account: MT5Account, interval: float = 5.0):\n    \"\"\"Monitor for changes in orders/positions\"\"\"\n    previous_tickets = set()\n\n    while True:\n        try:\n            data = await account.opened_orders()\n\n            # Collect all current tickets\n            current_tickets = set()\n            for order in data.opened_orders:\n                current_tickets.add((\"ORDER\", order.ticket))\n            for pos in data.position_infos:\n                current_tickets.add((\"POSITION\", pos.ticket))\n\n            # Detect new items\n            if previous_tickets:\n                new_items = current_tickets - previous_tickets\n                closed_items = previous_tickets - current_tickets\n\n                for item_type, ticket in new_items:\n                    print(f\"[+] New {item_type}: #{ticket}\")\n\n                for item_type, ticket in closed_items:\n                    print(f\"[-] Closed {item_type}: #{ticket}\")\n\n            previous_tickets = current_tickets\n\n        except Exception as e:\n            print(f\"[ERROR] {e}\")\n\n        await asyncio.sleep(interval)\n\n# Usage:\n# await monitor_opened(account, interval=5.0)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#7-get-positions-sorted-by-profit","title":"7) Get positions sorted by profit","text":"<pre><code>async def get_worst_positions(account: MT5Account, limit: int = 5):\n    \"\"\"Get positions with worst performance\"\"\"\n    data = await account.opened_orders()\n\n    # Sort by profit (worst first)\n    sorted_positions = sorted(\n        data.position_infos,\n        key=lambda p: p.profit\n    )\n\n    worst = sorted_positions[:limit]\n\n    print(f\"\\nWorst {limit} positions:\")\n    for i, pos in enumerate(worst, 1):\n        print(f\"{i}. #{pos.ticket} {pos.symbol}: ${pos.profit:+.2f}\")\n\n    return worst\n\n# Usage:\nworst = await get_worst_positions(account, limit=5)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#8-check-if-symbol-has-open-position","title":"8) Check if symbol has open position","text":"<pre><code>async def has_position_for_symbol(\n    account: MT5Account,\n    symbol: str\n) -&gt; bool:\n    \"\"\"Check if symbol has open position\"\"\"\n    data = await account.opened_orders()\n\n    has_pos = any(pos.symbol == symbol for pos in data.position_infos)\n\n    if has_pos:\n        print(f\"[OK] Position found for {symbol}\")\n    else:\n        print(f\"[INFO] No position for {symbol}\")\n\n    return has_pos\n\n# Usage:\nif not await has_position_for_symbol(account, \"EURUSD\"):\n    print(\"Can open new EURUSD position\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#common-patterns","title":"Common Patterns","text":""},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#quick-position-lookup","title":"Quick position lookup","text":"<pre><code>async def get_position_by_ticket(account: MT5Account, ticket: int):\n    \"\"\"Find specific position by ticket\"\"\"\n    data = await account.opened_orders()\n    for pos in data.position_infos:\n        if pos.ticket == ticket:\n            return pos\n    return None\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#calculate-exposure-by-symbol","title":"Calculate exposure by symbol","text":"<pre><code>async def get_symbol_exposure(account: MT5Account) -&gt; dict:\n    \"\"\"Calculate total volume per symbol\"\"\"\n    data = await account.opened_orders()\n\n    exposure = {}\n    for pos in data.position_infos:\n        exposure[pos.symbol] = exposure.get(pos.symbol, 0) + pos.volume\n\n    return exposure\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>positions_total - Get count only (faster)</li> <li>opened_orders_tickets - Get ticket IDs only</li> <li>positions_history - Get historical closed positions</li> <li>order_history - Get historical orders</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/","title":"Get Opened Orders and Positions Ticket IDs","text":"<p>Request: ticket IDs of all currently opened orders and positions (lightweight alternative to full details).</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.opened_orders_tickets(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.AccountHelper</code></li> <li>Proto definition: <code>OpenedOrdersTickets</code> (defined in <code>mt5-term-api-account-helper.proto</code>)</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.AccountHelper</code></li> <li>Method: <code>OpenedOrdersTickets(OpenedOrdersTicketsRequest) -&gt; OpenedOrdersTicketsReply</code></li> <li>Low-level client (generated): <code>AccountHelperStub.OpenedOrdersTickets(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Get only the ticket IDs of opened orders and positions without full details.</li> <li>Why you need it. Lightweight check for what orders/positions exist. More efficient than <code>opened_orders()</code>.</li> <li>When to use. Use this when you only need ticket IDs. Use <code>opened_orders()</code> for full details.</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to get ticket IDs only:</p> <ul> <li>Check which orders/positions are currently open</li> <li>Track ticket IDs for later queries</li> <li>Monitor for new/closed orders efficiently</li> <li>Lighter payload than full <code>opened_orders()</code></li> <li>Quick existence check before fetching full details</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; opened_orders_tickets - How it works</p>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#method-signature","title":"Method Signature","text":"<pre><code>async def opened_orders_tickets(\n    self,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; account_helper_pb2.OpenedOrdersTicketsData\n</code></pre> <p>Request message:</p> <pre><code>message OpenedOrdersTicketsRequest {\n  // Empty - no parameters needed\n}\n</code></pre> <p>Reply message:</p> <pre><code>message OpenedOrdersTicketsReply {\n  oneof response {\n    OpenedOrdersTicketsData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage OpenedOrdersTicketsData {\n  repeated int64 opened_orders_tickets = 1;\n  repeated int64 opened_position_tickets = 2;\n}\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation <p>No additional parameters - this method returns ticket IDs only.</p> <p>Deadline options:</p> <pre><code>from datetime import datetime, timedelta\n\n# With deadline\ndeadline = datetime.utcnow() + timedelta(seconds=3)\ndata = await account.opened_orders_tickets(deadline=deadline)\n\n# Without deadline\ndata = await account.opened_orders_tickets()\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#output-openedordersticketsdata","title":"\u2b06\ufe0f Output - <code>OpenedOrdersTicketsData</code>","text":"Field Type Python Type Description <code>opened_orders_tickets</code> <code>repeated int64</code> <code>list[int]</code> List of pending order ticket IDs <code>opened_position_tickets</code> <code>repeated int64</code> <code>list[int]</code> List of open position ticket IDs <p>Return value: The method returns <code>OpenedOrdersTicketsData</code> object with both lists accessible as attributes.</p>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":"<p>No enums used by this method.</p>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors.</li> <li>Lightweight: Only ticket IDs are returned - much smaller payload than <code>opened_orders()</code>.</li> <li>Two separate lists: Order tickets and position tickets are in separate lists.</li> <li>Connection required: You must call <code>connect_by_host_port()</code> or <code>connect_by_server_name()</code> first.</li> <li>Thread safety: Safe to call concurrently from multiple asyncio tasks.</li> <li>UUID handling: The terminal instance UUID is auto-generated by the server if not provided. For explicit control (e.g., in streaming scenarios), pass <code>id_=uuid4()</code> to constructor.</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#1-get-all-ticket-ids","title":"1) Get all ticket IDs","text":"<pre><code>import asyncio\nfrom datetime import datetime, timedelta\nfrom MetaRpcMT5 import MT5Account\n\nasync def main():\n    account = MT5Account(\n        user=12345678,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        deadline = datetime.utcnow() + timedelta(seconds=3)\n        data = await account.opened_orders_tickets(deadline=deadline)\n\n        print(f\"Order tickets: {data.opened_orders_tickets}\")\n        print(f\"Position tickets: {data.opened_position_tickets}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#2-check-if-ticket-exists","title":"2) Check if ticket exists","text":"<pre><code>async def ticket_exists(account: MT5Account, ticket: int) -&gt; bool:\n    \"\"\"Check if ticket ID exists in opened orders/positions\"\"\"\n    data = await account.opened_orders_tickets()\n\n    exists = (\n        ticket in data.opened_orders_tickets or\n        ticket in data.opened_position_tickets\n    )\n\n    if exists:\n        print(f\"[OK] Ticket #{ticket} found\")\n    else:\n        print(f\"[INFO] Ticket #{ticket} not found\")\n\n    return exists\n\n# Usage:\nif await ticket_exists(account, 123456):\n    print(\"Order/position still open\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#3-monitor-for-ticket-changes","title":"3) Monitor for ticket changes","text":"<pre><code>async def monitor_tickets(account: MT5Account, interval: float = 5.0):\n    \"\"\"Monitor for changes in ticket IDs\"\"\"\n    previous_tickets = set()\n\n    while True:\n        try:\n            data = await account.opened_orders_tickets()\n\n            current_tickets = set(data.opened_orders_tickets + data.opened_position_tickets)\n\n            if previous_tickets:\n                new = current_tickets - previous_tickets\n                closed = previous_tickets - current_tickets\n\n                for ticket in new:\n                    print(f\"[+] New ticket: #{ticket}\")\n                for ticket in closed:\n                    print(f\"[-] Closed ticket: #{ticket}\")\n\n            previous_tickets = current_tickets\n\n        except Exception as e:\n            print(f\"[ERROR] {e}\")\n\n        await asyncio.sleep(interval)\n\n# Usage:\n# await monitor_tickets(account, interval=5.0)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#4-get-all-tickets-combined","title":"4) Get all tickets combined","text":"<pre><code>async def get_all_tickets(account: MT5Account) -&gt; list[int]:\n    \"\"\"Get all order and position tickets combined\"\"\"\n    data = await account.opened_orders_tickets()\n\n    all_tickets = list(data.opened_orders_tickets) + list(data.opened_position_tickets)\n\n    print(f\"[OK] Total tickets: {len(all_tickets)}\")\n    return all_tickets\n\n# Usage:\ntickets = await get_all_tickets(account)\nprint(f\"All tickets: {tickets}\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#5-compare-with-previous-snapshot","title":"5) Compare with previous snapshot","text":"<pre><code>async def compare_tickets(\n    account: MT5Account,\n    previous_orders: list[int],\n    previous_positions: list[int]\n) -&gt; dict:\n    \"\"\"Compare current tickets with previous snapshot\"\"\"\n    data = await account.opened_orders_tickets()\n\n    result = {\n        \"new_orders\": list(set(data.opened_orders_tickets) - set(previous_orders)),\n        \"closed_orders\": list(set(previous_orders) - set(data.opened_orders_tickets)),\n        \"new_positions\": list(set(data.opened_position_tickets) - set(previous_positions)),\n        \"closed_positions\": list(set(previous_positions) - set(data.opened_position_tickets))\n    }\n\n    if result[\"new_orders\"]:\n        print(f\"[+] New orders: {result['new_orders']}\")\n    if result[\"closed_orders\"]:\n        print(f\"[-] Closed orders: {result['closed_orders']}\")\n    if result[\"new_positions\"]:\n        print(f\"[+] New positions: {result['new_positions']}\")\n    if result[\"closed_positions\"]:\n        print(f\"[-] Closed positions: {result['closed_positions']}\")\n\n    return result\n\n# Usage:\n# prev_orders = [12345, 12346]\n# prev_positions = [12347]\n# changes = await compare_tickets(account, prev_orders, prev_positions)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#common-patterns","title":"Common Patterns","text":""},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#quick-count-check","title":"Quick count check","text":"<pre><code>async def get_tickets_count(account: MT5Account) -&gt; dict:\n    \"\"\"Get count of orders and positions\"\"\"\n    data = await account.opened_orders_tickets()\n    return {\n        \"orders\": len(data.opened_orders_tickets),\n        \"positions\": len(data.opened_position_tickets),\n        \"total\": len(data.opened_orders_tickets) + len(data.opened_position_tickets)\n    }\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#ticket-set-operations","title":"Ticket set operations","text":"<pre><code>async def get_ticket_sets(account: MT5Account) -&gt; tuple:\n    \"\"\"Get ticket IDs as sets for easy comparison\"\"\"\n    data = await account.opened_orders_tickets()\n    return (\n        set(data.opened_orders_tickets),\n        set(data.opened_position_tickets)\n    )\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/opened_orders_tickets/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>opened_orders - Get full details of orders and positions</li> <li>positions_total - Get count only (even lighter)</li> <li>positions_history - Get historical closed positions</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/","title":"Get Historical Orders","text":"<p>Request: historical order data within a specified time range with pagination support.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.order_history(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.AccountHelper</code></li> <li>Proto definition: <code>OrderHistory</code> (defined in <code>mt5-term-api-account-helper.proto</code>)</li> <li>Enums in this method: 8 enums with 66 total constants (1 input, 7 output)</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.AccountHelper</code></li> <li>Method: <code>OrderHistory(OrderHistoryRequest) -&gt; OrderHistoryReply</code></li> <li>Low-level client (generated): <code>AccountHelperStub.OrderHistory(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Get historical orders and deals within a time range with sorting and pagination.</li> <li>Why you need it. Analyze trading history, calculate statistics, audit orders.</li> <li>When to use. Use this for order history. Use <code>positions_history()</code> for closed positions.</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to retrieve historical trading data:</p> <ul> <li>Get past orders and deals within date range</li> <li>Analyze trading performance</li> <li>Calculate profit/loss statistics</li> <li>Audit trading activity</li> <li>Export trading history</li> <li>Pagination support for large datasets</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; order_history - How it works</p>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#method-signature","title":"Method Signature","text":"<pre><code>async def order_history(\n    self,\n    from_dt: datetime,\n    to_dt: datetime,\n    sort_mode: account_helper_pb2.BMT5_ENUM_ORDER_HISTORY_SORT_TYPE = account_helper_pb2.BMT5_SORT_BY_CLOSE_TIME_ASC,\n    page_number: int = 0,\n    items_per_page: int = 0,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; account_helper_pb2.OrdersHistoryData\n</code></pre> <p>Request message:</p> <pre><code>message OrderHistoryRequest {\n  google.protobuf.Timestamp inputFrom = 1;\n  google.protobuf.Timestamp inputTo = 2;\n  BMT5_ENUM_ORDER_HISTORY_SORT_TYPE inputSortMode = 3;\n  int32 pageNumber = 4;\n  int32 itemsPerPage = 5;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message OrderHistoryReply {\n  oneof response {\n    OrdersHistoryData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage OrdersHistoryData {\n  int32 arrayTotal = 1;\n  int32 pageNumber = 2;\n  int32 itemsPerPage = 3;\n  repeated HistoryData history_data = 4;\n}\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>from_dt</code> <code>datetime</code> (required) Start time for history query (server time) <code>to_dt</code> <code>datetime</code> (required) End time for history query (server time) <code>sort_mode</code> <code>BMT5_ENUM_ORDER_HISTORY_SORT_TYPE</code> (enum) Sort mode (by time or ticket ID) <code>page_number</code> <code>int</code> (optional) Page number for pagination (default 0) <code>items_per_page</code> <code>int</code> (optional) Items per page (default 0 = all) <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation <p>Usage:</p> <pre><code>from datetime import datetime, timedelta\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\n# Get last 7 days history\nto_dt = datetime.utcnow()\nfrom_dt = to_dt - timedelta(days=7)\n\ndata = await account.order_history(\n    from_dt=from_dt,\n    to_dt=to_dt,\n    sort_mode=account_helper_pb2.BMT5_SORT_BY_CLOSE_TIME_DESC,\n    page_number=0,\n    items_per_page=100\n)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#output-ordershistorydata","title":"\u2b06\ufe0f Output - <code>OrdersHistoryData</code>","text":"Field Type Python Type Description <code>arrayTotal</code> <code>int32</code> <code>int</code> Total number of records (all pages) <code>pageNumber</code> <code>int32</code> <code>int</code> Current page number <code>itemsPerPage</code> <code>int32</code> <code>int</code> Items per page <code>history_data</code> <code>repeated HistoryData</code> <code>list[HistoryData]</code> List of historical order/deal records <p>Each HistoryData contains:</p> Field Type Description <code>index</code> <code>uint32</code> Index in the result set <code>history_order</code> <code>OrderHistoryData</code> Order details (if applicable) <code>history_deal</code> <code>DealHistoryData</code> Deal details (if applicable) <p>OrderHistoryData fields:</p> <ul> <li><code>ticket</code> (uint64) - Order ticket number</li> <li><code>setup_time</code> (Timestamp) - Order setup time</li> <li><code>done_time</code> (Timestamp) - Order execution time</li> <li><code>state</code> (BMT5_ENUM_ORDER_STATE) - Order state</li> <li><code>price_current</code> (double) - Current price</li> <li><code>price_open</code> (double) - Order open price</li> <li><code>stop_limit</code> (double) - Stop limit price</li> <li><code>stop_loss</code> (double) - Stop loss level</li> <li><code>take_profit</code> (double) - Take profit level</li> <li><code>volume_current</code> (double) - Current volume</li> <li><code>volume_initial</code> (double) - Initial volume</li> <li><code>magic_number</code> (int64) - Expert Advisor ID</li> <li><code>type</code> (BMT5_ENUM_ORDER_TYPE) - Order type</li> <li><code>time_expiration</code> (Timestamp) - Order expiration time</li> <li><code>type_filling</code> (BMT5_ENUM_ORDER_TYPE_FILLING) - Filling type</li> <li><code>type_time</code> (BMT5_ENUM_ORDER_TYPE_TIME) - Order lifetime</li> <li><code>position_id</code> (uint64) - Position ticket</li> <li><code>symbol</code> (string) - Symbol name</li> <li><code>external_id</code> (string) - External ID</li> <li><code>comment</code> (string) - Order comment</li> <li><code>account_login</code> (int64) - Account login</li> </ul> <p>DealHistoryData fields:</p> <ul> <li><code>ticket</code> (uint64) - Deal ticket number</li> <li><code>profit</code> (double) - Deal profit</li> <li><code>commission</code> (double) - Commission</li> <li><code>fee</code> (double) - Additional fee</li> <li><code>price</code> (double) - Deal price</li> <li><code>stop_loss</code> (double) - Stop loss level at deal time</li> <li><code>take_profit</code> (double) - Take profit level at deal time</li> <li><code>swap</code> (double) - Swap</li> <li><code>volume</code> (double) - Deal volume</li> <li><code>entry_type</code> (BMT5_ENUM_DEAL_ENTRY_TYPE) - Entry type</li> <li><code>time</code> (Timestamp) - Deal time</li> <li><code>type</code> (BMT5_ENUM_DEAL_TYPE) - Deal type</li> <li><code>reason</code> (BMT5_ENUM_DEAL_REASON) - Deal reason</li> <li><code>position_id</code> (uint64) - Position ID</li> <li><code>comment</code> (string) - Deal comment</li> <li><code>symbol</code> (string) - Symbol name</li> <li><code>external_id</code> (string) - External ID</li> <li><code>account_login</code> (int64) - Account login</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":""},{"location":"MT5Account/3.%20Positions_Orders/order_history/#bmt5_enum_order_history_sort_type","title":"<code>BMT5_ENUM_ORDER_HISTORY_SORT_TYPE</code>","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>.</p> Constant Value Description <code>BMT5_SORT_BY_OPEN_TIME_ASC</code> 0 Sort by open time ascending <code>BMT5_SORT_BY_OPEN_TIME_DESC</code> 1 Sort by open time descending <code>BMT5_SORT_BY_CLOSE_TIME_ASC</code> 2 Sort by close time ascending <code>BMT5_SORT_BY_CLOSE_TIME_DESC</code> 3 Sort by close time descending <code>BMT5_SORT_BY_ORDER_TICKET_ID_ASC</code> 4 Sort by ticket ID ascending <code>BMT5_SORT_BY_ORDER_TICKET_ID_DESC</code> 5 Sort by ticket ID descending <p>Usage:</p> <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\ndata = await account.order_history(\n    from_dt=from_dt,\n    to_dt=to_dt,\n    sort_mode=pb2.BMT5_SORT_BY_CLOSE_TIME_DESC\n)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#bmt5_enum_order_state","title":"<code>BMT5_ENUM_ORDER_STATE</code>","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>. Used in <code>OrderHistoryData</code> to indicate order state.</p> Constant Value Description <code>BMT5_ORDER_STATE_STARTED</code> 0 Order checked, but not yet accepted by broker <code>BMT5_ORDER_STATE_PLACED</code> 1 Order accepted <code>BMT5_ORDER_STATE_CANCELED</code> 2 Order canceled by client <code>BMT5_ORDER_STATE_PARTIAL</code> 3 Order partially executed <code>BMT5_ORDER_STATE_FILLED</code> 4 Order fully executed <code>BMT5_ORDER_STATE_REJECTED</code> 5 Order rejected <code>BMT5_ORDER_STATE_EXPIRED</code> 6 Order expired <code>BMT5_ORDER_STATE_REQUEST_ADD</code> 7 Order is being registered (placing to trading system) <code>BMT5_ORDER_STATE_REQUEST_MODIFY</code> 8 Order is being modified (changing its parameters) <code>BMT5_ORDER_STATE_REQUEST_CANCEL</code> 9 Order is being deleted (deleting from trading system) <p>Usage:</p> <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\n# Check order state in history\nfor item in data.history_data:\n    if item.history_order.state == pb2.BMT5_ORDER_STATE_FILLED:\n        print(f\"Order {item.history_order.ticket} was filled\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#bmt5_enum_order_type","title":"<code>BMT5_ENUM_ORDER_TYPE</code>","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>. Used in <code>OrderHistoryData</code> to indicate order type.</p> Constant Value Description <code>BMT5_ORDER_TYPE_BUY</code> 0 Market Buy order <code>BMT5_ORDER_TYPE_SELL</code> 1 Market Sell order <code>BMT5_ORDER_TYPE_BUY_LIMIT</code> 2 Buy Limit pending order <code>BMT5_ORDER_TYPE_SELL_LIMIT</code> 3 Sell Limit pending order <code>BMT5_ORDER_TYPE_BUY_STOP</code> 4 Buy Stop pending order <code>BMT5_ORDER_TYPE_SELL_STOP</code> 5 Sell Stop pending order <code>BMT5_ORDER_TYPE_BUY_STOP_LIMIT</code> 6 Buy Stop Limit pending order <code>BMT5_ORDER_TYPE_SELL_STOP_LIMIT</code> 7 Sell Stop Limit pending order <code>BMT5_ORDER_TYPE_CLOSE_BY</code> 8 Close by opposite position <p>Usage:</p> <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\n# Filter buy orders\nfor item in data.history_data:\n    if item.history_order.type == pb2.BMT5_ORDER_TYPE_BUY:\n        print(f\"Buy order: {item.history_order.ticket}\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#bmt5_enum_order_type_filling","title":"<code>BMT5_ENUM_ORDER_TYPE_FILLING</code>","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>. Used in <code>OrderHistoryData</code> to indicate order filling type.</p> Constant Value Description <code>BMT5_ORDER_FILLING_FOK</code> 0 Fill or Kill <code>BMT5_ORDER_FILLING_IOC</code> 1 Immediate or Cancel <code>BMT5_ORDER_FILLING_RETURN</code> 2 Return <code>BMT5_ORDER_FILLING_BOC</code> 3 Book or Cancel <p>Usage:</p> <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\n# Check filling type\nfor item in data.history_data:\n    if item.history_order.type_filling == pb2.BMT5_ORDER_FILLING_FOK:\n        print(f\"FOK order: {item.history_order.ticket}\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#bmt5_enum_order_type_time","title":"<code>BMT5_ENUM_ORDER_TYPE_TIME</code>","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>. Used in <code>OrderHistoryData</code> to indicate order lifetime.</p> Constant Value Description <code>BMT5_ORDER_TIME_GTC</code> 0 Good till cancel <code>BMT5_ORDER_TIME_DAY</code> 1 Good till current trade day <code>BMT5_ORDER_TIME_SPECIFIED</code> 2 Good till specified date <code>BMT5_ORDER_TIME_SPECIFIED_DAY</code> 3 Good till specified day <p>Usage:</p> <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\n# Check time type\nfor item in data.history_data:\n    if item.history_order.type_time == pb2.BMT5_ORDER_TIME_GTC:\n        print(f\"GTC order: {item.history_order.ticket}\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#bmt5_enum_deal_entry_type","title":"<code>BMT5_ENUM_DEAL_ENTRY_TYPE</code>","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>. Used in <code>DealHistoryData</code> to indicate deal entry type.</p> Constant Value Description <code>BMT5_DEAL_ENTRY_IN</code> 0 Entry in <code>BMT5_DEAL_ENTRY_OUT</code> 1 Entry out <code>BMT5_DEAL_ENTRY_INOUT</code> 2 Reverse <code>BMT5_DEAL_ENTRY_OUT_BY</code> 3 Close by <p>Usage:</p> <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\n# Check deal entry type\nfor item in data.history_data:\n    if item.history_deal.entry_type == pb2.BMT5_DEAL_ENTRY_IN:\n        print(f\"Entry in deal: {item.history_deal.ticket}\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#bmt5_enum_deal_type","title":"<code>BMT5_ENUM_DEAL_TYPE</code>","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>. Used in <code>DealHistoryData</code> to indicate deal type.</p> Constant Value Description <code>BMT5_DEAL_TYPE_BUY</code> 0 Buy <code>BMT5_DEAL_TYPE_SELL</code> 1 Sell <code>BMT5_DEAL_TYPE_BALANCE</code> 2 Balance <code>BMT5_DEAL_TYPE_CREDIT</code> 3 Credit <code>BMT5_DEAL_TYPE_CHARGE</code> 4 Additional charge <code>BMT5_DEAL_TYPE_CORRECTION</code> 5 Correction <code>BMT5_DEAL_TYPE_BONUS</code> 6 Bonus <code>BMT5_DEAL_TYPE_COMMISSION</code> 7 Additional commission <code>BMT5_DEAL_TYPE_COMMISSION_DAILY</code> 8 Daily commission <code>BMT5_DEAL_TYPE_COMMISSION_MONTHLY</code> 9 Monthly commission <code>BMT5_DEAL_TYPE_COMMISSION_AGENT_DAILY</code> 10 Daily agent commission <code>BMT5_DEAL_TYPE_COMMISSION_AGENT_MONTHLY</code> 11 Monthly agent commission <code>BMT5_DEAL_TYPE_INTEREST</code> 12 Interest rate <code>BMT5_DEAL_TYPE_BUY_CANCELED</code> 13 Canceled buy deal <code>BMT5_DEAL_TYPE_SELL_CANCELED</code> 14 Canceled sell deal <code>BMT5_DEAL_DIVIDEND</code> 15 Dividend <code>BMT5_DEAL_DIVIDEND_FRANKED</code> 16 Franked dividend <code>BMT5_DEAL_TAX</code> 17 Tax <p>Usage:</p> <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\n# Filter buy/sell deals\nfor item in data.history_data:\n    if item.history_deal.type == pb2.BMT5_DEAL_TYPE_BUY:\n        print(f\"Buy deal: {item.history_deal.ticket}\")\n    elif item.history_deal.type == pb2.BMT5_DEAL_TYPE_BALANCE:\n        print(f\"Balance operation: {item.history_deal.ticket}\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#bmt5_enum_deal_reason","title":"<code>BMT5_ENUM_DEAL_REASON</code>","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>. Used in <code>DealHistoryData</code> to indicate deal reason.</p> Constant Value Description <code>BMT5_DEAL_REASON_CLIENT</code> 0 Deal placed manually <code>BMT5_DEAL_REASON_MOBILE</code> 1 Deal placed from mobile <code>BMT5_DEAL_REASON_WEB</code> 2 Deal placed from web <code>BMT5_DEAL_REASON_EXPERT</code> 3 Deal placed by expert <code>BMT5_DEAL_REASON_SL</code> 4 Deal placed due to Stop Loss <code>BMT5_DEAL_REASON_TP</code> 5 Deal placed due to Take Profit <code>BMT5_DEAL_REASON_SO</code> 6 Deal placed due to Stop Out <code>BMT5_DEAL_REASON_ROLLOVER</code> 7 Deal due to rollover <code>BMT5_DEAL_REASON_VMARGIN</code> 8 Deal due to variation margin <code>BMT5_DEAL_REASON_SPLIT</code> 9 Deal due to split <code>BMT5_DEAL_REASON_CORPORATE_ACTION</code> 10 Deal due to corporate action <p>Usage:</p> <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\n# Check deal reason\nfor item in data.history_data:\n    if item.history_deal.reason == pb2.BMT5_DEAL_REASON_SL:\n        print(f\"Stop Loss deal: {item.history_deal.ticket}\")\n    elif item.history_deal.reason == pb2.BMT5_DEAL_REASON_EXPERT:\n        print(f\"EA deal: {item.history_deal.ticket}\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Server time: The <code>from_dt</code> and <code>to_dt</code> parameters use server time, not UTC.</li> <li>Pagination: Use <code>page_number</code> and <code>items_per_page</code> for large datasets. Set <code>items_per_page=0</code> to get all results.</li> <li>Total count: The <code>arrayTotal</code> field shows total records across all pages.</li> <li>Automatic reconnection: Built-in protection against transient gRPC errors.</li> <li>Connection required: Call <code>connect_by_host_port()</code> or <code>connect_by_server_name()</code> first.</li> <li>Thread safety: Safe to call concurrently from multiple asyncio tasks.</li> <li>UUID handling: The terminal instance UUID is auto-generated by the server if not provided.    For explicit control (e.g., in streaming scenarios), pass <code>id_=uuid4()</code> to constructor.</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/3.%20Positions_Orders/order_history/#1-get-last-7-days-history","title":"1) Get last 7 days history","text":"<pre><code>import asyncio\nfrom datetime import datetime, timedelta\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\nasync def main():\n    account = MT5Account(\n        user=12345678,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Last 7 days\n        to_dt = datetime.utcnow()\n        from_dt = to_dt - timedelta(days=7)\n\n        data = await account.order_history(\n            from_dt=from_dt,\n            to_dt=to_dt,\n            sort_mode=account_helper_pb2.BMT5_SORT_BY_CLOSE_TIME_DESC,\n            items_per_page=100\n        )\n\n        print(f\"Total records: {data.arrayTotal}\")\n        print(f\"Returned: {len(data.history_data)} records\")\n\n        for item in data.history_data:\n            if item.history_deal:\n                deal = item.history_deal\n                print(f\"Deal #{deal.ticket}: ${deal.profit:.2f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#2-get-history-with-pagination","title":"2) Get history with pagination","text":"<pre><code>async def get_all_history_paginated(\n    account: MT5Account,\n    from_dt: datetime,\n    to_dt: datetime,\n    page_size: int = 100\n):\n    \"\"\"Get all history records using pagination\"\"\"\n    all_records = []\n    page = 0\n\n    while True:\n        data = await account.order_history(\n            from_dt=from_dt,\n            to_dt=to_dt,\n            sort_mode=account_helper_pb2.BMT5_SORT_BY_CLOSE_TIME_ASC,\n            page_number=page,\n            items_per_page=page_size\n        )\n\n        print(f\"[OK] Page {page + 1}: {len(data.history_data)} records\")\n\n        all_records.extend(data.history_data)\n\n        # Check if we got all records\n        if len(all_records) &gt;= data.arrayTotal:\n            break\n\n        page += 1\n\n    print(f\"[OK] Total records retrieved: {len(all_records)}\")\n    return all_records\n\n# Usage:\nfrom_dt = datetime.utcnow() - timedelta(days=30)\nto_dt = datetime.utcnow()\nhistory = await get_all_history_paginated(account, from_dt, to_dt)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#3-calculate-total-profit-for-period","title":"3) Calculate total profit for period","text":"<pre><code>async def calculate_period_profit(\n    account: MT5Account,\n    from_dt: datetime,\n    to_dt: datetime\n) -&gt; float:\n    \"\"\"Calculate total profit for time period\"\"\"\n    data = await account.order_history(\n        from_dt=from_dt,\n        to_dt=to_dt,\n        items_per_page=0  # Get all\n    )\n\n    total_profit = 0.0\n    for item in data.history_data:\n        if item.history_deal:\n            total_profit += item.history_deal.profit\n\n    print(f\"Total profit ({from_dt.date()} to {to_dt.date()}): ${total_profit:+.2f}\")\n    return total_profit\n\n# Usage:\nfrom_dt = datetime(2024, 1, 1)\nto_dt = datetime(2024, 1, 31)\nprofit = await calculate_period_profit(account, from_dt, to_dt)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#4-get-todays-trading-history","title":"4) Get today's trading history","text":"<pre><code>async def get_today_history(account: MT5Account):\n    \"\"\"Get all trades from today\"\"\"\n    now = datetime.utcnow()\n    today_start = now.replace(hour=0, minute=0, second=0, microsecond=0)\n\n    data = await account.order_history(\n        from_dt=today_start,\n        to_dt=now,\n        sort_mode=account_helper_pb2.BMT5_SORT_BY_CLOSE_TIME_DESC\n    )\n\n    print(f\"\\nToday's trading activity:\")\n    print(f\"Total records: {data.arrayTotal}\")\n\n    for item in data.history_data:\n        if item.history_deal:\n            deal = item.history_deal\n            time = deal.time.ToDatetime()\n            print(f\"  {time.strftime('%H:%M:%S')} - \"\n                  f\"#{deal.ticket} {deal.symbol}: ${deal.profit:+.2f}\")\n\n    return data\n\n# Usage:\nawait get_today_history(account)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#5-export-history-to-csv","title":"5) Export history to CSV","text":"<pre><code>import csv\n\nasync def export_history_to_csv(\n    account: MT5Account,\n    from_dt: datetime,\n    to_dt: datetime,\n    filename: str = \"order_history.csv\"\n):\n    \"\"\"Export order history to CSV file\"\"\"\n    data = await account.order_history(\n        from_dt=from_dt,\n        to_dt=to_dt,\n        items_per_page=0\n    )\n\n    with open(filename, 'w', newline='', encoding='utf-8') as f:\n        writer = csv.writer(f)\n        writer.writerow([\n            'Ticket', 'Time', 'Symbol', 'Type', 'Volume',\n            'Price', 'Profit', 'Commission', 'Swap'\n        ])\n\n        for item in data.history_data:\n            if item.history_deal:\n                deal = item.history_deal\n                time = deal.time.ToDatetime()\n                writer.writerow([\n                    deal.ticket,\n                    time.strftime('%Y-%m-%d %H:%M:%S'),\n                    deal.symbol,\n                    deal.type,\n                    deal.volume,\n                    deal.price,\n                    deal.profit,\n                    deal.commission,\n                    deal.swap\n                ])\n\n    print(f\"[OK] Exported {data.arrayTotal} records to {filename}\")\n\n# Usage:\nfrom_dt = datetime.utcnow() - timedelta(days=30)\nto_dt = datetime.utcnow()\nawait export_history_to_csv(account, from_dt, to_dt)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#6-get-winning-vs-losing-trades","title":"6) Get winning vs losing trades","text":"<pre><code>async def analyze_win_loss(\n    account: MT5Account,\n    from_dt: datetime,\n    to_dt: datetime\n) -&gt; dict:\n    \"\"\"Analyze winning vs losing trades\"\"\"\n    data = await account.order_history(\n        from_dt=from_dt,\n        to_dt=to_dt,\n        items_per_page=0\n    )\n\n    wins = 0\n    losses = 0\n    total_win_profit = 0.0\n    total_loss_profit = 0.0\n\n    for item in data.history_data:\n        if item.history_deal:\n            profit = item.history_deal.profit\n            if profit &gt; 0:\n                wins += 1\n                total_win_profit += profit\n            elif profit &lt; 0:\n                losses += 1\n                total_loss_profit += profit\n\n    total_trades = wins + losses\n    win_rate = (wins / total_trades * 100) if total_trades &gt; 0 else 0\n\n    result = {\n        \"total_trades\": total_trades,\n        \"wins\": wins,\n        \"losses\": losses,\n        \"win_rate\": win_rate,\n        \"total_win_profit\": total_win_profit,\n        \"total_loss_profit\": total_loss_profit,\n        \"net_profit\": total_win_profit + total_loss_profit\n    }\n\n    print(f\"\\nTrading Statistics:\")\n    print(f\"  Total trades: {total_trades}\")\n    print(f\"  Wins: {wins} ({win_rate:.1f}%)\")\n    print(f\"  Losses: {losses}\")\n    print(f\"  Win profit: ${total_win_profit:.2f}\")\n    print(f\"  Loss profit: ${total_loss_profit:.2f}\")\n    print(f\"  Net profit: ${result['net_profit']:+.2f}\")\n\n    return result\n\n# Usage:\nfrom_dt = datetime.utcnow() - timedelta(days=30)\nto_dt = datetime.utcnow()\nstats = await analyze_win_loss(account, from_dt, to_dt)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#common-patterns","title":"Common Patterns","text":""},{"location":"MT5Account/3.%20Positions_Orders/order_history/#get-history-for-specific-symbol","title":"Get history for specific symbol","text":"<pre><code>async def get_symbol_history(\n    account: MT5Account,\n    symbol: str,\n    from_dt: datetime,\n    to_dt: datetime\n):\n    \"\"\"Filter history by symbol\"\"\"\n    data = await account.order_history(from_dt=from_dt, to_dt=to_dt)\n\n    symbol_deals = [\n        item for item in data.history_data\n        if item.history_deal and item.history_deal.symbol == symbol\n    ]\n\n    return symbol_deals\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#calculate-daily-profit","title":"Calculate daily profit","text":"<pre><code>from collections import defaultdict\n\nasync def get_daily_profit(account: MT5Account, from_dt: datetime, to_dt: datetime):\n    \"\"\"Calculate profit per day\"\"\"\n    data = await account.order_history(from_dt=from_dt, to_dt=to_dt, items_per_page=0)\n\n    daily_profit = defaultdict(float)\n\n    for item in data.history_data:\n        if item.history_deal:\n            deal = item.history_deal\n            date = deal.time.ToDatetime().date()\n            daily_profit[date] += deal.profit\n\n    return dict(daily_profit)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/order_history/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>positions_history - Get historical closed positions</li> <li>opened_orders - Get currently open orders</li> <li>positions_total - Get count of open positions</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/","title":"Get Historical Closed Positions","text":"<p>Request: historical closed positions within a time range with sorting and pagination support.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.positions_history(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.AccountHelper</code></li> <li>Proto definition: <code>PositionsHistory</code> (defined in <code>mt5-term-api-account-helper.proto</code>)</li> <li>Enums in this method: 2 enums with 13 total constants (1 input, 1 output)</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.AccountHelper</code></li> <li>Method: <code>PositionsHistory(PositionsHistoryRequest) -&gt; PositionsHistoryReply</code></li> <li>Low-level client (generated): <code>AccountHelperStub.PositionsHistory(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Get historical closed positions filtered by open time range.</li> <li>Why you need it. Analyze trading performance, calculate statistics on closed positions.</li> <li>When to use. Use this for closed positions. Use <code>order_history()</code> for order/deal history.</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to retrieve historical closed positions:</p> <ul> <li>Get closed positions within date range</li> <li>Analyze position performance</li> <li>Calculate profit/loss by position</li> <li>Review closed trades</li> <li>Filter by open time</li> <li>Pagination support for large datasets</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; positions_history - How it works</p>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#method-signature","title":"Method Signature","text":"<pre><code>async def positions_history(\n    self,\n    sort_type: account_helper_pb2.AH_ENUM_POSITIONS_HISTORY_SORT_TYPE,\n    open_from: Optional[datetime] = None,\n    open_to: Optional[datetime] = None,\n    page: int = 0,\n    size: int = 0,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; account_helper_pb2.PositionsHistoryData\n</code></pre> <p>Request message:</p> <pre><code>message PositionsHistoryRequest {\n  AH_ENUM_POSITIONS_HISTORY_SORT_TYPE sort_type = 1;\n  optional google.protobuf.Timestamp position_open_time_from = 2;\n  optional google.protobuf.Timestamp position_open_time_to = 3;\n  optional int32 page_number = 4;\n  optional int32 items_per_page = 5;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message PositionsHistoryReply {\n  oneof response {\n    PositionsHistoryData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage PositionsHistoryData {\n  repeated PositionHistoryInfo history_positions = 1;\n}\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>sort_type</code> <code>AH_ENUM_POSITIONS_HISTORY_SORT_TYPE</code> (enum, required) Sort mode for positions <code>open_from</code> <code>datetime</code> (optional) Start of open time filter (UTC) <code>open_to</code> <code>datetime</code> (optional) End of open time filter (UTC) <code>page</code> <code>int</code> (optional) Page number for pagination (default 0) <code>size</code> <code>int</code> (optional) Items per page (default 0 = all) <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation <p>Usage:</p> <pre><code>from datetime import datetime, timedelta\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\n# Get positions opened in last 7 days\nto_dt = datetime.utcnow()\nfrom_dt = to_dt - timedelta(days=7)\n\ndata = await account.positions_history(\n    sort_type=account_helper_pb2.AH_POSITION_OPEN_TIME_DESC,\n    open_from=from_dt,\n    open_to=to_dt,\n    page=0,\n    size=100\n)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#output-positionshistorydata","title":"\u2b06\ufe0f Output - <code>PositionsHistoryData</code>","text":"Field Type Python Type Description <code>history_positions</code> <code>repeated PositionHistoryInfo</code> <code>list[PositionHistoryInfo]</code> List of historical position records <p>Each PositionHistoryInfo contains:</p> Field Type Description <code>index</code> <code>int32</code> Index in the result set <code>position_ticket</code> <code>uint64</code> Position ticket ID <code>order_type</code> <code>AH_ENUM_POSITIONS_HISTORY_ORDER_TYPE</code> Order type (BUY, SELL, etc.) <code>open_time</code> <code>Timestamp</code> Position open time <code>close_time</code> <code>Timestamp</code> Position close time <code>volume</code> <code>double</code> Position volume in lots <code>open_price</code> <code>double</code> Open price <code>close_price</code> <code>double</code> Close price <code>stop_loss</code> <code>double</code> Stop loss level <code>take_profit</code> <code>double</code> Take profit level <code>market_value</code> <code>double</code> Market value <code>commission</code> <code>double</code> Commission charged <code>fee</code> <code>double</code> Additional fees <code>profit</code> <code>double</code> Position profit/loss <code>swap</code> <code>double</code> Swap (rollover) <code>comment</code> <code>string</code> Comment <code>symbol</code> <code>string</code> Symbol name <code>magic</code> <code>int64</code> Magic number (EA identifier)"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":""},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#ah_enum_positions_history_sort_type","title":"<code>AH_ENUM_POSITIONS_HISTORY_SORT_TYPE</code>","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>.</p> Constant Value Description <code>AH_POSITION_OPEN_TIME_ASC</code> 0 Sort by open time ascending <code>AH_POSITION_OPEN_TIME_DESC</code> 1 Sort by open time descending <code>AH_POSITION_TICKET_ASC</code> 2 Sort by ticket ID ascending <code>AH_POSITION_TICKET_DESC</code> 3 Sort by ticket ID descending <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\ndata = await account.positions_history(\n    sort_type=pb2.AH_POSITION_OPEN_TIME_DESC,\n    open_from=from_dt,\n    open_to=to_dt\n)\n</code></pre></p>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#ah_enum_positions_history_order_type","title":"<code>AH_ENUM_POSITIONS_HISTORY_ORDER_TYPE</code>","text":"<p>Defined in <code>mt5-term-api-account-helper.proto</code>. Used in <code>PositionHistoryInfo</code> to indicate order type.</p> Constant Value Description <code>AH_ORDER_TYPE_BUY</code> 0 Market Buy order <code>AH_ORDER_TYPE_SELL</code> 1 Market Sell order <code>AH_ORDER_TYPE_BUY_LIMIT</code> 2 Buy Limit pending order <code>AH_ORDER_TYPE_SELL_LIMIT</code> 3 Sell Limit pending order <code>AH_ORDER_TYPE_BUY_STOP</code> 4 Buy Stop pending order <code>AH_ORDER_TYPE_SELL_STOP</code> 5 Sell Stop pending order <code>AH_ORDER_TYPE_BUY_STOP_LIMIT</code> 6 Buy Stop Limit pending order <code>AH_ORDER_TYPE_SELL_STOP_LIMIT</code> 7 Sell Stop Limit pending order <code>AH_ORDER_TYPE_CLOSE_BY</code> 8 Close by opposite position <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_account_helper_pb2 as pb2\n\n# Filter buy positions\nfor pos in data.history_positions:\n    if pos.order_type == pb2.AH_ORDER_TYPE_BUY:\n        print(f\"Buy position: {pos.position_ticket}\")\n</code></pre></p>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Filter by open time: The <code>open_from</code> and <code>open_to</code> filter positions by when they were opened, not closed.</li> <li>Pagination: Use <code>page</code> and <code>size</code> for large datasets. Set <code>size=0</code> to get all results.</li> <li>Automatic reconnection: Built-in protection against transient gRPC errors.</li> <li>Connection required: Call <code>connect_by_host_port()</code> or <code>connect_by_server_name()</code> first.</li> <li>Thread safety: Safe to call concurrently from multiple asyncio tasks.</li> <li>UUID handling: The terminal instance UUID is auto-generated by the server if not provided. For explicit control (e.g., in streaming scenarios), pass <code>id_=uuid4()</code> to constructor.</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#1-get-last-30-days-closed-positions","title":"1) Get last 30 days closed positions","text":"<pre><code>import asyncio\nfrom datetime import datetime, timedelta\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_helper_pb2\n\nasync def main():\n    account = MT5Account(\n        user=12345678,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Last 30 days\n        to_dt = datetime.utcnow()\n        from_dt = to_dt - timedelta(days=30)\n\n        data = await account.positions_history(\n            sort_type=account_helper_pb2.AH_POSITION_OPEN_TIME_DESC,\n            open_from=from_dt,\n            open_to=to_dt,\n            size=100\n        )\n\n        print(f\"Closed positions: {len(data.history_positions)}\")\n\n        for pos in data.history_positions:\n            open_time = pos.open_time.ToDatetime()\n            close_time = pos.close_time.ToDatetime()\n            print(f\"#{pos.position_ticket} {pos.symbol}: \"\n                  f\"${pos.profit:+.2f} \"\n                  f\"({open_time.date()} - {close_time.date()})\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#2-calculate-total-profit-from-closed-positions","title":"2) Calculate total profit from closed positions","text":"<pre><code>async def calculate_closed_profit(\n    account: MT5Account,\n    from_dt: datetime,\n    to_dt: datetime\n) -&gt; float:\n    \"\"\"Calculate total profit from closed positions\"\"\"\n    data = await account.positions_history(\n        sort_type=account_helper_pb2.AH_POSITION_OPEN_TIME_ASC,\n        open_from=from_dt,\n        open_to=to_dt,\n        size=0  # Get all\n    )\n\n    total_profit = sum(pos.profit for pos in data.history_positions)\n    total_commission = sum(pos.commission for pos in data.history_positions)\n    total_swap = sum(pos.swap for pos in data.history_positions)\n\n    net_profit = total_profit - total_commission + total_swap\n\n    print(f\"Closed positions statistics:\")\n    print(f\"  Total positions: {len(data.history_positions)}\")\n    print(f\"  Gross profit: ${total_profit:+.2f}\")\n    print(f\"  Commission: ${total_commission:.2f}\")\n    print(f\"  Swap: ${total_swap:+.2f}\")\n    print(f\"  Net profit: ${net_profit:+.2f}\")\n\n    return net_profit\n\n# Usage:\nfrom_dt = datetime.utcnow() - timedelta(days=30)\nto_dt = datetime.utcnow()\nprofit = await calculate_closed_profit(account, from_dt, to_dt)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#3-analyze-win-rate","title":"3) Analyze win rate","text":"<pre><code>async def analyze_closed_positions(\n    account: MT5Account,\n    from_dt: datetime,\n    to_dt: datetime\n) -&gt; dict:\n    \"\"\"Analyze closed positions performance\"\"\"\n    data = await account.positions_history(\n        sort_type=account_helper_pb2.AH_POSITION_OPEN_TIME_ASC,\n        open_from=from_dt,\n        open_to=to_dt\n    )\n\n    wins = 0\n    losses = 0\n    total_win_profit = 0.0\n    total_loss_profit = 0.0\n\n    for pos in data.history_positions:\n        if pos.profit &gt; 0:\n            wins += 1\n            total_win_profit += pos.profit\n        elif pos.profit &lt; 0:\n            losses += 1\n            total_loss_profit += pos.profit\n\n    total = wins + losses\n    win_rate = (wins / total * 100) if total &gt; 0 else 0\n    avg_win = total_win_profit / wins if wins &gt; 0 else 0\n    avg_loss = total_loss_profit / losses if losses &gt; 0 else 0\n\n    result = {\n        \"total_positions\": total,\n        \"wins\": wins,\n        \"losses\": losses,\n        \"win_rate\": win_rate,\n        \"avg_win\": avg_win,\n        \"avg_loss\": avg_loss,\n        \"profit_factor\": abs(total_win_profit / total_loss_profit) if total_loss_profit != 0 else 0\n    }\n\n    print(f\"\\nPosition Analysis:\")\n    print(f\"  Total: {total}\")\n    print(f\"  Wins: {wins} ({win_rate:.1f}%)\")\n    print(f\"  Losses: {losses}\")\n    print(f\"  Avg Win: ${avg_win:.2f}\")\n    print(f\"  Avg Loss: ${avg_loss:.2f}\")\n    print(f\"  Profit Factor: {result['profit_factor']:.2f}\")\n\n    return result\n\n# Usage:\nfrom_dt = datetime.utcnow() - timedelta(days=30)\nto_dt = datetime.utcnow()\nstats = await analyze_closed_positions(account, from_dt, to_dt)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#4-get-best-and-worst-positions","title":"4) Get best and worst positions","text":"<pre><code>async def get_best_worst_positions(\n    account: MT5Account,\n    from_dt: datetime,\n    to_dt: datetime,\n    limit: int = 5\n):\n    \"\"\"Get best and worst performing positions\"\"\"\n    data = await account.positions_history(\n        sort_type=account_helper_pb2.AH_POSITION_OPEN_TIME_ASC,\n        open_from=from_dt,\n        open_to=to_dt\n    )\n\n    # Sort by profit\n    sorted_positions = sorted(data.history_positions, key=lambda p: p.profit, reverse=True)\n\n    best = sorted_positions[:limit]\n    worst = sorted_positions[-limit:]\n\n    print(f\"\\nBest {limit} positions:\")\n    for i, pos in enumerate(best, 1):\n        print(f\"  {i}. #{pos.position_ticket} {pos.symbol}: ${pos.profit:+.2f}\")\n\n    print(f\"\\nWorst {limit} positions:\")\n    for i, pos in enumerate(worst, 1):\n        print(f\"  {i}. #{pos.position_ticket} {pos.symbol}: ${pos.profit:+.2f}\")\n\n    return {\"best\": best, \"worst\": worst}\n\n# Usage:\nfrom_dt = datetime.utcnow() - timedelta(days=30)\nto_dt = datetime.utcnow()\nresults = await get_best_worst_positions(account, from_dt, to_dt)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#5-get-positions-by-symbol","title":"5) Get positions by symbol","text":"<pre><code>async def get_symbol_closed_positions(\n    account: MT5Account,\n    symbol: str,\n    from_dt: datetime,\n    to_dt: datetime\n):\n    \"\"\"Get closed positions for specific symbol\"\"\"\n    data = await account.positions_history(\n        sort_type=account_helper_pb2.AH_POSITION_OPEN_TIME_DESC,\n        open_from=from_dt,\n        open_to=to_dt\n    )\n\n    symbol_positions = [\n        pos for pos in data.history_positions\n        if pos.symbol == symbol\n    ]\n\n    total_profit = sum(pos.profit for pos in symbol_positions)\n\n    print(f\"\\n{symbol} closed positions: {len(symbol_positions)}\")\n    print(f\"Total profit: ${total_profit:+.2f}\")\n\n    return symbol_positions\n\n# Usage:\nfrom_dt = datetime.utcnow() - timedelta(days=30)\nto_dt = datetime.utcnow()\neurusd_positions = await get_symbol_closed_positions(account, \"EURUSD\", from_dt, to_dt)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#6-export-to-csv","title":"6) Export to CSV","text":"<pre><code>import csv\n\nasync def export_positions_to_csv(\n    account: MT5Account,\n    from_dt: datetime,\n    to_dt: datetime,\n    filename: str = \"positions_history.csv\"\n):\n    \"\"\"Export closed positions to CSV\"\"\"\n    data = await account.positions_history(\n        sort_type=account_helper_pb2.AH_POSITION_OPEN_TIME_ASC,\n        open_from=from_dt,\n        open_to=to_dt\n    )\n\n    with open(filename, 'w', newline='', encoding='utf-8') as f:\n        writer = csv.writer(f)\n        writer.writerow([\n            'Ticket', 'Symbol', 'Open Time', 'Close Time',\n            'Volume', 'Open Price', 'Close Price',\n            'Profit', 'Commission', 'Swap', 'Total'\n        ])\n\n        for pos in data.history_positions:\n            open_time = pos.open_time.ToDatetime()\n            close_time = pos.close_time.ToDatetime()\n            total = pos.profit - pos.commission + pos.swap\n\n            writer.writerow([\n                pos.position_ticket,\n                pos.symbol,\n                open_time.strftime('%Y-%m-%d %H:%M:%S'),\n                close_time.strftime('%Y-%m-%d %H:%M:%S'),\n                pos.volume,\n                pos.open_price,\n                pos.close_price,\n                pos.profit,\n                pos.commission,\n                pos.swap,\n                total\n            ])\n\n    print(f\"[OK] Exported {len(data.history_positions)} positions to {filename}\")\n\n# Usage:\nfrom_dt = datetime.utcnow() - timedelta(days=30)\nto_dt = datetime.utcnow()\nawait export_positions_to_csv(account, from_dt, to_dt)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#common-patterns","title":"Common Patterns","text":""},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#calculate-daily-profit","title":"Calculate daily profit","text":"<pre><code>from collections import defaultdict\n\nasync def get_daily_profit(account: MT5Account, from_dt: datetime, to_dt: datetime):\n    \"\"\"Calculate profit per day from closed positions\"\"\"\n    data = await account.positions_history(\n        sort_type=account_helper_pb2.AH_POSITION_OPEN_TIME_ASC,\n        open_from=from_dt,\n        open_to=to_dt\n    )\n\n    daily_profit = defaultdict(float)\n\n    for pos in data.history_positions:\n        close_date = pos.close_time.ToDatetime().date()\n        daily_profit[close_date] += pos.profit\n\n    return dict(daily_profit)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#get-positions-with-pagination","title":"Get positions with pagination","text":"<pre><code>async def get_all_positions_paginated(\n    account: MT5Account,\n    from_dt: datetime,\n    to_dt: datetime,\n    page_size: int = 100\n):\n    \"\"\"Get all positions using pagination\"\"\"\n    all_positions = []\n    page = 0\n\n    while True:\n        data = await account.positions_history(\n            sort_type=account_helper_pb2.AH_POSITION_OPEN_TIME_ASC,\n            open_from=from_dt,\n            open_to=to_dt,\n            page=page,\n            size=page_size\n        )\n\n        if not data.history_positions:\n            break\n\n        all_positions.extend(data.history_positions)\n        page += 1\n\n    return all_positions\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_history/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>order_history - Get historical orders and deals</li> <li>opened_orders - Get currently open positions</li> <li>positions_total - Get count of open positions</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/","title":"Get Total Number of Open Positions","text":"<p>Request: total count of currently open positions on the trading account.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.positions_total(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.TradeFunctions</code></li> <li>Proto definition: <code>PositionsTotal</code> (defined in <code>mt5-term-api-trade-functions.proto</code>)</li> <li>Enums in this method: 0 enums (simple count only)</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.TradeFunctions</code></li> <li>Method: <code>PositionsTotal(Empty) -&gt; PositionsTotalReply</code></li> <li>Low-level client (generated): <code>TradeFunctionsStub.PositionsTotal(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Get the total count of open positions without fetching detailed position data.</li> <li>Why you need it. Quick check for open positions. Useful for risk management and trading logic.</li> <li>When to use. Use this when you only need the count. Use <code>opened_orders()</code> for full position details.</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to get a simple count of open positions:</p> <ul> <li>Check if there are any open positions</li> <li>Monitor position count before placing new trades</li> <li>Implement position limits (max concurrent positions)</li> <li>Quick status check without loading full position data</li> <li>Efficient - minimal data transfer</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; positions_total - How it works</p>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#method-signature","title":"Method Signature","text":"<pre><code>async def positions_total(\n    self,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; trade_functions_pb2.PositionsTotalData\n</code></pre> <p>Request message:</p> <pre><code>message Empty {\n  // No parameters needed\n}\n</code></pre> <p>Reply message:</p> <pre><code>message PositionsTotalReply {\n  oneof response {\n    PositionsTotalData data = 1;\n    Error error = 2;\n  }\n}\n\nmessage PositionsTotalData {\n  int32 total_positions = 1;\n}\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation <p>No additional parameters - this method returns the total count only.</p> <p>Deadline options:</p> <pre><code>from datetime import datetime, timedelta\n\n# 1. With deadline (recommended)\ndeadline = datetime.utcnow() + timedelta(seconds=3)\nresult = await account.positions_total(deadline=deadline)\n\n# 2. With cancellation event\ncancel_event = asyncio.Event()\nresult = await account.positions_total(cancellation_event=cancel_event)\n\n# 3. No deadline (uses default timeout if configured)\nresult = await account.positions_total()\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#output-positionstotaldata","title":"\u2b06\ufe0f Output - <code>PositionsTotalData</code>","text":"Field Type Python Type Description <code>total_positions</code> <code>int32</code> <code>int</code> Total number of currently open positions <p>Return value: The method returns <code>PositionsTotalData</code> object with <code>total_positions</code> field accessible as attribute.</p> <p>Access the count:</p> <pre><code>data = await account.positions_total()\ncount = data.total_positions\nprint(f\"Open positions: {count}\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Default timeout: If <code>deadline</code> is <code>None</code>, the method will wait indefinitely (or until server timeout).</li> <li>Lightweight: This method only returns a count - use <code>opened_orders()</code> to get full position details.</li> <li>Connection required: You must call <code>connect_by_host_port()</code> or <code>connect_by_server_name()</code> before using this method.</li> <li>Real-time count: The count reflects the current state at the time of the call.</li> <li>Thread safety: All async methods are safe to call concurrently from multiple asyncio tasks.</li> <li>UUID handling: The terminal instance UUID is auto-generated by the server if not provided. For explicit control (e.g., in streaming scenarios), pass <code>id_=uuid4()</code> to constructor.</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#1-get-total-open-positions","title":"1) Get total open positions","text":"<pre><code>import asyncio\nfrom datetime import datetime, timedelta\nfrom MetaRpcMT5 import MT5Account\n\nasync def main():\n    # Create account instance\n    account = MT5Account(\n        user=12345678,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    # Connect first\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Set deadline\n        deadline = datetime.utcnow() + timedelta(seconds=3)\n\n        # Get total positions\n        data = await account.positions_total(deadline=deadline)\n\n        print(f\"Total open positions: {data.total_positions}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#2-check-if-any-positions-are-open","title":"2) Check if any positions are open","text":"<pre><code>async def has_open_positions(account: MT5Account) -&gt; bool:\n    \"\"\"\n    Check if there are any open positions.\n\n    Returns:\n        True if there are open positions\n    \"\"\"\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    data = await account.positions_total(deadline=deadline)\n\n    has_positions = data.total_positions &gt; 0\n\n    if has_positions:\n        print(f\"[OK] {data.total_positions} position(s) open\")\n    else:\n        print(\"[OK] No open positions\")\n\n    return has_positions\n\n# Usage:\nif await has_open_positions(account):\n    print(\"Account has active positions\")\nelse:\n    print(\"Account is flat\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#3-position-limit-checker","title":"3) Position limit checker","text":"<pre><code>async def check_position_limit(account: MT5Account, max_positions: int = 5) -&gt; bool:\n    \"\"\"\n    Check if current position count is below limit.\n\n    Args:\n        account: MT5Account instance\n        max_positions: Maximum allowed open positions\n\n    Returns:\n        True if can open more positions\n    \"\"\"\n    data = await account.positions_total()\n\n    current = data.total_positions\n\n    if current &gt;= max_positions:\n        print(f\"[WARNING] Position limit reached: {current}/{max_positions}\")\n        return False\n\n    remaining = max_positions - current\n    print(f\"[OK] Can open {remaining} more position(s)\")\n    return True\n\n# Usage:\nif await check_position_limit(account, max_positions=5):\n    # Place new order\n    pass\nelse:\n    print(\"Cannot open new position - limit reached\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#4-monitor-position-count","title":"4) Monitor position count","text":"<pre><code>async def monitor_positions(account: MT5Account, interval: float = 5.0):\n    \"\"\"\n    Monitor position count every N seconds.\n\n    Args:\n        account: MT5Account instance\n        interval: Update interval in seconds\n    \"\"\"\n    previous_count = None\n\n    while True:\n        try:\n            deadline = datetime.utcnow() + timedelta(seconds=3)\n            data = await account.positions_total(deadline=deadline)\n\n            count = data.total_positions\n\n            if previous_count is not None and count != previous_count:\n                if count &gt; previous_count:\n                    print(f\"[+] Position opened: {count} total\")\n                else:\n                    print(f\"[-] Position closed: {count} total\")\n            else:\n                print(f\"[{datetime.now().strftime('%H:%M:%S')}] Positions: {count}\")\n\n            previous_count = count\n\n        except Exception as e:\n            print(f\"[ERROR] {e}\")\n\n        await asyncio.sleep(interval)\n\n# Usage:\n# await monitor_positions(account, interval=5.0)  # Update every 5 seconds\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#5-pre-trade-validation","title":"5) Pre-trade validation","text":"<pre><code>async def validate_can_trade(account: MT5Account, max_positions: int = 10) -&gt; bool:\n    \"\"\"\n    Validate account can accept new positions.\n\n    Args:\n        account: MT5Account instance\n        max_positions: Maximum concurrent positions allowed\n\n    Returns:\n        True if trading is allowed\n    \"\"\"\n    # Get position count\n    data = await account.positions_total()\n    count = data.total_positions\n\n    # Check position limit\n    if count &gt;= max_positions:\n        print(f\"[ERROR] Position limit exceeded: {count}/{max_positions}\")\n        return False\n\n    print(f\"[OK] Current positions: {count}/{max_positions}\")\n    return True\n\n# Usage:\nif await validate_can_trade(account, max_positions=10):\n    # Place order\n    pass\nelse:\n    print(\"Trading blocked - too many positions\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#6-wait-for-positions-to-close","title":"6) Wait for positions to close","text":"<pre><code>async def wait_for_all_closed(\n    account: MT5Account,\n    timeout_seconds: int = 300,\n    check_interval: float = 2.0\n):\n    \"\"\"\n    Wait until all positions are closed.\n\n    Args:\n        account: MT5Account instance\n        timeout_seconds: Maximum time to wait\n        check_interval: How often to check\n\n    Raises:\n        TimeoutError: If positions don't close within timeout\n    \"\"\"\n    import time\n    start_time = time.time()\n\n    print(\"Waiting for all positions to close...\")\n\n    while True:\n        # Check timeout\n        elapsed = time.time() - start_time\n        if elapsed &gt; timeout_seconds:\n            data = await account.positions_total()\n            raise TimeoutError(\n                f\"Timeout: {data.total_positions} position(s) still open after {timeout_seconds}s\"\n            )\n\n        # Get position count\n        data = await account.positions_total()\n        count = data.total_positions\n\n        if count == 0:\n            print(\"[OK] All positions closed\")\n            return\n\n        print(f\"[INFO] Waiting... {count} position(s) still open\")\n        await asyncio.sleep(check_interval)\n\n# Usage:\ntry:\n    await wait_for_all_closed(account, timeout_seconds=300)\nexcept TimeoutError as e:\n    print(f\"[ERROR] {e}\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#7-position-count-alert-system","title":"7) Position count alert system","text":"<pre><code>async def position_alert_system(\n    account: MT5Account,\n    warning_threshold: int = 8,\n    critical_threshold: int = 10,\n    interval: float = 10.0\n):\n    \"\"\"\n    Alert when position count reaches thresholds.\n\n    Args:\n        account: MT5Account instance\n        warning_threshold: Warn at this count\n        critical_threshold: Critical at this count\n        interval: Check interval in seconds\n    \"\"\"\n    while True:\n        try:\n            data = await account.positions_total()\n            count = data.total_positions\n\n            if count &gt;= critical_threshold:\n                print(f\"[CRITICAL] {count} positions - at limit!\")\n            elif count &gt;= warning_threshold:\n                print(f\"[WARNING] {count} positions - approaching limit\")\n            else:\n                print(f\"[OK] {count} positions\")\n\n        except Exception as e:\n            print(f\"[ERROR] {e}\")\n\n        await asyncio.sleep(interval)\n\n# Usage:\n# await position_alert_system(account, warning_threshold=8, critical_threshold=10)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#8-compare-position-count-with-target","title":"8) Compare position count with target","text":"<pre><code>async def compare_with_target(\n    account: MT5Account,\n    target_positions: int\n) -&gt; dict:\n    \"\"\"\n    Compare current positions with target.\n\n    Args:\n        account: MT5Account instance\n        target_positions: Target number of positions\n\n    Returns:\n        Dictionary with comparison data\n    \"\"\"\n    data = await account.positions_total()\n    current = data.total_positions\n\n    difference = current - target_positions\n\n    result = {\n        \"current\": current,\n        \"target\": target_positions,\n        \"difference\": difference,\n        \"status\": \"exact\" if difference == 0 else \"above\" if difference &gt; 0 else \"below\"\n    }\n\n    if difference == 0:\n        print(f\"[OK] Exactly at target: {current} positions\")\n    elif difference &gt; 0:\n        print(f\"[INFO] {abs(difference)} above target ({current}/{target_positions})\")\n    else:\n        print(f\"[INFO] {abs(difference)} below target ({current}/{target_positions})\")\n\n    return result\n\n# Usage:\nresult = await compare_with_target(account, target_positions=5)\nprint(f\"Status: {result['status']}\")\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#common-patterns","title":"Common Patterns","text":""},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#quick-position-check","title":"Quick position check","text":"<pre><code>async def is_flat(account: MT5Account) -&gt; bool:\n    \"\"\"Check if account has no open positions\"\"\"\n    data = await account.positions_total()\n    return data.total_positions == 0\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#position-limit-guard","title":"Position limit guard","text":"<pre><code>async def can_open_position(\n    account: MT5Account,\n    max_concurrent: int = 10\n) -&gt; bool:\n    \"\"\"Check if can open another position\"\"\"\n    data = await account.positions_total()\n    return data.total_positions &lt; max_concurrent\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#risk-check-before-trading","title":"Risk check before trading","text":"<pre><code>async def pre_trade_risk_check(account: MT5Account) -&gt; bool:\n    \"\"\"Comprehensive risk check before trading\"\"\"\n    data = await account.positions_total()\n\n    # No more than 10 concurrent positions\n    if data.total_positions &gt;= 10:\n        print(\"[ERROR] Too many open positions\")\n        return False\n\n    print(f\"[OK] Risk check passed ({data.total_positions} positions)\")\n    return True\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/positions_total/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>opened_orders - Get full details of all open orders and positions</li> <li>opened_orders_tickets - Get ticket IDs only (lighter than opened_orders)</li> <li>positions_history - Get historical closed positions</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/","title":"Get Tick Value and Contract Size for Symbols","text":"<p>Request: tick value and contract size information for multiple symbols.</p> <p>API Information:</p> <ul> <li>Low-level API: <code>MT5Account.tick_value_with_size(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.AccountHelper</code></li> <li>Proto definition: <code>TickValueWithSize</code> (defined in <code>mt5-term-api-account-helper.proto</code>)</li> <li>Enums in this method: 0 enums (simple data structure)</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.AccountHelper</code></li> <li>Method: <code>TickValueWithSize(TickValueWithSizeRequest) -&gt; TickValueWithSizeReply</code></li> <li>Low-level client (generated): <code>AccountHelperStub.TickValueWithSize(request, metadata, timeout)</code></li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Get tick values and contract sizes for multiple symbols in one call.</li> <li>Why you need it. Calculate position value, margin requirements, and profit/loss in account currency.</li> <li>When to use. Use before trading to understand tick value and contract size for risk calculation.</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to get critical trading parameters:</p> <ul> <li>Get tick value (value of one tick movement)</li> <li>Get tick size (minimum price change)</li> <li>Get contract size (lot size)</li> <li>Calculate profit/loss per tick</li> <li>Understand margin requirements</li> <li>Batch query multiple symbols efficiently</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: -&gt; tick_value_with_size - How it works</p>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#method-signature","title":"Method Signature","text":"<pre><code>async def tick_value_with_size(\n    self,\n    symbols: list[str],\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; account_helper_pb2.TickValueWithSizeData\n</code></pre> <p>Request message:</p> <pre><code>message TickValueWithSizeRequest {\n  repeated string symbol_names = 1;\n}\n</code></pre> <p>Reply message:</p> <pre><code>message TickValueWithSizeReply {\n  TickValueWithSizeData data = 1;\n  Error error = 2;\n}\n\nmessage TickValueWithSizeData {\n  repeated TickSizeSymbol symbol_tick_size_infos = 1;\n}\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbols</code> <code>list[str]</code> (required) List of symbol names to query <code>deadline</code> <code>datetime</code> (optional) Deadline for the gRPC call (UTC datetime) <code>cancellation_event</code> <code>asyncio.Event</code> (optional) Event to cancel the operation <p>Usage:</p> <pre><code>from datetime import datetime, timedelta\n\n# Query multiple symbols\nsymbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\n\ndeadline = datetime.utcnow() + timedelta(seconds=5)\ndata = await account.tick_value_with_size(\n    symbols=symbols,\n    deadline=deadline\n)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#output-tickvaluewithsizedata","title":"\u2b06\ufe0f Output - <code>TickValueWithSizeData</code>","text":"Field Type Python Type Description <code>symbol_tick_size_infos</code> <code>repeated TickSizeSymbol</code> <code>list[TickSizeSymbol]</code> List of tick value/size info per symbol <p>Each TickSizeSymbol contains:</p> Field Type Python Type Description <code>Index</code> <code>int32</code> <code>int</code> Index in the result set <code>Name</code> <code>string</code> <code>str</code> Symbol name <code>TradeTickValue</code> <code>double</code> <code>float</code> Tick value (for both profit and loss) <code>TradeTickValueProfit</code> <code>double</code> <code>float</code> Tick value for profit calculation <code>TradeTickValueLoss</code> <code>double</code> <code>float</code> Tick value for loss calculation <code>TradeTickSize</code> <code>double</code> <code>float</code> Minimum price change (tick size) <code>TradeContractSize</code> <code>double</code> <code>float</code> Contract size (lot size, e.g., 100000 for EURUSD)"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Batch query: Query multiple symbols in one call for efficiency.</li> <li>Tick value: The value in account currency of one tick movement.</li> <li>Contract size: The size of one standard lot (e.g., 100000 units for EURUSD).</li> <li>Profit/Loss calculation: Use tick value and tick size to calculate P/L per pip/tick.</li> <li>Automatic reconnection: Built-in protection against transient gRPC errors.</li> <li>Connection required: Call <code>connect_by_host_port()</code> or <code>connect_by_server_name()</code> first.</li> <li>Thread safety: Safe to call concurrently from multiple asyncio tasks.</li> </ul>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#1-get-tick-values-for-multiple-symbols","title":"1) Get tick values for multiple symbols","text":"<pre><code>import asyncio\nfrom datetime import datetime, timedelta\nfrom MetaRpcMT5 import MT5Account\n\nasync def main():\n    account = MT5Account(\n        user=12345678,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\n        deadline = datetime.utcnow() + timedelta(seconds=5)\n\n        data = await account.tick_value_with_size(\n            symbols=symbols,\n            deadline=deadline\n        )\n\n        for info in data.symbol_tick_size_infos:\n            print(f\"\\n{info.Name}:\")\n            print(f\"  Tick Value: ${info.TradeTickValue:.2f}\")\n            print(f\"  Tick Size: {info.TradeTickSize}\")\n            print(f\"  Contract Size: {info.TradeContractSize:.0f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#2-calculate-profit-per-pip","title":"2) Calculate profit per pip","text":"<pre><code>async def calculate_profit_per_pip(\n    account: MT5Account,\n    symbol: str,\n    lots: float\n) -&gt; float:\n    \"\"\"Calculate profit per pip for given symbol and volume\"\"\"\n    data = await account.tick_value_with_size(symbols=[symbol])\n\n    if not data.symbol_tick_size_infos:\n        raise ValueError(f\"Symbol {symbol} not found\")\n\n    info = data.symbol_tick_size_infos[0]\n\n    # Calculate profit per pip (assuming 10 ticks per pip for most pairs)\n    profit_per_pip = info.TradeTickValue * 10 * lots\n\n    print(f\"{symbol}:\")\n    print(f\"  Volume: {lots} lots\")\n    print(f\"  Profit per pip: ${profit_per_pip:.2f}\")\n\n    return profit_per_pip\n\n# Usage:\nprofit_per_pip = await calculate_profit_per_pip(account, \"EURUSD\", 1.0)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#3-calculate-margin-requirement","title":"3) Calculate margin requirement","text":"<pre><code>async def calculate_margin(\n    account: MT5Account,\n    symbol: str,\n    lots: float,\n    price: float,\n    leverage: int\n) -&gt; float:\n    \"\"\"Calculate margin requirement for position\"\"\"\n    data = await account.tick_value_with_size(symbols=[symbol])\n\n    if not data.symbol_tick_size_infos:\n        raise ValueError(f\"Symbol {symbol} not found\")\n\n    info = data.symbol_tick_size_infos[0]\n\n    # Margin = (Contract Size * Lots * Price) / Leverage\n    contract_value = info.TradeContractSize * lots * price\n    margin = contract_value / leverage\n\n    print(f\"Margin calculation for {symbol}:\")\n    print(f\"  Volume: {lots} lots\")\n    print(f\"  Price: {price}\")\n    print(f\"  Leverage: 1:{leverage}\")\n    print(f\"  Contract Size: {info.TradeContractSize:.0f}\")\n    print(f\"  Required Margin: ${margin:.2f}\")\n\n    return margin\n\n# Usage:\nmargin = await calculate_margin(account, \"EURUSD\", 1.0, 1.10000, 100)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#4-get-tick-info-for-all-major-pairs","title":"4) Get tick info for all major pairs","text":"<pre><code>async def get_major_pairs_info(account: MT5Account):\n    \"\"\"Get tick value info for major currency pairs\"\"\"\n    major_pairs = [\n        \"EURUSD\", \"GBPUSD\", \"USDJPY\", \"USDCHF\",\n        \"AUDUSD\", \"USDCAD\", \"NZDUSD\"\n    ]\n\n    data = await account.tick_value_with_size(symbols=major_pairs)\n\n    print(\"\\nMajor Pairs Tick Information:\")\n    print(f\"{'Symbol':&lt;10} {'Tick Value':&lt;12} {'Tick Size':&lt;12} {'Contract Size':&lt;15}\")\n    print(\"-\" * 60)\n\n    for info in data.symbol_tick_size_infos:\n        print(f\"{info.Name:&lt;10} ${info.TradeTickValue:&lt;11.2f} \"\n              f\"{info.TradeTickSize:&lt;12} {info.TradeContractSize:&lt;15.0f}\")\n\n    return data\n\n# Usage:\nawait get_major_pairs_info(account)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#5-calculate-position-value","title":"5) Calculate position value","text":"<pre><code>async def calculate_position_value(\n    account: MT5Account,\n    symbol: str,\n    lots: float,\n    price: float\n) -&gt; dict:\n    \"\"\"Calculate total position value\"\"\"\n    data = await account.tick_value_with_size(symbols=[symbol])\n\n    if not data.symbol_tick_size_infos:\n        raise ValueError(f\"Symbol {symbol} not found\")\n\n    info = data.symbol_tick_size_infos[0]\n\n    # Position value = Contract Size * Lots * Price\n    position_value = info.TradeContractSize * lots * price\n\n    result = {\n        \"symbol\": symbol,\n        \"lots\": lots,\n        \"price\": price,\n        \"contract_size\": info.TradeContractSize,\n        \"position_value\": position_value,\n        \"tick_value\": info.TradeTickValue,\n        \"tick_size\": info.TradeTickSize\n    }\n\n    print(f\"\\nPosition Value Calculation:\")\n    print(f\"  Symbol: {symbol}\")\n    print(f\"  Volume: {lots} lots\")\n    print(f\"  Price: {price}\")\n    print(f\"  Contract Size: {info.TradeContractSize:.0f}\")\n    print(f\"  Position Value: ${position_value:,.2f}\")\n\n    return result\n\n# Usage:\nvalue = await calculate_position_value(account, \"EURUSD\", 1.0, 1.10000)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#6-compare-tick-values-across-symbols","title":"6) Compare tick values across symbols","text":"<pre><code>async def compare_tick_values(account: MT5Account, symbols: list[str]):\n    \"\"\"Compare tick values across multiple symbols\"\"\"\n    data = await account.tick_value_with_size(symbols=symbols)\n\n    # Sort by tick value\n    sorted_infos = sorted(\n        data.symbol_tick_size_infos,\n        key=lambda x: x.TradeTickValue,\n        reverse=True\n    )\n\n    print(\"\\nSymbols sorted by tick value:\")\n    for i, info in enumerate(sorted_infos, 1):\n        print(f\"{i}. {info.Name}: ${info.TradeTickValue:.2f} per tick\")\n\n    return sorted_infos\n\n# Usage:\nsymbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\", \"GOLD\", \"OIL\"]\nawait compare_tick_values(account, symbols)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#7-calculate-stop-loss-distance","title":"7) Calculate stop loss distance","text":"<pre><code>async def calculate_sl_distance(\n    account: MT5Account,\n    symbol: str,\n    lots: float,\n    max_loss: float\n) -&gt; float:\n    \"\"\"Calculate maximum SL distance for given max loss\"\"\"\n    data = await account.tick_value_with_size(symbols=[symbol])\n\n    if not data.symbol_tick_size_infos:\n        raise ValueError(f\"Symbol {symbol} not found\")\n\n    info = data.symbol_tick_size_infos[0]\n\n    # Calculate pips allowed\n    profit_per_pip = info.TradeTickValue * 10 * lots\n    max_pips = max_loss / profit_per_pip if profit_per_pip &gt; 0 else 0\n\n    print(f\"\\nStop Loss Calculation for {symbol}:\")\n    print(f\"  Volume: {lots} lots\")\n    print(f\"  Max Loss: ${max_loss:.2f}\")\n    print(f\"  Profit per pip: ${profit_per_pip:.2f}\")\n    print(f\"  Max SL distance: {max_pips:.1f} pips\")\n\n    return max_pips\n\n# Usage:\nmax_pips = await calculate_sl_distance(account, \"EURUSD\", 1.0, 100.0)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#8-validate-symbols-exist","title":"8) Validate symbols exist","text":"<pre><code>async def validate_symbols(\n    account: MT5Account,\n    symbols: list[str]\n) -&gt; dict:\n    \"\"\"Check which symbols are valid and available\"\"\"\n    data = await account.tick_value_with_size(symbols=symbols)\n\n    returned_symbols = {info.Name for info in data.symbol_tick_size_infos}\n    requested_symbols = set(symbols)\n\n    valid = list(returned_symbols)\n    invalid = list(requested_symbols - returned_symbols)\n\n    result = {\n        \"valid\": valid,\n        \"invalid\": invalid,\n        \"valid_count\": len(valid),\n        \"invalid_count\": len(invalid)\n    }\n\n    print(f\"\\nSymbol Validation:\")\n    print(f\"  Valid symbols: {valid}\")\n    if invalid:\n        print(f\"  Invalid symbols: {invalid}\")\n\n    return result\n\n# Usage:\nsymbols = [\"EURUSD\", \"INVALID_SYMBOL\", \"GBPUSD\"]\nvalidation = await validate_symbols(account, symbols)\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#common-patterns","title":"Common Patterns","text":""},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#get-tick-value-for-single-symbol","title":"Get tick value for single symbol","text":"<pre><code>async def get_symbol_tick_value(account: MT5Account, symbol: str) -&gt; float:\n    \"\"\"Get tick value for single symbol\"\"\"\n    data = await account.tick_value_with_size(symbols=[symbol])\n    if data.symbol_tick_size_infos:\n        return data.symbol_tick_size_infos[0].TradeTickValue\n    return 0.0\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#calculate-risk-per-position","title":"Calculate risk per position","text":"<pre><code>async def calculate_risk(\n    account: MT5Account,\n    symbol: str,\n    lots: float,\n    sl_pips: float\n) -&gt; float:\n    \"\"\"Calculate risk amount for position with SL\"\"\"\n    data = await account.tick_value_with_size(symbols=[symbol])\n    if not data.symbol_tick_size_infos:\n        return 0.0\n\n    info = data.symbol_tick_size_infos[0]\n    profit_per_pip = info.TradeTickValue * 10 * lots\n    risk = profit_per_pip * sl_pips\n\n    return risk\n</code></pre>"},{"location":"MT5Account/3.%20Positions_Orders/tick_value_with_size/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>opened_orders - Get currently open positions</li> <li>positions_total - Get count of open positions</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/Market_Depth.Overview/","title":"MT5Account - Market Depth - Overview","text":"<p>Subscribe to, retrieve, and manage Depth of Market (DOM) data: monitor order book, analyze liquidity, track bid/ask levels.</p>"},{"location":"MT5Account/4.%20Market_Depth/Market_Depth.Overview/#what-lives-here","title":"\ud83d\udcc1 What lives here","text":""},{"location":"MT5Account/4.%20Market_Depth/Market_Depth.Overview/#dom-operations","title":"DOM Operations","text":"<ul> <li>market_book_add - subscribe to DOM updates for a symbol.</li> <li>market_book_get - retrieve current DOM data.</li> <li>market_book_release - unsubscribe from DOM updates.</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/Market_Depth.Overview/#step-by-step-tutorials","title":"\ud83d\udcda Step-by-step tutorials","text":"<p>Note: All DOM operations are async methods. Check individual method pages for detailed examples.</p> <ul> <li>market_book_add - Subscription examples</li> <li>market_book_get - DOM analysis patterns</li> <li>market_book_release - Resource cleanup examples</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/Market_Depth.Overview/#plain-english","title":"\ud83e\udded Plain English","text":"<ul> <li>market_book_add -&gt; subscribe to Level 2 market data (order book).</li> <li>market_book_get -&gt; retrieve current DOM snapshot with bid/ask levels.</li> <li>market_book_release -&gt; unsubscribe and free resources when done.</li> </ul> <p>Rule of thumb: subscribe once with <code>market_book_add</code>, poll repeatedly with <code>market_book_get</code>, cleanup with <code>market_book_release</code>.</p>"},{"location":"MT5Account/4.%20Market_Depth/Market_Depth.Overview/#quick-choose","title":"Quick choose","text":"If you need... Use Returns Key inputs Subscribe to DOM updates <code>market_book_add</code> MarketBookAddData symbol Get current order book snapshot <code>market_book_get</code> MarketBookGetData symbol Unsubscribe from DOM <code>market_book_release</code> MarketBookReleaseData symbol Analyze bid/ask liquidity <code>market_book_get</code> MarketBookGetData symbol Monitor order flow <code>market_book_get</code> MarketBookGetData symbol (in loop) Find support/resistance levels <code>market_book_get</code> MarketBookGetData symbol"},{"location":"MT5Account/4.%20Market_Depth/Market_Depth.Overview/#i-cross-refs-gotchas","title":"\u2139\ufe0f Cross-refs &amp; gotchas","text":"<ul> <li>Broker support: Not all brokers provide DOM data - check with your broker.</li> <li>Subscription required: Must call <code>market_book_add</code> before <code>market_book_get</code>.</li> <li>Symbol must be selected: Ensure symbol is in Market Watch before subscribing.</li> <li>Always release: Call <code>market_book_release</code> when done to free resources.</li> <li>Empty data: Returns empty list if no DOM data available or not subscribed.</li> <li>Async methods: All DOM operations are async - use <code>await</code>.</li> <li>Automatic reconnection: All methods have built-in reconnection via <code>execute_with_reconnect</code>.</li> <li>Per-symbol basis: Subscribe/unsubscribe each symbol separately.</li> <li>Type enum: In <code>MrpcMqlBookInfo</code>, type 1 = SELL orders, type 2 = BUY orders.</li> <li>Volume fields: Use <code>volume_real</code> (double) instead of <code>volume</code> (int64).</li> <li>Real-time data: DOM is updated in real-time, call <code>market_book_get</code> repeatedly for monitoring.</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/Market_Depth.Overview/#minimal-snippets","title":"\ud83d\udfe2 Minimal snippets","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\n# Subscribe to DOM\nasync def subscribe_dom():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Subscribe to EURUSD DOM\n        result = await account.market_book_add(\"EURUSD\")\n\n        if result.opened_successfully:\n            print(f\"[SUCCESS] Subscribed to EURUSD DOM\")\n        else:\n            print(f\"[FAILED] Could not subscribe\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(subscribe_dom())\n</code></pre> <pre><code># Get DOM data\nasync def get_dom():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Subscribe first\n        await account.market_book_add(\"EURUSD\")\n\n        # Get DOM snapshot\n        dom_data = await account.market_book_get(\"EURUSD\")\n\n        print(f\"[DOM] EURUSD has {len(dom_data.mql_book_infos)} levels\")\n\n        for entry in dom_data.mql_book_infos[:5]:  # Show first 5\n            entry_type = \"SELL\" if entry.type in [0, 2] else \"BUY\"\n            print(f\"{entry_type:&lt;6} {entry.price:.5f} Vol: {entry.volume_real:.2f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(get_dom())\n</code></pre> <pre><code># Unsubscribe from DOM\nasync def unsubscribe_dom():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Subscribe\n        await account.market_book_add(\"EURUSD\")\n\n        # Do analysis...\n        dom_data = await account.market_book_get(\"EURUSD\")\n        print(f\"[ANALYSIS] {len(dom_data.mql_book_infos)} levels\")\n\n        # Unsubscribe when done\n        result = await account.market_book_release(\"EURUSD\")\n\n        if result.closed_successfully:\n            print(f\"[SUCCESS] DOM released\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(unsubscribe_dom())\n</code></pre> <pre><code># Complete DOM workflow\nasync def dom_workflow():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    symbol = \"EURUSD\"\n\n    try:\n        # 1. Subscribe to DOM\n        add_result = await account.market_book_add(symbol)\n        if not add_result.opened_successfully:\n            print(f\"[ERROR] Could not subscribe to {symbol}\")\n            return\n\n        print(f\"[1] Subscribed to {symbol} DOM\")\n\n        # 2. Monitor DOM for 10 seconds\n        print(f\"[2] Monitoring DOM...\")\n\n        for i in range(10):\n            dom_data = await account.market_book_get(symbol)\n\n            # Calculate liquidity\n            sell_volume = sum(e.volume_real for e in dom_data.mql_book_infos if e.type in [0, 2])\n            buy_volume = sum(e.volume_real for e in dom_data.mql_book_infos if e.type in [1, 3])\n\n            print(f\"  [{i+1}/10] Levels: {len(dom_data.mql_book_infos)}, \"\n                  f\"BUY: {buy_volume:.2f}, SELL: {sell_volume:.2f}\")\n\n            await asyncio.sleep(1)\n\n        # 3. Unsubscribe\n        release_result = await account.market_book_release(symbol)\n        if release_result.closed_successfully:\n            print(f\"[3] DOM released successfully\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(dom_workflow())\n</code></pre> <pre><code># Analyze bid/ask spread\nasync def analyze_spread():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        symbol = \"EURUSD\"\n\n        # Subscribe and get DOM\n        await account.market_book_add(symbol)\n        dom_data = await account.market_book_get(symbol)\n\n        # Separate buy and sell orders\n        sell_orders = [e for e in dom_data.mql_book_infos if e.type in [0, 2]]\n        buy_orders = [e for e in dom_data.mql_book_infos if e.type in [1, 3]]\n\n        if sell_orders and buy_orders:\n            best_ask = min(sell_orders, key=lambda x: x.price)\n            best_bid = max(buy_orders, key=lambda x: x.price)\n\n            spread = best_ask.price - best_bid.price\n            spread_pips = spread / 0.0001\n\n            print(f\"[SPREAD] {symbol}\")\n            print(f\"  Best Bid: {best_bid.price:.5f}\")\n            print(f\"  Best Ask: {best_ask.price:.5f}\")\n            print(f\"  Spread: {spread_pips:.1f} pips\")\n\n        # Cleanup\n        await account.market_book_release(symbol)\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(analyze_spread())\n</code></pre> <pre><code># Monitor multiple symbols\nasync def monitor_multiple_symbols():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\n\n    try:\n        # Subscribe to all symbols\n        for symbol in symbols:\n            result = await account.market_book_add(symbol)\n            if result.opened_successfully:\n                print(f\"[SUBSCRIBED] {symbol}\")\n\n        # Monitor all symbols\n        print(\"\\n[MONITORING] DOM for all symbols:\")\n\n        for _ in range(5):  # Monitor for 5 iterations\n            print(\"\\n\" + \"=\"*50)\n\n            for symbol in symbols:\n                dom_data = await account.market_book_get(symbol)\n\n                sell_volume = sum(e.volume_real for e in dom_data.mql_book_infos if e.type in [0, 2])\n                buy_volume = sum(e.volume_real for e in dom_data.mql_book_infos if e.type in [1, 3])\n\n                print(f\"{symbol:&lt;8} Levels: {len(dom_data.mql_book_infos):&lt;4} \"\n                      f\"BUY: {buy_volume:&gt;8.2f}  SELL: {sell_volume:&gt;8.2f}\")\n\n            await asyncio.sleep(2)\n\n        # Unsubscribe from all symbols\n        print(\"\\n[RELEASING] All subscriptions...\")\n        for symbol in symbols:\n            await account.market_book_release(symbol)\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(monitor_multiple_symbols())\n</code></pre> <pre><code># Context manager for automatic cleanup\nfrom contextlib import asynccontextmanager\n\n@asynccontextmanager\nasync def dom_subscription(account, symbol):\n    \"\"\"Context manager for automatic DOM subscription cleanup\"\"\"\n    try:\n        result = await account.market_book_add(symbol)\n        if not result.opened_successfully:\n            raise Exception(f\"Failed to subscribe to {symbol} DOM\")\n        yield\n    finally:\n        await account.market_book_release(symbol)\n\nasync def main():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # DOM is automatically released on exit\n        async with dom_subscription(account, \"EURUSD\"):\n            dom_data = await account.market_book_get(\"EURUSD\")\n            print(f\"[DOM] {len(dom_data.mql_book_infos)} levels\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre> <pre><code># Find key liquidity levels\nasync def find_key_levels():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        symbol = \"EURUSD\"\n\n        await account.market_book_add(symbol)\n        dom_data = await account.market_book_get(symbol)\n\n        # Find top 5 volume levels\n        sorted_levels = sorted(dom_data.mql_book_infos,\n                             key=lambda x: x.volume_real,\n                             reverse=True)\n\n        print(f\"[KEY LEVELS] {symbol} - Top 5 volume levels:\\n\")\n\n        for i, entry in enumerate(sorted_levels[:5], 1):\n            entry_type = \"SELL\" if entry.type in [0, 2] else \"BUY\"\n            print(f\"{i}. {entry_type:&lt;6} {entry.price:.5f} - {entry.volume_real:.2f} lots\")\n\n        # Cleanup\n        await account.market_book_release(symbol)\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(find_key_levels())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/Market_Depth.Overview/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>Symbols: symbol_select - add symbol to Market Watch before subscribing</li> <li>Prices: symbol_info_tick - get current tick prices</li> <li>Streaming: on_symbol_tick - real-time tick stream</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/","title":"Subscribe to Market Depth (DOM)","text":"<p>Request: Subscribe to Depth of Market (order book) updates for a symbol.</p> <p>API Information:</p> <ul> <li>Python API: <code>MT5Account.market_book_add(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>MarketBookAdd</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> <li>Enums in this method: 0 enums (simple boolean result)</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>MarketBookAdd(MarketBookAddRequest) -&gt; MarketBookAddReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.MarketBookAdd(request, metadata)</code></li> </ul> <pre><code>from MetaRpcMT5 import MT5Account\n\nclass MT5Account:\n    # ...\n\n    async def market_book_add(\n        self,\n        symbol: str,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ) -&gt; market_info_pb2.MarketBookAddData:\n        \"\"\"\n        Opens the Depth of Market (DOM) for a symbol and subscribes to updates.\n\n        Returns:\n            MarketBookAddData: Subscription result.\n        \"\"\"\n</code></pre> <p>Request message:</p> <pre><code>MarketBookAddRequest {\n  string symbol = 1;  // Symbol name\n}\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> Symbol name (e.g., \"EURUSD\") <code>deadline</code> <code>Optional[datetime]</code> Deadline for the operation (optional) <code>cancellation_event</code> <code>Optional[asyncio.Event]</code> Event to cancel the request (optional)"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#output","title":"\u2b06\ufe0f Output","text":"<p>Returns <code>MarketBookAddData</code> object.</p> <p>MarketBookAddData fields:</p> Field Type Description <code>opened_successfully</code> <code>bool</code> True if subscription was successful"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Subscribes to Level 2 market data (order book) for a symbol.</li> <li>Why you need it. Required before you can call <code>market_book_get</code> to retrieve DOM data.</li> <li>One-time subscription. Call once per symbol, then use <code>market_book_get</code> to fetch data.</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to:</p> <ul> <li>Subscribe to market depth (DOM) updates</li> <li>Enable Level 2 data access for a symbol</li> <li>Prepare for order book analysis</li> <li>Monitor bid/ask liquidity levels</li> <li>Analyze market microstructure</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: market_book_add - How it works</p>"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Subscription required: Must call this before <code>market_book_get</code>.</li> <li>Symbol must be selected: Ensure symbol is in Market Watch before subscribing.</li> <li>Broker support: Not all brokers provide DOM data.</li> <li>Resource cleanup: Call <code>market_book_release</code> when done to unsubscribe.</li> <li>One subscription: You only need to subscribe once per symbol.</li> <li>Check success: Always verify <code>opened_successfully == True</code>.</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#1-subscribe-to-dom-for-eurusd","title":"1) Subscribe to DOM for EURUSD","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def subscribe_dom():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Subscribe to DOM\n        result = await account.market_book_add(\"EURUSD\")\n\n        if result.opened_successfully:\n            print(f\"[SUCCESS] Subscribed to EURUSD DOM\")\n        else:\n            print(f\"[FAILED] Could not subscribe to DOM\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(subscribe_dom())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#2-subscribe-and-verify","title":"2) Subscribe and verify","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def subscribe_and_verify():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        symbol = \"EURUSD\"\n\n        # First, ensure symbol is selected in Market Watch\n        await account.symbol_select(symbol=symbol, select=True)\n        print(f\"[1] Symbol {symbol} selected in Market Watch\")\n\n        # Now subscribe to DOM\n        result = await account.market_book_add(symbol)\n\n        if result.opened_successfully:\n            print(f\"[2] Successfully subscribed to {symbol} DOM\")\n\n            # Verify by getting DOM data\n            dom_data = await account.market_book_get(symbol)\n            print(f\"[3] DOM has {len(dom_data.mql_book_infos)} levels\")\n        else:\n            print(f\"[2] Failed to subscribe to DOM\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(subscribe_and_verify())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#3-subscribe-to-multiple-symbols","title":"3) Subscribe to multiple symbols","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def subscribe_multiple():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\n\n    try:\n        for symbol in symbols:\n            result = await account.market_book_add(symbol)\n\n            if result.opened_successfully:\n                print(f\"[OK] {symbol} - DOM subscribed\")\n            else:\n                print(f\"[FAIL] {symbol} - Could not subscribe\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(subscribe_multiple())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#4-subscribe-with-error-handling","title":"4) Subscribe with error handling","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account, ApiExceptionMT5\n\nasync def subscribe_with_error_handling():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    symbol = \"EURUSD\"\n\n    try:\n        # Subscribe to DOM\n        result = await account.market_book_add(symbol)\n\n        if result.opened_successfully:\n            print(f\"[SUCCESS] Subscribed to {symbol} DOM\")\n            return True\n        else:\n            print(f\"[WARNING] Subscription returned false\")\n            return False\n\n    except ApiExceptionMT5 as e:\n        print(f\"[API ERROR] {e}\")\n        return False\n\n    except Exception as e:\n        print(f\"[ERROR] Unexpected error: {e}\")\n        return False\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(subscribe_with_error_handling())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#5-check-broker-dom-support","title":"5) Check broker DOM support","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def check_dom_support():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    test_symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\", \"XAUUSD\"]\n\n    try:\n        print(\"Checking DOM support for symbols:\\n\")\n        print(f\"{'Symbol':&lt;10} {'DOM Support':&lt;15}\")\n        print(\"-\" * 30)\n\n        for symbol in test_symbols:\n            try:\n                result = await account.market_book_add(symbol)\n\n                if result.opened_successfully:\n                    # Try to get DOM data\n                    dom_data = await account.market_book_get(symbol)\n\n                    if len(dom_data.mql_book_infos) &gt; 0:\n                        print(f\"{symbol:&lt;10} {'YES ('+str(len(dom_data.mql_book_infos))+' levels)':&lt;15}\")\n                    else:\n                        print(f\"{symbol:&lt;10} {'NO DATA':&lt;15}\")\n\n                    # Clean up\n                    await account.market_book_release(symbol)\n                else:\n                    print(f\"{symbol:&lt;10} {'NOT SUPPORTED':&lt;15}\")\n\n            except Exception as e:\n                print(f\"{symbol:&lt;10} {'ERROR':&lt;15}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(check_dom_support())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#6-subscribe-and-monitor-dom","title":"6) Subscribe and monitor DOM","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def monitor_dom(symbol: str, duration: int = 10):\n    \"\"\"Subscribe and monitor DOM for specified duration\"\"\"\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Subscribe to DOM\n        result = await account.market_book_add(symbol)\n\n        if not result.opened_successfully:\n            print(f\"[FAILED] Could not subscribe to {symbol} DOM\")\n            return\n\n        print(f\"[SUBSCRIBED] Monitoring {symbol} DOM for {duration} seconds\\n\")\n\n        start_time = asyncio.get_event_loop().time()\n\n        while (asyncio.get_event_loop().time() - start_time) &lt; duration:\n            # Get current DOM state\n            dom_data = await account.market_book_get(symbol)\n\n            # Clear screen\n            print(\"\\033[2J\\033[H\")\n\n            print(f\"=== {symbol} Market Depth ===\")\n            print(f\"Total levels: {len(dom_data.mql_book_infos)}\\n\")\n\n            print(f\"{'Type':&lt;10} {'Price':&lt;15} {'Volume':&lt;15}\")\n            print(\"-\" * 45)\n\n            for book_entry in dom_data.mql_book_infos[:10]:  # Show first 10 levels\n                entry_type = \"BUY\" if book_entry.type in [1, 3] else \"SELL\"\n                print(f\"{entry_type:&lt;10} {book_entry.price:&lt;15.5f} {book_entry.volume_real:&lt;15.2f}\")\n\n            await asyncio.sleep(1)  # Update every second\n\n        # Unsubscribe when done\n        await account.market_book_release(symbol)\n        print(f\"\\n[UNSUBSCRIBED] Stopped monitoring {symbol} DOM\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(monitor_dom(\"EURUSD\", duration=10))\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_add/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>MarketBookGet - Get current DOM data</li> <li>MarketBookRelease - Unsubscribe from DOM</li> <li>SymbolSelect - Add symbol to Market Watch</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/","title":"Get Market Depth Data","text":"<p>Request: Retrieve current Depth of Market (order book) data for a subscribed symbol.</p> <p>API Information:</p> <ul> <li>Python API: <code>MT5Account.market_book_get(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>MarketBookGet</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> <li>Enums in this method: 1 enum with 4 constants (1 output)</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>MarketBookGet(MarketBookGetRequest) -&gt; MarketBookGetReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.MarketBookGet(request, metadata)</code></li> </ul> <pre><code>from MetaRpcMT5 import MT5Account\n\nclass MT5Account:\n    # ...\n\n    async def market_book_get(\n        self,\n        symbol: str,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ) -&gt; market_info_pb2.MarketBookGetData:\n        \"\"\"\n        Gets the current Depth of Market (DOM) data for a symbol.\n\n        Returns:\n            MarketBookGetData: A list of book entries for the symbol's DOM.\n        \"\"\"\n</code></pre> <p>Request message:</p> <pre><code>MarketBookGetRequest {\n  string symbol = 1;  // Symbol name\n}\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> Symbol name (e.g., \"EURUSD\") <code>deadline</code> <code>Optional[datetime]</code> Deadline for the operation (optional) <code>cancellation_event</code> <code>Optional[asyncio.Event]</code> Event to cancel the request (optional)"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#output","title":"\u2b06\ufe0f Output","text":"<p>Returns <code>MarketBookGetData</code> object.</p> <p>MarketBookGetData fields:</p> Field Type Description <code>mql_book_infos</code> <code>list[MrpcMqlBookInfo]</code> List of order book entries <p>MrpcMqlBookInfo fields:</p> Field Type Description <code>type</code> <code>BookType</code> Order type (enum) <code>price</code> <code>double</code> Price level <code>volume</code> <code>int64</code> Volume in lots (legacy) <code>volume_real</code> <code>double</code> Real volume in lots"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":""},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#booktype","title":"<code>BookType</code>","text":"<p>Used in <code>MrpcMqlBookInfo</code> to indicate order book entry type.</p> Constant Name Value Description <code>BOOK_TYPE_SELL</code> 0 Sell order <code>BOOK_TYPE_BUY</code> 1 Buy order <code>BOOK_TYPE_SELL_MARKET</code> 2 Sell order at market price <code>BOOK_TYPE_BUY_MARKET</code> 3 Buy order at market price <p>Usage: <pre><code>from MetaRpcMT5 import mt5_term_api_market_info_pb2 as market_pb2\n\n# Access enum values\nmarket_pb2.BOOK_TYPE_SELL        # = 0\nmarket_pb2.BOOK_TYPE_BUY         # = 1\n</code></pre></p>"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Retrieves current Level 2 market data (order book) for a symbol.</li> <li>Why you need it. Analyze market depth, bid/ask liquidity, and order flow.</li> <li>Subscription required. Must call <code>market_book_add</code> first.</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to:</p> <ul> <li>Get current DOM snapshot</li> <li>Analyze bid/ask liquidity levels</li> <li>Monitor order book depth</li> <li>Identify support/resistance zones</li> <li>Calculate volume at price levels</li> <li>Detect large orders (iceberg detection)</li> <li>Market microstructure analysis</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: MarketBookGet - How it works</p>"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Subscription required: Must call <code>market_book_add</code> before this method.</li> <li>Empty data: Returns empty list if no DOM data available.</li> <li>Broker support: Not all brokers provide DOM data.</li> <li>Real-time snapshot: Returns current state at the time of request.</li> <li>Volume fields: Use <code>volume_real</code> (double) instead of <code>volume</code> (int64).</li> <li>Price levels: Sorted by price (best bid/ask first).</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#1-get-current-dom-data","title":"1) Get current DOM data","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def get_dom():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # First, subscribe to DOM\n        await account.market_book_add(\"EURUSD\")\n\n        # Get DOM data\n        dom_data = await account.market_book_get(\"EURUSD\")\n\n        print(f\"[DOM] EURUSD Market Depth:\")\n        print(f\"Total levels: {len(dom_data.mql_book_infos)}\\n\")\n\n        print(f\"{'Type':&lt;10} {'Price':&lt;15} {'Volume':&lt;15}\")\n        print(\"-\" * 45)\n\n        for entry in dom_data.mql_book_infos[:10]:  # Show first 10 levels\n            entry_type = \"SELL\" if entry.type in [0, 2] else \"BUY\"\n            print(f\"{entry_type:&lt;10} {entry.price:&lt;15.5f} {entry.volume_real:&lt;15.2f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(get_dom())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#2-analyze-bidask-spread","title":"2) Analyze bid/ask spread","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def analyze_spread():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        symbol = \"EURUSD\"\n\n        # Subscribe and get DOM\n        await account.market_book_add(symbol)\n        dom_data = await account.market_book_get(symbol)\n\n        if not dom_data.mql_book_infos:\n            print(f\"[WARNING] No DOM data available for {symbol}\")\n            return\n\n        # Separate buy and sell orders\n        sell_orders = [e for e in dom_data.mql_book_infos if e.type in [0, 2]]\n        buy_orders = [e for e in dom_data.mql_book_infos if e.type in [1, 3]]\n\n        if sell_orders and buy_orders:\n            best_ask = min(sell_orders, key=lambda x: x.price)\n            best_bid = max(buy_orders, key=lambda x: x.price)\n\n            spread = best_ask.price - best_bid.price\n            spread_pips = spread / 0.0001\n\n            print(f\"[SPREAD ANALYSIS] {symbol}\")\n            print(f\"  Best Bid: {best_bid.price:.5f} (Volume: {best_bid.volume_real:.2f})\")\n            print(f\"  Best Ask: {best_ask.price:.5f} (Volume: {best_ask.volume_real:.2f})\")\n            print(f\"  Spread: {spread:.5f} ({spread_pips:.1f} pips)\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(analyze_spread())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#3-calculate-total-liquidity","title":"3) Calculate total liquidity","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def calculate_liquidity():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        symbol = \"EURUSD\"\n\n        await account.market_book_add(symbol)\n        dom_data = await account.market_book_get(symbol)\n\n        # Calculate total volume by side\n        sell_volume = sum(e.volume_real for e in dom_data.mql_book_infos if e.type in [0, 2])\n        buy_volume = sum(e.volume_real for e in dom_data.mql_book_infos if e.type in [1, 3])\n        total_volume = sell_volume + buy_volume\n\n        print(f\"[LIQUIDITY] {symbol}\")\n        print(f\"  Total DOM levels: {len(dom_data.mql_book_infos)}\")\n        print(f\"  BUY side volume: {buy_volume:.2f} lots\")\n        print(f\"  SELL side volume: {sell_volume:.2f} lots\")\n        print(f\"  Total volume: {total_volume:.2f} lots\")\n\n        if total_volume &gt; 0:\n            buy_percent = (buy_volume / total_volume) * 100\n            sell_percent = (sell_volume / total_volume) * 100\n            print(f\"\\n  BUY: {buy_percent:.1f}% | SELL: {sell_percent:.1f}%\")\n\n            if buy_percent &gt; 60:\n                print(\"  [SIGNAL] Strong BUY side liquidity\")\n            elif sell_percent &gt; 60:\n                print(\"  [SIGNAL] Strong SELL side liquidity\")\n            else:\n                print(\"  [SIGNAL] Balanced liquidity\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(calculate_liquidity())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#4-find-supportresistance-levels","title":"4) Find support/resistance levels","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def find_key_levels():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        symbol = \"EURUSD\"\n\n        await account.market_book_add(symbol)\n        dom_data = await account.market_book_get(symbol)\n\n        # Find top 5 volume levels\n        sorted_levels = sorted(dom_data.mql_book_infos, key=lambda x: x.volume_real, reverse=True)\n\n        print(f\"[KEY LEVELS] {symbol} - Highest Volume Levels:\\n\")\n        print(f\"{'Rank':&lt;6} {'Type':&lt;10} {'Price':&lt;15} {'Volume':&lt;15}\")\n        print(\"-\" * 50)\n\n        for i, entry in enumerate(sorted_levels[:5], 1):\n            entry_type = \"SELL\" if entry.type in [0, 2] else \"BUY\"\n            print(f\"{i:&lt;6} {entry_type:&lt;10} {entry.price:&lt;15.5f} {entry.volume_real:&lt;15.2f}\")\n\n        print(\"\\n[NOTE] Large volume clusters may act as support/resistance\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(find_key_levels())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#5-monitor-dom-imbalance","title":"5) Monitor DOM imbalance","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def monitor_imbalance(duration: int = 30):\n    \"\"\"Monitor DOM imbalance for specified duration\"\"\"\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        symbol = \"EURUSD\"\n\n        await account.market_book_add(symbol)\n        print(f\"[MONITORING] {symbol} DOM imbalance for {duration} seconds\\n\")\n\n        start_time = asyncio.get_event_loop().time()\n\n        while (asyncio.get_event_loop().time() - start_time) &lt; duration:\n            dom_data = await account.market_book_get(symbol)\n\n            # Calculate imbalance\n            sell_volume = sum(e.volume_real for e in dom_data.mql_book_infos if e.type in [0, 2])\n            buy_volume = sum(e.volume_real for e in dom_data.mql_book_infos if e.type in [1, 3])\n\n            if sell_volume + buy_volume &gt; 0:\n                imbalance = ((buy_volume - sell_volume) / (buy_volume + sell_volume)) * 100\n\n                # Clear screen\n                print(\"\\033[2J\\033[H\")\n\n                print(f\"=== {symbol} DOM Imbalance ===\\n\")\n                print(f\"BUY:  {buy_volume:&gt;8.2f} lots\")\n                print(f\"SELL: {sell_volume:&gt;8.2f} lots\")\n                print(f\"\\nImbalance: {imbalance:+.2f}%\")\n\n                if imbalance &gt; 20:\n                    print(\"\\n[SIGNAL] Strong BUY pressure\")\n                elif imbalance &lt; -20:\n                    print(\"\\n[SIGNAL] Strong SELL pressure\")\n                else:\n                    print(\"\\n[SIGNAL] Balanced market\")\n\n            await asyncio.sleep(1)\n\n        await account.market_book_release(symbol)\n        print(f\"\\n[STOPPED] Monitoring ended\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(monitor_imbalance(duration=30))\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#6-volume-at-price-vap-analysis","title":"6) Volume at Price (VAP) analysis","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nfrom collections import defaultdict\n\nasync def volume_at_price():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        symbol = \"EURUSD\"\n\n        await account.market_book_add(symbol)\n        dom_data = await account.market_book_get(symbol)\n\n        # Group volume by price bins (e.g., 5 pip ranges)\n        pip_range = 5\n        pip_size = 0.0001\n        bin_size = pip_range * pip_size\n\n        volume_bins = defaultdict(float)\n\n        for entry in dom_data.mql_book_infos:\n            # Round price to nearest bin\n            bin_price = round(entry.price / bin_size) * bin_size\n            volume_bins[bin_price] += entry.volume_real\n\n        # Sort by price\n        sorted_bins = sorted(volume_bins.items(), key=lambda x: x[0])\n\n        print(f\"[VOLUME AT PRICE] {symbol} ({pip_range} pip bins)\\n\")\n        print(f\"{'Price Range':&lt;20} {'Volume':&lt;15} {'Bar':&lt;30}\")\n        print(\"-\" * 70)\n\n        max_volume = max(volume_bins.values()) if volume_bins else 1\n\n        for price, volume in sorted_bins[:15]:  # Show top 15 bins\n            bar_length = int((volume / max_volume) * 30)\n            bar = \"#\" * bar_length\n            print(f\"{price:.5f}-{price+bin_size:.5f}  {volume:&gt;8.2f} lots  {bar}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(volume_at_price())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_get/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>MarketBookAdd - Subscribe to DOM updates</li> <li>MarketBookRelease - Unsubscribe from DOM</li> <li>SymbolInfoTick - Get current tick prices</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/","title":"Unsubscribe from Market Depth","text":"<p>Request: Unsubscribe from Depth of Market (order book) updates for a symbol.</p> <p>API Information:</p> <ul> <li>Python API: <code>MT5Account.market_book_release(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.MarketInfo</code></li> <li>Proto definition: <code>MarketBookRelease</code> (defined in <code>mt5-term-api-market-info.proto</code>)</li> <li>Enums in this method: 0 enums (simple boolean result)</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.MarketInfo</code></li> <li>Method: <code>MarketBookRelease(MarketBookReleaseRequest) -&gt; MarketBookReleaseReply</code></li> <li>Low-level client (generated): <code>MarketInfoStub.MarketBookRelease(request, metadata)</code></li> </ul> <pre><code>from MetaRpcMT5 import MT5Account\n\nclass MT5Account:\n    # ...\n\n    async def market_book_release(\n        self,\n        symbol: str,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ) -&gt; market_info_pb2.MarketBookReleaseData:\n        \"\"\"\n        Closes the Depth of Market (DOM) for a symbol and unsubscribes from updates.\n\n        Returns:\n            MarketBookReleaseData: Unsubscription result.\n        \"\"\"\n</code></pre> <p>Request message:</p> <pre><code>MarketBookReleaseRequest {\n  string symbol = 1;  // Symbol name\n}\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbol</code> <code>str</code> Symbol name (e.g., \"EURUSD\") <code>deadline</code> <code>Optional[datetime]</code> Deadline for the operation (optional) <code>cancellation_event</code> <code>Optional[asyncio.Event]</code> Event to cancel the request (optional)"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#output","title":"\u2b06\ufe0f Output","text":"<p>Returns <code>MarketBookReleaseData</code> object.</p> <p>MarketBookReleaseData fields:</p> Field Type Description <code>closed_successfully</code> <code>bool</code> True if unsubscription was successful"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Unsubscribes from Level 2 market data (order book) for a symbol.</li> <li>Why you need it. Clean up resources and stop receiving DOM updates when no longer needed.</li> <li>Best practice. Always call when done monitoring DOM to free resources.</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to:</p> <ul> <li>Unsubscribe from DOM updates</li> <li>Free system resources</li> <li>Clean up after DOM analysis</li> <li>Stop market depth monitoring</li> <li>Manage subscription lifecycle</li> <li>Reduce bandwidth usage</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: MarketBookRelease - How it works</p>"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Resource cleanup: Always call this when done with DOM monitoring.</li> <li>No error if not subscribed: Safe to call even if not currently subscribed.</li> <li>Per-symbol basis: Each symbol must be released separately.</li> <li>Paired with add: Every <code>market_book_add</code> should have a matching <code>market_book_release</code>.</li> <li>Session cleanup: Subscriptions persist until explicitly released or session ends.</li> <li>Check success: Always verify <code>closed_successfully == True</code>.</li> </ul>"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#1-basic-unsubscribe","title":"1) Basic unsubscribe","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def unsubscribe_dom():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        symbol = \"EURUSD\"\n\n        # Subscribe to DOM\n        add_result = await account.market_book_add(symbol)\n        if add_result.opened_successfully:\n            print(f\"[SUBSCRIBED] {symbol} DOM\")\n\n        # Do some analysis...\n        dom_data = await account.market_book_get(symbol)\n        print(f\"[ANALYSIS] {len(dom_data.mql_book_infos)} DOM levels\")\n\n        # Unsubscribe when done\n        release_result = await account.market_book_release(symbol)\n        if release_result.closed_successfully:\n            print(f\"[UNSUBSCRIBED] {symbol} DOM released\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(unsubscribe_dom())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#2-context-manager-pattern","title":"2) Context manager pattern","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nfrom contextlib import asynccontextmanager\n\n@asynccontextmanager\nasync def dom_subscription(account, symbol):\n    \"\"\"Context manager for automatic DOM subscription cleanup\"\"\"\n    try:\n        # Subscribe\n        result = await account.market_book_add(symbol)\n        if not result.opened_successfully:\n            raise Exception(f\"Failed to subscribe to {symbol} DOM\")\n\n        print(f\"[SUBSCRIBED] {symbol} DOM\")\n        yield\n    finally:\n        # Always release on exit\n        await account.market_book_release(symbol)\n        print(f\"[RELEASED] {symbol} DOM\")\n\nasync def main():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        async with dom_subscription(account, \"EURUSD\"):\n            # DOM is active here\n            dom_data = await account.market_book_get(\"EURUSD\")\n            print(f\"[ANALYSIS] {len(dom_data.mql_book_infos)} DOM levels\")\n        # DOM automatically released here\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#3-release-multiple-symbols","title":"3) Release multiple symbols","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def release_multiple_symbols():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\n\n    try:\n        # Subscribe to multiple symbols\n        print(\"[SUBSCRIBING] To multiple symbols...\")\n        for symbol in symbols:\n            result = await account.market_book_add(symbol)\n            if result.opened_successfully:\n                print(f\"  [OK] {symbol} subscribed\")\n\n        # Do analysis...\n        await asyncio.sleep(5)\n\n        # Release all symbols\n        print(\"\\n[RELEASING] All subscriptions...\")\n        for symbol in symbols:\n            result = await account.market_book_release(symbol)\n            if result.closed_successfully:\n                print(f\"  [OK] {symbol} released\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(release_multiple_symbols())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#4-error-handling-and-cleanup","title":"4) Error handling and cleanup","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account, ApiExceptionMT5\n\nasync def safe_dom_usage():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    symbol = \"EURUSD\"\n    subscribed = False\n\n    try:\n        # Subscribe\n        add_result = await account.market_book_add(symbol)\n        if not add_result.opened_successfully:\n            print(f\"[ERROR] Failed to subscribe to {symbol}\")\n            return\n\n        subscribed = True\n        print(f\"[SUBSCRIBED] {symbol} DOM\")\n\n        # Perform analysis\n        dom_data = await account.market_book_get(symbol)\n        print(f\"[ANALYSIS] {len(dom_data.mql_book_infos)} levels\")\n\n    except ApiExceptionMT5 as e:\n        print(f\"[API ERROR] {e}\")\n\n    except Exception as e:\n        print(f\"[ERROR] Unexpected error: {e}\")\n\n    finally:\n        # Always clean up if subscribed\n        if subscribed:\n            try:\n                release_result = await account.market_book_release(symbol)\n                if release_result.closed_successfully:\n                    print(f\"[CLEANUP] {symbol} DOM released successfully\")\n                else:\n                    print(f\"[WARNING] Failed to release {symbol} DOM\")\n            except Exception as e:\n                print(f\"[CLEANUP ERROR] {e}\")\n\n        await account.channel.close()\n\nasyncio.run(safe_dom_usage())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#5-subscription-manager-class","title":"5) Subscription manager class","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nclass DOMSubscriptionManager:\n    def __init__(self, account):\n        self.account = account\n        self.active_subscriptions = set()\n\n    async def subscribe(self, symbol: str):\n        \"\"\"Subscribe to DOM with tracking\"\"\"\n        result = await self.account.market_book_add(symbol)\n\n        if result.opened_successfully:\n            self.active_subscriptions.add(symbol)\n            print(f\"[SUBSCRIBED] {symbol} (Total: {len(self.active_subscriptions)})\")\n            return True\n        else:\n            print(f\"[FAILED] Could not subscribe to {symbol}\")\n            return False\n\n    async def unsubscribe(self, symbol: str):\n        \"\"\"Unsubscribe from DOM\"\"\"\n        if symbol not in self.active_subscriptions:\n            print(f\"[WARNING] {symbol} not in active subscriptions\")\n            return False\n\n        result = await self.account.market_book_release(symbol)\n\n        if result.closed_successfully:\n            self.active_subscriptions.remove(symbol)\n            print(f\"[UNSUBSCRIBED] {symbol} (Remaining: {len(self.active_subscriptions)})\")\n            return True\n        else:\n            print(f\"[FAILED] Could not unsubscribe from {symbol}\")\n            return False\n\n    async def release_all(self):\n        \"\"\"Release all active subscriptions\"\"\"\n        print(f\"[RELEASING] All {len(self.active_subscriptions)} subscriptions...\")\n\n        for symbol in list(self.active_subscriptions):\n            await self.unsubscribe(symbol)\n\n        print(f\"[DONE] All subscriptions released\")\n\n    def list_active(self):\n        \"\"\"List all active subscriptions\"\"\"\n        return list(self.active_subscriptions)\n\nasync def main():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    manager = DOMSubscriptionManager(account)\n\n    try:\n        # Subscribe to multiple symbols\n        await manager.subscribe(\"EURUSD\")\n        await manager.subscribe(\"GBPUSD\")\n        await manager.subscribe(\"USDJPY\")\n\n        print(f\"\\n[ACTIVE] Subscriptions: {manager.list_active()}\")\n\n        # Do analysis...\n        await asyncio.sleep(5)\n\n        # Release specific symbol\n        await manager.unsubscribe(\"GBPUSD\")\n\n        # Release all remaining\n        await manager.release_all()\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#6-temporary-dom-snapshot-helper","title":"6) Temporary DOM snapshot helper","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def get_dom_snapshot(account, symbol: str):\n    \"\"\"\n    Helper function to get a quick DOM snapshot with automatic cleanup.\n    Subscribe -&gt; Get data -&gt; Release\n    \"\"\"\n    try:\n        # Subscribe\n        add_result = await account.market_book_add(symbol)\n        if not add_result.opened_successfully:\n            print(f\"[ERROR] Failed to subscribe to {symbol}\")\n            return None\n\n        # Get DOM data\n        dom_data = await account.market_book_get(symbol)\n\n        return dom_data\n\n    finally:\n        # Always release\n        try:\n            await account.market_book_release(symbol)\n        except Exception as e:\n            print(f\"[WARNING] Cleanup error: {e}\")\n\nasync def main():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\n\n        for symbol in symbols:\n            print(f\"\\n[SNAPSHOT] Getting {symbol} DOM...\")\n\n            dom_data = await get_dom_snapshot(account, symbol)\n\n            if dom_data:\n                sell_volume = sum(e.volume_real for e in dom_data.mql_book_infos if e.type in [0, 2])\n                buy_volume = sum(e.volume_real for e in dom_data.mql_book_infos if e.type in [1, 3])\n\n                print(f\"  Levels: {len(dom_data.mql_book_infos)}\")\n                print(f\"  BUY volume: {buy_volume:.2f} lots\")\n                print(f\"  SELL volume: {sell_volume:.2f} lots\")\n\n            await asyncio.sleep(1)  # Brief pause between snapshots\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/4.%20Market_Depth/market_book_release/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>MarketBookAdd - Subscribe to DOM updates</li> <li>MarketBookGet - Get DOM data</li> <li>SymbolSelect - Manage Market Watch symbols</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/Trading_Operations.Overview/","title":"MT5Account - Trading Operations - Overview","text":"<p>Execute, modify, and manage trades: send orders, close positions, validate requests, calculate margin.</p>"},{"location":"MT5Account/5.%20Trading_Operations/Trading_Operations.Overview/#what-lives-here","title":"\ud83d\udcc1 What lives here","text":""},{"location":"MT5Account/5.%20Trading_Operations/Trading_Operations.Overview/#order-execution","title":"Order Execution","text":"<ul> <li>order_send - send market or pending orders.</li> <li>order_close - close positions or delete pending orders.</li> <li>order_modify - modify SL/TP, price, or expiration.</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/Trading_Operations.Overview/#order-validation-calculation","title":"Order Validation &amp; Calculation","text":"<ul> <li>order_check - validate orders before execution.</li> <li>order_calc_margin - calculate required margin.</li> <li>order_calc_profit - calculate potential profit/loss.</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/Trading_Operations.Overview/#step-by-step-tutorials","title":"\ud83d\udcda Step-by-step tutorials","text":"<p>Note: All trading operations are async methods. Check individual method pages for detailed examples.</p> <ul> <li>order_send - Order execution examples</li> <li>order_close - Position closing patterns</li> <li>order_modify - SL/TP modification examples</li> <li>order_check - Order validation patterns</li> <li>order_calc_margin - Margin calculation examples</li> <li>order_calc_profit - Profit/loss calculation examples</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/Trading_Operations.Overview/#plain-english","title":"\ud83e\udded Plain English","text":"<ul> <li>order_send -&gt; open positions or place pending orders (BUY, SELL, LIMIT, STOP).</li> <li>order_close -&gt; close positions completely or partially, or delete pending orders.</li> <li>order_modify -&gt; change SL/TP or modify pending order parameters.</li> <li>order_check -&gt; validate orders before sending (check margin, parameters).</li> <li>order_calc_margin -&gt; calculate margin required for planned trades.</li> <li>order_calc_profit -&gt; calculate profit/loss for planned trades (risk/reward analysis).</li> </ul> <p>Rule of thumb: open -&gt; <code>order_send</code>; close -&gt; <code>order_close</code>; adjust -&gt; <code>order_modify</code>; validate -&gt; <code>order_check</code>; plan margin -&gt; <code>order_calc_margin</code>; plan profit -&gt; <code>order_calc_profit</code>.</p>"},{"location":"MT5Account/5.%20Trading_Operations/Trading_Operations.Overview/#quick-choose","title":"Quick choose","text":"If you need... Use Returns Key inputs Open market position (BUY/SELL) <code>order_send</code> OrderSendData symbol, operation, volume, price Place pending order (LIMIT/STOP) <code>order_send</code> OrderSendData symbol, operation, volume, price Close position completely <code>order_close</code> OrderCloseData ticket, volume=0, slippage Close position partially <code>order_close</code> OrderCloseData ticket, volume, slippage Delete pending order <code>order_close</code> OrderCloseData ticket, volume=0 Add/modify Stop Loss or Take Profit <code>order_modify</code> OrderModifyData ticket, stop_loss, take_profit Change pending order price <code>order_modify</code> OrderModifyData ticket, price Validate order before sending <code>order_check</code> OrderCheckData OrderSendRequest Calculate margin for planned trade <code>order_calc_margin</code> OrderCalcMarginData symbol, operation, volume Calculate profit/loss for planned trade <code>order_calc_profit</code> OrderCalcProfitData symbol, operation, volume, open/close price"},{"location":"MT5Account/5.%20Trading_Operations/Trading_Operations.Overview/#i-cross-refs-gotchas","title":"\u2139\ufe0f Cross-refs &amp; gotchas","text":"<ul> <li>Return codes: Always check <code>returned_code == 10009</code> for success (order_send/close), <code>== 0</code> for validation methods.</li> <li>Async methods: All trading operations are async - use <code>await</code>.</li> <li>Automatic reconnection: All methods have built-in reconnection via <code>execute_with_reconnect</code>.</li> <li>Volume = 0: In <code>order_close</code>, volume=0 means close entire position.</li> <li>Slippage: Set appropriate slippage for market orders (e.g., 20 points).</li> <li>SL/TP = 0: In <code>order_modify</code>, use 0 to remove SL or TP.</li> <li>Check before send: Always use <code>order_check</code> before <code>order_send</code> for large orders.</li> <li>Margin calculation: <code>order_check</code> includes margin, <code>order_calc_margin</code> only calculates margin.</li> <li>Profit calculation: <code>order_calc_profit</code> calculates potential profit/loss for risk/reward analysis.</li> <li>Freeze level: Cannot modify orders too close to market price (broker setting).</li> <li>Min distance: Broker enforces minimum distance from current price for SL/TP.</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/Trading_Operations.Overview/#minimal-snippets","title":"\ud83d\udfe2 Minimal snippets","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\n# Send market BUY order\nasync def market_buy():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        request = trading_pb2.OrderSendRequest(\n            symbol=\"EURUSD\",\n            operation=0,  # 0 = BUY\n            volume=0.01,\n            price=0,\n            slippage=20,\n            comment=\"Market BUY\"\n        )\n\n        result = await account.order_send(request)\n\n        if result.returned_code == 10009:\n            print(f\"[SUCCESS] Deal: #{result.deal}, Price: {result.price}\")\n        else:\n            print(f\"[FAILED] {result.returned_code_description}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(market_buy())\n</code></pre> <pre><code># Close position\nasync def close_position(ticket):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        request = trading_pb2.OrderCloseRequest(\n            ticket=ticket,\n            volume=0,  # Close all\n            slippage=20\n        )\n\n        result = await account.order_close(request)\n\n        if result.returned_code == 10009:\n            print(f\"[SUCCESS] Position closed\")\n        else:\n            print(f\"[FAILED] {result.returned_code_description}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(close_position(123456))\n</code></pre> <pre><code># Modify Stop Loss\nasync def modify_sl(ticket, new_sl):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        request = trading_pb2.OrderModifyRequest(\n            ticket=ticket,\n            stop_loss=new_sl,\n            take_profit=0,  # Keep existing\n            price=0\n        )\n\n        result = await account.order_modify(request)\n        print(f\"[SUCCESS] SL modified to {new_sl}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(modify_sl(123456, 1.08500))\n</code></pre> <pre><code># Check order before sending\nasync def check_and_send():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        import MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\n        # Create trade request\n        trade_request = trade_pb2.MrpcMqlTradeRequest(\n            action=0,  # TRADE_ACTION_DEAL\n            symbol=\"EURUSD\",\n            volume=0.10,\n            order_type=0,  # ORDER_TYPE_BUY\n            type_filling=2,  # ORDER_FILLING_RETURN\n            type_time=0  # ORDER_TIME_GTC\n        )\n\n        check_req = trade_pb2.OrderCheckRequest(mql_trade_request=trade_request)\n\n        # Check first\n        check_result = await account.order_check(check_req)\n\n        if check_result.returned_code == 0:\n            print(f\"[VALID] Margin: ${check_result.margin:.2f}\")\n\n            # Send order\n            send_request = trading_pb2.OrderSendRequest(\n                symbol=\"EURUSD\",\n                operation=0,\n                volume=0.10,\n                price=0,\n                slippage=20\n            )\n\n            send_result = await account.order_send(send_request)\n\n            if send_result.returned_code == 10009:\n                print(f\"[SUCCESS] Deal: #{send_result.deal}\")\n        else:\n            print(f\"[INVALID] {check_result.returned_code_description}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(check_and_send())\n</code></pre> <pre><code># Calculate margin\nasync def calc_margin():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        import MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\n        request = trade_pb2.OrderCalcMarginRequest(\n            symbol=\"EURUSD\",\n            order_type=0,  # ORDER_TYPE_BUY\n            volume=0.10,\n            open_price=1.10000\n        )\n\n        result = await account.order_calc_margin(request)\n\n        if result.returned_code == 0:\n            print(f\"Required margin: ${result.margin:,.2f}\")\n        else:\n            print(f\"[FAILED] {result.returned_code_description}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(calc_margin())\n</code></pre> <pre><code># Complete trading workflow\nasync def trading_workflow():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        import MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\n        # 1. Calculate margin\n        margin_req = trade_pb2.OrderCalcMarginRequest(\n            symbol=\"EURUSD\",\n            order_type=0,\n            volume=0.10,\n            open_price=1.10000\n        )\n\n        margin_result = await account.order_calc_margin(margin_req)\n        print(f\"[1] Margin: ${margin_result.margin:.2f}\")\n\n        # 2. Check order\n        trade_request = trade_pb2.MrpcMqlTradeRequest(\n            action=0,\n            symbol=\"EURUSD\",\n            volume=0.10,\n            order_type=0,\n            type_filling=2,\n            type_time=0\n        )\n\n        check_req = trade_pb2.OrderCheckRequest(mql_trade_request=trade_request)\n        check_result = await account.order_check(check_req)\n        if check_result.returned_code != 0:\n            print(f\"[2] Check failed: {check_result.returned_code_description}\")\n            return\n\n        print(f\"[2] Order valid, free margin after: ${check_result.margin_free:.2f}\")\n\n        # 3. Send order\n        send_req = trading_pb2.OrderSendRequest(\n            symbol=\"EURUSD\",\n            operation=0,\n            volume=0.10,\n            price=0,\n            slippage=20\n        )\n\n        send_result = await account.order_send(send_req)\n        if send_result.returned_code != 10009:\n            print(f\"[3] Send failed: {send_result.returned_code_description}\")\n            return\n\n        print(f\"[3] Order sent! Deal: #{send_result.deal}\")\n        ticket = send_result.deal\n\n        # 4. Modify to add SL/TP\n        await asyncio.sleep(1)  # Wait a moment\n\n        import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_pb2\n\n        tick_req = market_pb2.SymbolInfoTickRequest(symbol=\"EURUSD\")\n        tick = await account.symbol_info_tick(tick_req)\n\n        pip_size = 0.0001\n        sl = tick.tick.bid - (50 * pip_size)\n        tp = tick.tick.bid + (100 * pip_size)\n\n        modify_req = trading_pb2.OrderModifyRequest(\n            ticket=ticket,\n            stop_loss=sl,\n            take_profit=tp,\n            price=0\n        )\n\n        await account.order_modify(modify_req)\n        print(f\"[4] SL/TP added: SL={sl:.5f}, TP={tp:.5f}\")\n\n        # 5. Later... close position\n        await asyncio.sleep(5)\n\n        close_req = trading_pb2.OrderCloseRequest(\n            ticket=ticket,\n            volume=0,\n            slippage=20\n        )\n\n        close_result = await account.order_close(close_req)\n        if close_result.returned_code == 10009:\n            print(f\"[5] Position closed\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(trading_workflow())\n</code></pre> <pre><code># Batch operations\nasync def batch_operations():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\n\n    try:\n        # Open multiple positions\n        deals = []\n\n        for symbol in symbols:\n            request = trading_pb2.OrderSendRequest(\n                symbol=symbol,\n                operation=0,\n                volume=0.01,\n                price=0,\n                slippage=20,\n                comment=f\"{symbol} position\"\n            )\n\n            result = await account.order_send(request)\n\n            if result.returned_code == 10009:\n                deals.append(result.deal)\n                print(f\"[OPENED] {symbol}: #{result.deal}\")\n\n        # Wait...\n        await asyncio.sleep(10)\n\n        # Close all positions\n        for deal in deals:\n            close_req = trading_pb2.OrderCloseRequest(\n                ticket=deal,\n                volume=0,\n                slippage=20\n            )\n\n            result = await account.order_close(close_req)\n\n            if result.returned_code == 10009:\n                print(f\"[CLOSED] #{deal}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(batch_operations())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/Trading_Operations.Overview/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>Positions: opened_orders - get current positions</li> <li>History: order_history - get order history</li> <li>Account: account_summary - get account state</li> <li>Prices: symbol_info_tick - get current prices</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/","title":"Calculate Required Margin","text":"<p>Request: Calculate the margin required for a planned trade operation.</p> <p>API Information:</p> <ul> <li>Python API: <code>MT5Account.order_calc_margin(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.TradeFunctions</code></li> <li>Proto definition: <code>OrderCalcMargin</code> (defined in <code>mt5-term-api-trade-functions.proto</code>)</li> <li>Enums in this method: 1 enum with 9 constants (1 input)</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.TradeFunctions</code></li> <li>Method: <code>OrderCalcMargin(OrderCalcMarginRequest) -&gt; OrderCalcMarginReply</code></li> <li>Low-level client (generated): <code>TradeFunctionsStub.OrderCalcMargin(request, metadata)</code></li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Calculates required margin for a trade without executing it.</li> <li>Why you need it. Plan position sizing and risk management.</li> <li>Account currency. Returns margin in your account currency (USD, EUR, etc.).</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to:</p> <ul> <li>Calculate margin requirements before trading</li> <li>Determine maximum position size for available margin</li> <li>Plan multiple positions</li> <li>Risk management calculations</li> <li>Portfolio margin analysis</li> <li>Compare margin requirements across symbols</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: OrderCalcMargin - How it works</p> <pre><code>from MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nclass MT5Account:\n    # ...\n\n    async def order_calc_margin(\n        self,\n        request: trade_pb2.OrderCalcMarginRequest,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ) -&gt; trade_pb2.OrderCalcMarginData:\n        \"\"\"\n        Calculates the margin required for a planned trade operation.\n\n        Returns:\n            OrderCalcMarginData: The required margin in account currency.\n        \"\"\"\n</code></pre> <p>Request message:</p> <pre><code>message OrderCalcMarginRequest {\n  string symbol = 1;            // Symbol name\n  ENUM_ORDER_TYPE_TF order_type = 2;  // Order type\n  double volume = 3;            // Trade volume in lots\n  double open_price = 4;        // Order open price\n}\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>request</code> <code>OrderCalcMarginRequest</code> Margin calculation request <code>deadline</code> <code>Optional[datetime]</code> Deadline for the operation (optional) <code>cancellation_event</code> <code>Optional[asyncio.Event]</code> Event to cancel the request (optional) <p>OrderCalcMarginRequest fields:</p> Field Type Description <code>symbol</code> <code>string</code> Symbol name (e.g., \"EURUSD\") <code>order_type</code> <code>ENUM_ORDER_TYPE_TF</code> Order type (enum) <code>volume</code> <code>double</code> Trade volume in lots <code>open_price</code> <code>double</code> Order open price"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#output","title":"\u2b06\ufe0f Output","text":"<p>Returns <code>OrderCalcMarginData</code> object with margin calculation.</p> <p>OrderCalcMarginData fields:</p> Field Type Description <code>margin</code> <code>double</code> Required margin in account currency"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":""},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#enum_order_type_tf","title":"<code>ENUM_ORDER_TYPE_TF</code>","text":"<p>Used in <code>OrderCalcMarginRequest</code> to specify order type for margin calculation.</p> Constant Name Value Description <code>ORDER_TYPE_TF_BUY</code> 0 Market buy order <code>ORDER_TYPE_TF_SELL</code> 1 Market sell order <code>ORDER_TYPE_TF_BUY_LIMIT</code> 2 Buy limit pending order <code>ORDER_TYPE_TF_SELL_LIMIT</code> 3 Sell limit pending order <code>ORDER_TYPE_TF_BUY_STOP</code> 4 Buy stop pending order <code>ORDER_TYPE_TF_SELL_STOP</code> 5 Sell stop pending order <code>ORDER_TYPE_TF_BUY_STOP_LIMIT</code> 6 Buy stop limit pending order <code>ORDER_TYPE_TF_SELL_STOP_LIMIT</code> 7 Sell stop limit pending order <code>ORDER_TYPE_TF_CLOSE_BY</code> 8 Close by opposite position <p>Usage: <pre><code>from MetaRpcMT5 import mt5_term_api_trade_functions_pb2 as trade_pb2\n\n# Access enum values\ntrade_pb2.ORDER_TYPE_TF_BUY         # = 0\ntrade_pb2.ORDER_TYPE_TF_SELL        # = 1\n</code></pre></p>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>No execution: This method only calculates margin, does NOT execute orders.</li> <li>Same request: Uses identical request structure as <code>order_send</code>.</li> <li>Leverage impact: Result depends on symbol leverage and account settings.</li> <li>Real-time calculation: Uses current market prices for calculation.</li> <li>Different from order_check: This only returns margin, <code>order_check</code> validates full order.</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#1-calculate-margin-for-single-trade","title":"1) Calculate margin for single trade","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nasync def calc_margin():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Calculate margin for 0.10 lots EURUSD\n        request = trade_pb2.OrderCalcMarginRequest(\n            symbol=\"EURUSD\",\n            order_type=trade_pb2.ORDER_TYPE_TF_BUY,\n            volume=0.10,\n            open_price=1.0850\n        )\n\n        result = await account.order_calc_margin(request)\n\n        print(f\"[SUCCESS] Margin calculation:\")\n        print(f\"  Symbol: EURUSD\")\n        print(f\"  Volume: 0.10 lots\")\n        print(f\"  Required margin: ${result.margin:,.2f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(calc_margin())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#2-compare-margin-across-symbols","title":"2) Compare margin across symbols","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nasync def compare_margin():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\", \"XAUUSD\"]\n    volume = 0.10\n\n    try:\n        print(f\"Margin requirements for {volume} lots:\\n\")\n        print(f\"{'Symbol':&lt;10} {'Margin':&lt;15}\")\n        print(\"-\" * 30)\n\n        for symbol in symbols:\n            request = trade_pb2.OrderCalcMarginRequest(\n                symbol=symbol,\n                order_type=trade_pb2.ORDER_TYPE_TF_BUY,\n                volume=volume,\n                open_price=1.0\n            )\n\n            result = await account.order_calc_margin(request)\n            print(f\"{symbol:&lt;10} ${result.margin:&gt;12,.2f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(compare_margin())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#3-calculate-maximum-position-size","title":"3) Calculate maximum position size","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_pb2\n\nasync def calc_max_position(symbol: str, margin_percent: float = 50.0):\n    \"\"\"Calculate max position size using X% of free margin\"\"\"\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Get available margin\n        summary_req = account_pb2.AccountSummaryRequest()\n        summary = await account.account_summary(summary_req)\n        available_margin = summary.margin_free * (margin_percent / 100.0)\n\n        print(f\"Calculating max position for {symbol}:\")\n        print(f\"  Free margin: ${summary.margin_free:,.2f}\")\n        print(f\"  Using {margin_percent}% = ${available_margin:,.2f}\\n\")\n\n        # Binary search for max volume\n        min_vol = 0.01\n        max_vol = 100.0\n        best_volume = 0.01\n\n        while max_vol - min_vol &gt; 0.01:\n            test_volume = (min_vol + max_vol) / 2\n\n            request = trade_pb2.OrderCalcMarginRequest(\n                symbol=symbol,\n                order_type=trade_pb2.ORDER_TYPE_TF_BUY,\n                volume=test_volume,\n                open_price=1.0\n            )\n\n            result = await account.order_calc_margin(request)\n\n            if result.margin &lt;= available_margin:\n                best_volume = test_volume\n                min_vol = test_volume\n            else:\n                max_vol = test_volume\n\n        print(f\"[RESULT] Maximum position size: {best_volume:.2f} lots\")\n\n        # Verify final calculation\n        final_req = trade_pb2.OrderCalcMarginRequest(\n            symbol=symbol,\n            order_type=trade_pb2.ORDER_TYPE_TF_BUY,\n            volume=best_volume,\n            open_price=1.0\n        )\n        final_result = await account.order_calc_margin(final_req)\n\n        print(f\"  Required margin: ${final_result.margin:,.2f}\")\n        print(f\"  Margin usage: {(final_result.margin / available_margin * 100):.1f}%\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(calc_max_position(\"EURUSD\", margin_percent=50.0))\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#4-portfolio-margin-calculation","title":"4) Portfolio margin calculation","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_pb2\n\nasync def portfolio_margin():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    # Planned portfolio\n    trades = [\n        (\"EURUSD\", 0.10),\n        (\"GBPUSD\", 0.05),\n        (\"USDJPY\", 0.10),\n        (\"XAUUSD\", 0.01),\n    ]\n\n    try:\n        # Get current account state\n        summary_req = account_pb2.AccountSummaryRequest()\n        summary = await account.account_summary(summary_req)\n\n        print(f\"Portfolio Margin Analysis\\n\")\n        print(f\"Current state:\")\n        print(f\"  Balance: ${summary.balance:,.2f}\")\n        print(f\"  Free margin: ${summary.margin_free:,.2f}\\n\")\n\n        print(f\"Planned trades:\")\n        print(f\"{'Symbol':&lt;10} {'Volume':&lt;10} {'Margin':&lt;15}\")\n        print(\"-\" * 40)\n\n        total_margin = 0.0\n\n        for symbol, volume in trades:\n            request = trade_pb2.OrderCalcMarginRequest(\n                symbol=symbol,\n                order_type=trade_pb2.ORDER_TYPE_TF_BUY,\n                volume=volume,\n                open_price=1.0\n            )\n\n            result = await account.order_calc_margin(request)\n\n            print(f\"{symbol:&lt;10} {volume:&lt;10.2f} ${result.margin:&gt;12,.2f}\")\n            total_margin += result.margin\n\n        print(\"-\" * 40)\n        print(f\"{'TOTAL':&lt;10} {'':&lt;10} ${total_margin:&gt;12,.2f}\\n\")\n\n        # Check if portfolio fits\n        if total_margin &lt;= summary.margin_free:\n            remaining = summary.margin_free - total_margin\n            usage_percent = (total_margin / summary.margin_free) * 100\n            print(f\"[OK] Portfolio fits!\")\n            print(f\"  Margin usage: {usage_percent:.1f}%\")\n            print(f\"  Remaining free margin: ${remaining:,.2f}\")\n        else:\n            shortage = total_margin - summary.margin_free\n            print(f\"[WARNING] Insufficient margin!\")\n            print(f\"  Required: ${total_margin:,.2f}\")\n            print(f\"  Available: ${summary.margin_free:,.2f}\")\n            print(f\"  Shortage: ${shortage:,.2f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(portfolio_margin())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#5-risk-based-position-sizing","title":"5) Risk-based position sizing","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_pb2\n\nasync def risk_based_sizing(symbol: str, risk_percent: float = 2.0):\n    \"\"\"Calculate position size based on risk percentage\"\"\"\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Get account balance\n        summary_req = account_pb2.AccountSummaryRequest()\n        summary = await account.account_summary(summary_req)\n\n        max_risk_amount = summary.balance * (risk_percent / 100.0)\n\n        print(f\"Risk-based position sizing for {symbol}:\")\n        print(f\"  Account balance: ${summary.balance:,.2f}\")\n        print(f\"  Risk: {risk_percent}% = ${max_risk_amount:,.2f}\\n\")\n\n        # Test different volumes\n        volumes = [0.01, 0.05, 0.10, 0.20, 0.50, 1.00]\n\n        print(f\"{'Volume':&lt;10} {'Margin':&lt;15} {'% of Balance':&lt;15}\")\n        print(\"-\" * 45)\n\n        for volume in volumes:\n            request = trade_pb2.OrderCalcMarginRequest(\n                symbol=symbol,\n                order_type=trade_pb2.ORDER_TYPE_TF_BUY,\n                volume=volume,\n                open_price=1.0\n            )\n\n            result = await account.order_calc_margin(request)\n\n            margin_percent = (result.margin / summary.balance) * 100\n\n            status = \"[OK]\" if margin_percent &lt;= risk_percent else \"[OVER]\"\n\n            print(f\"{volume:&lt;10.2f} ${result.margin:&gt;12,.2f} {margin_percent:&gt;13.2f}% {status}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(risk_based_sizing(\"EURUSD\", risk_percent=2.0))\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#6-margin-calculator-helper-class","title":"6) Margin calculator helper class","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nclass MarginCalculator:\n    def __init__(self, account):\n        self.account = account\n        self.cache = {}  # Cache calculations\n\n    async def get_margin(self, symbol: str, volume: float, order_type: int = 0):\n        \"\"\"Get margin with caching\"\"\"\n        cache_key = f\"{symbol}_{volume}_{order_type}\"\n\n        if cache_key in self.cache:\n            return self.cache[cache_key]\n\n        request = trade_pb2.OrderCalcMarginRequest(\n            symbol=symbol,\n            order_type=order_type,\n            volume=volume,\n            open_price=1.0\n        )\n\n        result = await self.account.order_calc_margin(request)\n\n        self.cache[cache_key] = result.margin\n        return result.margin\n\n    async def get_leverage_ratio(self, symbol: str, volume: float = 1.0):\n        \"\"\"Calculate effective leverage for symbol\"\"\"\n        import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_pb2\n\n        # Get contract size\n        tick_req = market_pb2.SymbolInfoTickRequest(symbol=symbol)\n        tick_data = await self.account.symbol_info_tick(tick_req)\n\n        # Calculate margin for 1 lot\n        margin = await self.get_margin(symbol, volume)\n\n        # Contract value = price * contract_size\n        contract_value = tick_data.tick.ask * 100000  # Assuming 100k contract\n\n        leverage = contract_value / margin if margin &gt; 0 else 0\n\n        return leverage\n\nasync def main():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    calc = MarginCalculator(account)\n\n    try:\n        # Calculate margin\n        margin = await calc.get_margin(\"EURUSD\", 0.10)\n        print(f\"Margin for 0.10 lots EURUSD: ${margin:,.2f}\")\n\n        # Calculate leverage\n        leverage = await calc.get_leverage_ratio(\"EURUSD\", 1.0)\n        print(f\"Effective leverage: 1:{leverage:.0f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_margin/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>OrderCheck - Full order validation (includes margin)</li> <li>OrderCalcProfit - Calculate potential profit/loss</li> <li>OrderSend - Execute orders</li> <li>AccountSummary - Get account margin info</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/","title":"Calculate Potential Profit/Loss","text":"<p>Request: Calculate the potential profit or loss for a planned trade operation.</p> <p>API Information:</p> <ul> <li>Python API: <code>MT5Account.order_calc_profit(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.TradeFunctions</code></li> <li>Proto definition: <code>OrderCalcProfit</code> (defined in <code>mt5-term-api-trade-functions.proto</code>)</li> <li>Enums in this method: 1 enum with 9 constants (1 input)</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.TradeFunctions</code></li> <li>Method: <code>OrderCalcProfit(OrderCalcProfitRequest) -&gt; OrderCalcProfitReply</code></li> <li>Low-level client (generated): <code>TradeFunctionsStub.OrderCalcProfit(request, metadata)</code></li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Calculates potential profit/loss for a trade without executing it.</li> <li>Why you need it. Plan trades, calculate risk/reward ratios, position sizing.</li> <li>Account currency. Returns profit/loss in your account currency (USD, EUR, etc.).</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to:</p> <ul> <li>Calculate profit/loss before opening a trade</li> <li>Determine risk/reward ratio</li> <li>Plan exit strategies</li> <li>Compare profitability across symbols</li> <li>Calculate pip value for different lot sizes</li> <li>Portfolio profit/loss projections</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: OrderCalcProfit - How it works</p> <pre><code>from MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nclass MT5Account:\n    # ...\n\n    async def order_calc_profit(\n        self,\n        request: trade_pb2.OrderCalcProfitRequest,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ) -&gt; trade_pb2.OrderCalcProfitData:\n        \"\"\"\n        Calculates potential profit/loss for a planned trade operation.\n\n        Returns:\n            OrderCalcProfitData: The potential profit/loss in account currency.\n        \"\"\"\n</code></pre> <p>Request message:</p> <pre><code>message OrderCalcProfitRequest {\n  ENUM_ORDER_TYPE_TF order_type = 1;  // Order type\n  string symbol = 2;                  // Symbol name\n  double volume = 3;                  // Trade volume in lots\n  double open_price = 4;              // Entry price\n  double close_price = 5;             // Exit price\n}\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>request</code> <code>OrderCalcProfitRequest</code> Profit calculation request <code>deadline</code> <code>Optional[datetime]</code> Deadline for the operation (optional) <code>cancellation_event</code> <code>Optional[asyncio.Event]</code> Event to cancel the request (optional) <p>OrderCalcProfitRequest fields:</p> Field Type Description <code>order_type</code> <code>ENUM_ORDER_TYPE_TF</code> Order type (enum) <code>symbol</code> <code>string</code> Symbol name (e.g., \"EURUSD\") <code>volume</code> <code>double</code> Trade volume in lots <code>open_price</code> <code>double</code> Entry price <code>close_price</code> <code>double</code> Exit price"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#output","title":"\u2b06\ufe0f Output","text":"<p>Returns <code>OrderCalcProfitData</code> object.</p> <p>OrderCalcProfitData fields:</p> Field Type Description <code>profit</code> <code>double</code> Profit/loss in account currency (negative = loss)"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":""},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#enum_order_type_tf","title":"<code>ENUM_ORDER_TYPE_TF</code>","text":"<p>Used in <code>OrderCalcProfitRequest</code> to specify order type.</p> Constant Name Value Description <code>ORDER_TYPE_BUY</code> 0 Market buy order <code>ORDER_TYPE_SELL</code> 1 Market sell order <code>ORDER_TYPE_BUY_LIMIT</code> 2 Buy limit pending order <code>ORDER_TYPE_SELL_LIMIT</code> 3 Sell limit pending order <code>ORDER_TYPE_BUY_STOP</code> 4 Buy stop pending order <code>ORDER_TYPE_SELL_STOP</code> 5 Sell stop pending order <code>ORDER_TYPE_BUY_STOP_LIMIT</code> 6 Buy stop limit pending order <code>ORDER_TYPE_SELL_STOP_LIMIT</code> 7 Sell stop limit pending order <code>ORDER_TYPE_CLOSE_BY</code> 8 Close by opposite position <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\n# Access enum values\ntrade_pb2.ORDER_TYPE_BUY          # = 0\ntrade_pb2.ORDER_TYPE_SELL         # = 1\ntrade_pb2.ORDER_TYPE_BUY_LIMIT    # = 2\ntrade_pb2.ORDER_TYPE_SELL_LIMIT   # = 3\n</code></pre></p>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Return code: Check <code>returned_code == 0</code> for success (validation methods use 0, not 10009).</li> <li>Positive/Negative: Positive profit = gain, negative profit = loss.</li> <li>Account currency: Result is always in account currency (USD, EUR, etc.).</li> <li>Spread not included: This calculates theoretical profit - actual profit may differ due to spread and commissions.</li> <li>Use for planning: Great for calculating risk/reward before entering trades.</li> <li>Pip value: Use to calculate how much 1 pip is worth for your lot size.</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#1-calculate-profit-for-a-buy-trade","title":"1) Calculate profit for a BUY trade","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nasync def calc_buy_profit():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Calculate profit for BUY 0.10 lots EURUSD\n        # Entry: 1.10000, Exit: 1.10100 (100 pips profit)\n        request = trade_pb2.OrderCalcProfitRequest(\n            order_type=trade_pb2.ORDER_TYPE_BUY,\n            symbol=\"EURUSD\",\n            volume=0.10,\n            open_price=1.10000,\n            close_price=1.10100\n        )\n\n        result = await account.order_calc_profit(request)\n\n        print(f\"[PROFIT CALCULATION]\")\n        print(f\"  Entry: 1.10000\")\n        print(f\"  Exit: 1.10100\")\n        print(f\"  Volume: 0.10 lots\")\n        print(f\"  Profit: ${result.profit:.2f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(calc_buy_profit())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#2-calculate-loss-for-a-sell-trade","title":"2) Calculate loss for a SELL trade","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nasync def calc_sell_loss():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Calculate loss for SELL 0.01 lots EURUSD\n        # Entry: 1.10000, Exit: 1.10050 (50 pips loss)\n        request = trade_pb2.OrderCalcProfitRequest(\n            order_type=trade_pb2.ORDER_TYPE_SELL,\n            symbol=\"EURUSD\",\n            volume=0.01,\n            open_price=1.10000,\n            close_price=1.10050  # Price went against us\n        )\n\n        result = await account.order_calc_profit(request)\n\n        print(f\"[LOSS CALCULATION]\")\n        print(f\"  Entry: 1.10000\")\n        print(f\"  Exit: 1.10050\")\n        print(f\"  Volume: 0.01 lots\")\n        print(f\"  Loss: ${result.profit:.2f}\")  # Will be negative\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(calc_sell_loss())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#3-calculate-riskreward-ratio","title":"3) Calculate risk/reward ratio","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nasync def calc_risk_reward():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        entry = 1.10000\n        stop_loss = 1.09950  # 50 pips SL\n        take_profit = 1.10100  # 100 pips TP\n\n        # Calculate potential loss (hitting SL)\n        loss_req = trade_pb2.OrderCalcProfitRequest(\n            order_type=trade_pb2.ORDER_TYPE_BUY,\n            symbol=\"EURUSD\",\n            volume=0.10,\n            open_price=entry,\n            close_price=stop_loss\n        )\n\n        loss_result = await account.order_calc_profit(loss_req)\n        risk = abs(loss_result.profit)\n\n        # Calculate potential profit (hitting TP)\n        profit_req = trade_pb2.OrderCalcProfitRequest(\n            order_type=trade_pb2.ORDER_TYPE_BUY,\n            symbol=\"EURUSD\",\n            volume=0.10,\n            open_price=entry,\n            close_price=take_profit\n        )\n\n        profit_result = await account.order_calc_profit(profit_req)\n        reward = profit_result.profit\n\n        rr_ratio = reward / risk\n\n        print(f\"[RISK/REWARD ANALYSIS]\")\n        print(f\"  Entry: {entry}\")\n        print(f\"  SL: {stop_loss} (Risk: ${risk:.2f})\")\n        print(f\"  TP: {take_profit} (Reward: ${reward:.2f})\")\n        print(f\"  R:R Ratio: 1:{rr_ratio:.2f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(calc_risk_reward())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#4-calculate-pip-value","title":"4) Calculate pip value","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nasync def calc_pip_value():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Calculate value of 1 pip for 0.10 lots EURUSD\n        pip_size = 0.0001\n\n        request = trade_pb2.OrderCalcProfitRequest(\n            order_type=trade_pb2.ORDER_TYPE_BUY,\n            symbol=\"EURUSD\",\n            volume=0.10,\n            open_price=1.10000,\n            close_price=1.10000 + pip_size  # 1 pip movement\n        )\n\n        result = await account.order_calc_profit(request)\n\n        print(f\"[PIP VALUE CALCULATION]\")\n        print(f\"  Symbol: EURUSD\")\n        print(f\"  Volume: 0.10 lots\")\n        print(f\"  1 pip = ${result.profit:.2f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(calc_pip_value())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#5-compare-profitability-across-symbols","title":"5) Compare profitability across symbols","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nasync def compare_symbols():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    symbols = [\n        (\"EURUSD\", 1.10000, 1.10100),\n        (\"GBPUSD\", 1.30000, 1.30100),\n        (\"USDJPY\", 150.000, 150.100),\n    ]\n\n    try:\n        print(\"[PROFITABILITY COMPARISON]\")\n        print(\"Same pip movement (100 pips), same lot size (0.10)\")\n        print()\n\n        for symbol, entry, exit in symbols:\n            request = trade_pb2.OrderCalcProfitRequest(\n                order_type=trade_pb2.ORDER_TYPE_BUY,\n                symbol=symbol,\n                volume=0.10,\n                open_price=entry,\n                close_price=exit\n            )\n\n            result = await account.order_calc_profit(request)\n\n            print(f\"{symbol}: ${result.profit:.2f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(compare_symbols())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#6-position-sizing-based-on-risk","title":"6) Position sizing based on risk","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nasync def calc_position_size():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        max_risk = 100.00  # Maximum $100 risk\n        entry = 1.10000\n        stop_loss = 1.09950  # 50 pips SL\n\n        # Test different lot sizes to find appropriate size\n        for volume in [0.01, 0.05, 0.10, 0.20]:\n            request = trade_pb2.OrderCalcProfitRequest(\n                order_type=trade_pb2.ORDER_TYPE_BUY,\n                symbol=\"EURUSD\",\n                volume=volume,\n                open_price=entry,\n                close_price=stop_loss\n            )\n\n            result = await account.order_calc_profit(request)\n            risk = abs(result.profit)\n\n            print(f\"Volume: {volume} lots -&gt; Risk: ${risk:.2f}\")\n\n            if risk &lt;= max_risk:\n                recommended_size = volume\n            else:\n                break\n\n        print(f\"\\n[RECOMMENDATION] Use {recommended_size} lots for max ${max_risk} risk\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(calc_position_size())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_calc_profit/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>OrderCalcMargin - Calculate required margin</li> <li>OrderCheck - Validate order before sending</li> <li>OrderSend - Send market or pending orders</li> <li>SymbolInfoTick - Get current prices</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/","title":"Check Order Validity","text":"<p>Request: Validate if a trade request can be executed under current market conditions.</p> <p>API Information:</p> <ul> <li>Python API: <code>MT5Account.order_check(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.TradeFunctions</code></li> <li>Proto definition: <code>OrderCheck</code> (defined in <code>mt5-term-api-trade-functions.proto</code>)</li> <li>Enums in this method: 4 enums with 23 constants (4 input)</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.TradeFunctions</code></li> <li>Method: <code>OrderCheck(OrderCheckRequest) -&gt; OrderCheckReply</code></li> <li>Low-level client (generated): <code>TradeFunctionsStub.OrderCheck(request, metadata)</code></li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Validates trade requests before execution.</li> <li>Why you need it. Check if account has sufficient margin and validate order parameters.</li> <li>Use before sending. Always check orders before sending to avoid rejections.</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to:</p> <ul> <li>Verify sufficient margin before opening positions</li> <li>Validate order parameters (price, volume, SL/TP)</li> <li>Check broker restrictions</li> <li>Calculate margin requirements</li> <li>Estimate balance/equity changes</li> <li>Prevent rejected orders</li> </ul> <pre><code>from MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nclass MT5Account:\n    # ...\n\n    async def order_check(\n        self,\n        request: trade_pb2.OrderCheckRequest,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ) -&gt; trade_pb2.OrderCheckData:\n        \"\"\"\n        Checks whether a trade request can be successfully executed.\n\n        Returns:\n            OrderCheckData: Result of the trade request check.\n        \"\"\"\n</code></pre> <p>Request message:</p> <pre><code>message OrderCheckRequest {\n  MrpcMqlTradeRequest mql_trade_request = 1;  // Trade request to validate\n}\n\nmessage MrpcMqlTradeRequest {\n  MRPC_ENUM_TRADE_REQUEST_ACTIONS action = 1;  // Trade operation type\n  uint64 expert_advisor_magic_number = 2;      // Expert Advisor ID\n  uint64 order = 3;                            // Order ticket\n  string symbol = 4;                           // Symbol name\n  double volume = 5;                           // Volume in lots\n  double price = 6;                            // Price\n  double stop_limit = 7;                       // Stop limit price\n  double stop_loss = 8;                        // Stop loss price\n  double take_profit = 9;                      // Take profit price\n  uint64 deviation = 10;                       // Maximum deviation from price\n  ENUM_ORDER_TYPE_TF order_type = 11;          // Order type\n  MRPC_ENUM_ORDER_TYPE_FILLING type_filling = 12;  // Filling mode\n  MRPC_ENUM_ORDER_TYPE_TIME type_time = 13;    // Order lifetime\n  google.protobuf.Timestamp expiration = 14;   // Expiration time\n  string comment = 15;                         // Comment\n  uint64 position = 16;                        // Position ticket\n  uint64 position_by = 17;                     // Opposite position ticket\n}\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>request</code> <code>OrderCheckRequest</code> Trade request to validate <code>deadline</code> <code>Optional[datetime]</code> Deadline for the operation (optional) <code>cancellation_event</code> <code>Optional[asyncio.Event]</code> Event to cancel the request (optional)"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#output","title":"\u2b06\ufe0f Output","text":"<p>Returns <code>OrderCheckData</code> object with validation results.</p> <p>OrderCheckData fields:</p> Field Type Description <code>mql_trade_check_result</code> <code>MrpcMqlTradeCheckResult</code> Validation result structure <p>MrpcMqlTradeCheckResult fields:</p> Field Type Description <code>returned_code</code> <code>uint32</code> Return code (0 = success) <code>balance_after_deal</code> <code>double</code> Balance after order execution <code>equity_after_deal</code> <code>double</code> Equity after order execution <code>profit</code> <code>double</code> Estimated profit/loss <code>margin</code> <code>double</code> Required margin <code>free_margin</code> <code>double</code> Free margin after order <code>margin_level</code> <code>double</code> Margin level percentage <code>comment</code> <code>string</code> Comment or error description"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":""},{"location":"MT5Account/5.%20Trading_Operations/order_check/#mrpc_enum_trade_request_actions","title":"<code>MRPC_ENUM_TRADE_REQUEST_ACTIONS</code>","text":"<p>Used in <code>MrpcMqlTradeRequest</code> to specify the type of trade operation.</p> Constant Name Value Description <code>TRADE_ACTION_DEAL</code> 0 Place market order <code>TRADE_ACTION_PENDING</code> 1 Place pending order <code>TRADE_ACTION_SLTP</code> 2 Modify SL/TP <code>TRADE_ACTION_MODIFY</code> 3 Modify order <code>TRADE_ACTION_REMOVE</code> 4 Remove order <code>TRADE_ACTION_CLOSE_BY</code> 5 Close by opposite position <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\n# Access enum values\ntrade_pb2.TRADE_ACTION_DEAL     # = 0\ntrade_pb2.TRADE_ACTION_PENDING  # = 1\n</code></pre></p>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#enum_order_type_tf","title":"<code>ENUM_ORDER_TYPE_TF</code>","text":"<p>Used in <code>MrpcMqlTradeRequest</code> to specify order type.</p> Constant Name Value Description <code>ORDER_TYPE_TF_BUY</code> 0 Market buy order <code>ORDER_TYPE_TF_SELL</code> 1 Market sell order <code>ORDER_TYPE_TF_BUY_LIMIT</code> 2 Buy limit pending order <code>ORDER_TYPE_TF_SELL_LIMIT</code> 3 Sell limit pending order <code>ORDER_TYPE_TF_BUY_STOP</code> 4 Buy stop pending order <code>ORDER_TYPE_TF_SELL_STOP</code> 5 Sell stop pending order <code>ORDER_TYPE_TF_BUY_STOP_LIMIT</code> 6 Buy stop limit pending order <code>ORDER_TYPE_TF_SELL_STOP_LIMIT</code> 7 Sell stop limit pending order <code>ORDER_TYPE_TF_CLOSE_BY</code> 8 Close by opposite position <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\n# Access enum values\ntrade_pb2.ORDER_TYPE_TF_BUY         # = 0\ntrade_pb2.ORDER_TYPE_TF_SELL        # = 1\ntrade_pb2.ORDER_TYPE_TF_BUY_LIMIT   # = 2\n</code></pre></p>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#mrpc_enum_order_type_filling","title":"<code>MRPC_ENUM_ORDER_TYPE_FILLING</code>","text":"<p>Used in <code>MrpcMqlTradeRequest</code> to specify order filling mode.</p> Constant Name Value Description <code>ORDER_FILLING_FOK</code> 0 Fill or Kill <code>ORDER_FILLING_IOC</code> 1 Immediate or Cancel <code>ORDER_FILLING_RETURN</code> 2 Return order <code>ORDER_FILLING_BOC</code> 3 Book or Cancel <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\n# Access enum values\ntrade_pb2.ORDER_FILLING_FOK     # = 0\ntrade_pb2.ORDER_FILLING_IOC     # = 1\n</code></pre></p>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#mrpc_enum_order_type_time","title":"<code>MRPC_ENUM_ORDER_TYPE_TIME</code>","text":"<p>Used in <code>MrpcMqlTradeRequest</code> to specify order lifetime.</p> Constant Name Value Description <code>ORDER_TIME_GTC</code> 0 Good till cancelled <code>ORDER_TIME_DAY</code> 1 Good till current trading day <code>ORDER_TIME_SPECIFIED</code> 2 Good till specified date <code>ORDER_TIME_SPECIFIED_DAY</code> 3 Good till specified day <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\n# Access enum values\ntrade_pb2.ORDER_TIME_GTC        # = 0\ntrade_pb2.ORDER_TIME_DAY        # = 1\n</code></pre></p>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: OrderCheck - How it works</p>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>No execution: This method does NOT execute the order, only validates it.</li> <li>Nested structure: Request uses <code>OrderCheckRequest</code> which contains <code>MrpcMqlTradeRequest</code>.</li> <li>Margin check: Returns required margin and free margin after order.</li> <li>Return code: Check <code>returned_code</code> field (0 = success).</li> <li>Best practice: Always check before sending, especially for large volumes.</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/5.%20Trading_Operations/order_check/#1-basic-order-validation","title":"1) Basic order validation","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nasync def check_order():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Create order check request\n        request = trade_pb2.OrderCheckRequest()\n        request.mql_trade_request.action = trade_pb2.TRADE_ACTION_DEAL\n        request.mql_trade_request.symbol = \"EURUSD\"\n        request.mql_trade_request.volume = 0.10\n        request.mql_trade_request.order_type = trade_pb2.ORDER_TYPE_TF_BUY\n        request.mql_trade_request.price = 0.0\n        request.mql_trade_request.deviation = 20\n        request.mql_trade_request.type_filling = trade_pb2.ORDER_FILLING_FOK\n        request.mql_trade_request.type_time = trade_pb2.ORDER_TIME_GTC\n        request.mql_trade_request.comment = \"Check order\"\n\n        # Check order validity\n        result = await account.order_check(request)\n\n        if result.mql_trade_check_result.returned_code == 0:  # 0 = valid\n            print(f\"[VALID] Order can be executed!\")\n            print(f\"  Margin required: ${result.mql_trade_check_result.margin:.2f}\")\n            print(f\"  Free margin after: ${result.mql_trade_check_result.free_margin:.2f}\")\n            print(f\"  Balance after: ${result.mql_trade_check_result.balance_after_deal:.2f}\")\n        else:\n            print(f\"[INVALID] Order cannot be executed!\")\n            print(f\"  Code: {result.mql_trade_check_result.returned_code}\")\n            print(f\"  Comment: {result.mql_trade_check_result.comment}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(check_order())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#2-check-and-send-pattern","title":"2) Check and send pattern","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nasync def check_and_send():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Create order check request\n        check_request = trade_pb2.OrderCheckRequest()\n        check_request.mql_trade_request.action = trade_pb2.TRADE_ACTION_DEAL\n        check_request.mql_trade_request.symbol = \"EURUSD\"\n        check_request.mql_trade_request.volume = 0.05\n        check_request.mql_trade_request.order_type = trade_pb2.ORDER_TYPE_TF_BUY\n        check_request.mql_trade_request.price = 0.0\n        check_request.mql_trade_request.deviation = 20\n        check_request.mql_trade_request.type_filling = trade_pb2.ORDER_FILLING_FOK\n        check_request.mql_trade_request.type_time = trade_pb2.ORDER_TIME_GTC\n        check_request.mql_trade_request.comment = \"Checked order\"\n\n        # First, check the order\n        check_result = await account.order_check(check_request)\n\n        if check_result.mql_trade_check_result.returned_code == 0:\n            print(f\"[CHECK PASSED] Order is valid\")\n            print(f\"  Margin: ${check_result.mql_trade_check_result.margin:.2f}\")\n\n            # Now send the order (use same trade request)\n            send_request = trade_pb2.OrderSendRequest()\n            send_request.mql_trade_request.CopyFrom(check_request.mql_trade_request)\n            send_result = await account.order_send(send_request)\n\n            if send_result.mql_trade_result.returned_code == 10009:\n                print(f\"[SUCCESS] Order executed!\")\n                print(f\"  Deal: #{send_result.mql_trade_result.deal}\")\n                print(f\"  Price: {send_result.mql_trade_result.price}\")\n            else:\n                print(f\"[FAILED] {send_result.mql_trade_result.comment}\")\n        else:\n            print(f\"[CHECK FAILED] Cannot send order\")\n            print(f\"  Reason: {check_result.mql_trade_check_result.comment}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(check_and_send())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#3-check-multiple-volumes","title":"3) Check multiple volumes","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nasync def check_multiple_volumes():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    volumes = [0.01, 0.05, 0.10, 0.50, 1.00]\n\n    try:\n        print(\"Checking volumes for EURUSD BUY:\")\n        print(\"-\" * 60)\n\n        for volume in volumes:\n            request = trade_pb2.OrderCheckRequest()\n            request.mql_trade_request.action = trade_pb2.TRADE_ACTION_DEAL\n            request.mql_trade_request.symbol = \"EURUSD\"\n            request.mql_trade_request.volume = volume\n            request.mql_trade_request.order_type = trade_pb2.ORDER_TYPE_TF_BUY\n            request.mql_trade_request.price = 0.0\n            request.mql_trade_request.deviation = 20\n            request.mql_trade_request.type_filling = trade_pb2.ORDER_FILLING_FOK\n            request.mql_trade_request.type_time = trade_pb2.ORDER_TIME_GTC\n\n            result = await account.order_check(request)\n\n            if result.mql_trade_check_result.returned_code == 0:\n                print(f\"[OK] {volume:&gt;6.2f} lots - \"\n                      f\"Margin: ${result.mql_trade_check_result.margin:&gt;10,.2f}, \"\n                      f\"Free: ${result.mql_trade_check_result.free_margin:&gt;10,.2f}\")\n            else:\n                print(f\"[FAIL] {volume:&gt;6.2f} lots - \"\n                      f\"{result.mql_trade_check_result.comment}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(check_multiple_volumes())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#4-find-maximum-volume","title":"4) Find maximum volume","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nasync def find_max_volume():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        max_volume = 0.01\n        step = 0.01\n\n        # Binary search for maximum volume\n        current = 0.01\n\n        while current &lt;= 10.0:  # Max check up to 10 lots\n            request = trade_pb2.OrderCheckRequest()\n            request.mql_trade_request.action = trade_pb2.TRADE_ACTION_DEAL\n            request.mql_trade_request.symbol = \"EURUSD\"\n            request.mql_trade_request.volume = current\n            request.mql_trade_request.order_type = trade_pb2.ORDER_TYPE_TF_BUY\n            request.mql_trade_request.price = 0.0\n            request.mql_trade_request.deviation = 20\n            request.mql_trade_request.type_filling = trade_pb2.ORDER_FILLING_FOK\n            request.mql_trade_request.type_time = trade_pb2.ORDER_TIME_GTC\n\n            result = await account.order_check(request)\n\n            if (result.mql_trade_check_result.returned_code == 0 and\n                result.mql_trade_check_result.free_margin &gt; 0):\n                max_volume = current\n                current += step\n            else:\n                break\n\n        print(f\"[RESULT] Maximum volume: {max_volume:.2f} lots\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(find_max_volume())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#5-risk-calculator","title":"5) Risk calculator","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_pb2\n\nasync def calculate_risk_percent(volume: float):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Get current balance\n        summary_req = account_pb2.AccountSummaryRequest()\n        summary = await account.account_summary(summary_req)\n        current_balance = summary.balance\n\n        # Check order\n        request = trade_pb2.OrderCheckRequest()\n        request.mql_trade_request.action = trade_pb2.TRADE_ACTION_DEAL\n        request.mql_trade_request.symbol = \"EURUSD\"\n        request.mql_trade_request.volume = volume\n        request.mql_trade_request.order_type = trade_pb2.ORDER_TYPE_TF_BUY\n        request.mql_trade_request.price = 0.0\n        request.mql_trade_request.deviation = 20\n        request.mql_trade_request.type_filling = trade_pb2.ORDER_FILLING_FOK\n        request.mql_trade_request.type_time = trade_pb2.ORDER_TIME_GTC\n\n        result = await account.order_check(request)\n\n        if result.mql_trade_check_result.returned_code == 0:\n            margin_required = result.mql_trade_check_result.margin\n            risk_percent = (margin_required / current_balance) * 100\n\n            print(f\"[RISK ANALYSIS]\")\n            print(f\"  Volume: {volume:.2f} lots\")\n            print(f\"  Current balance: ${current_balance:,.2f}\")\n            print(f\"  Margin required: ${margin_required:,.2f}\")\n            print(f\"  Risk: {risk_percent:.2f}% of balance\")\n            print(f\"  Free margin after: ${result.mql_trade_check_result.free_margin:,.2f}\")\n        else:\n            print(f\"[ERROR] {result.mql_trade_check_result.comment}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(calculate_risk_percent(0.10))\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#6-validate-order-before-automated-trading","title":"6) Validate order before automated trading","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nclass OrderValidator:\n    def __init__(self, account):\n        self.account = account\n\n    async def validate_and_execute(self, trade_request):\n        \"\"\"Validate order before execution\"\"\"\n\n        # Check order\n        check_request = trade_pb2.OrderCheckRequest()\n        check_request.mql_trade_request.CopyFrom(trade_request)\n        check_result = await self.account.order_check(check_request)\n\n        if check_result.mql_trade_check_result.returned_code != 0:\n            return {\n                'success': False,\n                'stage': 'validation',\n                'error': check_result.mql_trade_check_result.comment\n            }\n\n        # Check free margin threshold (e.g., 30% minimum)\n        balance = check_result.mql_trade_check_result.balance_after_deal\n        margin_free = check_result.mql_trade_check_result.free_margin\n\n        if margin_free &lt; (balance * 0.30):\n            return {\n                'success': False,\n                'stage': 'margin_check',\n                'error': 'Insufficient free margin (&lt; 30%)'\n            }\n\n        # Execute order\n        send_request = trade_pb2.OrderSendRequest()\n        send_request.mql_trade_request.CopyFrom(trade_request)\n        send_result = await self.account.order_send(send_request)\n\n        if send_result.mql_trade_result.returned_code == 10009:\n            return {\n                'success': True,\n                'deal': send_result.mql_trade_result.deal,\n                'price': send_result.mql_trade_result.price\n            }\n        else:\n            return {\n                'success': False,\n                'stage': 'execution',\n                'error': send_result.mql_trade_result.comment\n            }\n\nasync def main():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    validator = OrderValidator(account)\n\n    try:\n        # Create trade request\n        trade_request = trade_pb2.MrpcMqlTradeRequest()\n        trade_request.action = trade_pb2.TRADE_ACTION_DEAL\n        trade_request.symbol = \"EURUSD\"\n        trade_request.volume = 0.05\n        trade_request.order_type = trade_pb2.ORDER_TYPE_TF_BUY\n        trade_request.price = 0.0\n        trade_request.deviation = 20\n        trade_request.type_filling = trade_pb2.ORDER_FILLING_FOK\n        trade_request.type_time = trade_pb2.ORDER_TIME_GTC\n\n        result = await validator.validate_and_execute(trade_request)\n\n        if result['success']:\n            print(f\"[SUCCESS] Deal: #{result['deal']}, Price: {result['price']}\")\n        else:\n            print(f\"[FAILED] Stage: {result['stage']}, Error: {result['error']}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_check/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>OrderSend - Send orders after validation</li> <li>OrderCalcMargin - Calculate margin only</li> <li>OrderCalcProfit - Calculate potential profit/loss</li> <li>AccountSummary - Get account balance/margin</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_close/","title":"Close Position or Order","text":"<p>Request: Close a market position or delete a pending order.</p> <p>API Information:</p> <ul> <li>Python API: <code>MT5Account.order_close(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.TradingHelper</code></li> <li>Proto definition: <code>OrderClose</code> (defined in <code>mt5-term-api-trading-helper.proto</code>)</li> <li>Enums in this method: 1 enum with 3 constants (1 output)</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.TradingHelper</code></li> <li>Method: <code>OrderClose(OrderCloseRequest) -&gt; OrderCloseReply</code></li> <li>Low-level client (generated): <code>TradingHelperStub.OrderClose(request, metadata)</code></li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Closes market positions or deletes pending orders.</li> <li>Why you need it. Exit positions or cancel pending orders.</li> <li>Partial close. Set volume &lt; position volume to close partially, or 0 to close all.</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to:</p> <ul> <li>Close market positions completely or partially</li> <li>Delete pending orders</li> <li>Exit losing positions quickly</li> <li>Take profits on winning positions</li> <li>Cancel unfilled pending orders</li> </ul> <pre><code>from MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\n\nclass MT5Account:\n    # ...\n\n    async def order_close(\n        self,\n        request: trading_pb2.OrderCloseRequest,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Closes a market or pending order asynchronously.\n\n        Returns:\n            OrderCloseData: The close result and return codes.\n        \"\"\"\n</code></pre> <p>Request message:</p> <pre><code>OrderCloseRequest {\n  uint64 ticket = 1;      // Order/position ticket to close\n  double volume = 2;      // Volume to close (0 = close all)\n  int32 slippage = 5;     // Max slippage in points\n}\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>request</code> <code>OrderCloseRequest</code> Close request (see fields above) <code>deadline</code> <code>Optional[datetime]</code> Deadline for the operation (optional) <code>cancellation_event</code> <code>Optional[asyncio.Event]</code> Event to cancel the request (optional)"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#output","title":"\u2b06\ufe0f Output","text":"<p>Returns <code>OrderCloseData</code> object.</p> <p>OrderCloseData fields:</p> Field Type Description <code>returned_code</code> <code>int32</code> Return code (10009 = success) <code>returned_string_code</code> <code>string</code> String return code <code>returned_code_description</code> <code>string</code> Description of return code <code>close_mode</code> <code>int32</code> Close mode used"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":""},{"location":"MT5Account/5.%20Trading_Operations/order_close/#mrpc_order_close_mode","title":"<code>MRPC_ORDER_CLOSE_MODE</code>","text":"<p>Used in <code>OrderCloseData</code> to indicate the close mode.</p> Constant Name Value Description <code>MRPC_MARKET_ORDER_CLOSE</code> 0 Full position close <code>MRPC_MARKET_ORDER_PARTIAL_CLOSE</code> 1 Partial position close <code>MRPC_PENDING_ORDER_REMOVE</code> 2 Pending order removal <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\n# Access enum values\ntrading_pb2.MRPC_MARKET_ORDER_CLOSE          # = 0\ntrading_pb2.MRPC_MARKET_ORDER_PARTIAL_CLOSE  # = 1\ntrading_pb2.MRPC_PENDING_ORDER_REMOVE        # = 2\n</code></pre></p>"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: OrderClose - How it works</p>"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Return code: Always check <code>returned_code == 10009</code> to verify success.</li> <li>Close all: Set <code>volume = 0</code> to close entire position.</li> <li>Partial close: Set <code>volume</code> to specific amount to close partially.</li> <li>Slippage: Set appropriate slippage for market positions to allow price movement.</li> <li>Pending orders: Slippage is ignored when closing pending orders.</li> <li>Ticket number: Get ticket from <code>opened_orders</code> or track it when opening positions.</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/5.%20Trading_Operations/order_close/#1-close-entire-position","title":"1) Close entire position","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\nasync def close_position():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Close position with ticket 123456\n        request = trading_pb2.OrderCloseRequest(\n            ticket=123456,\n            volume=0,  # 0 = close all\n            slippage=20  # 20 points max slippage\n        )\n\n        result = await account.order_close(request)\n\n        if result.returned_code == 10009:\n            print(f\"[SUCCESS] Position closed!\")\n            print(f\"  Mode: {result.close_mode}\")\n        else:\n            print(f\"[FAILED] Code: {result.returned_code}\")\n            print(f\"  Description: {result.returned_code_description}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(close_position())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#2-close-all-open-positions","title":"2) Close all open positions","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_pb2\n\nasync def close_all_positions():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Get all open positions\n        request = account_pb2.OpenedOrdersRequest()\n        positions_data = await account.opened_orders(request)\n\n        closed_count = 0\n        failed_count = 0\n\n        # Close each position\n        for position in positions_data.positions:\n            close_req = trading_pb2.OrderCloseRequest(\n                ticket=position.ticket,\n                volume=0,  # Close all\n                slippage=20\n            )\n\n            result = await account.order_close(close_req)\n\n            if result.returned_code == 10009:\n                closed_count += 1\n                print(f\"[CLOSED] Position #{position.ticket}\")\n            else:\n                failed_count += 1\n                print(f\"[FAILED] Position #{position.ticket}: \"\n                      f\"{result.returned_code_description}\")\n\n        print(f\"\\n[SUMMARY] Closed: {closed_count}, Failed: {failed_count}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(close_all_positions())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#3-partial-position-close","title":"3) Partial position close","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\nasync def partial_close():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Close half of a 0.10 lot position\n        request = trading_pb2.OrderCloseRequest(\n            ticket=123456,\n            volume=0.05,  # Close 0.05 lots\n            slippage=20\n        )\n\n        result = await account.order_close(request)\n\n        if result.returned_code == 10009:\n            print(f\"[SUCCESS] Partial close executed!\")\n            print(f\"  Closed volume: 0.05 lots\")\n            print(f\"  Remaining: 0.05 lots\")\n        else:\n            print(f\"[FAILED] {result.returned_code_description}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(partial_close())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#4-delete-pending-order","title":"4) Delete pending order","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\nasync def delete_pending_order():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Delete pending order\n        request = trading_pb2.OrderCloseRequest(\n            ticket=789012,\n            volume=0,\n            slippage=0  # Slippage not used for pending orders\n        )\n\n        result = await account.order_close(request)\n\n        if result.returned_code == 10009:\n            print(f\"[SUCCESS] Pending order deleted!\")\n        else:\n            print(f\"[FAILED] {result.returned_code_description}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(delete_pending_order())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#5-close-positions-by-symbol","title":"5) Close positions by symbol","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_pb2\n\nasync def close_by_symbol(symbol: str):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Get all open positions\n        request = account_pb2.OpenedOrdersRequest()\n        positions_data = await account.opened_orders(request)\n\n        closed = []\n        failed = []\n\n        # Close positions for specific symbol\n        for position in positions_data.positions:\n            if position.symbol == symbol:\n                close_req = trading_pb2.OrderCloseRequest(\n                    ticket=position.ticket,\n                    volume=0,\n                    slippage=20\n                )\n\n                result = await account.order_close(close_req)\n\n                if result.returned_code == 10009:\n                    closed.append(position.ticket)\n                    print(f\"[CLOSED] {symbol} position #{position.ticket}\")\n                else:\n                    failed.append(position.ticket)\n                    print(f\"[FAILED] #{position.ticket}: \"\n                          f\"{result.returned_code_description}\")\n\n        print(f\"\\n[{symbol}] Closed: {len(closed)}, Failed: {len(failed)}\")\n\n    finally:\n        await account.channel.close()\n\n# Close all EURUSD positions\nasyncio.run(close_by_symbol(\"EURUSD\"))\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#6-close-with-retry-and-error-handling","title":"6) Close with retry and error handling","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\nasync def close_with_retry(ticket: int, max_retries=3):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        for attempt in range(1, max_retries + 1):\n            print(f\"[ATTEMPT {attempt}/{max_retries}]\")\n\n            request = trading_pb2.OrderCloseRequest(\n                ticket=ticket,\n                volume=0,\n                slippage=30  # Allow higher slippage for retries\n            )\n\n            try:\n                result = await account.order_close(request)\n\n                if result.returned_code == 10009:\n                    print(f\"[SUCCESS] Position closed on attempt {attempt}!\")\n                    return True\n                else:\n                    print(f\"[FAILED] Code: {result.returned_code}\")\n                    print(f\"  Description: {result.returned_code_description}\")\n\n                    if attempt &lt; max_retries:\n                        print(f\"  Retrying in 1 second...\")\n                        await asyncio.sleep(1)\n\n            except Exception as e:\n                print(f\"[ERROR] {e}\")\n                if attempt &lt; max_retries:\n                    await asyncio.sleep(1)\n\n        print(f\"[GIVING UP] Failed to close position after {max_retries} attempts\")\n        return False\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(close_with_retry(123456))\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_close/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>OrderSend - Open positions</li> <li>OrderModify - Modify positions/orders</li> <li>OpenedOrders - Get open positions</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/","title":"Modify Order or Position","text":"<p>Request: Modify Stop Loss, Take Profit, price, or expiration of an order/position.</p> <p>API Information:</p> <ul> <li>Python API: <code>MT5Account.order_modify(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.TradingHelper</code></li> <li>Proto definition: <code>OrderModify</code> (defined in <code>mt5-term-api-trading-helper.proto</code>)</li> <li>Enums in this method: 1 enum with 4 constants (1 input)</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.TradingHelper</code></li> <li>Method: <code>OrderModify(OrderModifyRequest) -&gt; OrderModifyReply</code></li> <li>Low-level client (generated): <code>TradingHelperStub.OrderModify(request, metadata)</code></li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Modifies SL/TP, price, or expiration of existing orders/positions.</li> <li>Why you need it. Adjust risk management levels or pending order parameters.</li> <li>Set to zero. Use 0 to remove SL or TP.</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to:</p> <ul> <li>Add or modify Stop Loss levels</li> <li>Add or modify Take Profit levels</li> <li>Change pending order prices</li> <li>Update order expiration times</li> <li>Adjust trailing stops</li> <li>Remove SL/TP (set to 0)</li> </ul> <pre><code>from MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\nclass MT5Account:\n    # ...\n\n    async def order_modify(\n        self,\n        request: trading_pb2.OrderModifyRequest,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Modifies an existing order or position asynchronously.\n\n        Returns:\n            OrderModifyData: Response containing updated order/deal info.\n        \"\"\"\n</code></pre> <p>Request message:</p> <pre><code>OrderModifyRequest {\n  uint64 ticket = 1;                             // Order/position ticket to modify\n  double stop_loss = 2;                          // New Stop Loss price (0 = remove)\n  double take_profit = 3;                        // New Take Profit price (0 = remove)\n  double price = 4;                              // New price (for pending orders)\n  TMT5_ENUM_ORDER_TYPE_TIME expiration_time_type = 5;  // New expiration type\n  google.protobuf.Timestamp expiration_time = 6;       // New expiration time\n  double stop_limit = 8;                         // New stop limit price\n}\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>request</code> <code>OrderModifyRequest</code> Modification request (see fields above) <code>deadline</code> <code>Optional[datetime]</code> Deadline for the operation (optional) <code>cancellation_event</code> <code>Optional[asyncio.Event]</code> Event to cancel the request (optional)"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#output","title":"\u2b06\ufe0f Output","text":"<p>Returns <code>OrderModifyData</code> object.</p> <p>OrderModifyData fields:</p> Field Type Description <code>returned_code</code> <code>int32</code> Return code (10009 = success) <code>returned_string_code</code> <code>string</code> String return code <code>returned_code_description</code> <code>string</code> Description of return code <code>deal</code> <code>uint64</code> Deal ticket (if executed) <code>order</code> <code>uint64</code> Order ticket <code>volume</code> <code>double</code> Volume <code>price</code> <code>double</code> Execution price <code>bid</code> <code>double</code> Current bid price <code>ask</code> <code>double</code> Current ask price <code>comment</code> <code>string</code> Broker comment <code>request_id</code> <code>uint64</code> Request ID <code>ret_code_external</code> <code>uint32</code> External return code"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":""},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#tmt5_enum_order_type_time","title":"<code>TMT5_ENUM_ORDER_TYPE_TIME</code>","text":"<p>Used in <code>OrderModifyRequest</code> to specify expiration time type.</p> Constant Name Value Description <code>TMT5_ORDER_TIME_GTC</code> 0 Good till cancelled <code>TMT5_ORDER_TIME_DAY</code> 1 Good till current trading day <code>TMT5_ORDER_TIME_SPECIFIED</code> 2 Good till specified date <code>TMT5_ORDER_TIME_SPECIFIED_DAY</code> 3 Good till specified day <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\n# Access enum values\ntrading_pb2.TMT5_ORDER_TIME_GTC            # = 0\ntrading_pb2.TMT5_ORDER_TIME_DAY            # = 1\ntrading_pb2.TMT5_ORDER_TIME_SPECIFIED      # = 2\ntrading_pb2.TMT5_ORDER_TIME_SPECIFIED_DAY  # = 3\n</code></pre></p>"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: OrderModify - How it works</p>"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Zero to remove: Set <code>stop_loss=0</code> or <code>take_profit=0</code> to remove them.</li> <li>Pending orders: Can modify price and expiration of pending orders.</li> <li>Market positions: Can only modify SL/TP for market positions.</li> <li>Min distance: Broker enforces minimum distance from current price for SL/TP.</li> <li>Freeze level: Cannot modify orders too close to market price (broker setting).</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#1-add-stop-loss-to-position","title":"1) Add Stop Loss to position","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\nimport MetaRpcMT5.mt5_term_api_market_info_pb2 as market_pb2\n\nasync def add_stop_loss():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Get current price\n        tick_req = market_pb2.SymbolInfoTickRequest(symbol=\"EURUSD\")\n        tick_data = await account.symbol_info_tick(tick_req)\n        current_bid = tick_data.tick.bid\n\n        # Set SL 50 pips below current price\n        pip_size = 0.0001\n        sl_price = current_bid - (50 * pip_size)\n\n        # Modify position to add SL\n        request = trading_pb2.OrderModifyRequest(\n            ticket=123456,\n            stop_loss=sl_price,\n            take_profit=0,  # Keep existing TP or no TP\n            price=0         # Not used for market positions\n        )\n\n        result = await account.order_modify(request)\n        print(f\"[SUCCESS] Stop Loss added at {sl_price:.5f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(add_stop_loss())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#2-modify-both-sl-and-tp","title":"2) Modify both SL and TP","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\nimport MetaRpcMT5.mt5_term_api_market_info_pb2 as market_pb2\n\nasync def modify_sl_tp():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Get current price\n        tick_req = market_pb2.SymbolInfoTickRequest(symbol=\"EURUSD\")\n        tick_data = await account.symbol_info_tick(tick_req)\n        current_bid = tick_data.tick.bid\n\n        pip_size = 0.0001\n        new_sl = current_bid - (30 * pip_size)  # 30 pips SL\n        new_tp = current_bid + (60 * pip_size)  # 60 pips TP (2:1 R:R)\n\n        request = trading_pb2.OrderModifyRequest(\n            ticket=123456,\n            stop_loss=new_sl,\n            take_profit=new_tp,\n            price=0\n        )\n\n        result = await account.order_modify(request)\n        print(f\"[SUCCESS] Modified SL/TP!\")\n        print(f\"  New SL: {new_sl:.5f}\")\n        print(f\"  New TP: {new_tp:.5f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(modify_sl_tp())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#3-remove-stop-loss","title":"3) Remove Stop Loss","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\nasync def remove_stop_loss():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Set SL to 0 to remove it\n        request = trading_pb2.OrderModifyRequest(\n            ticket=123456,\n            stop_loss=0,     # Remove SL\n            take_profit=0,   # Keep existing TP\n            price=0\n        )\n\n        result = await account.order_modify(request)\n        print(f\"[SUCCESS] Stop Loss removed!\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(remove_stop_loss())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#4-modify-pending-order-price","title":"4) Modify pending order price","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\nimport MetaRpcMT5.mt5_term_api_market_info_pb2 as market_pb2\n\nasync def modify_pending_order_price():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Get current price\n        tick_req = market_pb2.SymbolInfoTickRequest(symbol=\"EURUSD\")\n        tick_data = await account.symbol_info_tick(tick_req)\n        current_bid = tick_data.tick.bid\n\n        # New BUY LIMIT price (15 pips below current)\n        pip_size = 0.0001\n        new_price = current_bid - (15 * pip_size)\n\n        request = trading_pb2.OrderModifyRequest(\n            ticket=789012,  # Pending order ticket\n            stop_loss=0,\n            take_profit=0,\n            price=new_price  # New entry price\n        )\n\n        result = await account.order_modify(request)\n        print(f\"[SUCCESS] Pending order price updated to {new_price:.5f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(modify_pending_order_price())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#5-trailing-stop-implementation","title":"5) Trailing stop implementation","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\nimport MetaRpcMT5.mt5_term_api_market_info_pb2 as market_pb2\n\nasync def trailing_stop(ticket: int, trail_distance_pips: int):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    pip_size = 0.0001\n    last_sl = None\n\n    try:\n        while True:\n            # Get current price\n            tick_req = market_pb2.SymbolInfoTickRequest(symbol=\"EURUSD\")\n            tick_data = await account.symbol_info_tick(tick_req)\n            current_bid = tick_data.tick.bid\n\n            # Calculate new SL\n            new_sl = current_bid - (trail_distance_pips * pip_size)\n\n            # Only update if new SL is higher (for BUY)\n            if last_sl is None or new_sl &gt; last_sl:\n                request = trading_pb2.OrderModifyRequest(\n                    ticket=ticket,\n                    stop_loss=new_sl,\n                    take_profit=0,\n                    price=0\n                )\n\n                result = await account.order_modify(request)\n                print(f\"[TRAIL] SL updated to {new_sl:.5f}\")\n                last_sl = new_sl\n\n            await asyncio.sleep(1)  # Check every second\n\n    except KeyboardInterrupt:\n        print(\"\\nTrailing stop stopped\")\n\n    finally:\n        await account.channel.close()\n\n# Trail stop 30 pips behind price\nasyncio.run(trailing_stop(123456, 30))\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#6-break-even-stop-loss","title":"6) Break-even stop loss","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\nimport MetaRpcMT5.mt5_term_api_account_helper_pb2 as account_pb2\n\nasync def move_to_breakeven(ticket: int, breakeven_trigger_pips: int):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Get position details\n        positions_req = account_pb2.OpenedOrdersRequest()\n        positions_data = await account.opened_orders(positions_req)\n\n        position = next((p for p in positions_data.positions if p.ticket == ticket), None)\n\n        if not position:\n            print(f\"[ERROR] Position #{ticket} not found\")\n            return\n\n        entry_price = position.price_open\n        pip_size = 0.0001\n\n        # Check if profit reached trigger level\n        profit_pips = (position.price_current - entry_price) / pip_size\n\n        if profit_pips &gt;= breakeven_trigger_pips:\n            # Move SL to breakeven\n            request = trading_pb2.OrderModifyRequest(\n                ticket=ticket,\n                stop_loss=entry_price,  # Set SL to entry price\n                take_profit=0,\n                price=0\n            )\n\n            result = await account.order_modify(request)\n            print(f\"[BREAKEVEN] SL moved to entry price {entry_price:.5f}\")\n            print(f\"  Current profit: {profit_pips:.1f} pips\")\n        else:\n            print(f\"[WAITING] Profit {profit_pips:.1f} pips &lt; trigger {breakeven_trigger_pips} pips\")\n\n    finally:\n        await account.channel.close()\n\n# Move to breakeven when profit reaches 20 pips\nasyncio.run(move_to_breakeven(123456, 20))\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_modify/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>OrderSend - Open positions</li> <li>OrderClose - Close positions</li> <li>OpenedOrders - Get position details</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/","title":"Send Market or Pending Order","text":"<p>Request: Send a market or pending order to the trading server.</p> <p>API Information:</p> <ul> <li>Python API: <code>MT5Account.order_send(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.TradingHelper</code></li> <li>Proto definition: <code>OrderSend</code> (defined in <code>mt5-term-api-trading-helper.proto</code>)</li> <li>Enums in this method: 2 enums with 13 constants (2 input)</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.TradingHelper</code></li> <li>Method: <code>OrderSend(OrderSendRequest) -&gt; OrderSendReply</code></li> <li>Low-level client (generated): <code>TradingHelperStub.OrderSend(request, metadata)</code></li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Sends market or pending orders to the MT5 trading server.</li> <li>Why you need it. Primary method for opening positions and placing pending orders.</li> <li>Success code. Return code 10009 means success.</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to:</p> <ul> <li>Open market positions (BUY or SELL)</li> <li>Place pending orders (LIMIT, STOP, STOP_LIMIT)</li> <li>Set Stop Loss and Take Profit levels</li> <li>Specify order expiration</li> <li>Add order comments and magic numbers</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: OrderSend - How it works</p> <pre><code>from MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\nclass MT5Account:\n    # ...\n\n    async def order_send(\n        self,\n        request: trading_pb2.OrderSendRequest,\n        deadline: Optional[datetime] = None,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ) -&gt; trading_pb2.OrderSendData:\n        \"\"\"\n        Sends a market or pending order to the trading server asynchronously.\n\n        Returns:\n            OrderSendData: Response with deal/order confirmation data.\n        \"\"\"\n</code></pre> <p>Request message:</p> <pre><code>message OrderSendRequest {\n  string symbol = 1;                             // Trading symbol\n  TMT5_ENUM_ORDER_TYPE operation = 2;            // Order type (BUY, SELL, BUY_LIMIT, etc.)\n  double volume = 3;                             // Order volume in lots\n  double price = 4;                              // Order price (for pending orders)\n  uint64 slippage = 5;                           // Max slippage in points\n  double stop_loss = 6;                          // Stop loss price (optional)\n  double take_profit = 7;                        // Take profit price (optional)\n  string comment = 8;                            // Order comment\n  uint64 expert_id = 9;                          // Expert Advisor ID (magic number)\n  double stop_limit_price = 10;                  // Stop limit price (for STOP_LIMIT orders)\n  TMT5_ENUM_ORDER_TYPE_TIME expiration_time_type = 11;  // Expiration type (GTC, DAY, etc.)\n  google.protobuf.Timestamp expiration_time = 12;       // Expiration time\n}\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>request</code> <code>OrderSendRequest</code> Order request (see fields above) <code>deadline</code> <code>Optional[datetime]</code> Deadline for the operation (optional) <code>cancellation_event</code> <code>Optional[asyncio.Event]</code> Event to cancel the request (optional)"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#output","title":"\u2b06\ufe0f Output","text":"<p>Returns <code>OrderSendData</code> object.</p> <p>OrderSendData fields:</p> Field Type Description <code>returned_code</code> <code>uint32</code> Return code (10009 = success) <code>deal</code> <code>uint32</code> Deal ticket (for market orders) <code>order</code> <code>uint32</code> Order ticket (for pending orders) <code>volume</code> <code>double</code> Executed volume <code>price</code> <code>double</code> Execution price <code>bid</code> <code>double</code> Current Bid price <code>ask</code> <code>double</code> Current Ask price <code>comment</code> <code>string</code> Broker comment <code>request_id</code> <code>uint32</code> Request ID <code>ret_code_external</code> <code>uint64</code> External return code <code>returned_string_code</code> <code>string</code> String return code <code>returned_code_description</code> <code>string</code> Description of return code"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#related-enums-from-proto","title":"\ud83e\uddf1 Related enums (from proto)","text":""},{"location":"MT5Account/5.%20Trading_Operations/order_send/#tmt5_enum_order_type","title":"<code>TMT5_ENUM_ORDER_TYPE</code>","text":"<p>Used in <code>OrderSendRequest</code> to specify order type.</p> Constant Name Value Description <code>TMT5_ORDER_TYPE_BUY</code> 0 Market buy order <code>TMT5_ORDER_TYPE_SELL</code> 1 Market sell order <code>TMT5_ORDER_TYPE_BUY_LIMIT</code> 2 Buy limit pending order <code>TMT5_ORDER_TYPE_SELL_LIMIT</code> 3 Sell limit pending order <code>TMT5_ORDER_TYPE_BUY_STOP</code> 4 Buy stop pending order <code>TMT5_ORDER_TYPE_SELL_STOP</code> 5 Sell stop pending order <code>TMT5_ORDER_TYPE_BUY_STOP_LIMIT</code> 6 Buy stop limit pending order <code>TMT5_ORDER_TYPE_SELL_STOP_LIMIT</code> 7 Sell stop limit pending order <code>TMT5_ORDER_TYPE_CLOSE_BY</code> 8 Close by opposite position <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\n# Access enum values\ntrading_pb2.TMT5_ORDER_TYPE_BUY             # = 0\ntrading_pb2.TMT5_ORDER_TYPE_SELL            # = 1\ntrading_pb2.TMT5_ORDER_TYPE_BUY_LIMIT       # = 2\ntrading_pb2.TMT5_ORDER_TYPE_SELL_LIMIT      # = 3\ntrading_pb2.TMT5_ORDER_TYPE_BUY_STOP        # = 4\ntrading_pb2.TMT5_ORDER_TYPE_SELL_STOP       # = 5\ntrading_pb2.TMT5_ORDER_TYPE_BUY_STOP_LIMIT  # = 6\ntrading_pb2.TMT5_ORDER_TYPE_SELL_STOP_LIMIT # = 7\ntrading_pb2.TMT5_ORDER_TYPE_CLOSE_BY        # = 8\n</code></pre></p>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#tmt5_enum_order_type_time","title":"<code>TMT5_ENUM_ORDER_TYPE_TIME</code>","text":"<p>Used in <code>OrderSendRequest</code> to specify order lifetime.</p> Constant Name Value Description <code>TMT5_ORDER_TIME_GTC</code> 0 Good till cancelled <code>TMT5_ORDER_TIME_DAY</code> 1 Good till current trading day <code>TMT5_ORDER_TIME_SPECIFIED</code> 2 Good till specified date <code>TMT5_ORDER_TIME_SPECIFIED_DAY</code> 3 Good till specified day <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\n# Access enum values\ntrading_pb2.TMT5_ORDER_TIME_GTC            # = 0\ntrading_pb2.TMT5_ORDER_TIME_DAY            # = 1\ntrading_pb2.TMT5_ORDER_TIME_SPECIFIED      # = 2\ntrading_pb2.TMT5_ORDER_TIME_SPECIFIED_DAY  # = 3\n</code></pre></p>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_with_reconnect</code>.</li> <li>Return code: Always check <code>returned_code == 10009</code> to verify success.</li> <li>Market vs Pending: Use operation 0 (BUY) or 1 (SELL) for market orders, other codes for pending orders.</li> <li>Slippage: Set appropriate slippage for market orders to allow price movement.</li> <li>Volume: Volume is specified in lots (e.g., 0.01 = 1 micro lot).</li> <li>SL/TP: Can be set during order placement or modified later.</li> <li>Magic number: Use <code>expert_id</code> to identify orders from your EA.</li> <li>Validation: Use <code>order_check</code> before sending to validate the order.</li> </ul>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/5.%20Trading_Operations/order_send/#1-send-market-buy-order","title":"1) Send market BUY order","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\nasync def market_buy():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Create market BUY order request\n        request = trading_pb2.OrderSendRequest(\n            symbol=\"EURUSD\",\n            operation=trading_pb2.TMT5_ORDER_TYPE_BUY,\n            volume=0.01,  # 0.01 lots (1 micro lot)\n            price=0,      # 0 for market orders\n            slippage=20,  # 20 points max slippage\n            stop_loss=0,  # No SL\n            take_profit=0,  # No TP\n            comment=\"Market BUY\",\n            expert_id=12345\n        )\n\n        # Send order\n        result = await account.order_send(request)\n\n        # Check result\n        if result.returned_code == 10009:\n            print(f\"[SUCCESS] Order executed!\")\n            print(f\"  Deal: #{result.deal}\")\n            print(f\"  Volume: {result.volume}\")\n            print(f\"  Price: {result.price}\")\n            print(f\"  Bid: {result.bid}, Ask: {result.ask}\")\n        else:\n            print(f\"[FAILED] Code: {result.returned_code}\")\n            print(f\"  Description: {result.returned_code_description}\")\n            print(f\"  Comment: {result.comment}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(market_buy())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#2-send-market-order-with-sltp","title":"2) Send market order with SL/TP","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\nasync def market_order_with_sl_tp():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Get current price first\n        import MetaRpcMT5.mt5_term_api_market_info_pb2 as market_pb2\n\n        tick_req = market_pb2.SymbolInfoTickRequest(symbol=\"EURUSD\")\n        tick_data = await account.symbol_info_tick(tick_req)\n\n        current_ask = tick_data.tick.ask\n        current_bid = tick_data.tick.bid\n\n        # Calculate SL/TP levels (50 pips)\n        pip_size = 0.0001\n        sl_price = current_ask - (50 * pip_size)  # 50 pips below\n        tp_price = current_ask + (50 * pip_size)  # 50 pips above\n\n        # Create BUY order with SL/TP\n        request = trading_pb2.OrderSendRequest(\n            symbol=\"EURUSD\",\n            operation=trading_pb2.TMT5_ORDER_TYPE_BUY,\n            volume=0.01,\n            price=0,\n            slippage=20,\n            stop_loss=sl_price,\n            take_profit=tp_price,\n            comment=\"BUY with SL/TP\",\n            expert_id=12345\n        )\n\n        result = await account.order_send(request)\n\n        if result.returned_code == 10009:\n            print(f\"[SUCCESS] Order with SL/TP executed!\")\n            print(f\"  Entry: {result.price:.5f}\")\n            print(f\"  SL: {sl_price:.5f}\")\n            print(f\"  TP: {tp_price:.5f}\")\n        else:\n            print(f\"[FAILED] {result.returned_code_description}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(market_order_with_sl_tp())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#3-place-pending-buy-limit-order","title":"3) Place pending BUY LIMIT order","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\nimport MetaRpcMT5.mt5_term_api_market_info_pb2 as market_pb2\n\nasync def buy_limit_order():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Get current price\n        tick_req = market_pb2.SymbolInfoTickRequest(symbol=\"EURUSD\")\n        tick_data = await account.symbol_info_tick(tick_req)\n\n        current_bid = tick_data.tick.bid\n\n        # Place BUY LIMIT 20 pips below current price\n        pip_size = 0.0001\n        limit_price = current_bid - (20 * pip_size)\n\n        # Create BUY LIMIT order\n        request = trading_pb2.OrderSendRequest(\n            symbol=\"EURUSD\",\n            operation=trading_pb2.TMT5_ORDER_TYPE_BUY_LIMIT,\n            volume=0.01,\n            price=limit_price,\n            slippage=0,  # Not used for pending orders\n            stop_loss=0,\n            take_profit=0,\n            comment=\"BUY LIMIT order\",\n            expert_id=12345\n        )\n\n        result = await account.order_send(request)\n\n        if result.returned_code == 10009:\n            print(f\"[SUCCESS] BUY LIMIT order placed!\")\n            print(f\"  Order: #{result.order}\")\n            print(f\"  Price: {limit_price:.5f}\")\n            print(f\"  Current: {current_bid:.5f}\")\n        else:\n            print(f\"[FAILED] {result.returned_code_description}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(buy_limit_order())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#4-place-buy-stop-order-with-expiration","title":"4) Place BUY STOP order with expiration","text":"<pre><code>import asyncio\nfrom datetime import datetime, timedelta\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\nimport MetaRpcMT5.mt5_term_api_market_info_pb2 as market_pb2\n\nasync def buy_stop_with_expiration():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Get current price\n        tick_req = market_pb2.SymbolInfoTickRequest(symbol=\"EURUSD\")\n        tick_data = await account.symbol_info_tick(tick_req)\n\n        current_ask = tick_data.tick.ask\n\n        # Place BUY STOP 20 pips above current price\n        pip_size = 0.0001\n        stop_price = current_ask + (20 * pip_size)\n\n        # Set expiration to 1 hour from now\n        from google.protobuf.timestamp_pb2 import Timestamp\n        expiration = datetime.now() + timedelta(hours=1)\n        expiration_timestamp = Timestamp()\n        expiration_timestamp.FromDatetime(expiration)\n\n        # Create BUY STOP order\n        request = trading_pb2.OrderSendRequest(\n            symbol=\"EURUSD\",\n            operation=trading_pb2.TMT5_ORDER_TYPE_BUY_STOP,\n            volume=0.01,\n            price=stop_price,\n            slippage=0,\n            stop_loss=0,\n            take_profit=0,\n            comment=\"BUY STOP 1h expiry\",\n            expert_id=12345,\n            expiration_time_type=trading_pb2.TMT5_ORDER_TIME_SPECIFIED\n        )\n        request.expiration_time.CopyFrom(expiration_timestamp)\n\n        result = await account.order_send(request)\n\n        if result.returned_code == 10009:\n            print(f\"[SUCCESS] BUY STOP order placed!\")\n            print(f\"  Order: #{result.order}\")\n            print(f\"  Price: {stop_price:.5f}\")\n            print(f\"  Expires: {expiration.strftime('%Y-%m-%d %H:%M:%S')}\")\n        else:\n            print(f\"[FAILED] {result.returned_code_description}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(buy_stop_with_expiration())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#5-multiple-orders-with-error-handling","title":"5) Multiple orders with error handling","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\nasync def multiple_orders():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    orders = [\n        (\"EURUSD\", 0.01, \"EUR order\"),\n        (\"GBPUSD\", 0.01, \"GBP order\"),\n        (\"USDJPY\", 0.01, \"JPY order\"),\n    ]\n\n    successful = 0\n    failed = 0\n\n    try:\n        for symbol, volume, comment in orders:\n            request = trading_pb2.OrderSendRequest(\n                symbol=symbol,\n                operation=trading_pb2.TMT5_ORDER_TYPE_BUY,\n                volume=volume,\n                price=0,\n                slippage=20,\n                comment=comment,\n                expert_id=12345\n            )\n\n            try:\n                result = await account.order_send(request)\n\n                if result.returned_code == 10009:\n                    successful += 1\n                    print(f\"[OK] {symbol}: Deal #{result.deal} @ {result.price}\")\n                else:\n                    failed += 1\n                    print(f\"[FAIL] {symbol}: {result.returned_code_description}\")\n\n            except Exception as e:\n                failed += 1\n                print(f\"[ERROR] {symbol}: {e}\")\n\n        print(f\"\\n[SUMMARY] Successful: {successful}, Failed: {failed}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(multiple_orders())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#6-order-with-retry-logic","title":"6) Order with retry logic","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_helper_pb2 as trading_pb2\n\nasync def order_with_retry():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    max_retries = 3\n    retry_delay = 1.0  # seconds\n\n    try:\n        request = trading_pb2.OrderSendRequest(\n            symbol=\"EURUSD\",\n            operation=trading_pb2.TMT5_ORDER_TYPE_BUY,\n            volume=0.01,\n            price=0,\n            slippage=20,\n            comment=\"Order with retry\",\n            expert_id=12345\n        )\n\n        for attempt in range(1, max_retries + 1):\n            print(f\"[ATTEMPT {attempt}/{max_retries}]\")\n\n            result = await account.order_send(request)\n\n            if result.returned_code == 10009:\n                print(f\"[SUCCESS] Order executed on attempt {attempt}!\")\n                print(f\"  Deal: #{result.deal}\")\n                print(f\"  Price: {result.price}\")\n                break\n            else:\n                print(f\"[FAILED] Code: {result.returned_code}\")\n                print(f\"  Description: {result.returned_code_description}\")\n\n                if attempt &lt; max_retries:\n                    print(f\"  Retrying in {retry_delay} seconds...\")\n                    await asyncio.sleep(retry_delay)\n                else:\n                    print(f\"  Max retries reached. Giving up.\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(order_with_retry())\n</code></pre>"},{"location":"MT5Account/5.%20Trading_Operations/order_send/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>OrderCheck - Validate order before sending</li> <li>OrderModify - Modify existing orders</li> <li>OrderClose - Close positions</li> <li>OrderCalcMargin - Calculate required margin</li> <li>OrderCalcProfit - Calculate potential profit/loss</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/Streaming_Methods.Overview/","title":"MT5Account - Streaming Methods - Overview","text":"<p>Real-time streams: ticks, trades, profit updates, transaction log. Use this page to choose the right API for real-time subscriptions.</p>"},{"location":"MT5Account/6.%20Streaming_Methods/Streaming_Methods.Overview/#what-lives-here","title":"\ud83d\udcc1 What lives here","text":""},{"location":"MT5Account/6.%20Streaming_Methods/Streaming_Methods.Overview/#real-time-price-updates","title":"Real-Time Price Updates","text":"<ul> <li>on_symbol_tick - real-time tick stream for symbols.</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/Streaming_Methods.Overview/#trading-events","title":"Trading Events","text":"<ul> <li>on_trade - position/order changes (opened, closed, modified).</li> <li>on_trade_transaction - detailed transaction log (complete audit trail).</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/Streaming_Methods.Overview/#position-monitoring","title":"Position Monitoring","text":"<ul> <li>on_position_profit - periodic profit/loss updates.</li> <li>on_positions_and_pending_orders_tickets - periodic ticket lists (lightweight).</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/Streaming_Methods.Overview/#step-by-step-tutorials","title":"\ud83d\udcda Step-by-step tutorials","text":"<p>Note: Streaming methods are async generator-based APIs. Check individual method pages for detailed examples of asyncio patterns and event handling.</p> <ul> <li>on_symbol_tick - Detailed tick streaming examples</li> <li>on_trade - Trade event monitoring patterns</li> <li>on_trade_transaction - Transaction logging examples</li> <li>on_position_profit - P/L monitoring patterns</li> <li>on_positions_and_pending_orders_tickets - Ticket tracking examples</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/Streaming_Methods.Overview/#plain-english","title":"\ud83e\udded Plain English","text":"<ul> <li>on_symbol_tick -&gt; stream live prices for symbols (bid, ask, volume updates).</li> <li>on_trade -&gt; monitor trade events (position opened/closed/modified).</li> <li>on_trade_transaction -&gt; detailed audit log of all trading operations.</li> <li>on_position_profit -&gt; periodic P/L updates for open positions.</li> <li>on_positions_and_pending_orders_tickets -&gt; periodic ticket lists (lightweight monitoring).</li> </ul> <p>Rule of thumb: need live prices -&gt; <code>on_symbol_tick</code>; need trade notifications -&gt; <code>on_trade</code>; need detailed audit -&gt; <code>on_trade_transaction</code>; need P/L monitoring -&gt; <code>on_position_profit</code>.</p>"},{"location":"MT5Account/6.%20Streaming_Methods/Streaming_Methods.Overview/#quick-choose","title":"Quick choose","text":"If you need... Use Returns (async stream) Key inputs Real-time price ticks <code>on_symbol_tick</code> OnSymbolTickData List of symbol names Trade event notifications <code>on_trade</code> OnTradeData (none) Detailed transaction audit log <code>on_trade_transaction</code> OnTradeTransactionData (none) Real-time profit/loss updates <code>on_position_profit</code> OnPositionProfitData Interval (ms), ignore_empty flag Real-time ticket list changes <code>on_positions_and_pending_orders_tickets</code> OnPositionsAndPendingOrdersTicketsData Interval (ms)"},{"location":"MT5Account/6.%20Streaming_Methods/Streaming_Methods.Overview/#i-cross-refs-gotchas","title":"\u2139\ufe0f Cross-refs &amp; gotchas","text":"<ul> <li>Streaming = async generators - Methods return async generators, use <code>async for</code> to consume data.</li> <li>Cancellation - Use <code>asyncio.Event</code> and call <code>event.set()</code> to stop streams gracefully.</li> <li>Async/await required - All streaming methods must be called with <code>await</code> in async functions.</li> <li>on_symbol_tick - High frequency, can generate many updates per second.</li> <li>on_trade - Triggered on every trade event (open, close, modify, delete).</li> <li>on_trade_transaction - Most detailed, includes all transaction types and states.</li> <li>on_position_profit - Periodic updates at specified intervals (e.g., every 500ms).</li> <li>Resource management - Always cancel streams when done to close connections and free resources.</li> <li>Error handling - Errors are raised as exceptions - wrap in try/except for error handling.</li> <li>Automatic reconnection - All streams have built-in reconnection via <code>execute_stream_with_reconnect</code>.</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/Streaming_Methods.Overview/#minimal-snippets","title":"\ud83d\udfe2 Minimal snippets","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\n# Stream live ticks for EURUSD\nasync def stream_ticks():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        async for tick_data in account.on_symbol_tick(symbols=[\"EURUSD\"]):\n            tick = tick_data.symbol_tick\n            print(f\"EURUSD: Bid={tick.bid:.5f}, Ask={tick.ask:.5f}\")\n\n    except KeyboardInterrupt:\n        print(\"Stopping...\")\n    finally:\n        await account.channel.close()\n\nasyncio.run(stream_ticks())\n</code></pre> <pre><code># Monitor trade events\nasync def monitor_trades():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        async for trade_data in account.on_trade():\n            event = trade_data.event_data\n\n            if event.new_positions:\n                print(f\"New positions: {len(event.new_positions)}\")\n            if event.disappeared_positions:\n                print(f\"Closed positions: {len(event.disappeared_positions)}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(monitor_trades())\n</code></pre> <pre><code># Monitor position profit/loss\nasync def monitor_pnl():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        async for update in account.on_position_profit(\n            interval_ms=500,\n            ignore_empty=True\n        ):\n            for pos in update.updated_positions:\n                print(f\"#{pos.ticket} ({pos.position_symbol}): ${pos.profit:.2f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(monitor_pnl())\n</code></pre> <pre><code># Monitor position tickets\nasync def monitor_tickets():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        async for update in account.on_positions_and_pending_orders_tickets(\n            interval_ms=1000\n        ):\n            print(f\"Open positions: {len(update.position_tickets)}\")\n            print(f\"Pending orders: {len(update.pending_order_tickets)}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(monitor_tickets())\n</code></pre> <pre><code># Detailed transaction log\nasync def transaction_log():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        async for tx_data in account.on_trade_transaction():\n            tx = tx_data.trade_transaction\n            print(f\"Transaction: Order #{tx.order_ticket}, \"\n                  f\"Deal #{tx.deal_ticket}, State: {tx.order_state}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(transaction_log())\n</code></pre> <pre><code># Multiple streams with cancellation\nasync def multiple_streams():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    cancel_event = asyncio.Event()\n\n    async def stop_after(seconds):\n        await asyncio.sleep(seconds)\n        cancel_event.set()\n\n    async def stream_ticks():\n        async for tick_data in account.on_symbol_tick(\n            symbols=[\"EURUSD\"],\n            cancellation_event=cancel_event\n        ):\n            tick = tick_data.symbol_tick\n            print(f\"[TICK] {tick.bid:.5f}\")\n\n    async def stream_trades():\n        async for trade_data in account.on_trade(\n            cancellation_event=cancel_event\n        ):\n            print(f\"[TRADE] Event received\")\n\n    try:\n        # Run multiple streams concurrently\n        await asyncio.gather(\n            stream_ticks(),\n            stream_trades(),\n            stop_after(30)  # Stop all after 30 seconds\n        )\n    finally:\n        await account.channel.close()\n\nasyncio.run(multiple_streams())\n</code></pre> <pre><code># Using cancellation event for graceful shutdown\nasync def stream_with_cancellation():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    cancel_event = asyncio.Event()\n\n    async def handle_keyboard_interrupt():\n        \"\"\"Wait for Ctrl+C and trigger cancellation\"\"\"\n        try:\n            await asyncio.Event().wait()  # Wait forever\n        except asyncio.CancelledError:\n            cancel_event.set()\n\n    try:\n        # Create task for keyboard interrupt handling\n        interrupt_task = asyncio.create_task(handle_keyboard_interrupt())\n\n        # Stream with cancellation support\n        async for tick_data in account.on_symbol_tick(\n            symbols=[\"EURUSD\", \"GBPUSD\"],\n            cancellation_event=cancel_event\n        ):\n            tick = tick_data.symbol_tick\n            print(f\"{tick.symbol}: {tick.bid:.5f}\")\n\n        interrupt_task.cancel()\n\n    except KeyboardInterrupt:\n        cancel_event.set()\n        print(\"\\nGracefully stopping stream...\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(stream_with_cancellation())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/Streaming_Methods.Overview/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>Account info: account_summary - get current account state</li> <li>Positions: opened_orders - get current positions snapshot</li> <li>Symbol info: symbol_info_tick - get current price snapshot</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/","title":"Stream Real-Time Position Profit/Loss","text":"<p>Request: subscribe to real-time profit/loss updates for open positions.</p> <p>API Information:</p> <ul> <li>Python API: <code>MT5Account.on_position_profit(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.SubscriptionService</code></li> <li>Proto definition: <code>OnPositionProfit</code> (defined in <code>mt5-term-api-subscriptions.proto</code>)</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.SubscriptionService</code></li> <li>Method: <code>OnPositionProfit(OnPositionProfitRequest) -&gt; stream OnPositionProfitReply</code></li> <li>Low-level client (generated): <code>SubscriptionServiceStub.OnPositionProfit(request, metadata)</code></li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Periodic stream of position profit/loss updates.</li> <li>Why you need it. Monitor P&amp;L, implement stop-loss logic, track account performance.</li> <li>Periodic updates. Updates sent at specified intervals (e.g., every 500ms).</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to:</p> <ul> <li>Monitor real-time profit/loss for open positions</li> <li>Implement dynamic stop-loss and take-profit logic</li> <li>Track account performance in real-time</li> <li>Set up profit/loss alerts</li> <li>Build real-time P&amp;L dashboards</li> <li>Detect position changes immediately</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: OnPositionProfit - How it works</p> <pre><code>from MetaRpcMT5 import MT5Account\n\nclass MT5Account:\n    # ...\n\n    async def on_position_profit(\n        self,\n        interval_ms: int,\n        ignore_empty: bool = True,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Subscribes to real-time profit updates for open positions.\n\n        Yields:\n            OnPositionProfitData: Profit update data.\n        \"\"\"\n</code></pre> <p>Request message:</p> <pre><code>message OnPositionProfitRequest {\n  int32 timer_period_milliseconds = 1;  // Polling interval in milliseconds\n  bool ignore_empty_data = 2;           // Skip frames with no changes (default: true)\n}\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>interval_ms</code> <code>int</code> Interval in milliseconds to poll the server <code>ignore_empty</code> <code>bool</code> Skip frames with no change (default: True) <code>cancellation_event</code> <code>Optional[asyncio.Event]</code> Event to cancel streaming (optional)"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#output-async-generator","title":"\u2b06\ufe0f Output - Async Generator","text":"<p>Returns an async generator that yields <code>OnPositionProfitData</code> objects.</p> <p>OnPositionProfitData fields:</p> Field Type Description <code>type</code> <code>int</code> Update type <code>new_positions</code> <code>repeated OnPositionProfitPositionInfo</code> Newly opened positions <code>updated_positions</code> <code>repeated OnPositionProfitPositionInfo</code> Positions with profit changes <code>deleted_positions</code> <code>repeated OnPositionProfitPositionInfo</code> Closed positions <code>account_info</code> <code>OnEventAccountInfo</code> Current account information <code>terminal_instance_guid_id</code> <code>str</code> Terminal instance identifier <p>OnPositionProfitPositionInfo fields:</p> Field Type Description <code>index</code> <code>int32</code> Position index in the list <code>ticket</code> <code>uint64</code> Position ticket number <code>profit</code> <code>double</code> Current profit/loss <code>position_symbol</code> <code>string</code> Trading symbol <p>OnEventAccountInfo fields:</p> Field Type Description <code>balance</code> <code>double</code> Account balance <code>equity</code> <code>double</code> Account equity <code>profit</code> <code>double</code> Total profit <code>margin</code> <code>double</code> Used margin <code>margin_free</code> <code>double</code> Free margin <p>Position type enum (SUB_ENUM_POSITION_TYPE):</p> Name Value Description <code>SUB_POSITION_TYPE_BUY</code> 0 Buy position (long) <code>SUB_POSITION_TYPE_SELL</code> 1 Sell position (short) <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\n\n# Access enum values\nsubscriptions_pb2.SUB_POSITION_TYPE_BUY   # = 0\nsubscriptions_pb2.SUB_POSITION_TYPE_SELL  # = 1\n</code></pre></p>"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> streaming methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_stream_with_reconnect</code>.</li> <li>Async generator: The method returns an async generator - use <code>async for</code> to consume data.</li> <li>Polling interval: Choose interval based on your needs - shorter intervals = more frequent updates but higher load.</li> <li>Ignore empty: Set <code>ignore_empty=True</code> to skip updates when nothing changed (recommended).</li> <li>Three lists: Each update contains <code>new_positions</code>, <code>updated_positions</code>, and <code>deleted_positions</code>.</li> <li>Account info: Each update includes current account balance, equity, and margin.</li> <li>Resource management: Always cancel streams when done to free resources.</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#1-monitor-all-positions-pl","title":"1) Monitor all positions P&amp;L","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def monitor_positions_pnl():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Poll every 500ms, skip empty updates\n        async for update in account.on_position_profit(\n            interval_ms=500,\n            ignore_empty=True\n        ):\n            # New positions\n            if update.new_positions:\n                for pos in update.new_positions:\n                    print(f\"[NEW] Position #{pos.ticket} ({pos.position_symbol}): \"\n                          f\"P&amp;L={pos.profit:.2f}\")\n\n            # Updated positions (profit changed)\n            if update.updated_positions:\n                for pos in update.updated_positions:\n                    print(f\"[UPDATE] Position #{pos.ticket} ({pos.position_symbol}): \"\n                          f\"P&amp;L={pos.profit:.2f}\")\n\n            # Closed positions\n            if update.deleted_positions:\n                for pos in update.deleted_positions:\n                    print(f\"[CLOSED] Position #{pos.ticket} ({pos.position_symbol}): \"\n                          f\"Final P&amp;L={pos.profit:.2f}\")\n\n            # Account summary\n            if update.account_info:\n                acc = update.account_info\n                print(f\"[ACCOUNT] Balance={acc.balance:.2f}, \"\n                      f\"Equity={acc.equity:.2f}, Profit={acc.profit:.2f}\\n\")\n\n    except KeyboardInterrupt:\n        print(\"Stopping stream...\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(monitor_positions_pnl())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#2-real-time-total-pl-dashboard","title":"2) Real-time total P&amp;L dashboard","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def realtime_pnl_dashboard():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    # Track all positions\n    positions = {}  # ticket -&gt; (symbol, profit)\n\n    try:\n        async for update in account.on_position_profit(\n            interval_ms=1000,\n            ignore_empty=True\n        ):\n            # Add new positions\n            for pos in update.new_positions:\n                positions[pos.ticket] = (pos.position_symbol, pos.profit)\n\n            # Update existing positions\n            for pos in update.updated_positions:\n                positions[pos.ticket] = (pos.position_symbol, pos.profit)\n\n            # Remove closed positions\n            for pos in update.deleted_positions:\n                if pos.ticket in positions:\n                    del positions[pos.ticket]\n\n            # Calculate total P&amp;L\n            total_profit = sum(profit for _, profit in positions.values())\n\n            # Display dashboard\n            print(\"\\033[2J\\033[H\")  # Clear screen\n            print(\"=\" * 60)\n            print(f\"REAL-TIME P&amp;L DASHBOARD\")\n            print(\"=\" * 60)\n\n            if update.account_info:\n                acc = update.account_info\n                print(f\"Balance:  ${acc.balance:,.2f}\")\n                print(f\"Equity:   ${acc.equity:,.2f}\")\n                print(f\"Margin:   ${acc.margin:,.2f}\")\n                print(f\"Free:     ${acc.margin_free:,.2f}\")\n                print(f\"Profit:   ${acc.profit:,.2f}\")\n                print(\"-\" * 60)\n\n            print(f\"\\nOpen Positions: {len(positions)}\")\n            print(f\"Total P&amp;L: ${total_profit:,.2f}\\n\")\n\n            # Show individual positions\n            for ticket, (symbol, profit) in sorted(positions.items()):\n                status = \"[+]\" if profit &gt;= 0 else \"[-]\"\n                print(f\"{status} #{ticket} {symbol:8s} ${profit:&gt;10,.2f}\")\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping dashboard...\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(realtime_pnl_dashboard())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#3-auto-stop-loss-on-profit-target","title":"3) Auto stop-loss on profit target","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_pb2 as trading_pb2\n\nasync def auto_take_profit(target_profit: float = 100.0):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        async for update in account.on_position_profit(\n            interval_ms=500,\n            ignore_empty=True\n        ):\n            # Check updated positions for profit target\n            for pos in update.updated_positions:\n                if pos.profit &gt;= target_profit:\n                    print(f\"\\n[TARGET] Profit reached for #{pos.ticket}: \"\n                          f\"${pos.profit:.2f}\")\n\n                    # Close position\n                    close_req = trading_pb2.OrderCloseRequest(\n                        ticket=pos.ticket,\n                        volume=0,  # Close all\n                        deviation=20,\n                        comment=\"Auto TP\"\n                    )\n\n                    result = await account.order_close(close_req)\n\n                    if result.error.error_type == 0:  # Success\n                        print(f\"[SUCCESS] Position #{pos.ticket} closed\")\n                    else:\n                        print(f\"[FAILED] Could not close #{pos.ticket}: \"\n                              f\"{result.error.description}\")\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping auto TP...\")\n\n    finally:\n        await account.channel.close()\n\n# Close positions when they reach $100 profit\nasyncio.run(auto_take_profit(100.0))\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#4-loss-limit-protection","title":"4) Loss limit protection","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trading_pb2 as trading_pb2\n\nasync def loss_limit_protection(max_loss: float = -50.0):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        async for update in account.on_position_profit(\n            interval_ms=500,\n            ignore_empty=True\n        ):\n            # Check for excessive losses\n            for pos in update.updated_positions:\n                if pos.profit &lt;= max_loss:\n                    print(f\"\\n[WARNING] Loss limit exceeded for #{pos.ticket}: \"\n                          f\"${pos.profit:.2f}\")\n\n                    # Emergency close\n                    close_req = trading_pb2.OrderCloseRequest(\n                        ticket=pos.ticket,\n                        volume=0,\n                        deviation=50,  # Allow higher slippage for emergency\n                        comment=\"Emergency stop\"\n                    )\n\n                    result = await account.order_close(close_req)\n\n                    if result.error.error_type == 0:\n                        print(f\"[EMERGENCY] Position #{pos.ticket} closed\")\n                    else:\n                        print(f\"[FAILED] Could not close: {result.error.description}\")\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping loss protection...\")\n\n    finally:\n        await account.channel.close()\n\n# Close positions when they lose more than $50\nasyncio.run(loss_limit_protection(-50.0))\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#5-pl-statistics-tracker","title":"5) P&amp;L statistics tracker","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom MetaRpcMT5 import MT5Account\n\nasync def track_pnl_stats(duration_seconds: int = 300):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    # Statistics storage\n    stats = {}  # ticket -&gt; {max_profit, max_loss, updates_count, symbol}\n\n    prev_positions = set()\n    cancel_event = asyncio.Event()\n\n    async def auto_stop():\n        await asyncio.sleep(duration_seconds)\n        cancel_event.set()\n\n    try:\n        stop_task = asyncio.create_task(auto_stop())\n\n        async for update in account.on_position_profit(\n            interval_ms=1000,\n            ignore_empty=True,\n            cancellation_event=cancel_event\n        ):\n            current_positions = set(update.position_tickets)\n            stats['updates'] += 1\n\n            # Add new positions\n            for pos in update.new_positions:\n                stats[pos.ticket] = {\n                    'symbol': pos.position_symbol,\n                    'max_profit': pos.profit,\n                    'max_loss': pos.profit,\n                    'updates': 1,\n                    'current': pos.profit\n                }\n\n            # Update statistics\n            for pos in update.updated_positions:\n                if pos.ticket in stats:\n                    s = stats[pos.ticket]\n                    s['max_profit'] = max(s['max_profit'], pos.profit)\n                    s['max_loss'] = min(s['max_loss'], pos.profit)\n                    s['updates'] += 1\n                    s['current'] = pos.profit\n\n            # Mark deleted positions\n            for pos in update.deleted_positions:\n                if pos.ticket in stats:\n                    stats[pos.ticket]['closed'] = True\n                    stats[pos.ticket]['final_profit'] = pos.profit\n\n        await stop_task\n\n        # Print statistics\n        print(\"\\n\" + \"=\" * 70)\n        print(\"P&amp;L STATISTICS REPORT\")\n        print(\"=\" * 70)\n\n        for ticket, s in stats.items():\n            status = \"CLOSED\" if s.get('closed') else \"OPEN\"\n            print(f\"\\nPosition #{ticket} ({s['symbol']}) - {status}\")\n            print(f\"  Max profit:    ${s['max_profit']:&gt;10,.2f}\")\n            print(f\"  Max loss:      ${s['max_loss']:&gt;10,.2f}\")\n            print(f\"  Updates:       {s['updates']:&gt;10,}\")\n            if s.get('closed'):\n                print(f\"  Final P&amp;L:     ${s['final_profit']:&gt;10,.2f}\")\n            else:\n                print(f\"  Current P&amp;L:   ${s['current']:&gt;10,.2f}\")\n\n        print(\"=\" * 70)\n\n    finally:\n        await account.channel.close()\n\n# Track statistics for 5 minutes\nasyncio.run(track_pnl_stats(300))\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#6-total-account-profit-alert","title":"6) Total account profit alert","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def total_profit_alert(target: float = 500.0):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    alerted = False\n\n    try:\n        async for update in account.on_position_profit(\n            interval_ms=1000,\n            ignore_empty=True\n        ):\n            if update.account_info:\n                total_profit = update.account_info.profit\n\n                # Check if target reached\n                if total_profit &gt;= target and not alerted:\n                    print(f\"\\n[TARGET REACHED]\")\n                    print(f\"Total account profit: ${total_profit:.2f}\")\n                    print(f\"Balance: ${update.account_info.balance:.2f}\")\n                    print(f\"Equity: ${update.account_info.equity:.2f}\")\n                    alerted = True\n                    break\n\n                # Show progress\n                progress = (total_profit / target) * 100\n                print(f\"\\rProfit: ${total_profit:&gt;8.2f} \"\n                      f\"({progress:&gt;5.1f}% of target)\", end=\"\")\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping alert...\")\n\n    finally:\n        await account.channel.close()\n\n# Alert when total profit reaches $500\nasyncio.run(total_profit_alert(500.0))\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_position_profit/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>OpenedOrders - Get full position details (snapshot)</li> <li>OrderClose - Close positions</li> <li>OnSymbolTick - Stream price updates</li> <li>AccountSummary - Get account info (snapshot)</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/","title":"Stream Position and Pending Order Tickets","text":"<p>Request: subscribe to periodic updates of position and pending order ticket IDs.</p> <p>API Information:</p> <ul> <li>Python API: <code>MT5Account.on_positions_and_pending_orders_tickets(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.SubscriptionService</code></li> <li>Proto definition: <code>OnPositionsAndPendingOrdersTickets</code> (defined in <code>mt5-term-api-subscriptions.proto</code>)</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.SubscriptionService</code></li> <li>Method: <code>OnPositionsAndPendingOrdersTickets(OnPositionsAndPendingOrdersTicketsRequest) -&gt; stream OnPositionsAndPendingOrdersTicketsReply</code></li> <li>Low-level client (generated): <code>SubscriptionServiceStub.OnPositionsAndPendingOrdersTickets(request, metadata)</code></li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Periodic stream of ticket IDs for open positions and pending orders.</li> <li>Why you need it. Lightweight monitoring of positions/orders, detect changes without full data.</li> <li>Periodic updates. Snapshot sent at specified intervals (e.g., every 1000ms).</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to:</p> <ul> <li>Monitor position and order count changes</li> <li>Detect when new positions are opened (new tickets appear)</li> <li>Detect when positions are closed (tickets disappear)</li> <li>Lightweight alternative to <code>on_trade</code> when you only need ticket IDs</li> <li>Track ticket lifecycle without fetching full position data</li> <li>Build efficient change detection systems</li> </ul> <pre><code>from MetaRpcMT5 import MT5Account\n\nclass MT5Account:\n    # ...\n\n    async def on_positions_and_pending_orders_tickets(\n        self,\n        interval_ms: int,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Subscribes to updates of position and pending order ticket IDs.\n\n        Yields:\n            OnPositionsAndPendingOrdersTicketsData: Snapshot of tickets.\n        \"\"\"\n</code></pre> <p>Request message:</p> <pre><code>message OnPositionsAndPendingOrdersTicketsRequest {\n  int32 timer_period_milliseconds = 1;  // Polling interval in milliseconds\n}\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>interval_ms</code> <code>int</code> Polling interval in milliseconds <code>cancellation_event</code> <code>Optional[asyncio.Event]</code> Event to cancel streaming (optional)"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#output-async-generator","title":"\u2b06\ufe0f Output - Async Generator","text":"<p>Returns an async generator that yields <code>OnPositionsAndPendingOrdersTicketsData</code> objects.</p> <p>OnPositionsAndPendingOrdersTicketsData fields:</p> Field Type Description <code>position_tickets</code> <code>repeated uint64</code> List of open position ticket IDs <code>pending_order_tickets</code> <code>repeated uint64</code> List of pending order ticket IDs <code>server_time</code> <code>google.protobuf.Timestamp</code> Server timestamp <code>terminal_instance_guid_id</code> <code>str</code> Terminal instance identifier"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: OnPositionsAndPendingOrdersTickets - How it works</p>"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> streaming methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_stream_with_reconnect</code>.</li> <li>Async generator: The method returns an async generator - use <code>async for</code> to consume data.</li> <li>Periodic snapshots: Each update is a complete snapshot (not incremental changes).</li> <li>Lightweight: Only returns ticket IDs - use this when you don't need full position/order data.</li> <li>Change detection: Compare ticket lists between updates to detect new/closed positions.</li> <li>Polling interval: Choose interval based on your needs - shorter = more frequent updates.</li> <li>Resource efficient: Much lighter than <code>on_trade</code> or <code>on_position_profit</code>.</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#1-monitor-ticket-changes","title":"1) Monitor ticket changes","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def monitor_tickets():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    prev_positions = set()\n    prev_orders = set()\n\n    try:\n        # Poll every second\n        async for update in account.on_positions_and_pending_orders_tickets(\n            interval_ms=1000\n        ):\n            current_positions = set(update.position_tickets)\n            current_orders = set(update.pending_order_tickets)\n\n            # Detect new positions\n            new_positions = current_positions - prev_positions\n            if new_positions:\n                print(f\"[NEW] Positions: {new_positions}\")\n\n            # Detect closed positions\n            closed_positions = prev_positions - current_positions\n            if closed_positions:\n                print(f\"[CLOSED] Positions: {closed_positions}\")\n\n            # Detect new pending orders\n            new_orders = current_orders - prev_orders\n            if new_orders:\n                print(f\"[NEW] Orders: {new_orders}\")\n\n            # Detect removed pending orders\n            removed_orders = prev_orders - current_orders\n            if removed_orders:\n                print(f\"[REMOVED] Orders: {removed_orders}\")\n\n            # Show current state\n            print(f\"[STATUS] Positions: {len(current_positions)}, \"\n                  f\"Orders: {len(current_orders)}\\n\")\n\n            prev_positions = current_positions\n            prev_orders = current_orders\n\n    except KeyboardInterrupt:\n        print(\"Stopping monitor...\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(monitor_tickets())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#2-alert-on-position-count-changes","title":"2) Alert on position count changes","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def alert_on_position_changes():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    prev_count = 0\n\n    try:\n        async for update in account.on_positions_and_pending_orders_tickets(\n            interval_ms=500\n        ):\n            current_count = len(update.position_tickets)\n\n            # Alert on changes\n            if current_count &gt; prev_count:\n                print(f\"\\n[ALERT] {current_count - prev_count} position(s) OPENED\")\n                print(f\"   Total positions: {current_count}\")\n                print(f\"   Tickets: {list(update.position_tickets)}\")\n\n            elif current_count &lt; prev_count:\n                print(f\"\\n[ALERT] {prev_count - current_count} position(s) CLOSED\")\n                print(f\"   Remaining positions: {current_count}\")\n                print(f\"   Tickets: {list(update.position_tickets)}\")\n\n            prev_count = current_count\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping alerts...\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(alert_on_position_changes())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#3-track-positionorder-statistics","title":"3) Track position/order statistics","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom MetaRpcMT5 import MT5Account\n\nasync def track_ticket_statistics(duration_seconds=300):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    stats = {\n        'max_positions': 0,\n        'max_orders': 0,\n        'total_opened': 0,\n        'total_closed': 0,\n        'updates': 0,\n    }\n\n    prev_positions = set()\n    cancel_event = asyncio.Event()\n\n    async def auto_stop():\n        await asyncio.sleep(duration_seconds)\n        cancel_event.set()\n\n    try:\n        stop_task = asyncio.create_task(auto_stop())\n\n        async for update in account.on_positions_and_pending_orders_tickets(\n            interval_ms=1000,\n            cancellation_event=cancel_event\n        ):\n            current_positions = set(update.position_tickets)\n            stats['updates'] += 1\n\n            # Update max counts\n            stats['max_positions'] = max(stats['max_positions'], len(current_positions))\n            stats['max_orders'] = max(stats['max_orders'], len(update.pending_order_tickets))\n\n            # Count opened/closed\n            stats['total_opened'] += len(current_positions - prev_positions)\n            stats['total_closed'] += len(prev_positions - current_positions)\n\n            prev_positions = current_positions\n\n        await stop_task\n\n        # Print statistics\n        print(\"\\n\" + \"=\" * 60)\n        print(\"TICKET STATISTICS REPORT\")\n        print(\"=\" * 60)\n        print(f\"Duration:          {duration_seconds} seconds\")\n        print(f\"Updates received:  {stats['updates']}\")\n        print(f\"Max positions:     {stats['max_positions']}\")\n        print(f\"Max orders:        {stats['max_orders']}\")\n        print(f\"Total opened:      {stats['total_opened']}\")\n        print(f\"Total closed:      {stats['total_closed']}\")\n        print(\"=\" * 60)\n\n    finally:\n        await account.channel.close()\n\n# Track for 5 minutes\nasyncio.run(track_ticket_statistics(300))\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#4-position-count-limiter","title":"4) Position count limiter","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def position_count_limiter(max_positions=5):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        async for update in account.on_positions_and_pending_orders_tickets(\n            interval_ms=500\n        ):\n            position_count = len(update.position_tickets)\n\n            if position_count &gt;= max_positions:\n                print(f\"\\n[WARNING] Position limit reached!\")\n                print(f\"   Current positions: {position_count}/{max_positions}\")\n                print(f\"   Tickets: {list(update.position_tickets)}\")\n                print(f\"   [BLOCK] New positions should be blocked\\n\")\n            else:\n                available = max_positions - position_count\n                print(f\"[OK] Positions: {position_count}/{max_positions} \"\n                      f\"({available} slots available)\")\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping limiter...\")\n\n    finally:\n        await account.channel.close()\n\n# Alert when 5 or more positions are open\nasyncio.run(position_count_limiter(5))\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#5-ticket-change-logger-to-file","title":"5) Ticket change logger to file","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom MetaRpcMT5 import MT5Account\n\nasync def log_ticket_changes():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    prev_positions = set()\n    prev_orders = set()\n\n    try:\n        with open('ticket_changes.log', 'w') as logfile:\n            logfile.write(\"Timestamp,Event,Ticket\\n\")\n\n            async for update in account.on_positions_and_pending_orders_tickets(\n                interval_ms=1000\n            ):\n                timestamp = datetime.now().isoformat()\n                current_positions = set(update.position_tickets)\n                current_orders = set(update.pending_order_tickets)\n\n                # Log new positions\n                for ticket in current_positions - prev_positions:\n                    logfile.write(f\"{timestamp},POSITION_OPENED,{ticket}\\n\")\n                    logfile.flush()\n                    print(f\"[{timestamp}] Position opened: {ticket}\")\n\n                # Log closed positions\n                for ticket in prev_positions - current_positions:\n                    logfile.write(f\"{timestamp},POSITION_CLOSED,{ticket}\\n\")\n                    logfile.flush()\n                    print(f\"[{timestamp}] Position closed: {ticket}\")\n\n                # Log new orders\n                for ticket in current_orders - prev_orders:\n                    logfile.write(f\"{timestamp},ORDER_CREATED,{ticket}\\n\")\n                    logfile.flush()\n                    print(f\"[{timestamp}] Order created: {ticket}\")\n\n                # Log removed orders\n                for ticket in prev_orders - current_orders:\n                    logfile.write(f\"{timestamp},ORDER_REMOVED,{ticket}\\n\")\n                    logfile.flush()\n                    print(f\"[{timestamp}] Order removed: {ticket}\")\n\n                prev_positions = current_positions\n                prev_orders = current_orders\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping logger...\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(log_ticket_changes())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#6-lightweight-position-monitor-dashboard","title":"6) Lightweight position monitor dashboard","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom MetaRpcMT5 import MT5Account\n\nasync def position_dashboard():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    start_time = datetime.now()\n\n    try:\n        async for update in account.on_positions_and_pending_orders_tickets(\n            interval_ms=1000\n        ):\n            # Clear screen\n            print(\"\\033[2J\\033[H\")\n\n            runtime = datetime.now() - start_time\n            server_time = datetime.fromtimestamp(update.server_time.seconds)\n\n            print(\"=\" * 70)\n            print(f\"POSITION MONITOR DASHBOARD\")\n            print(\"=\" * 70)\n            print(f\"Runtime:     {runtime}\")\n            print(f\"Server time: {server_time}\")\n            print(f\"Last update: {datetime.now().strftime('%H:%M:%S')}\")\n            print(\"-\" * 70)\n\n            print(f\"\\nOpen Positions: {len(update.position_tickets)}\")\n            if update.position_tickets:\n                for i, ticket in enumerate(update.position_tickets, 1):\n                    print(f\"  {i}. Ticket #{ticket}\")\n            else:\n                print(\"  (none)\")\n\n            print(f\"\\nPending Orders: {len(update.pending_order_tickets)}\")\n            if update.pending_order_tickets:\n                for i, ticket in enumerate(update.pending_order_tickets, 1):\n                    print(f\"  {i}. Ticket #{ticket}\")\n            else:\n                print(\"  (none)\")\n\n            print(\"\\n\" + \"=\" * 70)\n            print(\"Press Ctrl+C to stop\")\n\n    except KeyboardInterrupt:\n        print(\"\\n\\nStopping dashboard...\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(position_dashboard())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_positions_and_pending_orders_tickets/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>OpenedOrdersTickets - Get ticket snapshot (one-time)</li> <li>OpenedOrders - Get full position data (one-time)</li> <li>OnTrade - Stream detailed trade events</li> <li>OnPositionProfit - Stream position profit updates</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/","title":"Stream Real-Time Symbol Ticks","text":"<p>Request: subscribe to real-time tick data for specified symbols.</p> <p>API Information:</p> <ul> <li>Python API: <code>MT5Account.on_symbol_tick(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.SubscriptionService</code></li> <li>Proto definition: <code>OnSymbolTick</code> (defined in <code>mt5-term-api-subscriptions.proto</code>)</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.SubscriptionService</code></li> <li>Method: <code>OnSymbolTick(OnSymbolTickRequest) -&gt; stream OnSymbolTickReply</code></li> <li>Low-level client (generated): <code>SubscriptionServiceStub.OnSymbolTick(request, metadata)</code></li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Real-time stream of price ticks for specified symbols.</li> <li>Why you need it. Monitor live prices, implement tick-based strategies, track market movements.</li> <li>High frequency. Can generate many updates per second during active trading.</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to:</p> <ul> <li>Monitor real-time price changes for symbols</li> <li>Implement tick-based trading strategies</li> <li>Track bid/ask spreads in real-time</li> <li>Build live price dashboards</li> <li>Detect price movements immediately</li> <li>Collect tick data for analysis</li> </ul> <pre><code>from MetaRpcMT5 import MT5Account\n\nclass MT5Account:\n    # ...\n\n    async def on_symbol_tick(\n        self,\n        symbols: list[str],\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Subscribes to real-time tick data for specified symbols.\n\n        Yields:\n            OnSymbolTickData: Async stream of tick data responses.\n        \"\"\"\n</code></pre> <p>Request message:</p> <pre><code>message OnSymbolTickRequest {\n  repeated string symbol_names = 1;  // List of symbols to subscribe to\n}\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>symbols</code> <code>list[str]</code> Symbol names to subscribe to (e.g., [\"EURUSD\", \"GBPUSD\"]) <code>cancellation_event</code> <code>Optional[asyncio.Event]</code> Event to cancel streaming (optional)"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#output-async-generator","title":"\u2b06\ufe0f Output - Async Generator","text":"<p>Returns an async generator that yields <code>OnSymbolTickData</code> objects.</p> <p>OnSymbolTickData fields:</p> Field Type Description <code>symbol_tick</code> <code>MrpcSubscriptionMqlTick</code> Tick data (see below) <code>terminal_instance_guid_id</code> <code>str</code> Terminal instance identifier <p>MrpcSubscriptionMqlTick fields:</p> Field Type Description <code>symbol</code> <code>str</code> Symbol name <code>time</code> <code>google.protobuf.Timestamp</code> Time of last price update <code>time_msc</code> <code>int64</code> Time of last price update (milliseconds) <code>bid</code> <code>float64</code> Current Bid price <code>ask</code> <code>float64</code> Current Ask price <code>last</code> <code>float64</code> Price of last deal (Last) <code>volume</code> <code>uint64</code> Volume for the current Last price <code>volume_real</code> <code>float64</code> Volume for the current Last price (real) <code>flags</code> <code>uint32</code> Tick flags (buy/sell indication)"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: OnSymbolTick - How it works</p>"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> streaming methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_stream_with_reconnect</code>.</li> <li>Async generator: The method returns an async generator - use <code>async for</code> to consume data.</li> <li>Multiple symbols: You can subscribe to multiple symbols in a single stream.</li> <li>Cancellation: Pass an <code>asyncio.Event</code> and call <code>event.set()</code> to stop the stream gracefully.</li> <li>High frequency: Tick streams can be very high frequency - ensure your processing is efficient.</li> <li>Resource management: Always cancel streams when done to free resources.</li> <li>Error handling: Errors are raised as exceptions - wrap in try/except for error handling.</li> <li>UUID handling: The terminal instance UUID is auto-generated by the server if not provided.    For explicit control (e.g., in streaming scenarios), pass <code>id_=uuid4()</code> to constructor.</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#1-monitor-live-ticks-for-eurusd","title":"1) Monitor live ticks for EURUSD","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def monitor_ticks():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Subscribe to EURUSD ticks\n        async for tick_data in account.on_symbol_tick(symbols=[\"EURUSD\"]):\n            tick = tick_data.symbol_tick\n            print(f\"{tick.symbol}: Bid={tick.bid:.5f}, Ask={tick.ask:.5f}, \"\n                  f\"Spread={tick.ask - tick.bid:.5f}\")\n\n    except KeyboardInterrupt:\n        print(\"Stopping tick stream...\")\n\n    finally:\n        await account.channel.close()\n\n# Run\nasyncio.run(monitor_ticks())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#2-monitor-multiple-symbols-with-cancellation","title":"2) Monitor multiple symbols with cancellation","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def monitor_multiple_symbols():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    # Create cancellation event\n    cancel_event = asyncio.Event()\n\n    # Stop after 30 seconds\n    async def auto_cancel():\n        await asyncio.sleep(30)\n        cancel_event.set()\n        print(\"\\nStopping stream...\")\n\n    try:\n        # Start auto-cancel task\n        cancel_task = asyncio.create_task(auto_cancel())\n\n        # Subscribe to multiple symbols\n        symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\n\n        async for tick_data in account.on_symbol_tick(\n            symbols=symbols,\n            cancellation_event=cancel_event\n        ):\n            tick = tick_data.symbol_tick\n            spread_pips = (tick.ask - tick.bid) * 10000  # for 4-digit pairs\n\n            print(f\"[{tick.time_msc}] {tick.symbol}: \"\n                  f\"Bid={tick.bid:.5f}, Ask={tick.ask:.5f}, \"\n                  f\"Spread={spread_pips:.1f} pips\")\n\n        await cancel_task\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(monitor_multiple_symbols())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#3-track-bid-ask-spread-statistics","title":"3) Track bid-ask spread statistics","text":"<pre><code>import asyncio\nfrom collections import defaultdict\nfrom MetaRpcMT5 import MT5Account\n\nasync def track_spread_stats():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    # Statistics storage\n    spreads = defaultdict(list)\n    cancel_event = asyncio.Event()\n\n    async def stop_after_duration(seconds):\n        await asyncio.sleep(seconds)\n        cancel_event.set()\n\n    try:\n        # Stop after 60 seconds\n        stop_task = asyncio.create_task(stop_after_duration(60))\n\n        symbols = [\"EURUSD\", \"GBPUSD\"]\n\n        async for tick_data in account.on_symbol_tick(\n            symbols=symbols,\n            cancellation_event=cancel_event\n        ):\n            tick = tick_data.symbol_tick\n            spread = tick.ask - tick.bid\n            spreads[tick.symbol].append(spread)\n\n        await stop_task\n\n        # Print statistics\n        print(\"\\n=== Spread Statistics ===\")\n        for symbol, spread_list in spreads.items():\n            avg_spread = sum(spread_list) / len(spread_list)\n            min_spread = min(spread_list)\n            max_spread = max(spread_list)\n\n            print(f\"\\n{symbol}:\")\n            print(f\"  Ticks received: {len(spread_list)}\")\n            print(f\"  Average spread: {avg_spread * 10000:.1f} pips\")\n            print(f\"  Min spread: {min_spread * 10000:.1f} pips\")\n            print(f\"  Max spread: {max_spread * 10000:.1f} pips\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(track_spread_stats())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#4-price-alert-system","title":"4) Price alert system","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def price_alert_system():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    # Set price alerts\n    alerts = {\n        \"EURUSD\": {\"above\": 1.1000, \"below\": 1.0900},\n        \"GBPUSD\": {\"above\": 1.2700, \"below\": 1.2500},\n    }\n\n    triggered = set()\n\n    try:\n        async for tick_data in account.on_symbol_tick(\n            symbols=list(alerts.keys())\n        ):\n            tick = tick_data.symbol_tick\n            symbol = tick.symbol\n\n            if symbol not in alerts:\n                continue\n\n            # Check above threshold\n            if tick.bid &gt;= alerts[symbol][\"above\"]:\n                alert_key = f\"{symbol}_above\"\n                if alert_key not in triggered:\n                    print(f\"\\n[ALERT] {symbol} bid {tick.bid:.5f} \"\n                          f\"is ABOVE {alerts[symbol]['above']:.5f}\")\n                    triggered.add(alert_key)\n\n            # Check below threshold\n            if tick.bid &lt;= alerts[symbol][\"below\"]:\n                alert_key = f\"{symbol}_below\"\n                if alert_key not in triggered:\n                    print(f\"\\n[ALERT] {symbol} bid {tick.bid:.5f} \"\n                          f\"is BELOW {alerts[symbol]['below']:.5f}\")\n                    triggered.add(alert_key)\n\n            # Stop if all alerts triggered\n            if len(triggered) == len(alerts) * 2:\n                print(\"\\nAll alerts triggered. Stopping...\")\n                break\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(price_alert_system())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#5-real-time-tick-logger-to-csv","title":"5) Real-time tick logger to CSV","text":"<pre><code>import asyncio\nimport csv\nfrom datetime import datetime\nfrom MetaRpcMT5 import MT5Account\n\nasync def log_ticks_to_csv():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    cancel_event = asyncio.Event()\n\n    # Stop after 5 minutes\n    async def auto_stop():\n        await asyncio.sleep(300)\n        cancel_event.set()\n\n    try:\n        stop_task = asyncio.create_task(auto_stop())\n\n        # Open CSV file\n        with open('ticks.csv', 'w', newline='') as csvfile:\n            writer = csv.writer(csvfile)\n            writer.writerow(['Timestamp', 'Symbol', 'Bid', 'Ask', 'Last', 'Volume'])\n\n            tick_count = 0\n\n            async for tick_data in account.on_symbol_tick(\n                symbols=[\"EURUSD\"],\n                cancellation_event=cancel_event\n            ):\n                tick = tick_data.symbol_tick\n\n                # Write to CSV\n                writer.writerow([\n                    datetime.fromtimestamp(tick.time_msc / 1000).isoformat(),\n                    tick.symbol,\n                    tick.bid,\n                    tick.ask,\n                    tick.last,\n                    tick.volume_real\n                ])\n\n                tick_count += 1\n\n                if tick_count % 100 == 0:\n                    print(f\"Logged {tick_count} ticks...\")\n                    csvfile.flush()  # Flush to disk\n\n        await stop_task\n        print(f\"\\nTotal ticks logged: {tick_count}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(log_ticks_to_csv())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#6-concurrent-tick-monitoring-with-tasks","title":"6) Concurrent tick monitoring with tasks","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def process_eurusd_ticks(account):\n    \"\"\"Process EURUSD ticks\"\"\"\n    async for tick_data in account.on_symbol_tick(symbols=[\"EURUSD\"]):\n        tick = tick_data.symbol_tick\n        print(f\"[EUR] {tick.bid:.5f}\")\n        await asyncio.sleep(0.1)  # Throttle output\n\nasync def process_gbpusd_ticks(account):\n    \"\"\"Process GBPUSD ticks\"\"\"\n    async for tick_data in account.on_symbol_tick(symbols=[\"GBPUSD\"]):\n        tick = tick_data.symbol_tick\n        print(f\"[GBP] {tick.bid:.5f}\")\n        await asyncio.sleep(0.1)  # Throttle output\n\nasync def main():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # Run multiple streams concurrently\n        await asyncio.gather(\n            process_eurusd_ticks(account),\n            process_gbpusd_ticks(account),\n        )\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping streams...\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_symbol_tick/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>SymbolInfoTick - Get current tick snapshot (one-time)</li> <li>OnTrade - Stream trade events</li> <li>OnPositionProfit - Stream position profit updates</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/","title":"Stream Trade Events","text":"<p>Request: subscribe to all trade-related events: orders, deals, positions.</p> <p>API Information:</p> <ul> <li>Python API: <code>MT5Account.on_trade(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.SubscriptionService</code></li> <li>Proto definition: <code>OnTrade</code> (defined in <code>mt5-term-api-subscriptions.proto</code>)</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.SubscriptionService</code></li> <li>Method: <code>OnTrade(OnTradeRequest) -&gt; stream OnTradeReply</code></li> <li>Low-level client (generated): <code>SubscriptionServiceStub.OnTrade(request, metadata)</code></li> </ul> <pre><code>from MetaRpcMT5 import MT5Account\n\nclass MT5Account:\n    # ...\n\n    async def on_trade(\n        self,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Subscribes to all trade-related events: orders, deals, positions.\n\n        Yields:\n            OnTradeData: Trade event data.\n        \"\"\"\n</code></pre> <p>Request message:</p> <pre><code>message OnTradeRequest {\n  // No parameters - subscribes to all trade events\n}\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Real-time stream of all trading activity on the account.</li> <li>Why you need it. Monitor trades, detect position changes, track order execution.</li> <li>Event-driven. Updates triggered immediately when trading events occur.</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to:</p> <ul> <li>Monitor all trading activity in real-time</li> <li>Detect when positions are opened or closed</li> <li>Track pending order lifecycle</li> <li>Build trade event logging systems</li> <li>Implement trade notifications</li> <li>Synchronize local state with MT5</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>cancellation_event</code> <code>Optional[asyncio.Event]</code> Event to cancel streaming (optional)"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#output-async-generator","title":"\u2b06\ufe0f Output - Async Generator","text":"<p>Returns an async generator that yields <code>OnTradeData</code> objects.</p> <p>OnTradeData fields:</p> Field Type Description <code>type</code> <code>int</code> Event type <code>event_data</code> <code>OnTradeEventData</code> Detailed event information <code>account_info</code> <code>OnEventAccountInfo</code> Current account state <code>terminal_instance_guid_id</code> <code>str</code> Terminal instance identifier <p>OnTradeEventData fields (all are repeated/lists):</p> Field Type Description <code>new_orders</code> <code>repeated OnTradeOrderInfo</code> New pending orders created <code>disappeared_orders</code> <code>repeated OnTradeOrderInfo</code> Pending orders removed <code>state_changed_orders</code> <code>repeated OnTradeOrderStateChange</code> Orders with state changes <code>new_positions</code> <code>repeated OnTradePositionInfo</code> New positions opened <code>disappeared_positions</code> <code>repeated OnTradePositionInfo</code> Positions closed <code>updated_positions</code> <code>repeated OnTradePositionUpdate</code> Positions modified <code>new_history_orders</code> <code>repeated OnTradeHistoryOrderInfo</code> New historical orders <code>disappeared_history_orders</code> <code>repeated OnTradeHistoryOrderInfo</code> Historical orders removed <code>updated_history_orders</code> <code>repeated OnTradeHistoryOrderUpdate</code> Historical orders updated <code>new_history_deals</code> <code>repeated OnTradeHistoryDealInfo</code> New deals in history <code>disappeared_history_deals</code> <code>repeated OnTradeHistoryDealInfo</code> Deals removed from history <code>updated_history_deals</code> <code>repeated OnTradeHistoryDealUpdate</code> Deals updated in history <p>Structure and ENUMs usage:</p> <pre><code>OnTradeData\n\u251c\u2500\u2500 type (MT5_SUB_ENUM_EVENT_GROUP_TYPE) - Event group type\n\u251c\u2500\u2500 event_data (OnTradeEventData)\n\u2502   \u251c\u2500\u2500 new_positions (list[OnTradePositionInfo])\n\u2502   \u2502   \u2514\u2500\u2500 Uses: SUB_ENUM_POSITION_TYPE, SUB_ENUM_POSITION_REASON\n\u2502   \u251c\u2500\u2500 disappeared_positions (list[OnTradePositionInfo])\n\u2502   \u2502   \u2514\u2500\u2500 Uses: SUB_ENUM_POSITION_TYPE, SUB_ENUM_POSITION_REASON\n\u2502   \u251c\u2500\u2500 new_orders (list[OnTradeOrderInfo])\n\u2502   \u2502   \u2514\u2500\u2500 Uses: SUB_ENUM_ORDER_TYPE, SUB_ENUM_ORDER_STATE,\n\u2502   \u2502              SUB_ENUM_ORDER_TYPE_TIME, SUB_ENUM_ORDER_TYPE_FILLING,\n\u2502   \u2502              SUB_ENUM_ORDER_REASON\n\u2502   \u251c\u2500\u2500 disappeared_orders (list[OnTradeOrderInfo])\n\u2502   \u2502   \u2514\u2500\u2500 Uses: SUB_ENUM_ORDER_TYPE, SUB_ENUM_ORDER_STATE,\n\u2502   \u2502              SUB_ENUM_ORDER_TYPE_TIME, SUB_ENUM_ORDER_TYPE_FILLING,\n\u2502   \u2502              SUB_ENUM_ORDER_REASON\n\u2502   \u251c\u2500\u2500 new_history_orders (list[OnTradeHistoryOrderInfo])\n\u2502   \u2502   \u2514\u2500\u2500 Uses: SUB_ENUM_ORDER_TYPE, SUB_ENUM_ORDER_STATE,\n\u2502   \u2502              SUB_ENUM_ORDER_TYPE_TIME, SUB_ENUM_ORDER_TYPE_FILLING,\n\u2502   \u2502              SUB_ENUM_DEAL_REASON\n\u2502   \u251c\u2500\u2500 disappeared_history_orders (list[OnTradeHistoryOrderInfo])\n\u2502   \u2502   \u2514\u2500\u2500 Uses: SUB_ENUM_ORDER_TYPE, SUB_ENUM_ORDER_STATE,\n\u2502   \u2502              SUB_ENUM_ORDER_TYPE_TIME, SUB_ENUM_ORDER_TYPE_FILLING,\n\u2502   \u2502              SUB_ENUM_DEAL_REASON\n\u2502   \u251c\u2500\u2500 new_history_deals (list[OnTradeHistoryDealInfo])\n\u2502   \u2502   \u2514\u2500\u2500 Uses: SUB_ENUM_DEAL_TYPE, SUB_ENUM_DEAL_ENTRY, SUB_ENUM_DEAL_REASON\n\u2502   \u2514\u2500\u2500 disappeared_history_deals (list[OnTradeHistoryDealInfo])\n\u2502       \u2514\u2500\u2500 Uses: SUB_ENUM_DEAL_TYPE, SUB_ENUM_DEAL_ENTRY, SUB_ENUM_DEAL_REASON\n\u251c\u2500\u2500 account_info (OnEventAccountInfo)\n\u2514\u2500\u2500 terminal_instance_guid_id (str)\n</code></pre> <p>Event group type enum (MT5_SUB_ENUM_EVENT_GROUP_TYPE):</p> <p>Used in <code>OnTradeData.type</code> field:</p> Name Value Description <code>OrderProfit</code> 0 Order profit event <code>OrderUpdate</code> 1 Order update event <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.OrderProfit   # = 0\n</code></pre></p> <p>Enums used in nested structures:</p> <p>The following enums are used by the nested message types inside <code>OnTradeEventData</code>:</p> Nested Structure Used in Fields Enums Used <code>OnTradePositionInfo</code> <code>new_positions</code>, <code>disappeared_positions</code> <code>SUB_ENUM_POSITION_TYPE</code>, <code>SUB_ENUM_POSITION_REASON</code> <code>OnTradeOrderInfo</code> <code>new_orders</code>, <code>disappeared_orders</code> <code>SUB_ENUM_ORDER_TYPE</code>, <code>SUB_ENUM_ORDER_STATE</code>, <code>SUB_ENUM_ORDER_TYPE_TIME</code>, <code>SUB_ENUM_ORDER_TYPE_FILLING</code>, <code>SUB_ENUM_ORDER_REASON</code> <code>OnTradeHistoryOrderInfo</code> <code>new_history_orders</code>, <code>disappeared_history_orders</code> <code>SUB_ENUM_ORDER_TYPE</code>, <code>SUB_ENUM_ORDER_STATE</code>, <code>SUB_ENUM_ORDER_TYPE_TIME</code>, <code>SUB_ENUM_ORDER_TYPE_FILLING</code>, <code>SUB_ENUM_DEAL_REASON</code> <code>OnTradeHistoryDealInfo</code> <code>new_history_deals</code>, <code>disappeared_history_deals</code> <code>SUB_ENUM_DEAL_TYPE</code>, <code>SUB_ENUM_DEAL_ENTRY</code>, <code>SUB_ENUM_DEAL_REASON</code> <p>Position type enum (SUB_ENUM_POSITION_TYPE):</p> Name Value Description <code>SUB_POSITION_TYPE_BUY</code> 0 Buy position <code>SUB_POSITION_TYPE_SELL</code> 1 Sell position <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_POSITION_TYPE_BUY   # = 0\n</code></pre></p> <p>Position reason enum (SUB_ENUM_POSITION_REASON):</p> Name Value Description <code>SUB_POSITION_REASON_CLIENT</code> 0 Position opened from desktop terminal <code>SUB_POSITION_REASON_MOBILE</code> 1 Position opened from mobile app <code>SUB_POSITION_REASON_WEB</code> 2 Position opened from web terminal <code>SUB_POSITION_REASON_EXPERT</code> 3 Position opened by Expert Advisor <code>SUB_POSITION_REASON_SL</code> 4 Position closed by Stop Loss <code>SUB_POSITION_REASON_TP</code> 5 Position closed by Take Profit <code>SUB_POSITION_REASON_SO</code> 6 Position closed by Stop Out <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_POSITION_REASON_CLIENT  # = 0\n</code></pre></p> <p>Order type enum (SUB_ENUM_ORDER_TYPE):</p> Name Value Description <code>SUB_ORDER_TYPE_BUY</code> 0 Market buy order <code>SUB_ORDER_TYPE_SELL</code> 1 Market sell order <code>SUB_ORDER_TYPE_BUY_LIMIT</code> 2 Buy limit pending order <code>SUB_ORDER_TYPE_SELL_LIMIT</code> 3 Sell limit pending order <code>SUB_ORDER_TYPE_BUY_STOP</code> 4 Buy stop pending order <code>SUB_ORDER_TYPE_SELL_STOP</code> 5 Sell stop pending order <code>SUB_ORDER_TYPE_BUY_STOP_LIMIT</code> 6 Buy stop limit pending order <code>SUB_ORDER_TYPE_SELL_STOP_LIMIT</code> 7 Sell stop limit pending order <code>SUB_ORDER_TYPE_CLOSE_BY</code> 8 Close by opposite position <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_ORDER_TYPE_BUY   # = 0\n</code></pre></p> <p>Order state enum (SUB_ENUM_ORDER_STATE):</p> Name Value Description <code>SUB_ORDER_STATE_STARTED</code> 0 Order checked, but not yet accepted <code>SUB_ORDER_STATE_PLACED</code> 1 Order accepted <code>SUB_ORDER_STATE_CANCELED</code> 2 Order canceled by client <code>SUB_ORDER_STATE_PARTIAL</code> 3 Order partially executed <code>SUB_ORDER_STATE_FILLED</code> 4 Order fully executed <code>SUB_ORDER_STATE_REJECTED</code> 5 Order rejected <code>SUB_ORDER_STATE_EXPIRED</code> 6 Order expired <code>SUB_ORDER_STATE_REQUEST_ADD</code> 7 Order being registered <code>SUB_ORDER_STATE_REQUEST_MODIFY</code> 8 Order being modified <code>SUB_ORDER_STATE_REQUEST_CANCEL</code> 9 Order being deleted <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_ORDER_STATE_STARTED   # = 0\n</code></pre></p> <p>Deal type enum (SUB_ENUM_DEAL_TYPE):</p> Name Value Description <code>SUB_DEAL_TYPE_BUY</code> 0 Buy deal <code>SUB_DEAL_TYPE_SELL</code> 1 Sell deal <code>SUB_DEAL_TYPE_BALANCE</code> 2 Balance operation <code>SUB_DEAL_TYPE_CREDIT</code> 3 Credit operation <code>SUB_DEAL_TYPE_CHARGE</code> 4 Additional charge <code>SUB_DEAL_TYPE_CORRECTION</code> 5 Correction <code>SUB_DEAL_TYPE_BONUS</code> 6 Bonus <code>SUB_DEAL_TYPE_COMMISSION</code> 7 Commission <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_DEAL_TYPE_BUY   # = 0\n</code></pre></p> <p>Order time type enum (SUB_ENUM_ORDER_TYPE_TIME):</p> Name Value Description <code>SUB_ORDER_TIME_GTC</code> 0 Good till cancel <code>SUB_ORDER_TIME_DAY</code> 1 Good till current trading day <code>SUB_ORDER_TIME_SPECIFIED</code> 2 Good till specified date <code>SUB_ORDER_TIME_SPECIFIED_DAY</code> 3 Good till specified day <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_ORDER_TIME_GTC   # = 0\n</code></pre></p> <p>Order filling type enum (SUB_ENUM_ORDER_TYPE_FILLING):</p> Name Value Description <code>SUB_ORDER_FILLING_FOK</code> 0 Fill or Kill <code>SUB_ORDER_FILLING_IOC</code> 1 Immediate or Cancel <code>SUB_ORDER_FILLING_BOC</code> 2 Book or Cancel <code>SUB_ORDER_FILLING_RETURN</code> 3 Return <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_ORDER_FILLING_FOK   # = 0\n</code></pre></p> <p>Order reason enum (SUB_ENUM_ORDER_REASON):</p> Name Value Description <code>SUB_ORDER_REASON_CLIENT</code> 0 Order placed from desktop terminal <code>SUB_ORDER_REASON_MOBILE</code> 2 Order placed from mobile app <code>SUB_ORDER_REASON_WEB</code> 3 Order placed from web terminal <code>SUB_ORDER_REASON_EXPERT</code> 4 Order placed by Expert Advisor <code>SUB_ORDER_REASON_SL</code> 5 Order triggered by Stop Loss <code>SUB_ORDER_REASON_TP</code> 6 Order triggered by Take Profit <code>SUB_ORDER_REASON_SO</code> 7 Order triggered by Stop Out <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_ORDER_REASON_CLIENT   # = 0\n</code></pre></p> <p>Deal entry type enum (SUB_ENUM_DEAL_ENTRY):</p> Name Value Description <code>SUB_DEAL_ENTRY_IN</code> 0 Entry into market <code>SUB_DEAL_ENTRY_OUT</code> 1 Exit from market <code>SUB_DEAL_ENTRY_INOUT</code> 2 Reverse <code>SUB_DEAL_ENTRY_OUT_BY</code> 3 Close by opposite position <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_DEAL_ENTRY_IN   # = 0\n</code></pre></p> <p>Deal reason enum (SUB_ENUM_DEAL_REASON):</p> Name Value Description <code>SUB_DEAL_REASON_CLIENT</code> 0 Deal from desktop terminal <code>SUB_DEAL_REASON_MOBILE</code> 1 Deal from mobile app <code>SUB_DEAL_REASON_WEB</code> 2 Deal from web terminal <code>SUB_DEAL_REASON_EXPERT</code> 3 Deal by Expert Advisor <code>SUB_DEAL_REASON_SL</code> 4 Deal by Stop Loss <code>SUB_DEAL_REASON_TP</code> 5 Deal by Take Profit <code>SUB_DEAL_REASON_SO</code> 6 Deal by Stop Out <code>SUB_DEAL_REASON_ROLLOVER</code> 7 Deal by rollover <code>SUB_DEAL_REASON_VMARGIN</code> 8 Deal by variation margin <code>SUB_DEAL_REASON_SPLIT</code> 9 Deal by split <code>SUB_DEAL_REASON_CORPORATE_ACTION</code> 10 Deal by corporate action <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_DEAL_REASON_CLIENT   # = 0\n</code></pre></p>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: OnTrade - How it works</p>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> streaming methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_stream_with_reconnect</code>.</li> <li>Async generator: The method returns an async generator - use <code>async for</code> to consume data.</li> <li>No parameters: This stream subscribes to ALL trade events automatically.</li> <li>Comprehensive: Tracks orders, positions, and deals (both active and historical).</li> <li>Event-driven: Updates arrive immediately when events occur (not periodic).</li> <li>Multiple lists: Each update may contain multiple types of events simultaneously.</li> <li>Resource management: Always cancel streams when done to free resources.</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#1-monitor-all-trade-events","title":"1) Monitor all trade events","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def monitor_trades():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        async for trade_data in account.on_trade():\n            event = trade_data.event_data\n\n            # New positions\n            if event.new_positions:\n                for pos in event.new_positions:\n                    print(f\"[NEW POSITION] #{pos.index}\")\n\n            # Closed positions\n            if event.disappeared_positions:\n                for pos in event.disappeared_positions:\n                    print(f\"[CLOSED POSITION] #{pos.index}\")\n\n            # Updated positions\n            if event.updated_positions:\n                for pos in event.updated_positions:\n                    print(f\"[UPDATED POSITION] #{pos.index}\")\n\n            # New pending orders\n            if event.new_orders:\n                for order in event.new_orders:\n                    print(f\"[NEW ORDER] #{order.index}\")\n\n            # Removed pending orders\n            if event.disappeared_orders:\n                for order in event.disappeared_orders:\n                    print(f\"[REMOVED ORDER] #{order.index}\")\n\n            # Account info\n            if trade_data.account_info:\n                acc = trade_data.account_info\n                print(f\"[ACCOUNT] Balance: ${acc.balance:.2f}, \"\n                      f\"Equity: ${acc.equity:.2f}\\n\")\n\n    except KeyboardInterrupt:\n        print(\"Stopping trade monitor...\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(monitor_trades())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#2-trade-event-logger","title":"2) Trade event logger","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom MetaRpcMT5 import MT5Account\n\nasync def log_trade_events():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    event_count = 0\n\n    try:\n        async for trade_data in account.on_trade():\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            event = trade_data.event_data\n\n            # Log new positions\n            for pos in event.new_positions:\n                event_count += 1\n                print(f\"[{timestamp}] NEW_POSITION | Index: {pos.index}\")\n\n            # Log closed positions\n            for pos in event.disappeared_positions:\n                event_count += 1\n                print(f\"[{timestamp}] CLOSED_POSITION | Index: {pos.index}\")\n\n            # Log updated positions\n            for pos in event.updated_positions:\n                event_count += 1\n                print(f\"[{timestamp}] UPDATED_POSITION | Index: {pos.index}\")\n\n            # Log new pending orders\n            for order in event.new_orders:\n                event_count += 1\n                print(f\"[{timestamp}] NEW_ORDER | Index: {order.index}\")\n\n            # Log order state changes\n            for order in event.state_changed_orders:\n                event_count += 1\n                print(f\"[{timestamp}] ORDER_STATE_CHANGE | Index: {order.index}\")\n\n            # Log new deals\n            for deal in event.new_history_deals:\n                event_count += 1\n                print(f\"[{timestamp}] NEW_DEAL | Index: {deal.index}\")\n\n            if event_count % 10 == 0:\n                print(f\"\\n--- Total events logged: {event_count} ---\\n\")\n\n    except KeyboardInterrupt:\n        print(f\"\\nStopping logger. Total events: {event_count}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(log_trade_events())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#3-position-openedclosed-tracker","title":"3) Position opened/closed tracker","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def track_position_lifecycle():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    active_positions = set()\n    total_opened = 0\n    total_closed = 0\n\n    try:\n        async for trade_data in account.on_trade():\n            event = trade_data.event_data\n\n            # Track new positions\n            for pos in event.new_positions:\n                active_positions.add(pos.index)\n                total_opened += 1\n                print(f\"[OPENED] Position #{pos.index}\")\n                print(f\"   Active: {len(active_positions)}, \"\n                      f\"Total opened: {total_opened}\")\n\n            # Track closed positions\n            for pos in event.disappeared_positions:\n                if pos.index in active_positions:\n                    active_positions.remove(pos.index)\n                total_closed += 1\n                print(f\"[CLOSED] Position #{pos.index}\")\n                print(f\"   Active: {len(active_positions)}, \"\n                      f\"Total closed: {total_closed}\")\n\n            # Show current state\n            if event.new_positions or event.disappeared_positions:\n                print(f\"\\n[STATS] Current state:\")\n                print(f\"   Active positions: {len(active_positions)}\")\n                print(f\"   Total opened: {total_opened}\")\n                print(f\"   Total closed: {total_closed}\")\n                print(f\"   Win rate: \"\n                      f\"{(total_closed / total_opened * 100) if total_opened &gt; 0 else 0:.1f}%\\n\")\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping tracker...\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(track_position_lifecycle())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#4-real-time-trade-notifications","title":"4) Real-time trade notifications","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def trade_notifications():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        async for trade_data in account.on_trade():\n            event = trade_data.event_data\n\n            # Notify on new positions\n            if event.new_positions:\n                count = len(event.new_positions)\n                print(f\"\\n[NOTIFICATION] {count} new position(s) opened\")\n\n                if trade_data.account_info:\n                    print(f\"   Current balance: ${trade_data.account_info.balance:.2f}\")\n                    print(f\"   Current equity: ${trade_data.account_info.equity:.2f}\")\n\n            # Notify on closed positions\n            if event.disappeared_positions:\n                count = len(event.disappeared_positions)\n                print(f\"\\n[NOTIFICATION] {count} position(s) closed\")\n\n                if trade_data.account_info:\n                    print(f\"   Current balance: ${trade_data.account_info.balance:.2f}\")\n                    print(f\"   Total profit: ${trade_data.account_info.profit:.2f}\")\n\n            # Notify on pending orders\n            if event.new_orders:\n                count = len(event.new_orders)\n                print(f\"\\n[NOTIFICATION] {count} pending order(s) created\")\n\n            # Notify on order execution\n            if event.disappeared_orders:\n                count = len(event.disappeared_orders)\n                print(f\"\\n[NOTIFICATION] {count} pending order(s) executed/cancelled\")\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping notifications...\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(trade_notifications())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#5-trade-statistics-collector","title":"5) Trade statistics collector","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def collect_trade_statistics(duration_seconds=300):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    stats = {\n        'positions_opened': 0,\n        'positions_closed': 0,\n        'positions_modified': 0,\n        'orders_created': 0,\n        'orders_removed': 0,\n        'deals_executed': 0,\n    }\n\n    cancel_event = asyncio.Event()\n\n    async def auto_stop():\n        await asyncio.sleep(duration_seconds)\n        cancel_event.set()\n\n    try:\n        stop_task = asyncio.create_task(auto_stop())\n\n        async for trade_data in account.on_trade(\n            cancellation_event=cancel_event\n        ):\n            event = trade_data.event_data\n\n            stats['positions_opened'] += len(event.new_positions)\n            stats['positions_closed'] += len(event.disappeared_positions)\n            stats['positions_modified'] += len(event.updated_positions)\n            stats['orders_created'] += len(event.new_orders)\n            stats['orders_removed'] += len(event.disappeared_orders)\n            stats['deals_executed'] += len(event.new_history_deals)\n\n        await stop_task\n\n        # Print final statistics\n        print(\"\\n\" + \"=\" * 60)\n        print(\"TRADE STATISTICS REPORT\")\n        print(\"=\" * 60)\n        print(f\"Positions opened:     {stats['positions_opened']:&gt;6,}\")\n        print(f\"Positions closed:     {stats['positions_closed']:&gt;6,}\")\n        print(f\"Positions modified:   {stats['positions_modified']:&gt;6,}\")\n        print(f\"Orders created:       {stats['orders_created']:&gt;6,}\")\n        print(f\"Orders removed:       {stats['orders_removed']:&gt;6,}\")\n        print(f\"Deals executed:       {stats['deals_executed']:&gt;6,}\")\n        print(\"=\" * 60)\n\n    finally:\n        await account.channel.close()\n\n# Collect statistics for 5 minutes\nasyncio.run(collect_trade_statistics(300))\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#6-real-time-trade-synchronizer","title":"6) Real-time trade synchronizer","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nclass TradeSynchronizer:\n    def __init__(self):\n        self.positions = {}  # index -&gt; position data\n        self.orders = {}     # index -&gt; order data\n\n    async def sync_trades(self, account):\n        \"\"\"Synchronize local state with MT5 account\"\"\"\n        async for trade_data in account.on_trade():\n            event = trade_data.event_data\n\n            # Sync positions\n            for pos in event.new_positions:\n                self.positions[pos.index] = pos\n                print(f\"[SYNC] Added position #{pos.index}\")\n\n            for pos in event.disappeared_positions:\n                if pos.index in self.positions:\n                    del self.positions[pos.index]\n                    print(f\"[SYNC] Removed position #{pos.index}\")\n\n            for pos in event.updated_positions:\n                if pos.index in self.positions:\n                    # Update position data\n                    print(f\"[SYNC] Updated position #{pos.index}\")\n\n            # Sync orders\n            for order in event.new_orders:\n                self.orders[order.index] = order\n                print(f\"[SYNC] Added order #{order.index}\")\n\n            for order in event.disappeared_orders:\n                if order.index in self.orders:\n                    del self.orders[order.index]\n                    print(f\"[SYNC] Removed order #{order.index}\")\n\n            # Show current state\n            print(f\"\\n[STATE] Local state: {len(self.positions)} positions, \"\n                  f\"{len(self.orders)} orders\\n\")\n\nasync def main():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    synchronizer = TradeSynchronizer()\n\n    try:\n        await synchronizer.sync_trades(account)\n    except KeyboardInterrupt:\n        print(\"\\nStopping synchronizer...\")\n    finally:\n        await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>OnTradeTransaction - More detailed transaction events</li> <li>OnPositionProfit - Stream position profit updates</li> <li>OpenedOrders - Get current positions snapshot</li> <li>OrderHistory - Get historical orders</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/","title":"Stream Trade Transaction Events","text":"<p>Request: subscribe to real-time trade transaction events (detailed audit trail).</p> <p>API Information:</p> <ul> <li>Python API: <code>MT5Account.on_trade_transaction(...)</code> (defined in <code>package/MetaRpcMT5/helpers/mt5_account.py</code>)</li> <li>gRPC service: <code>mt5_term_api.SubscriptionService</code></li> <li>Proto definition: <code>OnTradeTransaction</code> (defined in <code>mt5-term-api-subscriptions.proto</code>)</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#rpc","title":"RPC","text":"<ul> <li>Service: <code>mt5_term_api.SubscriptionService</code></li> <li>Method: <code>OnTradeTransaction(OnTradeTransactionRequest) -&gt; stream OnTradeTransactionReply</code></li> <li>Low-level client (generated): <code>SubscriptionServiceStub.OnTradeTransaction(request, metadata)</code></li> </ul> <pre><code>from MetaRpcMT5 import MT5Account\n\nclass MT5Account:\n    # ...\n\n    async def on_trade_transaction(\n        self,\n        cancellation_event: Optional[asyncio.Event] = None,\n    ):\n        \"\"\"\n        Subscribes to real-time trade transaction events.\n\n        Yields:\n            OnTradeTransactionData: Trade transaction data.\n        \"\"\"\n</code></pre> <p>Request message:</p> <pre><code>message OnTradeTransactionRequest {\n  // No parameters - subscribes to all trade transactions\n}\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#just-the-essentials","title":"\ud83d\udcac Just the essentials","text":"<ul> <li>What it is. Real-time stream of detailed trade transaction events (most comprehensive).</li> <li>Why you need it. Complete audit trail, detailed transaction logging, trade verification.</li> <li>Event-driven. Updates triggered immediately on every transaction event.</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#purpose","title":"\ud83c\udfaf Purpose","text":"<p>Use it to:</p> <ul> <li>Build complete trade audit logs</li> <li>Track detailed transaction lifecycle</li> <li>Monitor order state changes in detail</li> <li>Verify trade execution</li> <li>Debug trading operations</li> <li>Implement transaction-based logic</li> <li>Create detailed trade journals</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#input","title":"\ud83d\udd3d Input","text":"Parameter Type Description <code>cancellation_event</code> <code>Optional[asyncio.Event]</code> Event to cancel streaming (optional)"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#output-async-generator","title":"\u2b06\ufe0f Output - Async Generator","text":"<p>Returns an async generator that yields <code>OnTradeTransactionData</code> objects.</p> <p>OnTradeTransactionData fields:</p> Field Type Description <code>type</code> <code>int</code> Transaction type <code>trade_transaction</code> <code>MqlTradeTransaction</code> Detailed transaction information <code>trade_request</code> <code>MqlTradeRequest</code> Original trade request <code>trade_result</code> <code>MqlTradeResult</code> Trade execution result <code>account_info</code> <code>OnEventAccountInfo</code> Current account state <code>terminal_instance_guid_id</code> <code>str</code> Terminal instance identifier <p>Order type enum (SUB_ENUM_ORDER_TYPE):</p> Name Value Description <code>SUB_ORDER_TYPE_BUY</code> 0 Market buy order <code>SUB_ORDER_TYPE_SELL</code> 1 Market sell order <code>SUB_ORDER_TYPE_BUY_LIMIT</code> 2 Buy limit pending order <code>SUB_ORDER_TYPE_SELL_LIMIT</code> 3 Sell limit pending order <code>SUB_ORDER_TYPE_BUY_STOP</code> 4 Buy stop pending order <code>SUB_ORDER_TYPE_SELL_STOP</code> 5 Sell stop pending order <code>SUB_ORDER_TYPE_BUY_STOP_LIMIT</code> 6 Buy stop limit pending order <code>SUB_ORDER_TYPE_SELL_STOP_LIMIT</code> 7 Sell stop limit pending order <code>SUB_ORDER_TYPE_CLOSE_BY</code> 8 Close by opposite position <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_ORDER_TYPE_BUY   # = 0\n</code></pre></p> <p>Order state enum (SUB_ENUM_ORDER_STATE):</p> Name Value Description <code>SUB_ORDER_STATE_STARTED</code> 0 Order checked, but not yet accepted <code>SUB_ORDER_STATE_PLACED</code> 1 Order accepted <code>SUB_ORDER_STATE_CANCELED</code> 2 Order canceled by client <code>SUB_ORDER_STATE_PARTIAL</code> 3 Order partially executed <code>SUB_ORDER_STATE_FILLED</code> 4 Order fully executed <code>SUB_ORDER_STATE_REJECTED</code> 5 Order rejected <code>SUB_ORDER_STATE_EXPIRED</code> 6 Order expired <code>SUB_ORDER_STATE_REQUEST_ADD</code> 7 Order being registered <code>SUB_ORDER_STATE_REQUEST_MODIFY</code> 8 Order being modified <code>SUB_ORDER_STATE_REQUEST_CANCEL</code> 9 Order being deleted <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_ORDER_STATE_FILLED   # = 4\n</code></pre></p> <p>Deal type enum (SUB_ENUM_DEAL_TYPE):</p> Name Value Description <code>SUB_DEAL_TYPE_BUY</code> 0 Buy deal <code>SUB_DEAL_TYPE_SELL</code> 1 Sell deal <code>SUB_DEAL_TYPE_BALANCE</code> 2 Balance operation <code>SUB_DEAL_TYPE_CREDIT</code> 3 Credit operation <code>SUB_DEAL_TYPE_CHARGE</code> 4 Additional charge <code>SUB_DEAL_TYPE_CORRECTION</code> 5 Correction <code>SUB_DEAL_TYPE_BONUS</code> 6 Bonus <code>SUB_DEAL_TYPE_COMMISSION</code> 7 Commission <code>SUB_DEAL_TYPE_COMMISSION_DAILY</code> 8 Daily commission <code>SUB_DEAL_TYPE_COMMISSION_MONTHLY</code> 9 Monthly commission <code>SUB_DEAL_TYPE_COMMISSION_AGENT_DAILY</code> 10 Agent daily commission <code>SUB_DEAL_TYPE_COMMISSION_AGENT_MONTHLY</code> 11 Agent monthly commission <code>SUB_DEAL_TYPE_INTEREST</code> 12 Interest rate <code>SUB_DEAL_TYPE_BUY_CANCELED</code> 13 Canceled buy deal <code>SUB_DEAL_TYPE_SELL_CANCELED</code> 14 Canceled sell deal <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_DEAL_TYPE_BUY   # = 0\n</code></pre></p> <p>Deal entry enum (SUB_ENUM_DEAL_ENTRY):</p> Name Value Description <code>SUB_DEAL_ENTRY_IN</code> 0 Entry into position <code>SUB_DEAL_ENTRY_OUT</code> 1 Exit from position <code>SUB_DEAL_ENTRY_INOUT</code> 2 Reverse of position <code>SUB_DEAL_ENTRY_OUT_BY</code> 3 Close by opposite position <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_DEAL_ENTRY_IN   # = 0\n</code></pre></p> <p>Deal reason enum (SUB_ENUM_DEAL_REASON):</p> Name Value Description <code>SUB_DEAL_REASON_CLIENT</code> 0 Deal placed from desktop terminal <code>SUB_DEAL_REASON_MOBILE</code> 1 Deal placed from mobile app <code>SUB_DEAL_REASON_WEB</code> 2 Deal placed from web terminal <code>SUB_DEAL_REASON_EXPERT</code> 3 Deal placed by Expert Advisor <code>SUB_DEAL_REASON_SL</code> 4 Deal due to Stop Loss activation <code>SUB_DEAL_REASON_TP</code> 5 Deal due to Take Profit activation <code>SUB_DEAL_REASON_SO</code> 6 Deal due to Stop Out <code>SUB_DEAL_REASON_ROLLOVER</code> 7 Deal due to rollover <code>SUB_DEAL_REASON_VMARGIN</code> 8 Deal due to variation margin <code>SUB_DEAL_REASON_SPLIT</code> 9 Deal due to split <code>SUB_DEAL_REASON_CORPORATE_ACTION</code> 10 Deal due to corporate action <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_DEAL_REASON_CLIENT   # = 0\n</code></pre></p> <p>Order time type enum (SUB_ENUM_ORDER_TYPE_TIME):</p> Name Value Description <code>SUB_ORDER_TIME_GTC</code> 0 Good till cancel <code>SUB_ORDER_TIME_DAY</code> 1 Good till current trading day <code>SUB_ORDER_TIME_SPECIFIED</code> 2 Good till specified date <code>SUB_ORDER_TIME_SPECIFIED_DAY</code> 3 Good till specified day <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_ORDER_TIME_GTC   # = 0\n</code></pre></p> <p>Order filling type enum (SUB_ENUM_ORDER_TYPE_FILLING):</p> Name Value Description <code>SUB_ORDER_FILLING_FOK</code> 0 Fill or Kill <code>SUB_ORDER_FILLING_IOC</code> 1 Immediate or Cancel <code>SUB_ORDER_FILLING_BOC</code> 2 Book or Cancel <code>SUB_ORDER_FILLING_RETURN</code> 3 Return <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_ORDER_FILLING_FOK   # = 0\n</code></pre></p> <p>Order reason enum (SUB_ENUM_ORDER_REASON):</p> Name Value Description <code>SUB_ORDER_REASON_CLIENT</code> 0 Order placed from desktop terminal <code>SUB_ORDER_REASON_MOBILE</code> 2 Order placed from mobile app <code>SUB_ORDER_REASON_WEB</code> 3 Order placed from web terminal <code>SUB_ORDER_REASON_EXPERT</code> 4 Order placed by Expert Advisor <code>SUB_ORDER_REASON_SL</code> 5 Order triggered by Stop Loss <code>SUB_ORDER_REASON_TP</code> 6 Order triggered by Take Profit <code>SUB_ORDER_REASON_SO</code> 7 Order triggered by Stop Out <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_ORDER_REASON_CLIENT   # = 0\n</code></pre></p> <p>Position type enum (SUB_ENUM_POSITION_TYPE):</p> Name Value Description <code>SUB_POSITION_TYPE_BUY</code> 0 Buy position <code>SUB_POSITION_TYPE_SELL</code> 1 Sell position <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_POSITION_TYPE_BUY   # = 0\n</code></pre></p> <p>Position reason enum (SUB_ENUM_POSITION_REASON):</p> Name Value Description <code>SUB_POSITION_REASON_CLIENT</code> 0 Position from desktop terminal <code>SUB_POSITION_REASON_MOBILE</code> 2 Position from mobile app <code>SUB_POSITION_REASON_WEB</code> 3 Position from web terminal <code>SUB_POSITION_REASON_EXPERT</code> 4 Position from Expert Advisor <p>Usage: <pre><code>import MetaRpcMT5.mt5_term_api_subscriptions_pb2 as subscriptions_pb2\nsubscriptions_pb2.SUB_POSITION_REASON_CLIENT   # = 0\n</code></pre></p> <p>MqlTradeTransaction fields (partial list):</p> Field Type Description <code>deal_ticket</code> <code>uint64</code> Deal ticket number <code>order_ticket</code> <code>uint64</code> Order ticket number <code>symbol</code> <code>string</code> Trading symbol <code>type</code> <code>enum</code> Transaction type <code>order_type</code> <code>enum</code> Order type (market, limit, stop, etc.) <code>order_state</code> <code>enum</code> Order state (started, placed, etc.) <code>deal_type</code> <code>enum</code> Deal type (buy, sell) <code>order_time_type</code> <code>enum</code> Order time type (GTC, DAY, etc.) <code>price</code> <code>double</code> Price <code>price_stop_loss</code> <code>double</code> Stop loss price <code>price_take_profit</code> <code>double</code> Take profit price <code>volume</code> <code>double</code> Volume <code>position_ticket</code> <code>uint64</code> Position ticket <p>MqlTradeRequest fields:</p> Field Type Description <code>action</code> <code>enum</code> Trade operation type <code>magic</code> <code>uint64</code> Expert Advisor ID <code>order</code> <code>uint64</code> Order ticket <code>symbol</code> <code>string</code> Trading symbol <code>volume</code> <code>double</code> Requested volume <code>price</code> <code>double</code> Price <p>MqlTradeResult fields:</p> Field Type Description <code>retcode</code> <code>uint32</code> Operation return code <code>deal</code> <code>uint64</code> Deal ticket <code>order</code> <code>uint64</code> Order ticket <code>volume</code> <code>double</code> Deal volume <code>price</code> <code>double</code> Deal price <code>bid</code> <code>double</code> Current Bid price <code>ask</code> <code>double</code> Current Ask price <code>comment</code> <code>string</code> Broker comment"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#tutorial","title":"\ud83d\udcda Tutorial","text":"<p>For a detailed line-by-line explanation with examples, see: OnTradeTransaction - How it works</p>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#notes-tips","title":"\ud83e\udde9 Notes &amp; Tips","text":"<ul> <li>Automatic reconnection: All <code>MT5Account</code> streaming methods have built-in protection against transient gRPC errors with automatic reconnection via <code>execute_stream_with_reconnect</code>.</li> <li>Async generator: The method returns an async generator - use <code>async for</code> to consume data.</li> <li>Most detailed: This is the most comprehensive transaction stream - includes full request/result data.</li> <li>No parameters: Subscribes to ALL trade transactions automatically.</li> <li>Event-driven: Updates arrive immediately when transactions occur (not periodic).</li> <li>Complete lifecycle: Tracks order placement, modification, execution, and cancellation.</li> <li>Includes failures: Receives events for both successful and failed transactions.</li> <li>Resource intensive: Most detailed stream - use <code>on_trade</code> if you don't need this level of detail.</li> </ul>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#1-basic-transaction-monitor","title":"1) Basic transaction monitor","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def monitor_transactions():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        async for tx_data in account.on_trade_transaction():\n            tx = tx_data.trade_transaction\n\n            print(f\"\\n[TRANSACTION EVENT]\")\n            print(f\"   Type: {tx.type}\")\n            print(f\"   Symbol: {tx.symbol}\")\n            print(f\"   Order: #{tx.order_ticket}\")\n            print(f\"   Deal: #{tx.deal_ticket}\")\n            print(f\"   Position: #{tx.position_ticket}\")\n            print(f\"   Price: {tx.price}\")\n            print(f\"   Volume: {tx.volume}\")\n            print(f\"   Order state: {tx.order_state}\")\n\n            # Show request if available\n            if tx_data.trade_request and tx_data.trade_request.symbol:\n                req = tx_data.trade_request\n                print(f\"\\n   Request:\")\n                print(f\"     Symbol: {req.symbol}\")\n                print(f\"     Volume: {req.volume}\")\n                print(f\"     Price: {req.price}\")\n\n            # Show result if available\n            if tx_data.trade_result and tx_data.trade_result.retcode != 0:\n                res = tx_data.trade_result\n                print(f\"\\n   Result:\")\n                print(f\"     Return code: {res.retcode}\")\n                print(f\"     Comment: {res.comment}\")\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping transaction monitor...\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(monitor_transactions())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#2-complete-transaction-audit-log","title":"2) Complete transaction audit log","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom MetaRpcMT5 import MT5Account\n\nasync def audit_log():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        with open('trade_audit.log', 'w') as logfile:\n            logfile.write(\"Timestamp,Type,Symbol,Order,Deal,Position,Price,Volume,State\\n\")\n\n            async for tx_data in account.on_trade_transaction():\n                tx = tx_data.trade_transaction\n                timestamp = datetime.now().isoformat()\n\n                # Write to audit log\n                logfile.write(\n                    f\"{timestamp},\"\n                    f\"{tx.type},\"\n                    f\"{tx.symbol},\"\n                    f\"{tx.order_ticket},\"\n                    f\"{tx.deal_ticket},\"\n                    f\"{tx.position_ticket},\"\n                    f\"{tx.price},\"\n                    f\"{tx.volume},\"\n                    f\"{tx.order_state}\\n\"\n                )\n                logfile.flush()\n\n                print(f\"[{timestamp}] Logged transaction: \"\n                      f\"Order #{tx.order_ticket}, Deal #{tx.deal_ticket}\")\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping audit log...\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(audit_log())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#3-order-lifecycle-tracker","title":"3) Order lifecycle tracker","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def track_order_lifecycle():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    order_states = {}  # order_ticket -&gt; list of states\n\n    try:\n        async for tx_data in account.on_trade_transaction():\n            tx = tx_data.trade_transaction\n\n            if tx.order_ticket &gt; 0:\n                # Track order state changes\n                if tx.order_ticket not in order_states:\n                    order_states[tx.order_ticket] = []\n\n                order_states[tx.order_ticket].append({\n                    'state': tx.order_state,\n                    'type': tx.type,\n                    'price': tx.price,\n                    'volume': tx.volume\n                })\n\n                print(f\"\\n[LIFECYCLE] Order #{tx.order_ticket}:\")\n                for i, state in enumerate(order_states[tx.order_ticket], 1):\n                    print(f\"   {i}. State: {state['state']}, \"\n                          f\"Type: {state['type']}, \"\n                          f\"Price: {state['price']}\")\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping lifecycle tracker...\")\n        print(f\"\\nTracked {len(order_states)} orders\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(track_order_lifecycle())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#4-failed-transaction-monitor","title":"4) Failed transaction monitor","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def monitor_failed_transactions():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    failed_count = 0\n\n    try:\n        async for tx_data in account.on_trade_transaction():\n            # Check for failed transactions\n            if tx_data.trade_result and tx_data.trade_result.retcode != 10009:  # Not DONE\n                failed_count += 1\n                res = tx_data.trade_result\n                tx = tx_data.trade_transaction\n\n                print(f\"\\n[FAILED TRANSACTION #{failed_count}]\")\n                print(f\"   Return code: {res.retcode}\")\n                print(f\"   Comment: {res.comment}\")\n                print(f\"   Symbol: {tx.symbol}\")\n                print(f\"   Order: #{tx.order_ticket}\")\n                print(f\"   Requested volume: {tx.volume}\")\n                print(f\"   Price: {tx.price}\")\n\n                if tx_data.trade_request:\n                    req = tx_data.trade_request\n                    print(f\"\\n   Original request:\")\n                    print(f\"     Action: {req.action}\")\n                    print(f\"     Symbol: {req.symbol}\")\n                    print(f\"     Volume: {req.volume}\")\n\n    except KeyboardInterrupt:\n        print(f\"\\n\\nStopping monitor. Total failed: {failed_count}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(monitor_failed_transactions())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#5-transaction-statistics-collector","title":"5) Transaction statistics collector","text":"<pre><code>import asyncio\nfrom collections import defaultdict\nfrom MetaRpcMT5 import MT5Account\n\nasync def collect_transaction_stats(duration_seconds=300):\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    stats = {\n        'total_transactions': 0,\n        'by_type': defaultdict(int),\n        'by_state': defaultdict(int),\n        'by_symbol': defaultdict(int),\n        'successful': 0,\n        'failed': 0,\n    }\n\n    cancel_event = asyncio.Event()\n\n    async def auto_stop():\n        await asyncio.sleep(duration_seconds)\n        cancel_event.set()\n\n    try:\n        stop_task = asyncio.create_task(auto_stop())\n\n        async for tx_data in account.on_trade_transaction(\n            cancellation_event=cancel_event\n        ):\n            tx = tx_data.trade_transaction\n            stats['total_transactions'] += 1\n            stats['by_type'][tx.type] += 1\n            stats['by_state'][tx.order_state] += 1\n\n            if tx.symbol:\n                stats['by_symbol'][tx.symbol] += 1\n\n            # Check success/failure\n            if tx_data.trade_result:\n                if tx_data.trade_result.retcode == 10009:  # DONE\n                    stats['successful'] += 1\n                else:\n                    stats['failed'] += 1\n\n        await stop_task\n\n        # Print statistics\n        print(\"\\n\" + \"=\" * 70)\n        print(\"TRANSACTION STATISTICS REPORT\")\n        print(\"=\" * 70)\n        print(f\"Total transactions:  {stats['total_transactions']:&gt;6,}\")\n        print(f\"Successful:          {stats['successful']:&gt;6,}\")\n        print(f\"Failed:              {stats['failed']:&gt;6,}\")\n\n        print(\"\\nBy Type:\")\n        for tx_type, count in sorted(stats['by_type'].items()):\n            print(f\"  Type {tx_type}: {count:&gt;6,}\")\n\n        print(\"\\nBy State:\")\n        for state, count in sorted(stats['by_state'].items()):\n            print(f\"  State {state}: {count:&gt;6,}\")\n\n        print(\"\\nBy Symbol:\")\n        for symbol, count in sorted(stats['by_symbol'].items(),\n                                    key=lambda x: x[1], reverse=True)[:10]:\n            print(f\"  {symbol}: {count:&gt;6,}\")\n\n        print(\"=\" * 70)\n\n    finally:\n        await account.channel.close()\n\n# Collect statistics for 5 minutes\nasyncio.run(collect_transaction_stats(300))\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#6-real-time-trade-journal","title":"6) Real-time trade journal","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom MetaRpcMT5 import MT5Account\n\nasync def trade_journal():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    journal_entries = []\n\n    try:\n        async for tx_data in account.on_trade_transaction():\n            tx = tx_data.trade_transaction\n\n            # Create journal entry\n            entry = {\n                'timestamp': datetime.now(),\n                'type': tx.type,\n                'symbol': tx.symbol,\n                'order_ticket': tx.order_ticket,\n                'deal_ticket': tx.deal_ticket,\n                'position_ticket': tx.position_ticket,\n                'price': tx.price,\n                'volume': tx.volume,\n                'order_state': tx.order_state,\n                'sl': tx.price_stop_loss,\n                'tp': tx.price_take_profit,\n            }\n\n            # Add result info if available\n            if tx_data.trade_result:\n                entry['retcode'] = tx_data.trade_result.retcode\n                entry['comment'] = tx_data.trade_result.comment\n\n            # Add account balance\n            if tx_data.account_info:\n                entry['balance'] = tx_data.account_info.balance\n                entry['equity'] = tx_data.account_info.equity\n\n            journal_entries.append(entry)\n\n            # Display entry\n            print(f\"\\n{'=' * 70}\")\n            print(f\"JOURNAL ENTRY #{len(journal_entries)}\")\n            print(f\"{'=' * 70}\")\n            print(f\"Time:       {entry['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}\")\n            print(f\"Symbol:     {entry['symbol']}\")\n            print(f\"Type:       {entry['type']}\")\n            print(f\"Order:      #{entry['order_ticket']}\")\n            print(f\"Deal:       #{entry['deal_ticket']}\")\n            print(f\"Position:   #{entry['position_ticket']}\")\n            print(f\"Price:      {entry['price']}\")\n            print(f\"Volume:     {entry['volume']}\")\n            print(f\"SL:         {entry['sl']}\")\n            print(f\"TP:         {entry['tp']}\")\n            print(f\"State:      {entry['order_state']}\")\n\n            if 'balance' in entry:\n                print(f\"Balance:    ${entry['balance']:.2f}\")\n                print(f\"Equity:     ${entry['equity']:.2f}\")\n\n            # Save journal periodically\n            if len(journal_entries) % 10 == 0:\n                print(f\"\\n[SAVED] {len(journal_entries)} entries to journal\")\n\n    except KeyboardInterrupt:\n        print(f\"\\n\\nStopping journal. Total entries: {len(journal_entries)}\")\n\n        # Export journal\n        with open('trade_journal.txt', 'w') as f:\n            f.write(\"TRADE JOURNAL\\n\")\n            f.write(\"=\" * 70 + \"\\n\\n\")\n            for i, entry in enumerate(journal_entries, 1):\n                f.write(f\"Entry #{i}\\n\")\n                f.write(f\"  Time: {entry['timestamp']}\\n\")\n                f.write(f\"  Symbol: {entry['symbol']}\\n\")\n                f.write(f\"  Order: #{entry['order_ticket']}\\n\")\n                f.write(f\"  Price: {entry['price']}\\n\")\n                f.write(\"\\n\")\n\n        print(f\"Journal exported to trade_journal.txt\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(trade_journal())\n</code></pre>"},{"location":"MT5Account/6.%20Streaming_Methods/on_trade_transaction/#see-also","title":"\ud83d\udcda See also","text":"<ul> <li>OnTrade - Simpler trade event stream (less detailed)</li> <li>OrderSend - Send trade orders</li> <li>OrderCheck - Verify order before sending</li> <li>OrderHistory - Get historical orders</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_double_HOW/","title":"account info double HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_double_HOW/#account_info_double-how-it-works","title":"account_info_double \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_double_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to retrieve a specific numeric account property using the low-level asynchronous method <code>account_info_double()</code>.</p> <p>The method is designed to request exactly one account value stored as a floating-point number (e.g., balance, equity, margin level).</p> <p>It performs one request and returns one value of type <code>float</code>.</p> <p>The method performs no aggregation, validation, or trading logic.</p> <p>Simply put:</p> <p>The method simply requests \"give me this numeric account property\" and returns the result as a regular Python <code>float</code>.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_double_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def account_info_double(\n    property_id: AccountInfoDoublePropertyType,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; float\n</code></pre> <p>Key Points:</p> <ul> <li>The method is asynchronous and must be called with <code>await</code>.</li> <li><code>property_id</code> specifies which account property to request.</li> <li><code>deadline</code> and <code>cancellation_event</code> control call execution time.</li> <li>Return value is a regular Python <code>float</code>.</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_double_HOW/#code-example-checking-margin-level-before-trading","title":"\ud83e\udde9 Code Example \u2014 Checking Margin Level Before Trading","text":"<pre><code>async def check_margin_level(account: MT5Account, min_level: float = 200.0) -&gt; bool:\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    margin_level = await account.account_info_double(\n        property_id=account_info_pb2.AccountInfoDoublePropertyType.ACCOUNT_MARGIN_LEVEL,\n        deadline=deadline\n    )\n\n    print(f\"Margin Level: {margin_level:.2f}%\")\n\n    if margin_level &lt; min_level:\n        raise ValueError(\n            f\"Margin level {margin_level:.2f}% is below minimum {min_level:.2f}%\"\n        )\n\n    return True\n</code></pre> <p>In this example, <code>account_info_double()</code> is used as a building block for a simple safety check before opening trades.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_double_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_double_HOW/#1-method-call","title":"1\ufe0f\u20e3 Method Call","text":"<pre><code>margin_level = await account.account_info_double(\n    property_id=account_info_pb2.AccountInfoDoublePropertyType.ACCOUNT_MARGIN_LEVEL,\n    deadline=deadline\n)\n</code></pre> <p>This line performs one request for a single numeric account property.</p> <ul> <li><code>ACCOUNT_MARGIN_LEVEL</code> specifies which value to retrieve</li> <li>the method asynchronously awaits the terminal's response</li> <li>upon successful execution, a <code>float</code> is returned</li> </ul> <p>At this stage:</p> <ul> <li>no validation is performed</li> <li>no value interpretation occurs</li> <li>the number is returned exactly as provided by the terminal</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_double_HOW/#2-working-with-return-value","title":"2\ufe0f\u20e3 Working with Return Value","text":"<pre><code>print(f\"Margin Level: {margin_level:.2f}%\")\n</code></pre> <p>The return value is a regular Python number.</p> <ul> <li>no protobuf objects</li> <li>no nested structures</li> <li>no additional data parsing required</li> </ul> <p>The value can be immediately used in calculations, logs, or conditions.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_double_HOW/#3-applying-business-logic","title":"3\ufe0f\u20e3 Applying Business Logic","text":"<pre><code>if margin_level &lt; min_level:\n    raise ValueError(...)\n</code></pre> <p>After receiving the numeric value, regular user application logic begins.</p> <p>In this example:</p> <ul> <li><code>margin_level</code> is the value returned from <code>account_info_double()</code></li> <li><code>min_level</code> is a threshold defined by strategy logic or risk management</li> </ul> <p>The code simply compares two numbers and makes a decision:</p> <ul> <li>if margin level is below acceptable \u2014 execution is interrupted</li> <li>if condition is met \u2014 function completes successfully</li> </ul> <p>It's important to understand the boundary of responsibility:</p> <ul> <li><code>account_info_double()</code> only returns a number</li> <li>comparison, interpretation, and reaction to the value are not part of the API</li> </ul> <p>This is exactly how low-level methods are intended to be used \u2014 as a data source on top of which your own strategy logic is built.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_double_HOW/#what-this-method-does","title":"What This Method Does","text":"<ul> <li>Requests one numeric account property</li> <li>Performs one asynchronous call</li> <li>Returns one value of type <code>float</code></li> </ul> <p>Typical use cases:</p> <ul> <li>balance checking</li> <li>equity monitoring</li> <li>margin and free margin control</li> <li>risk management conditions</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_double_HOW/#summary","title":"Summary","text":"<ul> <li><code>account_info_double()</code> is a low-level getter for numeric account properties.</li> <li>It retrieves exactly one property per call.</li> <li>The method returns a clean Python <code>float</code>, ready to use.</li> <li>All decision-making logic remains on the calling code side.</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_integer_HOW/","title":"account info integer HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_integer_HOW/#account_info_integer-how-it-works","title":"account_info_integer \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_integer_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to retrieve integer account properties using the low-level asynchronous method <code>account_info_integer()</code>.</p> <p>The method is used to request values that are represented in MetaTrader as integers: whether trading is allowed, leverage size, account login, trade mode, and other flags or parameters.</p> <p>Unlike <code>account_info_double()</code>, this method always returns an integer (<code>int</code>).</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_integer_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def account_info_integer(\n    property_id: AccountInfoIntegerPropertyType,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; int\n</code></pre> <p>Key Points:</p> <ul> <li>The method is asynchronous and called with <code>await</code>.</li> <li><code>property_id</code> specifies which integer property of the account to request.</li> <li><code>deadline</code> and <code>cancellation_event</code> control call execution time.</li> <li>The result is returned as a regular Python <code>int</code>.</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_integer_HOW/#code-example-pre-validation-of-account-before-trading","title":"\ud83e\udde9 Code Example \u2014 Pre-validation of Account Before Trading","text":"<pre><code>async def validate_account_for_trading(account: MT5Account) -&gt; bool:\n    deadline = datetime.utcnow() + timedelta(seconds=5)\n\n    # Check: is trading allowed on the account\n    trade_allowed = await account.account_info_integer(\n        account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_TRADE_ALLOWED,\n        deadline\n    )\n\n    if not trade_allowed:\n        print(\"[ERROR] Trading is disabled on this account\")\n        return False\n\n    # Check: is leverage configured correctly\n    leverage = await account.account_info_integer(\n        account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_LEVERAGE,\n        deadline\n    )\n\n    if leverage &lt; 1:\n        print(\"[ERROR] Invalid leverage setting\")\n        return False\n\n    print(f\"[OK] Account ready to trade (Leverage: 1:{leverage})\")\n    return True\n</code></pre> <p>In this example, <code>account_info_integer()</code> is used as a source of flags and parameters needed for basic validation of account readiness for trading.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_integer_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_integer_HOW/#1-checking-trading-permission","title":"1\ufe0f\u20e3 Checking Trading Permission","text":"<pre><code>trade_allowed = await account.account_info_integer(\n    account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_TRADE_ALLOWED,\n    deadline\n)\n</code></pre> <p>Here, a request is made for a single integer account property \u2014 a flag that indicates whether trading is allowed.</p> <ul> <li>the method performs an asynchronous call</li> <li>the return value is an integer (<code>int</code>)</li> </ul> <p>In practice, this value is used as a boolean flag:</p> <ul> <li><code>0</code> \u2014 trading is disabled</li> <li>non-zero value \u2014 trading is allowed</li> </ul> <p>The method itself does not interpret this value \u2014 it only returns a number.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_integer_HOW/#2-using-the-value-in-application-logic","title":"2\ufe0f\u20e3 Using the Value in Application Logic","text":"<pre><code>if not trade_allowed:\n    print(\"[ERROR] Trading is disabled on this account\")\n    return False\n</code></pre> <p>At this stage, regular user logic begins:</p> <ul> <li>the value received from <code>account_info_integer()</code> is used in a condition</li> <li>when trading is disabled, function execution terminates</li> </ul> <p>This decision is completely outside the responsibility of the low-level API.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_integer_HOW/#3-checking-leverage","title":"3\ufe0f\u20e3 Checking Leverage","text":"<pre><code>leverage = await account.account_info_integer(\n    account_info_pb2.AccountInfoIntegerPropertyType.ACCOUNT_LEVERAGE,\n    deadline\n)\n</code></pre> <p>Here, a second call to the same method is performed, but with a different <code>property_id</code>.</p> <p>Important:</p> <ul> <li>each call requests exactly one property</li> <li>the method does not cache values</li> <li>each value is retrieved independently</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_integer_HOW/#4-applying-the-check","title":"4\ufe0f\u20e3 Applying the Check","text":"<pre><code>if leverage &lt; 1:\n    print(\"[ERROR] Invalid leverage setting\")\n    return False\n</code></pre> <p>The received value is used directly:</p> <ul> <li>compared against expected threshold</li> <li>when value is incorrect, execution is interrupted</li> </ul> <p>As in the previous case:</p> <ul> <li>the method doesn't know which leverage is considered acceptable</li> <li>value interpretation is the calling code's responsibility</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_integer_HOW/#summary","title":"Summary","text":"<p>In this example, <code>account_info_integer()</code> is used as a simple source of integer account parameters.</p> <p>The method is called multiple times with different <code>property_id</code>, and all decision-making logic is built on top of the returned values.</p> <p>This approach allows:</p> <ul> <li>separating data retrieval from interpretation</li> <li>reusing low-level API in different strategies</li> <li>explicitly controlling trading logic behavior</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_string_HOW/","title":"account info string HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_string_HOW/#account_info_string-how-it-works","title":"account_info_string \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_string_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example demonstrates how to retrieve a string property of a trading account using the low-level asynchronous method <code>account_info_string()</code>.</p> <p>The method is used to request values that are represented as strings in MetaTrader: server name, account name, deposit currency, and other text parameters.</p> <p>The method executes one request and returns one string value (<code>str</code>).</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_string_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def account_info_string(\n    property_id: AccountInfoStringPropertyType,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; str\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and must be called with <code>await</code></li> <li><code>property_id</code> specifies which string property to request</li> <li><code>deadline</code> and <code>cancellation_event</code> control the execution time</li> <li>The result is returned as a regular Python string (<code>str</code>)</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_string_HOW/#code-example-verifying-server-connection","title":"\ud83e\udde9 Code Example \u2014 Verifying Server Connection","text":"<pre><code>async def verify_server_connection(account: MT5Account, expected_server: str) -&gt; bool:\n    deadline = datetime.utcnow() + timedelta(seconds=3)\n\n    server = await account.account_info_string(\n        property_id=account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_SERVER,\n        deadline=deadline\n    )\n\n    if server.lower() != expected_server.lower():\n        print(f\"[WARNING] Connected to {server}, expected {expected_server}\")\n        return False\n\n    print(f\"[OK] Confirmed: Connected to {server}\")\n    return True\n</code></pre> <p>In this example, <code>account_info_string()</code> is used to retrieve the server name and subsequently verify that the account is connected to the expected trading environment.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_string_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_string_HOW/#1-requesting-a-string-property","title":"1\ufe0f\u20e3 Requesting a String Property","text":"<pre><code>server = await account.account_info_string(\n    property_id=account_info_pb2.AccountInfoStringPropertyType.ACCOUNT_SERVER,\n    deadline=deadline\n)\n</code></pre> <p>At this step, a single string property of the account is requested.</p> <ul> <li><code>ACCOUNT_SERVER</code> specifies which value to retrieve</li> <li>The method asynchronously awaits the response</li> <li>The result is a regular Python string</li> </ul> <p>What does NOT happen here:</p> <ul> <li>No validation of string content</li> <li>No case normalization</li> <li>No value interpretation</li> </ul> <p>The method simply returns the text value received from the terminal.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_string_HOW/#2-working-with-the-retrieved-string","title":"2\ufe0f\u20e3 Working with the Retrieved String","text":"<pre><code>if server.lower() != expected_server.lower():\n</code></pre> <p>After receiving the value, user application logic begins.</p> <p>In this example:</p> <ul> <li><code>server</code> \u2014 the actual server name received from the terminal</li> <li><code>expected_server</code> \u2014 the server name expected by the user or strategy</li> </ul> <p>Both values are converted to lowercase so the comparison is case-insensitive.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_string_HOW/#3-reacting-to-verification-result","title":"3\ufe0f\u20e3 Reacting to Verification Result","text":"<pre><code>print(f\"[WARNING] Connected to {server}, expected {expected_server}\")\nreturn False\n</code></pre> <p>If the server doesn't match:</p> <ul> <li>A warning is printed</li> <li>The function returns <code>False</code></li> </ul> <p>This is a deliberate decision in the application code. The <code>account_info_string()</code> method itself:</p> <ul> <li>Does not know which server is considered correct</li> <li>Makes no decisions about connection validity</li> </ul> <pre><code>print(f\"[OK] Confirmed: Connected to {server}\")\nreturn True\n</code></pre> <p>If the server matches:</p> <ul> <li>A confirmation is printed</li> <li>The function returns <code>True</code></li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_info_string_HOW/#summary","title":"Summary","text":"<p>In this example, <code>account_info_string()</code> is used as a simple source of string account parameters.</p> <p>The method returns one string value, while all verification logic and reaction to the result is completely within the calling code.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_summary_HOW/","title":"account summary HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_summary_HOW/#account_summary-how-it-works","title":"account_summary \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_summary_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example demonstrates how to retrieve a trading account summary using the low-level asynchronous method <code>account_summary()</code>.</p> <p>Unlike <code>account_info_*</code> methods that return one specific value, <code>account_summary()</code> is used when you need multiple related account parameters at once.</p> <p>The method executes one request and returns an object with pre-collected account state data.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_summary_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def account_summary(\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and must be called with <code>await</code></li> <li>Parameters <code>deadline</code> and <code>cancellation_event</code> control execution time</li> <li>The method does not accept <code>property_id</code> because it returns a set of values, not a single field</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_summary_HOW/#code-example-assessing-trading-risk","title":"\ud83e\udde9 Code Example \u2014 Assessing Trading Risk","text":"<pre><code>async def assess_trading_risk(account: MT5Account) -&gt; str:\n    summary = await account.account_summary()\n\n    # Calculate risk factors\n    balance = summary.account_balance\n    equity = summary.account_equity\n    leverage = summary.account_leverage\n\n    # Risk score\n    if leverage &gt; 200:\n        risk = \"HIGH\"\n    elif leverage &gt; 100:\n        risk = \"MEDIUM\"\n    else:\n        risk = \"LOW\"\n\n    # Check current losses\n    if equity &lt; balance * 0.9:\n        risk = \"HIGH\"\n\n    print(f\"Risk Assessment: {risk}\")\n    print(f\"  Leverage: 1:{leverage}\")\n    print(f\"  Balance: ${balance:.2f}\")\n    print(f\"  Equity: ${equity:.2f}\")\n\n    return risk\n</code></pre> <p>In this example, <code>account_summary()</code> is used to retrieve the current account state and subsequently assess the trading risk level.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_summary_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_summary_HOW/#1-retrieving-account-summary-data","title":"1\ufe0f\u20e3 Retrieving Account Summary Data","text":"<pre><code>summary = await account.account_summary()\n</code></pre> <p>At this step, one asynchronous call is executed.</p> <ul> <li>The method requests the entire account state</li> <li>The result is a <code>summary</code> object</li> <li>No repeated API calls are required to read individual fields</li> </ul> <p>After this line, all necessary data is already available locally.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_summary_HOW/#2-extracting-values-from-summary","title":"2\ufe0f\u20e3 Extracting Values from Summary","text":"<pre><code>balance = summary.account_balance\nequity = summary.account_equity\nleverage = summary.account_leverage\n</code></pre> <p>No server communication occurs here.</p> <ul> <li><code>summary</code> is a regular Python object</li> <li>Values are accessible as attributes</li> <li>Reading fields is a local operation</li> </ul> <p>Each line simply extracts the needed parameter from the already-retrieved account state snapshot.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_summary_HOW/#3-initial-risk-assessment-by-leverage","title":"3\ufe0f\u20e3 Initial Risk Assessment by Leverage","text":"<pre><code>if leverage &gt; 200:\n    risk = \"HIGH\"\nelif leverage &gt; 100:\n    risk = \"MEDIUM\"\nelse:\n    risk = \"LOW\"\n</code></pre> <p>Application logic for risk assessment begins.</p> <ul> <li>Only the leverage value is used</li> <li>Threshold values are defined</li> <li>A base risk level is selected</li> </ul> <p>These thresholds are part of user logic and are not related to API operation.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_summary_HOW/#4-additional-check-for-current-losses","title":"4\ufe0f\u20e3 Additional Check for Current Losses","text":"<pre><code>if equity &lt; balance * 0.9:\n    risk = \"HIGH\"\n</code></pre> <p>A second check complements the initial assessment.</p> <ul> <li>Current equity is compared with balance</li> <li>If losses exceed the specified threshold, risk is elevated</li> </ul> <p>Regular arithmetic comparison is used here without any special rules.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_summary_HOW/#5-output-and-result-return","title":"5\ufe0f\u20e3 Output and Result Return","text":"<pre><code>print(f\"Risk Assessment: {risk}\")\n...\nreturn risk\n</code></pre> <p>At the end of the function:</p> <ul> <li>The final risk assessment is printed</li> <li>A string value of the risk level is returned</li> </ul> <p>What to do with this result next is up to the calling code.</p>"},{"location":"MT5Account/HOW_IT_WORK/1.%20Account_information_HOW/account_summary_HOW/#summary","title":"Summary","text":"<p>In this example, <code>account_summary()</code> is used as a source of an account state snapshot.</p> <p>One API call returns a set of related parameters, after which all analysis and decision-making logic executes locally, without additional server requests.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_exist_HOW/","title":"symbol exist HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_exist_HOW/#symbol_exist-how-it-works","title":"symbol_exist \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_exist_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example demonstrates how to check whether a trading symbol exists in the terminal using the low-level asynchronous method <code>symbol_exist()</code>.</p> <p>The method is used for basic input data validation: before subscribing, before trading, or before loading symbol parameters.</p> <p>It answers only one question:</p> <p>Is a symbol with this name known to the terminal?</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_exist_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_exist(\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and must be called with <code>await</code></li> <li><code>symbol</code> \u2014 symbol name as a string (e.g., <code>\"EURUSD\"</code>)</li> <li><code>deadline</code> and <code>cancellation_event</code> control execution time</li> <li>The method returns an object with information about symbol existence</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_exist_HOW/#code-example-checking-multiple-symbols","title":"\ud83e\udde9 Code Example \u2014 Checking Multiple Symbols","text":"<pre><code>async def check_symbols(account: MT5Account, symbols: list[str]):\n    results = {}\n\n    for symbol in symbols:\n        data = await account.symbol_exist(symbol=symbol)\n        results[symbol] = data.exists\n\n    for symbol, exists in results.items():\n        status = \"[OK]\" if exists else \"[ERROR]\"\n        print(f\"{status} {symbol}: {'exists' if exists else 'not found'}\")\n\n    return results\n</code></pre> <p>In this example, <code>symbol_exist()</code> is used to sequentially check a list of symbols.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_exist_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_exist_HOW/#1-iterating-through-symbol-list","title":"1\ufe0f\u20e3 Iterating Through Symbol List","text":"<pre><code>for symbol in symbols:\n</code></pre> <p>The function iterates through a list of strings, where each string is a trading symbol name.</p> <p>Checks are performed sequentially, for each symbol separately.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_exist_HOW/#2-checking-symbol-existence","title":"2\ufe0f\u20e3 Checking Symbol Existence","text":"<pre><code>data = await account.symbol_exist(symbol=symbol)\n</code></pre> <p>At this step, one asynchronous call is executed.</p> <ul> <li>The symbol name is passed to the method</li> <li>The terminal checks whether such a symbol is known</li> <li>The result is returned as a response object</li> </ul> <p>The method does not throw an error if the symbol is not found \u2014 this information is returned in the response data.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_exist_HOW/#3-extracting-check-result","title":"3\ufe0f\u20e3 Extracting Check Result","text":"<pre><code>results[symbol] = data.exists\n</code></pre> <p>The response object contains the <code>exists</code> field.</p> <ul> <li><code>True</code> \u2014 symbol exists</li> <li><code>False</code> \u2014 symbol not found</li> </ul> <p>Only this fact is saved to the dictionary, without additional symbol information.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_exist_HOW/#4-processing-results","title":"4\ufe0f\u20e3 Processing Results","text":"<pre><code>for symbol, exists in results.items():\n</code></pre> <p>After all checks are completed, results are processed separately.</p> <p>This allows:</p> <ul> <li>First collecting data</li> <li>Then making decisions or displaying information</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_exist_HOW/#5-displaying-information","title":"5\ufe0f\u20e3 Displaying Information","text":"<pre><code>status = \"[OK]\" if exists else \"[ERROR]\"\nprint(f\"{status} {symbol}: {'exists' if exists else 'not found'}\")\n</code></pre> <p>Regular application logic is used here:</p> <ul> <li>A human-readable status is formed</li> <li>Symbol name and check result are displayed</li> </ul> <p>This code does not affect the check itself \u2014 it's only for convenience.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_exist_HOW/#summary","title":"Summary","text":"<p>In this example, <code>symbol_exist()</code> is used as a simple way to verify the correctness of symbol names.</p> <p>The method is called for each symbol separately, returns information about its existence, and all result processing logic remains on the calling code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_double_HOW/","title":"symbol info double HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_double_HOW/#symbol_info_double-how-it-works","title":"symbol_info_double \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_double_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example demonstrates how to retrieve a numeric property of a trading symbol using the low-level asynchronous method <code>symbol_info_double()</code>.</p> <p>The method is used to read symbol parameters that are represented in MetaTrader as floating-point numbers: swaps, spreads, price step, minimum distances, and other trading characteristics.</p> <p>Each method call requests one specific numeric property of one symbol.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_double_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_info_double(\n    symbol: str,\n    property: SymbolInfoDoubleProperty,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and must be called with <code>await</code></li> <li><code>symbol</code> \u2014 trading symbol name (e.g., <code>\"GBPUSD\"</code>)</li> <li><code>property</code> specifies which numeric property of the symbol to retrieve</li> <li><code>deadline</code> and <code>cancellation_event</code> control execution time</li> <li>The method returns an object with the numeric property value</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_double_HOW/#code-example-getting-swap-rates-for-a-symbol","title":"\ud83e\udde9 Code Example \u2014 Getting Swap Rates for a Symbol","text":"<pre><code>async def get_swap_info(account: MT5Account, symbol: str):\n    # Get long swap\n    long_swap_data = await account.symbol_info_double(\n        symbol,\n        market_info_pb2.SYMBOL_SWAP_LONG\n    )\n\n    # Get short swap\n    short_swap_data = await account.symbol_info_double(\n        symbol,\n        market_info_pb2.SYMBOL_SWAP_SHORT\n    )\n\n    print(f\"Swap for {symbol}:\")\n    print(f\"  Long: {long_swap_data.value:.2f}\")\n    print(f\"  Short: {short_swap_data.value:.2f}\")\n\n    return {\n        \"long\": long_swap_data.value,\n        \"short\": short_swap_data.value\n    }\n</code></pre> <p>In this example, <code>symbol_info_double()</code> is used to retrieve swap values for long and short positions for one symbol.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_double_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_double_HOW/#1-requesting-numeric-symbol-property","title":"1\ufe0f\u20e3 Requesting Numeric Symbol Property","text":"<pre><code>long_swap_data = await account.symbol_info_double(\n    symbol,\n    market_info_pb2.SYMBOL_SWAP_LONG\n)\n</code></pre> <p>At this step, one asynchronous call is executed.</p> <ul> <li>The symbol name is passed to the method</li> <li>The second argument specifies the type of numeric property</li> <li>A request to the terminal is executed</li> </ul> <p>The result is a response object containing the property value.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_double_HOW/#2-repeated-call-for-another-property","title":"2\ufe0f\u20e3 Repeated Call for Another Property","text":"<pre><code>short_swap_data = await account.symbol_info_double(\n    symbol,\n    market_info_pb2.SYMBOL_SWAP_SHORT\n)\n</code></pre> <p>The method is called again, but with a different <code>property</code> value.</p> <p>Important:</p> <ul> <li>Each call requests exactly one property</li> <li>Values are not cached</li> <li>Each parameter is retrieved with a separate request</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_double_HOW/#3-extracting-numeric-value","title":"3\ufe0f\u20e3 Extracting Numeric Value","text":"<pre><code>long_swap_data.value\nshort_swap_data.value\n</code></pre> <p>The returned object contains a <code>value</code> field.</p> <ul> <li>This field holds the numeric property value</li> <li>The value type is <code>float</code></li> </ul> <p>After extracting <code>.value</code>, you can work with the number as a regular Python value.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_double_HOW/#4-using-retrieved-data","title":"4\ufe0f\u20e3 Using Retrieved Data","text":"<pre><code>return {\n    \"long\": long_swap_data.value,\n    \"short\": short_swap_data.value\n}\n</code></pre> <p>The retrieved values are combined into a dictionary.</p> <p>This is done solely for convenience of the calling code \u2014 the <code>symbol_info_double()</code> method:</p> <ul> <li>Does not combine properties</li> <li>Does not interpret values</li> <li>Does not know how they will be used</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_double_HOW/#summary","title":"Summary","text":"<p>In this example, <code>symbol_info_double()</code> is used as a source of numeric trading symbol parameters.</p> <p>The method is called as many times as properties need to be retrieved, and all processing and data combination logic is performed on the user side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_integer_HOW/","title":"symbol info integer HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_integer_HOW/#symbol_info_integer-how-it-works","title":"symbol_info_integer \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_integer_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example demonstrates how to retrieve integer properties of a trading symbol using the low-level asynchronous method <code>symbol_info_integer()</code>.</p> <p>The method is used to read symbol parameters that are represented in MetaTrader as integers: number of decimal places, spread, trading modes, and other numeric characteristics.</p> <p>Each method call requests one specific integer property of one symbol.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_integer_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_info_integer(\n    symbol: str,\n    property: SymbolInfoIntegerProperty,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and must be called with <code>await</code></li> <li><code>symbol</code> \u2014 trading symbol name (e.g., <code>\"EURUSD\"</code>)</li> <li><code>property</code> specifies which integer property of the symbol to retrieve</li> <li><code>deadline</code> and <code>cancellation_event</code> control execution time</li> <li>The method returns an object with the integer property value</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_integer_HOW/#code-example-getting-digits-and-spread","title":"\ud83e\udde9 Code Example \u2014 Getting Digits and Spread","text":"<pre><code># Get digits (decimal places)\nresult = await account.symbol_info_integer(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_DIGITS\n)\nprint(f\"Digits: {result.value}\")\n\n# Get spread in points\nspread_result = await account.symbol_info_integer(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_SPREAD\n)\nprint(f\"Spread: {spread_result.value} points\")\n</code></pre> <p>In this example, <code>symbol_info_integer()</code> is used to retrieve parameters that directly affect price calculations and symbol trading conditions.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_integer_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_integer_HOW/#1-requesting-number-of-decimal-places","title":"1\ufe0f\u20e3 Requesting Number of Decimal Places","text":"<pre><code>result = await account.symbol_info_integer(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_DIGITS\n)\n</code></pre> <p>At this step, one asynchronous call is executed.</p> <ul> <li>The symbol name is passed to the method</li> <li>The second argument specifies the integer property type (<code>SYMBOL_DIGITS</code>)</li> <li>The terminal returns a response object with the result</li> </ul> <p>The numeric value itself is located in the <code>result.value</code> field.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_integer_HOW/#2-using-retrieved-value","title":"2\ufe0f\u20e3 Using Retrieved Value","text":"<pre><code>print(f\"Digits: {result.value}\")\n</code></pre> <ul> <li><code>result.value</code> \u2014 number of decimal places</li> <li>Value type \u2014 <code>int</code></li> <li>The value can be used directly in price calculations</li> </ul> <p>No additional API calls occur at this stage.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_integer_HOW/#3-requesting-spread","title":"3\ufe0f\u20e3 Requesting Spread","text":"<pre><code>spread_result = await account.symbol_info_integer(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_SPREAD\n)\n</code></pre> <p>The method is called again for the same symbol, but with a different property.</p> <p>Important:</p> <ul> <li>Each call retrieves exactly one property</li> <li>Values are not cached automatically</li> <li>Each property is requested with a separate call</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_integer_HOW/#4-working-with-spread-value","title":"4\ufe0f\u20e3 Working with Spread Value","text":"<pre><code>print(f\"Spread: {spread_result.value} points\")\n</code></pre> <ul> <li><code>spread_result.value</code> \u2014 spread in points</li> <li>The value is an integer</li> <li>Used directly, without conversions</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_integer_HOW/#summary","title":"Summary","text":"<p>In this example, <code>symbol_info_integer()</code> is used as a source of integer trading symbol parameters.</p> <p>The method is called separately for each required property, and all logic for using retrieved values remains on the calling code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_margin_rate_HOW/","title":"symbol info margin rate HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_margin_rate_HOW/#symbol_info_margin_rate-how-it-works","title":"symbol_info_margin_rate \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_margin_rate_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example demonstrates how to retrieve margin requirements for a trading symbol depending on trade direction using the low-level asynchronous method <code>symbol_info_margin_rate()</code>.</p> <p>Unlike symbol parameters that don't depend on direction (digits, spread, swap, etc.), margin requirements can differ for BUY and SELL.</p> <p>The method is used when you need to understand:</p> <ul> <li>How much margin is required to open a position</li> <li>Whether conditions are the same for buying and selling</li> <li>How account type or instrument affects margin calculations</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_margin_rate_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_info_margin_rate(\n    symbol: str,\n    order_type: ENUM_ORDER_TYPE,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and must be called with <code>await</code></li> <li><code>symbol</code> \u2014 trading symbol name (e.g., <code>\"XAUUSD\"</code>)</li> <li><code>order_type</code> specifies trade direction (<code>BUY</code>, <code>SELL</code>, etc.)</li> <li><code>deadline</code> and <code>cancellation_event</code> control execution time</li> <li>The method returns an object with margin coefficients</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_margin_rate_HOW/#code-example-comparing-margin-for-buy-and-sell","title":"\ud83e\udde9 Code Example \u2014 Comparing Margin for BUY and SELL","text":"<pre><code># Get BUY margin rates\nbuy_rates = await account.symbol_info_margin_rate(\n    symbol=\"XAUUSD\",\n    order_type=market_info_pb2.ORDER_TYPE_BUY\n)\n\n# Get SELL margin rates\nsell_rates = await account.symbol_info_margin_rate(\n    symbol=\"XAUUSD\",\n    order_type=market_info_pb2.ORDER_TYPE_SELL\n)\n\nprint(f\"XAUUSD Margin Rates:\")\nprint(f\"  BUY  - Initial: {buy_rates.initial_margin_rate}, Maintenance: {buy_rates.maintenance_margin_rate}\")\nprint(f\"  SELL - Initial: {sell_rates.initial_margin_rate}, Maintenance: {sell_rates.maintenance_margin_rate}\")\n\nif buy_rates.initial_margin_rate == sell_rates.initial_margin_rate:\n    print(\"  Same margin rates for both directions (hedge account)\")\nelse:\n    print(\"  Different margin rates (check account type)\")\n</code></pre> <p>In this example, the method is called twice for the same symbol but with different trade directions.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_margin_rate_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_margin_rate_HOW/#1-requesting-margin-parameters-for-buy","title":"1\ufe0f\u20e3 Requesting Margin Parameters for BUY","text":"<pre><code>buy_rates = await account.symbol_info_margin_rate(\n    symbol=\"XAUUSD\",\n    order_type=market_info_pb2.ORDER_TYPE_BUY\n)\n</code></pre> <p>At this step:</p> <ul> <li>One asynchronous call is executed</li> <li>Symbol name and BUY order type are passed to the terminal</li> <li>An object with margin parameters for buying is returned</li> </ul> <p>The returned object contains coefficients that the terminal uses when calculating margin for a BUY position.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_margin_rate_HOW/#2-requesting-margin-parameters-for-sell","title":"2\ufe0f\u20e3 Requesting Margin Parameters for SELL","text":"<pre><code>sell_rates = await account.symbol_info_margin_rate(\n    symbol=\"XAUUSD\",\n    order_type=market_info_pb2.ORDER_TYPE_SELL\n)\n</code></pre> <p>The method is called again:</p> <ul> <li>Same symbol</li> <li>Same method</li> <li>Different trade direction</li> </ul> <p>The result is a second object with margin parameters \u2014 now for a SELL position.</p> <p>Each call:</p> <ul> <li>Is independent</li> <li>Is executed with a separate request</li> <li>Returns data only for the specified direction</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_margin_rate_HOW/#3-working-with-retrieved-data","title":"3\ufe0f\u20e3 Working with Retrieved Data","text":"<pre><code>buy_rates.initial_margin_rate\nbuy_rates.maintenance_margin_rate\n</code></pre> <p>Both objects (<code>buy_rates</code> and <code>sell_rates</code>) contain the same fields:</p> <ul> <li><code>initial_margin_rate</code> \u2014 initial margin coefficient</li> <li><code>maintenance_margin_rate</code> \u2014 maintenance margin coefficient</li> </ul> <p>These are numeric values that can be:</p> <ul> <li>Compared</li> <li>Logged</li> <li>Used in your own calculations</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_margin_rate_HOW/#4-comparing-margin-requirements","title":"4\ufe0f\u20e3 Comparing Margin Requirements","text":"<pre><code>if buy_rates.initial_margin_rate == sell_rates.initial_margin_rate:\n</code></pre> <p>Application logic begins.</p> <p>In the example, the initial margin for BUY and SELL is compared:</p> <ul> <li>If values are equal \u2014 margin conditions are symmetric</li> <li>If they differ \u2014 requirements depend on trade direction</li> </ul> <p>This comparison is not part of the API \u2014 it's a user code decision.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_margin_rate_HOW/#5-interpreting-results","title":"5\ufe0f\u20e3 Interpreting Results","text":"<pre><code>print(\"Same margin rates for both directions (hedge account)\")\n</code></pre> <p>When values match, you can usually conclude that:</p> <ul> <li>The account operates in hedge mode</li> <li>Margin requirements are the same for BUY and SELL</li> </ul> <pre><code>print(\"Different margin rates (check account type)\")\n</code></pre> <p>If values differ:</p> <ul> <li>Margin depends on position direction</li> <li>This may be related to account type or instrument</li> </ul> <p>The code makes no assumptions, only records the fact of difference.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_margin_rate_HOW/#summary","title":"Summary","text":"<p>In this example, <code>symbol_info_margin_rate()</code> is used to retrieve and compare margin requirements for one symbol across different trade directions.</p> <p>The method returns margin coefficients for the specified symbol and order type, and all analysis and interpretation logic remains on the calling code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_quote_HOW/","title":"symbol info session quote HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_quote_HOW/#symbol_info_session_quote-how-it-works","title":"symbol_info_session_quote \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_quote_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example demonstrates how to retrieve quote sessions for a trading symbol using the low-level asynchronous method <code>symbol_info_session_quote()</code>.</p> <p>The method is used to determine at what hours the terminal publishes quotes for a specific symbol on a particular day of the week.</p> <p>Important:</p> <ul> <li>This concerns quotes, not trading availability</li> <li>Sessions may differ by day of the week</li> <li>A single day can have multiple sessions</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_quote_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_info_session_quote(\n    symbol: str,\n    day_of_week: DayOfWeek,\n    session_index: int,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and must be called with <code>await</code></li> <li><code>symbol</code> \u2014 trading symbol name (e.g., <code>\"EURUSD\"</code>)</li> <li><code>day_of_week</code> \u2014 specific day of the week</li> <li><code>session_index</code> \u2014 session index within the day (numbering starts from <code>0</code>)</li> <li>The method returns an object with session start and end time</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_quote_HOW/#code-example-getting-all-weekly-quote-sessions","title":"\ud83e\udde9 Code Example \u2014 Getting All Weekly Quote Sessions","text":"<pre><code>days = {\n    market_info_pb2.SUNDAY: \"Sunday\",\n    market_info_pb2.MONDAY: \"Monday\",\n    market_info_pb2.TUESDAY: \"Tuesday\",\n    market_info_pb2.WEDNESDAY: \"Wednesday\",\n    market_info_pb2.THURSDAY: \"Thursday\",\n    market_info_pb2.FRIDAY: \"Friday\",\n    market_info_pb2.SATURDAY: \"Saturday\"\n}\n\nprint(\"EURUSD Quote Sessions:\")\nfor day_enum, day_name in days.items():\n    try:\n        session = await account.symbol_info_session_quote(\n            symbol=\"EURUSD\",\n            day_of_week=day_enum,\n            session_index=0\n        )\n\n        from_hours = session.from.seconds // 3600\n        from_mins = (session.from.seconds % 3600) // 60\n        to_hours = session.to.seconds // 3600\n        to_mins = (session.to.seconds % 3600) // 60\n\n        print(f\"  {day_name:10s} {from_hours:02d}:{from_mins:02d} - {to_hours:02d}:{to_mins:02d}\")\n    except Exception:\n        print(f\"  {day_name:10s} No session\")\n</code></pre> <p>In this example, the first quote session (<code>session_index = 0</code>) is requested for each day of the week.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_quote_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_quote_HOW/#1-iterating-through-days-of-the-week","title":"1\ufe0f\u20e3 Iterating Through Days of the Week","text":"<pre><code>for day_enum, day_name in days.items():\n</code></pre> <p>The code sequentially iterates through all days of the week.</p> <ul> <li><code>day_enum</code> is used when calling the API</li> <li><code>day_name</code> is used only for formatted output</li> </ul> <p>Each day is processed independently.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_quote_HOW/#2-requesting-quote-session","title":"2\ufe0f\u20e3 Requesting Quote Session","text":"<pre><code>session = await account.symbol_info_session_quote(\n    symbol=\"EURUSD\",\n    day_of_week=day_enum,\n    session_index=0\n)\n</code></pre> <p>At this step, one asynchronous call is executed.</p> <p>The method answers the question:</p> <p>Is there a quote session with index 0 for this symbol on this day?</p> <p>If the session exists:</p> <ul> <li>An object with start and end time is returned</li> </ul> <p>If there is no session:</p> <ul> <li>The server returns an error</li> <li>Control passes to <code>except</code></li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_quote_HOW/#3-session-time-format","title":"3\ufe0f\u20e3 Session Time Format","text":"<pre><code>from_hours = session.from.seconds // 3600\nfrom_mins = (session.from.seconds % 3600) // 60\n</code></pre> <p>Session start and end time is returned as number of seconds from the beginning of the day.</p> <p>Conversion to <code>HH:MM</code> format is performed entirely on the user code side.</p> <p>The API returns only raw time values.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_quote_HOW/#4-displaying-session-information","title":"4\ufe0f\u20e3 Displaying Session Information","text":"<pre><code>print(f\"  {day_name:10s} {from_hours:02d}:{from_mins:02d} - {to_hours:02d}:{to_mins:02d}\")\n</code></pre> <p>If the session exists:</p> <ul> <li>Day of the week is displayed</li> <li>Quote interval is displayed</li> </ul> <p>This is purely a visual representation of data.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_quote_HOW/#5-handling-missing-session","title":"5\ufe0f\u20e3 Handling Missing Session","text":"<pre><code>except Exception:\n    print(f\"  {day_name:10s} No session\")\n</code></pre> <p>If there is no quote session with index <code>0</code> for the given day:</p> <ul> <li>The exception is caught</li> <li>Message <code>No session</code> is displayed</li> </ul> <p>Absence of a session is treated as a normal situation.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_quote_HOW/#summary","title":"Summary","text":"<p>In this example, <code>symbol_info_session_quote()</code> is used to retrieve information about quote sessions for a trading symbol.</p> <p>The method returns start and end time for one session for the specified day of the week and index, and all logic for iterating through days, formatting time, and handling missing sessions remains on the user code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_trade_HOW/","title":"symbol info session trade HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_trade_HOW/#symbol_info_session_trade-how-it-works","title":"symbol_info_session_trade \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_trade_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to determine whether trading is allowed for a symbol at the current moment using the low-level asynchronous method <code>symbol_info_session_trade()</code>.</p> <p>Unlike quote sessions, trading sessions answer a different question:</p> <p>Can you open and close trades for this symbol right now?</p> <p>This is a typical safety check used before sending orders.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_trade_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_info_session_trade(\n    symbol: str,\n    day_of_week: DayOfWeek,\n    session_index: int,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and called with <code>await</code></li> <li><code>symbol</code> \u2014 trading symbol name</li> <li><code>day_of_week</code> \u2014 day of week for which to check the trading session</li> <li><code>session_index</code> \u2014 trading session index within the day (numbered from <code>0</code>)</li> <li>The method returns an object with trading session start and end times</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_trade_HOW/#code-example-checking-if-trading-is-allowed-now","title":"\ud83e\udde9 Code Example \u2014 Checking if trading is allowed now","text":"<pre><code>async def is_trading_allowed(account, symbol: str) -&gt; bool:\n    now = datetime.utcnow()\n\n    day_of_week = now.weekday() + 1\n    if day_of_week == 7:  # Sunday\n        day_of_week = 0\n\n    try:\n        session = await account.symbol_info_session_trade(\n            symbol=symbol,\n            day_of_week=day_of_week,\n            session_index=0\n        )\n\n        current_seconds = now.hour * 3600 + now.minute * 60 + now.second\n\n        if session.from.seconds &lt;= current_seconds &lt;= session.to.seconds:\n            return True\n        return False\n    except Exception:\n        return False\n</code></pre> <p>In this example, the method is used to check a single trading session at the current moment.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_trade_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_trade_HOW/#1-determining-current-day-of-week","title":"1\ufe0f\u20e3 Determining Current Day of Week","text":"<pre><code>now = datetime.utcnow()\nday_of_week = now.weekday() + 1\nif day_of_week == 7:\n    day_of_week = 0\n</code></pre> <p>Here, data is prepared for the API call.</p> <ul> <li><code>datetime.weekday()</code> returns a number from <code>0</code> (Monday) to <code>6</code> (Sunday)</li> <li> <p>The <code>DayOfWeek</code> enum in MT5 uses:</p> </li> <li> <p><code>0</code> \u2014 Sunday</p> </li> <li><code>1</code> \u2014 Monday</li> <li>\u2026</li> </ul> <p>The code converts the value to the format expected by the <code>symbol_info_session_trade()</code> method.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_trade_HOW/#2-requesting-trading-session","title":"2\ufe0f\u20e3 Requesting Trading Session","text":"<pre><code>session = await account.symbol_info_session_trade(\n    symbol=symbol,\n    day_of_week=day_of_week,\n    session_index=0\n)\n</code></pre> <p>At this step, one asynchronous call is performed.</p> <p>The method answers the question:</p> <p>Is there a trading session with index 0 for this symbol on this day?</p> <p>If the session exists:</p> <ul> <li>an object with trading start and end times is returned</li> </ul> <p>If the session does not exist:</p> <ul> <li>the server returns an error</li> <li>control passes to the <code>except</code> block</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_trade_HOW/#3-converting-current-time-to-api-format","title":"3\ufe0f\u20e3 Converting Current Time to API Format","text":"<pre><code>current_seconds = now.hour * 3600 + now.minute * 60 + now.second\n</code></pre> <p>Trading session time is returned as number of seconds from the beginning of the day.</p> <p>To correctly compare current time with session boundaries, it is converted to the same format.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_trade_HOW/#4-checking-time-interval-match","title":"4\ufe0f\u20e3 Checking Time Interval Match","text":"<pre><code>if session.from.seconds &lt;= current_seconds &lt;= session.to.seconds:\n    return True\n</code></pre> <p>This is the key check in the example.</p> <ul> <li>if current time is within the trading session</li> <li>trading is considered allowed</li> </ul> <p>If current time falls outside the interval \u2014 trading is closed.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_trade_HOW/#5-handling-absence-of-trading-session","title":"5\ufe0f\u20e3 Handling Absence of Trading Session","text":"<pre><code>except Exception:\n    return False\n</code></pre> <p>If:</p> <ul> <li>the trading session does not exist</li> <li>the day is non-trading</li> <li>the session index is absent</li> </ul> <p>The function returns <code>False</code>.</p> <p>The absence of a trading session is treated as a normal situation.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_session_trade_HOW/#summary","title":"Summary","text":"<p>In this example, <code>symbol_info_session_trade()</code> is used to check whether trading is allowed for the symbol at the current moment.</p> <p>The method returns the time boundaries of a single trading session, while all logic for determining current time, comparison, and result interpretation is performed on the user code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_string_HOW/","title":"symbol info string HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_string_HOW/#symbol_info_string-how-it-works-symbol_path","title":"symbol_info_string \u2014 How it works (SYMBOL_PATH)","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_string_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level asynchronous method <code>symbol_info_string()</code> to retrieve a string property of a symbol and parse it at the application code level.</p> <p>The example uses the <code>SYMBOL_PATH</code> property, which describes the symbol's location in the MetaTrader terminal's Market Watch hierarchy.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_string_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_info_string(\n    symbol: str,\n    property: SymbolInfoStringProperty,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and called with <code>await</code></li> <li><code>symbol</code> \u2014 trading symbol name</li> <li><code>property</code> specifies which string property of the symbol to retrieve</li> <li>The method returns an object containing the string property value</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_string_HOW/#code-example-retrieving-and-parsing-symbol-path","title":"\ud83e\udde9 Code Example \u2014 Retrieving and parsing symbol path","text":"<pre><code>result = await account.symbol_info_string(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_PATH\n)\n\npath = result.value\nfolders = path.split(\"\\\\\")\n\nprint(f\"Symbol Path: {path}\")\nprint(f\"Hierarchy: {' &gt; '.join(folders)}\")\n</code></pre> <p>In this example, the <code>symbol_info_string()</code> method is used to retrieve the symbol path, after which the string is parsed into separate levels.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_string_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_string_HOW/#1-requesting-symbol-string-property","title":"1\ufe0f\u20e3 Requesting Symbol String Property","text":"<pre><code>result = await account.symbol_info_string(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_PATH\n)\n</code></pre> <p>At this step:</p> <ul> <li>one asynchronous call is performed</li> <li>the symbol name and string property type are passed to the terminal</li> <li>a response object is returned</li> </ul> <p>The method itself does not interpret the value \u2014 it only returns the string associated with the symbol.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_string_HOW/#2-extracting-value","title":"2\ufe0f\u20e3 Extracting Value","text":"<pre><code>path = result.value\n</code></pre> <p>Here:</p> <ul> <li><code>result.value</code> \u2014 regular Python string</li> <li>example value:</li> </ul> <pre><code>Forex\\\\Majors\\\\EURUSD\n</code></pre> <p>After this line, the API work is complete, only the local value is used further.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_string_HOW/#3-parsing-string-into-levels","title":"3\ufe0f\u20e3 Parsing String into Levels","text":"<pre><code>folders = path.split(\"\\\\\")\n</code></pre> <p>The level separator is the <code>\\\\</code> character.</p> <p>The result is a list of strings:</p> <pre><code>[\"Forex\", \"Majors\", \"EURUSD\"]\n</code></pre> <p>String parsing is performed entirely on the user code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_string_HOW/#4-human-readable-representation","title":"4\ufe0f\u20e3 Human-Readable Representation","text":"<pre><code>print(f\"Hierarchy: {' &gt; '.join(folders)}\")\n</code></pre> <p>This step is not related to the API.</p> <p>It is only needed for:</p> <ul> <li>visual display of hierarchy</li> <li>debugging</li> <li>interface output</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_string_HOW/#what-symbol_path-means","title":"What SYMBOL_PATH Means","text":"<p><code>SYMBOL_PATH</code> is a string description of where the symbol is located in the Market Watch tree of the MetaTrader terminal.</p> <p>The last element of the path always corresponds to the symbol itself, while all previous elements are the groups in which it is displayed.</p> <p>For example:</p> <pre><code>Forex\\\\Majors\\\\EURUSD\n</code></pre> <p>means:</p> <p>the symbol <code>EURUSD</code> is located in the <code>Majors</code> group, which is in the <code>Forex</code> group</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_string_HOW/#important-note","title":"Important Note","text":"<p>The <code>SYMBOL_PATH</code> structure:</p> <ul> <li>is not standardized</li> <li>may differ between brokers</li> <li>may have different depth</li> </ul> <p>Therefore, the path should be considered as descriptive metadata, not as a strict format.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_string_HOW/#summary","title":"Summary","text":"<p>In this example, <code>symbol_info_string()</code> is used to retrieve a string property of a symbol and parse it in application code.</p> <p>The method returns the string without interpretation, while all logic for analyzing and using the value is entirely on the user side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_tick_HOW/","title":"symbol info tick HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_tick_HOW/#symbol_info_tick-how-it-works","title":"symbol_info_tick \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_tick_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level asynchronous method <code>symbol_info_tick()</code> to retrieve the current tick for a symbol and perform custom validation of market data before trading.</p> <p>A tick is the latest available market information (Bid, Ask, time, etc.). By itself, it does not guarantee that the data is suitable for trading, so the example immediately demonstrates how this data is validated on the user side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_tick_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_info_tick(\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and called with <code>await</code></li> <li><code>symbol</code> \u2014 trading symbol name</li> <li>The method returns an object with the last known tick</li> <li>The method does not perform data correctness checks</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_tick_HOW/#code-example-tick-validation-before-trading","title":"\ud83e\udde9 Code Example \u2014 Tick validation before trading","text":"<pre><code>async def validate_tick(account, symbol: str) -&gt; bool:\n    try:\n        tick = await account.symbol_info_tick(symbol)\n\n        if tick.bid &lt;= 0 or tick.ask &lt;= 0:\n            print(f\"Invalid prices: bid={tick.bid}, ask={tick.ask}\")\n            return False\n\n        spread = tick.ask - tick.bid\n        if spread &lt;= 0:\n            print(f\"Invalid spread: {spread}\")\n            return False\n\n        if tick.time &gt; 0:\n            current_time = datetime.now(timezone.utc).timestamp()\n            age = current_time - tick.time\n\n            if age &gt; 10:\n                print(f\"Tick too old: {age} seconds\")\n                return False\n\n        print(\"Tick validation passed\")\n        return True\n\n    except Exception as e:\n        print(f\"Validation error: {e}\")\n        return False\n</code></pre> <p>This example demonstrates a typical safety check that is performed before sending trading operations.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_tick_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_tick_HOW/#1-retrieving-last-tick","title":"1\ufe0f\u20e3 Retrieving Last Tick","text":"<pre><code>tick = await account.symbol_info_tick(symbol)\n</code></pre> <p>At this step:</p> <ul> <li>one asynchronous call is performed</li> <li>the terminal returns the last known tick for the symbol</li> <li>the <code>tick</code> object contains prices and time</li> </ul> <p>The method returns data \"as is\", without interpretation.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_tick_HOW/#2-checking-bid-and-ask-prices","title":"2\ufe0f\u20e3 Checking Bid and Ask Prices","text":"<pre><code>if tick.bid &lt;= 0 or tick.ask &lt;= 0:\n</code></pre> <p>The presence of valid prices is checked:</p> <ul> <li>values <code>&lt;= 0</code> indicate absence of valid quotes</li> <li>such data cannot be used for trading</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_tick_HOW/#3-checking-spread","title":"3\ufe0f\u20e3 Checking Spread","text":"<pre><code>spread = tick.ask - tick.bid\nif spread &lt;= 0:\n</code></pre> <p>Here, the logical correctness of prices is checked:</p> <ul> <li>Ask must be greater than Bid</li> <li>spread must be positive</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_tick_HOW/#4-checking-tick-freshness","title":"4\ufe0f\u20e3 Checking Tick Freshness","text":"<pre><code>if tick.time &gt; 0:\n    current_time = datetime.now(timezone.utc).timestamp()\n    age = current_time - tick.time\n</code></pre> <p>Tick time is compared with current time:</p> <ul> <li><code>tick.time</code> \u2014 Unix timestamp</li> <li>tick age is calculated in seconds</li> </ul> <pre><code>if age &gt; 10:\n</code></pre> <p>The example uses a custom rule:</p> <ul> <li>a tick older than 10 seconds is considered unsuitable for trading</li> </ul> <p>This is not an API rule, but a decision of the application code.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_tick_HOW/#5-successful-validation","title":"5\ufe0f\u20e3 Successful Validation","text":"<pre><code>print(\"Tick validation passed\")\nreturn True\n</code></pre> <p>If all checks pass, the tick is considered valid.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_tick_HOW/#6-error-handling","title":"6\ufe0f\u20e3 Error Handling","text":"<pre><code>except Exception:\n    return False\n</code></pre> <p>Any error when retrieving or checking the tick leads to trading prohibition.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_tick_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>symbol_info_tick()</code>:</p> <ul> <li>returns the last tick</li> <li>does not check its correctness</li> <li>does not assess data freshness</li> </ul> <p><code>validate_tick()</code>:</p> <ul> <li>checks prices</li> <li>checks spread</li> <li>checks tick age</li> <li>makes the decision whether trading is allowed</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_info_tick_HOW/#summary","title":"Summary","text":"<p>This example illustrates the basic pattern of working with low-level API:</p> <p>low-level data \u2192 custom validation \u2192 trading decision</p> <p>The <code>symbol_info_tick()</code> method provides raw market data, while all logic for their interpretation and validation remains on the user side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_is_synchronized_HOW/","title":"symbol is synchronized HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_is_synchronized_HOW/#symbol_is_synchronized-how-it-works","title":"symbol_is_synchronized \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_is_synchronized_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level asynchronous method <code>symbol_is_synchronized()</code> to determine whether a symbol is ready for use, and how to implement waiting for symbol synchronization with the server based on it.</p> <p>Symbol synchronization means that:</p> <ul> <li>the terminal has loaded data for the instrument</li> <li>the symbol is available for retrieving quotes, sessions, and ticks</li> </ul> <p>Before synchronization is complete, many market methods may return empty or incorrect data.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_is_synchronized_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_is_synchronized(\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and called with <code>await</code></li> <li><code>symbol</code> \u2014 trading symbol name</li> <li>The method returns an object with synchronization flag</li> <li>The method does not initiate synchronization, it only reports the current state</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_is_synchronized_HOW/#code-example-waiting-for-symbol-synchronization","title":"\ud83e\udde9 Code Example \u2014 Waiting for symbol synchronization","text":"<pre><code>async def ensure_symbol_synchronized(account, symbol: str, max_retries: int = 5) -&gt; bool:\n    result = await account.symbol_is_synchronized(symbol)\n    if result.synchronized:\n        print(f\"{symbol} already synchronized\")\n        return True\n\n    print(f\"Selecting {symbol}...\")\n    await account.symbol_select(symbol, True)\n\n    for attempt in range(max_retries):\n        await asyncio.sleep(0.5 * (attempt + 1))\n\n        result = await account.symbol_is_synchronized(symbol)\n        if result.synchronized:\n            print(f\"{symbol} synchronized after {attempt + 1} attempt(s)\")\n            return True\n\n        print(f\"Attempt {attempt + 1}/{max_retries}: still waiting...\")\n\n    print(f\"Failed to synchronize {symbol} after {max_retries} attempts\")\n    return False\n</code></pre> <p>This example demonstrates a typical pattern: check \u2192 initiate \u2192 wait \u2192 recheck.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_is_synchronized_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_is_synchronized_HOW/#1-checking-current-synchronization-state","title":"1\ufe0f\u20e3 Checking Current Synchronization State","text":"<pre><code>result = await account.symbol_is_synchronized(symbol)\n</code></pre> <p>At this step:</p> <ul> <li>one asynchronous call is performed</li> <li>the server reports whether the symbol is synchronized</li> <li>the result is available in the <code>result.synchronized</code> field</li> </ul> <p>If the value is <code>True</code>, no additional work is required.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_is_synchronized_HOW/#2-selecting-symbol-in-terminal","title":"2\ufe0f\u20e3 Selecting Symbol in Terminal","text":"<pre><code>await account.symbol_select(symbol, True)\n</code></pre> <p>If the symbol is not yet synchronized:</p> <ul> <li>it is forcibly selected (added) to Market Watch</li> <li>this starts the data loading process for the symbol</li> </ul> <p>Important: synchronization does not happen instantly.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_is_synchronized_HOW/#3-repeated-checks-with-waiting","title":"3\ufe0f\u20e3 Repeated Checks with Waiting","text":"<pre><code>for attempt in range(max_retries):\n    await asyncio.sleep(0.5 * (attempt + 1))\n</code></pre> <p>Waiting with increasing delay is implemented:</p> <ul> <li>first attempt \u2014 after 0.5 seconds</li> <li>delay gradually increases thereafter</li> </ul> <p>This allows the server to complete data loading.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_is_synchronized_HOW/#4-checking-result-after-waiting","title":"4\ufe0f\u20e3 Checking Result After Waiting","text":"<pre><code>result = await account.symbol_is_synchronized(symbol)\nif result.synchronized:\n</code></pre> <p>After each pause:</p> <ul> <li>a recheck is performed</li> <li>if synchronization is complete, the function returns <code>True</code></li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_is_synchronized_HOW/#5-handling-failed-synchronization","title":"5\ufe0f\u20e3 Handling Failed Synchronization","text":"<pre><code>print(f\"Failed to synchronize {symbol} after {max_retries} attempts\")\nreturn False\n</code></pre> <p>If after all attempts the symbol is not synchronized:</p> <ul> <li>it is considered unavailable</li> <li>no further work with it is performed</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_is_synchronized_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>symbol_is_synchronized()</code>:</p> <ul> <li>reports the current synchronization state of the symbol</li> <li>does not initiate data loading</li> <li>does not wait for synchronization to complete</li> </ul> <p><code>ensure_symbol_synchronized()</code>:</p> <ul> <li>decides what to do when synchronization is absent</li> <li>initiates symbol selection</li> <li>implements waiting and retries</li> <li>makes the final decision</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_is_synchronized_HOW/#summary","title":"Summary","text":"<p>This example illustrates a typical pattern of working with states in low-level API:</p> <p>check state \u2192 initiate action \u2192 recheck \u2192 decision</p> <p>The <code>symbol_is_synchronized()</code> method provides only information about the current state, while all logic for waiting and managing the synchronization process is implemented on the user code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_name_HOW/","title":"symbol name HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_name_HOW/#symbol_name-how-it-works","title":"symbol_name \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_name_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to retrieve trading symbol names by index using the low-level asynchronous method <code>symbol_name()</code> and how to safely build a list of symbols with error handling based on it.</p> <p>The <code>symbol_name()</code> method itself is very simple \u2014 it returns the symbol name by a given index. However, in practice, it is almost always used in pair with <code>symbols_total()</code> and inside a loop.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_name_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_name(\n    index: int,\n    selected: bool,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and called with <code>await</code></li> <li><code>index</code> \u2014 symbol index (numbering starts from <code>0</code>)</li> <li> <p><code>selected</code> determines where the symbol list is taken from:</p> </li> <li> <p><code>True</code> \u2014 only symbols from Market Watch</p> </li> <li><code>False</code> \u2014 all available symbols</li> <li>The method returns an object with the symbol name</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_name_HOW/#code-example-safe-retrieval-of-symbol-list","title":"\ud83e\udde9 Code Example \u2014 Safe retrieval of symbol list","text":"<pre><code>async def get_symbols_safe(account, selected_only: bool = True) -&gt; list[str]:\n    symbols = []\n\n    try:\n        count_data = await account.symbols_total(selected_only=selected_only)\n        total = count_data.total\n\n        for i in range(total):\n            try:\n                symbol_data = await account.symbol_name(index=i, selected=selected_only)\n                symbols.append(symbol_data.name)\n            except Exception as e:\n                print(f\"Error getting symbol at index {i}: {e}\")\n                continue\n\n        print(f\"Successfully retrieved {len(symbols)} out of {total} symbols\")\n\n    except Exception as e:\n        print(f\"Error getting symbol count: {e}\")\n\n    return symbols\n</code></pre> <p>This example demonstrates an error-resistant way to iterate through the symbol list.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_name_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_name_HOW/#1-getting-symbol-count","title":"1\ufe0f\u20e3 Getting Symbol Count","text":"<pre><code>count_data = await account.symbols_total(selected_only=selected_only)\ntotal = count_data.total\n</code></pre> <p>At this step:</p> <ul> <li>a separate low-level call is performed</li> <li>the server returns the total number of symbols</li> <li>this value is used as the loop boundary</li> </ul> <p>Without this step, it is impossible to correctly use <code>symbol_name()</code>.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_name_HOW/#2-iterating-through-indices","title":"2\ufe0f\u20e3 Iterating Through Indices","text":"<pre><code>for i in range(total):\n</code></pre> <p>The code iterates through all possible indices:</p> <ul> <li>each index corresponds to one symbol</li> <li>the order is determined by the server</li> </ul> <p>Indices are not stable identifiers for symbols.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_name_HOW/#3-getting-symbol-name-by-index","title":"3\ufe0f\u20e3 Getting Symbol Name by Index","text":"<pre><code>symbol_data = await account.symbol_name(index=i, selected=selected_only)\n</code></pre> <p>At this step:</p> <ul> <li>one asynchronous call is performed</li> <li>the server returns the symbol name for the given index</li> <li>the name is available in the <code>symbol_data.name</code> field</li> </ul> <p>The method does not return any additional information about the symbol.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_name_HOW/#4-local-error-handling","title":"4\ufe0f\u20e3 Local Error Handling","text":"<pre><code>except Exception as e:\n    print(f\"Error getting symbol at index {i}: {e}\")\n    continue\n</code></pre> <p>Here, important protective logic is implemented:</p> <ul> <li>an error retrieving one symbol does not interrupt the entire process</li> <li>the problematic index is simply skipped</li> <li>the loop continues</li> </ul> <p>This is especially important when working with large symbol lists.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_name_HOW/#5-handling-symbol-count-error","title":"5\ufe0f\u20e3 Handling Symbol Count Error","text":"<pre><code>except Exception as e:\n    print(f\"Error getting symbol count: {e}\")\n</code></pre> <p>If the total number of symbols could not be retrieved:</p> <ul> <li>further iteration is impossible</li> <li>the function returns an empty list</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_name_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>symbol_name()</code>:</p> <ul> <li>returns the symbol name by index</li> <li>does not know the total number of symbols</li> <li>does not manage list iteration</li> <li>does not handle iteration errors</li> </ul> <p><code>get_symbols_safe()</code>:</p> <ul> <li>retrieves the number of symbols</li> <li>manages the loop</li> <li>handles errors</li> <li>forms the final list</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_name_HOW/#summary","title":"Summary","text":"<p>This example illustrates the standard pattern of working with index-based low-level methods:</p> <p>get size \u2192 iterate \u2192 handle errors \u2192 collect result</p> <p>The <code>symbol_name()</code> method provides minimal data access, while all iteration and resilience logic is implemented on the user code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_params_many_HOW/","title":"symbol params many HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_params_many_HOW/#symbol_params_many-how-it-works","title":"symbol_params_many \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_params_many_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level asynchronous method <code>symbol_params_many()</code> to retrieve parameters for all symbols using pagination loading.</p> <p>The <code>symbol_params_many()</code> method is designed for batch retrieval of information for multiple symbols at once. Since the number of symbols can be large, the API uses pagination.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_params_many_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_params_many(\n    request: SymbolParamsManyRequest,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and called with <code>await</code></li> <li>Request parameters are passed through a <code>SymbolParamsManyRequest</code> object</li> <li>Pagination settings are specified in the request</li> <li>The method returns one page of data per call</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_params_many_HOW/#code-example-iterating-through-all-pages","title":"\ud83e\udde9 Code Example \u2014 Iterating through all pages","text":"<pre><code>async def get_all_symbols(account):\n    all_symbols = []\n    page_number = 0\n    items_per_page = 100\n\n    while True:\n        request = account_helper_pb2.SymbolParamsManyRequest()\n        request.page_number = page_number\n        request.items_per_page = items_per_page\n\n        data = await account.symbol_params_many(request)\n\n        all_symbols.extend(data.symbol_infos)\n        print(f\"Page {page_number}: Retrieved {len(data.symbol_infos)} symbols\")\n\n        if len(all_symbols) &gt;= data.symbols_total:\n            break\n\n        if len(data.symbol_infos) == 0:\n            break\n\n        page_number += 1\n\n    print(f\"Total symbols retrieved: {len(all_symbols)}\")\n    return all_symbols\n</code></pre> <p>In this example, the <code>symbol_params_many()</code> method is used inside a loop to sequentially retrieve all pages.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_params_many_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_params_many_HOW/#1-initializing-pagination-parameters","title":"1\ufe0f\u20e3 Initializing Pagination Parameters","text":"<pre><code>page_number = 0\nitems_per_page = 100\n</code></pre> <ul> <li><code>page_number</code> specifies the page number (numbering starts from <code>0</code>)</li> <li><code>items_per_page</code> determines the maximum number of symbols per page</li> </ul> <p>The page size is chosen by the user based on the balance between speed and data volume.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_params_many_HOW/#2-forming-the-request","title":"2\ufe0f\u20e3 Forming the Request","text":"<pre><code>request = account_helper_pb2.SymbolParamsManyRequest()\nrequest.page_number = page_number\nrequest.items_per_page = items_per_page\n</code></pre> <p>At each step of the loop:</p> <ul> <li>a new request object is created</li> <li>current page parameters are set in it</li> </ul> <p>The method does not store pagination state \u2014 all page management is on the user code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_params_many_HOW/#3-retrieving-one-page-of-data","title":"3\ufe0f\u20e3 Retrieving One Page of Data","text":"<pre><code>data = await account.symbol_params_many(request)\n</code></pre> <p>At this step:</p> <ul> <li>one asynchronous call is performed</li> <li>the server returns one page of symbols</li> <li> <p>the response contains:</p> </li> <li> <p>list of symbol parameters for the current page</p> </li> <li>total number of symbols (<code>symbols_total</code>)</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_params_many_HOW/#4-accumulating-results","title":"4\ufe0f\u20e3 Accumulating Results","text":"<pre><code>all_symbols.extend(data.symbol_infos)\n</code></pre> <p>The retrieved data is added to the overall list.</p> <p>The API does not aggregate pages automatically \u2014 this is done manually in user code.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_params_many_HOW/#5-loop-exit-conditions","title":"5\ufe0f\u20e3 Loop Exit Conditions","text":"<pre><code>if len(all_symbols) &gt;= data.symbols_total:\n    break\n</code></pre> <p>The loop terminates when:</p> <ul> <li>the number of collected symbols reaches the total count</li> </ul> <pre><code>if len(data.symbol_infos) == 0:\n    break\n</code></pre> <p>Additional safety check:</p> <ul> <li>if the server returned an empty page</li> <li>further requests make no sense</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_params_many_HOW/#6-moving-to-next-page","title":"6\ufe0f\u20e3 Moving to Next Page","text":"<pre><code>page_number += 1\n</code></pre> <p>After processing the current page, the number is incremented and the loop continues.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_params_many_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>symbol_params_many()</code>:</p> <ul> <li>returns one page of symbol parameters</li> <li>reports the total number of symbols</li> <li>does not manage pagination</li> <li>does not aggregate data</li> </ul> <p><code>get_all_symbols()</code>:</p> <ul> <li>manages page numbers</li> <li>accumulates results</li> <li>determines termination conditions</li> <li>forms the final list</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_params_many_HOW/#summary","title":"Summary","text":"<p>This example demonstrates the standard pattern of working with paginated low-level methods:</p> <p>request page \u2192 process data \u2192 check conditions \u2192 request next page</p> <p>The <code>symbol_params_many()</code> method provides access to data by pages, while all iteration and aggregation logic is implemented on the user code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_select_HOW/","title":"symbol select HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_select_HOW/#symbol_select-how-it-works","title":"symbol_select \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_select_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level asynchronous method <code>symbol_select()</code> to manage Market Watch content \u2014 add and remove symbols.</p> <p>The example implements a practical task: cleaning Market Watch of all symbols except a predefined list.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_select_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def symbol_select(\n    symbol: str,\n    select: bool,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and called with <code>await</code></li> <li><code>symbol</code> \u2014 trading symbol name</li> <li><code>select=True</code> adds the symbol to Market Watch</li> <li><code>select=False</code> removes the symbol from Market Watch</li> <li>The method returns the operation result</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_select_HOW/#code-example-market-watch-cleanup","title":"\ud83e\udde9 Code Example \u2014 Market Watch Cleanup","text":"<pre><code>async def cleanup_market_watch(account: MT5Account, keep_symbols: list[str]):\n    total_data = await account.symbols_total(selected_only=True)\n    total = total_data.total\n\n    removed = []\n    for i in range(total):\n        name_data = await account.symbol_name(index=i, selected=True)\n        symbol = name_data.name\n\n        if symbol not in keep_symbols:\n            data = await account.symbol_select(symbol=symbol, select=False)\n            if data.success:\n                removed.append(symbol)\n                print(f\"Removed: {symbol}\")\n\n    print(f\"Removed {len(removed)} symbols from Market Watch\")\n    return removed\n</code></pre> <p>This example demonstrates practical use of <code>symbol_select()</code> for managing the displayed symbols list.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_select_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_select_HOW/#1-getting-selected-symbols-count","title":"1\ufe0f\u20e3 Getting Selected Symbols Count","text":"<pre><code>total_data = await account.symbols_total(selected_only=True)\ntotal = total_data.total\n</code></pre> <p>At this step:</p> <ul> <li>the number of symbols in Market Watch is requested</li> <li>this value is used as the iteration boundary</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_select_HOW/#2-iterating-through-symbols-by-index","title":"2\ufe0f\u20e3 Iterating Through Symbols by Index","text":"<pre><code>for i in range(total):\n</code></pre> <p>The code sequentially iterates through all symbols currently added to Market Watch.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_select_HOW/#3-getting-symbol-name","title":"3\ufe0f\u20e3 Getting Symbol Name","text":"<pre><code>name_data = await account.symbol_name(index=i, selected=True)\nsymbol = name_data.name\n</code></pre> <p>At this step:</p> <ul> <li>the symbol name is obtained by index</li> <li>the name is used to decide on removal</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_select_HOW/#4-removing-symbol-from-market-watch","title":"4\ufe0f\u20e3 Removing Symbol from Market Watch","text":"<pre><code>data = await account.symbol_select(symbol=symbol, select=False)\n</code></pre> <p>If the symbol is not in the <code>keep_symbols</code> list:</p> <ul> <li><code>symbol_select()</code> is called with <code>select=False</code></li> <li>a command is sent to the terminal to remove the symbol from Market Watch</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_select_HOW/#5-checking-operation-result","title":"5\ufe0f\u20e3 Checking Operation Result","text":"<pre><code>if data.success:\n</code></pre> <p>The method returns an object with a <code>success</code> flag:</p> <ul> <li><code>True</code> \u2014 operation completed successfully</li> <li><code>False</code> \u2014 operation was not completed</li> </ul> <p>User code decides how to interpret the result.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_select_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>symbol_select()</code>:</p> <ul> <li>adds or removes a symbol from Market Watch</li> <li>performs one specific operation</li> <li>returns the operation result</li> </ul> <p><code>cleanup_market_watch()</code>:</p> <ul> <li>determines which symbols to keep</li> <li>manages list iteration</li> <li>decides on removal</li> <li>aggregates the result</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbol_select_HOW/#summary","title":"Summary","text":"<p>This example illustrates the state management pattern through low-level API:</p> <p>get current state \u2192 make decision \u2192 change state \u2192 check result</p> <p>The <code>symbol_select()</code> method performs an atomic operation of adding or removing a symbol, while all Market Watch management logic is implemented on the user code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbols_total_HOW/","title":"symbols total HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbols_total_HOW/#symbols_total-how-it-works","title":"symbols_total \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbols_total_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level asynchronous method <code>symbols_total()</code> to get the number of trading symbols and calculate Market Watch usage based on it.</p> <p>The <code>symbols_total()</code> method returns only a numeric value \u2014 the total number of symbols. All analytics and interpretation are performed on the user code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbols_total_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def symbols_total(\n    selected_only: bool,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and called with <code>await</code></li> <li><code>selected_only=True</code> \u2014 count only symbols from Market Watch</li> <li><code>selected_only=False</code> \u2014 count all available symbols on the server</li> <li>The method returns an object with numeric value <code>total</code></li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbols_total_HOW/#code-example-market-watch-usage-calculation","title":"\ud83e\udde9 Code Example \u2014 Market Watch Usage Calculation","text":"<pre><code>async def calculate_mw_usage(account: MT5Account) -&gt; dict:\n    all_data = await account.symbols_total(selected_only=False)\n    mw_data = await account.symbols_total(selected_only=True)\n\n    total = all_data.total\n    used = mw_data.total\n    usage_pct = (used / total * 100) if total &gt; 0 else 0\n\n    result = {\n        \"total_available\": total,\n        \"in_market_watch\": used,\n        \"usage_percent\": usage_pct\n    }\n\n    print(f\"Market Watch Usage:\")\n    print(f\"  Using {used} of {total} symbols ({usage_pct:.1f}%)\")\n\n    return result\n</code></pre> <p>In this example, the method is called twice with different parameters to compare the total number of symbols and the number of symbols added to Market Watch.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbols_total_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbols_total_HOW/#1-getting-total-symbol-count","title":"1\ufe0f\u20e3 Getting Total Symbol Count","text":"<pre><code>all_data = await account.symbols_total(selected_only=False)\n</code></pre> <p>At this step:</p> <ul> <li>one asynchronous call is performed</li> <li>the server returns the count of all symbols available on the platform</li> <li>the value is available in the <code>all_data.total</code> field</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbols_total_HOW/#2-getting-market-watch-symbol-count","title":"2\ufe0f\u20e3 Getting Market Watch Symbol Count","text":"<pre><code>mw_data = await account.symbols_total(selected_only=True)\n</code></pre> <p>Here the method is used again, but for a different data slice:</p> <ul> <li>only symbols added to Market Watch are counted</li> <li>the result is also returned in the <code>mw_data.total</code> field</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbols_total_HOW/#3-extracting-numeric-values","title":"3\ufe0f\u20e3 Extracting Numeric Values","text":"<pre><code>total = all_data.total\nused = mw_data.total\n</code></pre> <p>At this stage:</p> <ul> <li>the API is no longer used</li> <li>regular work with numbers in Python follows</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbols_total_HOW/#4-calculating-usage-percentage","title":"4\ufe0f\u20e3 Calculating Usage Percentage","text":"<pre><code>usage_pct = (used / total * 100) if total &gt; 0 else 0\n</code></pre> <p>User code:</p> <ul> <li>protects against division by zero</li> <li>calculates the percentage of symbols added to Market Watch</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbols_total_HOW/#5-forming-the-result","title":"5\ufe0f\u20e3 Forming the Result","text":"<pre><code>result = {\n    \"total_available\": total,\n    \"in_market_watch\": used,\n    \"usage_percent\": usage_pct\n}\n</code></pre> <p>The <code>symbols_total()</code> method returns only a number, while the result structure is entirely formed on the user side.</p>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbols_total_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>symbols_total()</code>:</p> <ul> <li>returns the symbol count</li> <li>does not compare values</li> <li>does not calculate percentages</li> <li>does not draw conclusions</li> </ul> <p><code>calculate_mw_usage()</code>:</p> <ul> <li>calls the method with different parameters</li> <li>compares results</li> <li>performs calculations</li> <li>forms statistics</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/2.%20Symbol_information_HOW/symbols_total_HOW/#summary","title":"Summary","text":"<p>This example illustrates a simple but important pattern of working with low-level API:</p> <p>get numeric values \u2192 perform calculation \u2192 interpret result</p> <p>The <code>symbols_total()</code> method provides basic data, while all analytics and conclusions remain on the user code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_HOW/","title":"opened orders HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_HOW/#opened_orders-how-it-works","title":"opened_orders \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level asynchronous method <code>opened_orders()</code> to get a current snapshot of the trading account state:</p> <ul> <li>list of pending orders</li> <li>list of open positions</li> </ul> <p>The method is used for account monitoring, displaying trading state, and making subsequent decisions.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def opened_orders(\n    sort_mode: BMT5_ENUM_OPENED_ORDER_SORT_TYPE = BMT5_OPENED_ORDER_SORT_BY_OPEN_TIME_ASC,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and called with <code>await</code></li> <li><code>sort_mode</code> affects only the order of pending orders</li> <li>positions are returned without sorting</li> <li>The method returns one aggregated state object</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_HOW/#code-example-getting-opened-orders-and-positions","title":"\ud83e\udde9 Code Example \u2014 Getting Opened Orders and Positions","text":"<pre><code>data = await account.opened_orders(\n    sort_mode=account_helper_pb2.BMT5_OPENED_ORDER_SORT_BY_OPEN_TIME_ASC,\n    deadline=deadline\n)\n\nprint(f\"Pending orders: {len(data.opened_orders)}\")\nprint(f\"Open positions: {len(data.position_infos)}\")\n\n# Show positions\nfor pos in data.position_infos:\n    print(\n        f\"Position #{pos.ticket} {pos.symbol}: \"\n        f\"{pos.volume} lots @ {pos.price_open}, P/L: ${pos.profit:.2f}\"\n    )\n\n# Show orders\nfor order in data.opened_orders:\n    print(\n        f\"Order #{order.ticket} {order.symbol}: \"\n        f\"{order.volume_initial} lots @ {order.price_open}\"\n    )\n</code></pre> <p>This example demonstrates working with the result without additional filtering or transformations.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_HOW/#1-calling-the-opened_orders-method","title":"1\ufe0f\u20e3 Calling the opened_orders Method","text":"<pre><code>data = await account.opened_orders(\n    sort_mode=account_helper_pb2.BMT5_OPENED_ORDER_SORT_BY_OPEN_TIME_ASC,\n    deadline=deadline\n)\n</code></pre> <p>At this step:</p> <ul> <li>one asynchronous request is performed</li> <li>the server forms the current trading state of the account</li> <li>data is returned as one object</li> </ul> <p>This object represents a snapshot of the state at a specific moment in time.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_HOW/#2-result-structure","title":"2\ufe0f\u20e3 Result Structure","text":"<p>The response contains two independent lists:</p> <pre><code>data.opened_orders     # pending orders\ndata.position_infos    # open positions\n</code></pre> <p>These are fundamentally different entities:</p> <ul> <li>positions \u2014 already opened trades</li> <li>orders \u2014 instructions waiting for execution</li> </ul> <p>They are returned together because they reflect the same account state.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_HOW/#3-counting-orders-and-positions","title":"3\ufe0f\u20e3 Counting Orders and Positions","text":"<pre><code>len(data.opened_orders)\nlen(data.position_infos)\n</code></pre> <p>Here:</p> <ul> <li>lists are already formed by the server</li> <li>the client simply counts elements</li> </ul> <p>The method does not filter or hide data.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_HOW/#4-iterating-through-open-positions","title":"4\ufe0f\u20e3 Iterating Through Open Positions","text":"<pre><code>for pos in data.position_infos:\n</code></pre> <p>Each element in the positions list contains a set of fields, such as:</p> <ul> <li><code>ticket</code> \u2014 position identifier</li> <li><code>symbol</code> \u2014 trading instrument</li> <li><code>volume</code> \u2014 position volume</li> <li><code>price_open</code> \u2014 opening price</li> <li><code>profit</code> \u2014 current profit or loss</li> </ul> <p>User code:</p> <ul> <li>selects needed fields</li> <li>formats output</li> <li>decides what to consider important</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_HOW/#5-iterating-through-pending-orders","title":"5\ufe0f\u20e3 Iterating Through Pending Orders","text":"<pre><code>for order in data.opened_orders:\n</code></pre> <p>Pending orders:</p> <ul> <li>do not have current profit</li> <li>use <code>volume_initial</code> instead of <code>volume</code></li> <li>exist separately from positions</li> </ul> <p>This emphasizes why the method returns two different lists.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_HOW/#6-the-role-of-sort_mode-parameter","title":"6\ufe0f\u20e3 The Role of sort_mode Parameter","text":"<pre><code>sort_mode=BMT5_OPENED_ORDER_SORT_BY_OPEN_TIME_ASC\n</code></pre> <p>Important:</p> <ul> <li>sorting applies only to pending orders</li> <li>positions are not sorted</li> <li>sorting is performed on the server side</li> </ul> <p>The client receives an already ordered list of orders.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>opened_orders()</code>:</p> <ul> <li>returns the current state of orders and positions</li> <li>aggregates data on the server side</li> <li>does not filter or analyze them</li> <li>does not make trading decisions</li> </ul> <p>User code:</p> <ul> <li>decides which fields to use</li> <li>how to display data</li> <li>what actions to perform next</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_HOW/#summary","title":"Summary","text":"<p>This example illustrates the basic pattern of working with aggregating low-level methods:</p> <p>get state snapshot \u2192 parse data \u2192 make decision</p> <p>The <code>opened_orders()</code> method provides the current trading state, while all analysis logic and subsequent actions remain on the user code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_tickets_HOW/","title":"opened orders tickets HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_tickets_HOW/#opened_orders_tickets-how-it-works","title":"opened_orders_tickets \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_tickets_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level asynchronous method <code>opened_orders_tickets()</code> to track changes in the trading account state by identifiers (ticket IDs).</p> <p>Unlike <code>opened_orders()</code>, which returns detailed information, this method is designed for lightweight change monitoring:</p> <ul> <li>appearance of new orders or positions</li> <li>closing of existing ones</li> </ul> <p>It is especially useful for background monitoring and reactive logic.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_tickets_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def opened_orders_tickets(\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>the method is asynchronous and called with <code>await</code></li> <li>does not accept filtering parameters</li> <li>returns only identifiers (tickets)</li> <li>does not contain detailed information about orders or positions</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_tickets_HOW/#code-example-monitoring-changes-by-tickets","title":"\ud83e\udde9 Code Example \u2014 Monitoring Changes by Tickets","text":"<pre><code>async def monitor_tickets(account: MT5Account, interval: float = 5.0):\n    previous_tickets = set()\n\n    while True:\n        try:\n            data = await account.opened_orders_tickets()\n\n            current_tickets = set(\n                data.opened_orders_tickets + data.opened_position_tickets\n            )\n\n            if previous_tickets:\n                new = current_tickets - previous_tickets\n                closed = previous_tickets - current_tickets\n\n                for ticket in new:\n                    print(f\"[+] New ticket: #{ticket}\")\n                for ticket in closed:\n                    print(f\"[-] Closed ticket: #{ticket}\")\n\n            previous_tickets = current_tickets\n\n        except Exception as e:\n            print(f\"[ERROR] {e}\")\n\n        await asyncio.sleep(interval)\n</code></pre> <p>This example implements a simple observation loop for tracking trading state changes.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_tickets_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_tickets_HOW/#1-storing-previous-state","title":"1\ufe0f\u20e3 Storing Previous State","text":"<pre><code>previous_tickets = set()\n</code></pre> <ul> <li><code>set</code> is used for fast comparison</li> <li>it stores tickets from the previous iteration</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_tickets_HOW/#2-getting-the-current-ticket-list","title":"2\ufe0f\u20e3 Getting the Current Ticket List","text":"<pre><code>data = await account.opened_orders_tickets()\n</code></pre> <p>At this step:</p> <ul> <li>one asynchronous call is performed</li> <li> <p>the server returns:</p> </li> <li> <p><code>opened_orders_tickets</code></p> </li> <li><code>opened_position_tickets</code></li> </ul> <p>These are two independent lists of numeric identifiers.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_tickets_HOW/#3-merging-orders-and-positions","title":"3\ufe0f\u20e3 Merging Orders and Positions","text":"<pre><code>current_tickets = set(\n    data.opened_orders_tickets + data.opened_position_tickets\n)\n</code></pre> <p>Here:</p> <ul> <li>lists are merged</li> <li>converted into a <code>set</code></li> <li>the current state of account tickets is formed</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_tickets_HOW/#4-comparing-states","title":"4\ufe0f\u20e3 Comparing States","text":"<pre><code>new = current_tickets - previous_tickets\nclosed = previous_tickets - current_tickets\n</code></pre> <p>Standard set operation logic is used:</p> <ul> <li><code>new</code> \u2014 tickets that appeared since the last poll</li> <li><code>closed</code> \u2014 tickets that have disappeared</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_tickets_HOW/#5-reacting-to-changes","title":"5\ufe0f\u20e3 Reacting to Changes","text":"<pre><code>for ticket in new:\n    print(f\"[+] New ticket: #{ticket}\")\n</code></pre> <p>User code:</p> <ul> <li>decides on its own how to react</li> <li>can log, update UI, trigger logic</li> </ul> <p>The API method does not interpret changes.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_tickets_HOW/#6-updating-state","title":"6\ufe0f\u20e3 Updating State","text":"<pre><code>previous_tickets = current_tickets\n</code></pre> <p>The current state is saved for the next loop iteration.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_tickets_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>opened_orders_tickets()</code>:</p> <ul> <li>returns only order and position identifiers</li> <li>does not contain prices, volumes, or profit</li> <li>does not track changes over time</li> </ul> <p><code>monitor_tickets()</code>:</p> <ul> <li>implements the polling loop</li> <li>compares states</li> <li>determines what appeared and what disappeared</li> <li>makes decisions</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/opened_orders_tickets_HOW/#summary","title":"Summary","text":"<p>This example demonstrates the pattern of lightweight state monitoring:</p> <p>get identifiers \u2192 compare states \u2192 react to changes</p> <p>The <code>opened_orders_tickets()</code> method provides the minimum set of data for tracking changes, while all monitoring and interpretation logic is implemented on the user code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/","title":"order history HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/#order_history-how-it-works","title":"order_history \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level asynchronous method <code>order_history()</code> to retrieve historical trading data for a given time range and perform custom trade analysis on the client side.</p> <p>In this scenario, the method is used as a raw data source to calculate:</p> <ul> <li>number of winning trades</li> <li>number of losing trades</li> <li>win rate</li> <li>total profit and loss</li> </ul> <p>All analytical logic is implemented in user code.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def order_history(\n    from_dt: datetime,\n    to_dt: datetime,\n    sort_mode: BMT5_ENUM_ORDER_HISTORY_SORT_TYPE = BMT5_SORT_BY_CLOSE_TIME_ASC,\n    page_number: int = 0,\n    items_per_page: int = 0,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>The method is asynchronous and called with <code>await</code></li> <li><code>from_dt</code> / <code>to_dt</code> define the time range for history retrieval</li> <li><code>items_per_page=0</code> disables pagination and returns all data at once</li> <li>The method returns historical records without any analysis</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/#code-example-winning-vs-losing-trades-analysis","title":"\ud83e\udde9 Code Example \u2014 Winning vs Losing Trades Analysis","text":"<pre><code>async def analyze_win_loss(\n    account: MT5Account,\n    from_dt: datetime,\n    to_dt: datetime\n) -&gt; dict:\n    \"\"\"Analyze winning vs losing trades\"\"\"\n\n    data = await account.order_history(\n        from_dt=from_dt,\n        to_dt=to_dt,\n        items_per_page=0\n    )\n\n    wins = 0\n    losses = 0\n    total_win_profit = 0.0\n    total_loss_profit = 0.0\n\n    for item in data.history_data:\n        if item.history_deal:\n            profit = item.history_deal.profit\n            if profit &gt; 0:\n                wins += 1\n                total_win_profit += profit\n            elif profit &lt; 0:\n                losses += 1\n                total_loss_profit += profit\n\n    total_trades = wins + losses\n    win_rate = (wins / total_trades * 100) if total_trades &gt; 0 else 0\n\n    result = {\n        \"total_trades\": total_trades,\n        \"wins\": wins,\n        \"losses\": losses,\n        \"win_rate\": win_rate,\n        \"total_win_profit\": total_win_profit,\n        \"total_loss_profit\": total_loss_profit,\n        \"net_profit\": total_win_profit + total_loss_profit\n    }\n\n    print(\"Trading Statistics:\")\n    print(f\"  Total trades: {total_trades}\")\n    print(f\"  Wins: {wins} ({win_rate:.1f}%)\")\n    print(f\"  Losses: {losses}\")\n    print(f\"  Win profit: ${total_win_profit:.2f}\")\n    print(f\"  Loss profit: ${total_loss_profit:.2f}\")\n    print(f\"  Net profit: ${result['net_profit']:+.2f}\")\n\n    return result\n</code></pre> <p>This example demonstrates a complete user-level analysis workflow built on top of raw historical data.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/#1-calling-the-order_history-method","title":"1\ufe0f\u20e3 Calling the order_history Method","text":"<pre><code>data = await account.order_history(\n    from_dt=from_dt,\n    to_dt=to_dt,\n    items_per_page=0\n)\n</code></pre> <p>At this step:</p> <ul> <li>one asynchronous request is performed</li> <li>the server returns all historical records within the given time range</li> <li>no filtering, aggregation, or classification is applied</li> </ul> <p>The result represents raw historical trading data.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/#2-initializing-counters-and-accumulators","title":"2\ufe0f\u20e3 Initializing Counters and Accumulators","text":"<pre><code>wins = 0\nlosses = 0\ntotal_win_profit = 0.0\ntotal_loss_profit = 0.0\n</code></pre> <p>These variables are part of user logic:</p> <ul> <li>the API does not track win/loss statistics</li> <li>all counters are initialized manually</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/#3-iterating-through-historical-records","title":"3\ufe0f\u20e3 Iterating Through Historical Records","text":"<pre><code>for item in data.history_data:\n</code></pre> <p><code>history_data</code> is a list of history records.</p> <p>Each record may represent different entities (orders, deals, etc.), so user code must decide what to process.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/#4-filtering-only-executed-deals","title":"4\ufe0f\u20e3 Filtering Only Executed Deals","text":"<pre><code>if item.history_deal:\n</code></pre> <p>In this example:</p> <ul> <li>only executed deals are analyzed</li> <li>records without a deal are skipped</li> </ul> <p>This filtering rule is entirely user-defined.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/#5-classifying-trades-by-profit","title":"5\ufe0f\u20e3 Classifying Trades by Profit","text":"<pre><code>profit = item.history_deal.profit\n</code></pre> <p>The profit value is then classified:</p> <pre><code>if profit &gt; 0:\n    wins += 1\n    total_win_profit += profit\nelif profit &lt; 0:\n    losses += 1\n    total_loss_profit += profit\n</code></pre> <p>The API does not define what constitutes a win or a loss.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/#6-calculating-final-statistics","title":"6\ufe0f\u20e3 Calculating Final Statistics","text":"<pre><code>total_trades = wins + losses\nwin_rate = (wins / total_trades * 100) if total_trades &gt; 0 else 0\n</code></pre> <p>All statistical calculations are performed in user code, including edge-case handling.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/#7-building-the-result-object","title":"7\ufe0f\u20e3 Building the Result Object","text":"<pre><code>result = {\n    \"total_trades\": total_trades,\n    \"wins\": wins,\n    \"losses\": losses,\n    \"win_rate\": win_rate,\n    \"net_profit\": total_win_profit + total_loss_profit\n}\n</code></pre> <p>The final analytical result is a pure client-side construct.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>order_history()</code>:</p> <ul> <li>retrieves historical trading records</li> <li>filters by time range</li> <li>supports sorting and pagination</li> <li>does not analyze or aggregate data</li> </ul> <p>User code:</p> <ul> <li>selects which records to process</li> <li>defines win/loss logic</li> <li>computes statistics</li> <li>produces analytical output</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/order_history_HOW/#summary","title":"Summary","text":"<p>This example illustrates the standard pattern for working with historical data:</p> <p>retrieve raw history \u2192 filter records \u2192 analyze results \u2192 build statistics</p> <p>The <code>order_history()</code> method provides historical data access, while all analytical and decision-making logic remains on the user side.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/","title":"positions history HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/#positions_history-how-it-works","title":"positions_history \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level asynchronous method <code>positions_history()</code> to retrieve the history of closed positions for a given period and use it for exporting data to an external format (CSV).</p> <p>In this scenario, the method serves as a source of historical data, while all formatting, calculation, and result saving logic is implemented on the user code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def positions_history(\n    sort_type: AH_ENUM_POSITIONS_HISTORY_SORT_TYPE,\n    open_from: Optional[datetime] = None,\n    open_to: Optional[datetime] = None,\n    page: int = 0,\n    size: int = 0,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>the method is asynchronous and called with <code>await</code></li> <li><code>open_from</code> / <code>open_to</code> define the position opening time range</li> <li><code>size=0</code> means all records are returned in one response</li> <li>the method returns only historical data without any aggregation</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/#code-example-exporting-position-history-to-csv","title":"\ud83e\udde9 Code Example \u2014 Exporting Position History to CSV","text":"<pre><code>import csv\n\nasync def export_positions_to_csv(\n    account: MT5Account,\n    from_dt: datetime,\n    to_dt: datetime,\n    filename: str = \"positions_history.csv\"\n):\n    \"\"\"Export closed positions to CSV\"\"\"\n\n    data = await account.positions_history(\n        sort_type=account_helper_pb2.AH_POSITION_OPEN_TIME_ASC,\n        open_from=from_dt,\n        open_to=to_dt\n    )\n\n    with open(filename, 'w', newline='', encoding='utf-8') as f:\n        writer = csv.writer(f)\n        writer.writerow([\n            'Ticket', 'Symbol', 'Open Time', 'Close Time',\n            'Volume', 'Open Price', 'Close Price',\n            'Profit', 'Commission', 'Swap', 'Total'\n        ])\n\n        for pos in data.history_positions:\n            open_time = pos.open_time.ToDatetime()\n            close_time = pos.close_time.ToDatetime()\n            total = pos.profit - pos.commission + pos.swap\n\n            writer.writerow([\n                pos.position_ticket,\n                pos.symbol,\n                open_time.strftime('%Y-%m-%d %H:%M:%S'),\n                close_time.strftime('%Y-%m-%d %H:%M:%S'),\n                pos.volume,\n                pos.open_price,\n                pos.close_price,\n                pos.profit,\n                pos.commission,\n                pos.swap,\n                total\n            ])\n\n    print(f\"[OK] Exported {len(data.history_positions)} positions to {filename}\")\n</code></pre> <p>This example demonstrates a complete user-level data export scenario built on top of a low-level method.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/#1-calling-the-positions_history-method","title":"1\ufe0f\u20e3 Calling the positions_history Method","text":"<pre><code>data = await account.positions_history(\n    sort_type=account_helper_pb2.AH_POSITION_OPEN_TIME_ASC,\n    open_from=from_dt,\n    open_to=to_dt\n)\n</code></pre> <p>At this step:</p> <ul> <li>one asynchronous request is made to the server</li> <li>the server filters historical positions by opening time</li> <li>data is returned as a <code>history_positions</code> list</li> </ul> <p>The method does not perform any calculations or modify data.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/#2-preparing-the-csv-file","title":"2\ufe0f\u20e3 Preparing the CSV File","text":"<pre><code>with open(filename, 'w', newline='', encoding='utf-8') as f:\n    writer = csv.writer(f)\n</code></pre> <p>This is entirely user logic:</p> <ul> <li>format selection (CSV)</li> <li>encoding</li> <li>data writing method</li> </ul> <p>The API does not participate in this process.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/#3-writing-the-header","title":"3\ufe0f\u20e3 Writing the Header","text":"<pre><code>writer.writerow([\n    'Ticket', 'Symbol', 'Open Time', 'Close Time',\n    'Volume', 'Open Price', 'Close Price',\n    'Profit', 'Commission', 'Swap', 'Total'\n])\n</code></pre> <p>Column headers:</p> <ul> <li>are user-defined</li> <li>reflect the selected set of fields</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/#4-iterating-through-historical-positions","title":"4\ufe0f\u20e3 Iterating Through Historical Positions","text":"<pre><code>for pos in data.history_positions:\n</code></pre> <p>Each <code>pos</code> element represents one closed position and contains:</p> <ul> <li>identifiers</li> <li>opening and closing prices</li> <li>financial metrics</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/#5-time-conversion","title":"5\ufe0f\u20e3 Time Conversion","text":"<pre><code>open_time = pos.open_time.ToDatetime()\nclose_time = pos.close_time.ToDatetime()\n</code></pre> <p>Time values:</p> <ul> <li>arrive in protobuf format</li> <li>are converted to <code>datetime</code> for convenient formatting</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/#6-user-calculations","title":"6\ufe0f\u20e3 User Calculations","text":"<pre><code>total = pos.profit - pos.commission + pos.swap\n</code></pre> <p>Calculating the final position result:</p> <ul> <li>performed on the client side</li> <li>the API does not calculate aggregated values</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/#7-writing-a-row-to-csv","title":"7\ufe0f\u20e3 Writing a Row to CSV","text":"<pre><code>writer.writerow([...])\n</code></pre> <p>At this step:</p> <ul> <li>the required position fields are selected</li> <li>data is converted to string format</li> <li>one CSV file row is formed</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>positions_history()</code>:</p> <ul> <li>returns position history based on specified filters</li> <li>performs sorting and time filtering</li> <li>does not analyze or format data</li> </ul> <p>User code:</p> <ul> <li>defines the export format</li> <li>performs calculations</li> <li>manages data output</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_history_HOW/#summary","title":"Summary","text":"<p>This example illustrates the standard pattern for working with historical data:</p> <p>retrieve history \u2192 transform data \u2192 save to external format</p> <p>The <code>positions_history()</code> method provides access to historical positions, while all export and data processing logic is fully implemented on the user side.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_total_HOW/","title":"positions total HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_total_HOW/#positions_total-how-it-works","title":"positions_total \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_total_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level asynchronous method <code>positions_total()</code> to get the current number of open positions on the account and compare it with a specified target value.</p> <p>This scenario is typical for risk management and trading state control:</p> <ul> <li>limiting the maximum number of positions</li> <li>maintaining a specified number of trades</li> <li>controlling account overload</li> </ul> <p>The method is used exclusively as a source of actual state.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_total_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def positions_total(\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>the method is asynchronous and called with <code>await</code></li> <li>does not accept filters or parameters</li> <li>returns only the number of open positions</li> <li>does not perform checks or comparisons</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_total_HOW/#code-example-comparing-position-count-with-target-value","title":"\ud83e\udde9 Code Example \u2014 Comparing Position Count with Target Value","text":"<pre><code>async def compare_with_target(\n    account: MT5Account,\n    target_positions: int\n) -&gt; dict:\n    data = await account.positions_total()\n    current = data.total_positions\n\n    difference = current - target_positions\n\n    result = {\n        \"current\": current,\n        \"target\": target_positions,\n        \"difference\": difference,\n        \"status\": \"exact\" if difference == 0 else \"above\" if difference &gt; 0 else \"below\"\n    }\n\n    if difference == 0:\n        print(f\"[OK] Exactly at target: {current} positions\")\n    elif difference &gt; 0:\n        print(f\"[INFO] {abs(difference)} above target ({current}/{target_positions})\")\n    else:\n        print(f\"[INFO] {abs(difference)} below target ({current}/{target_positions})\")\n\n    return result\n</code></pre> <p>This example demonstrates an applied check of the trading state against a specified limit.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_total_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_total_HOW/#1-getting-the-current-position-count","title":"1\ufe0f\u20e3 Getting the Current Position Count","text":"<pre><code>data = await account.positions_total()\ncurrent = data.total_positions\n</code></pre> <p>At this step:</p> <ul> <li>one asynchronous request is performed</li> <li>the server returns the number of open positions</li> <li>no additional information is transmitted</li> </ul> <p>The method returns the current state, not history.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_total_HOW/#2-comparing-with-target-value","title":"2\ufe0f\u20e3 Comparing with Target Value","text":"<pre><code>difference = current - target_positions\n</code></pre> <p>User logic begins here:</p> <ul> <li>deviation from the target value is calculated</li> <li>positive value means exceeding the limit</li> <li>negative value means insufficient positions</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_total_HOW/#3-forming-status","title":"3\ufe0f\u20e3 Forming Status","text":"<pre><code>status = \"exact\" if difference == 0 else \"above\" if difference &gt; 0 else \"below\"\n</code></pre> <p>Status is fully user-defined:</p> <ul> <li><code>exact</code> \u2014 current count matches the target</li> <li><code>above</code> \u2014 more positions than needed</li> <li><code>below</code> \u2014 fewer positions than required</li> </ul> <p>The API does not interpret the result.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_total_HOW/#4-reacting-to-result","title":"4\ufe0f\u20e3 Reacting to Result","text":"<pre><code>if difference == 0:\n    ...\nelif difference &gt; 0:\n    ...\nelse:\n    ...\n</code></pre> <p>At this step:</p> <ul> <li>a decision is made</li> <li>logging is performed</li> <li>if necessary, trading logic can be here (closing / opening positions)</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_total_HOW/#5-returning-aggregated-result","title":"5\ufe0f\u20e3 Returning Aggregated Result","text":"<pre><code>return result\n</code></pre> <p>The function returns a structure with the already interpreted state.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_total_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>positions_total()</code>:</p> <ul> <li>returns only the number of open positions</li> <li>does not know what \"target\" or \"limit\" means</li> <li>does not make decisions</li> </ul> <p>User code:</p> <ul> <li>sets the target value</li> <li>compares the current state with the target</li> <li>interprets the result</li> <li>takes further actions</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/positions_total_HOW/#summary","title":"Summary","text":"<p>This example illustrates a simple but important state control pattern:</p> <p>get current value \u2192 compare with target \u2192 make decision</p> <p>The <code>positions_total()</code> method provides the actual account state, while all control and management logic is implemented on the user side.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/tick_value_with_size_HOW/","title":"tick value with size HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/tick_value_with_size_HOW/#tick_value_with_size-how-it-works","title":"tick_value_with_size \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/tick_value_with_size_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level asynchronous method <code>tick_value_with_size()</code> to get the tick value and tick size of an instrument and use this data to calculate the acceptable Stop Loss distance for a given maximum loss.</p> <p>The method is used as a source of instrument market parameters, while all risk calculations are performed on the user code side.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/tick_value_with_size_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def tick_value_with_size(\n    symbols: list[str],\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>the method is asynchronous and called with <code>await</code></li> <li>accepts a list of symbols (even if only one is needed)</li> <li>returns tick value and tick size parameters</li> <li>does not perform any risk or SL calculations</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/tick_value_with_size_HOW/#code-example-calculating-stop-loss-distance","title":"\ud83e\udde9 Code Example \u2014 Calculating Stop Loss Distance","text":"<pre><code>async def calculate_sl_distance(\n    account: MT5Account,\n    symbol: str,\n    lots: float,\n    max_loss: float\n) -&gt; float:\n    \"\"\"Calculate maximum SL distance for given max loss\"\"\"\n\n    data = await account.tick_value_with_size(symbols=[symbol])\n\n    if not data.symbol_tick_size_infos:\n        raise ValueError(f\"Symbol {symbol} not found\")\n\n    info = data.symbol_tick_size_infos[0]\n\n    # Calculate pips allowed\n    profit_per_pip = info.TradeTickValue * 10 * lots\n    max_pips = max_loss / profit_per_pip if profit_per_pip &gt; 0 else 0\n\n    print(f\"\\nStop Loss Calculation for {symbol}:\")\n    print(f\"  Volume: {lots} lots\")\n    print(f\"  Max Loss: ${max_loss:.2f}\")\n    print(f\"  Profit per pip: ${profit_per_pip:.2f}\")\n    print(f\"  Max SL distance: {max_pips:.1f} pips\")\n\n    return max_pips\n</code></pre> <p>This example demonstrates a complete user-level Stop Loss parameter calculation based on market data.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/tick_value_with_size_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/tick_value_with_size_HOW/#1-getting-instrument-tick-parameters","title":"1\ufe0f\u20e3 Getting Instrument Tick Parameters","text":"<pre><code>data = await account.tick_value_with_size(symbols=[symbol])\n</code></pre> <p>At this step:</p> <ul> <li>one asynchronous request is performed</li> <li>the server returns instrument parameters</li> <li>data arrives as a <code>symbol_tick_size_infos</code> list</li> </ul> <p>The method does not know how these values will be used.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/tick_value_with_size_HOW/#2-checking-symbol-data-availability","title":"2\ufe0f\u20e3 Checking Symbol Data Availability","text":"<pre><code>if not data.symbol_tick_size_infos:\n    raise ValueError(f\"Symbol {symbol} not found\")\n</code></pre> <p>This is user-level protection:</p> <ul> <li>checks if the server returned data</li> <li>stops calculation if data is missing</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/tick_value_with_size_HOW/#3-extracting-symbol-data","title":"3\ufe0f\u20e3 Extracting Symbol Data","text":"<pre><code>info = data.symbol_tick_size_infos[0]\n</code></pre> <p>Each element contains:</p> <ul> <li><code>TradeTickValue</code> \u2014 value of one tick</li> <li>tick size and contract parameters</li> </ul> <p>The user chooses which fields to use.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/tick_value_with_size_HOW/#4-calculating-pip-value","title":"4\ufe0f\u20e3 Calculating Pip Value","text":"<pre><code>profit_per_pip = info.TradeTickValue * 10 * lots\n</code></pre> <p>Business logic begins here:</p> <ul> <li>tick value is scaled</li> <li>position volume in lots is accounted for</li> <li>an assumption about pip size is used</li> </ul> <p>The API does not perform this calculation.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/tick_value_with_size_HOW/#5-calculating-acceptable-stop-loss-distance","title":"5\ufe0f\u20e3 Calculating Acceptable Stop Loss Distance","text":"<pre><code>max_pips = max_loss / profit_per_pip if profit_per_pip &gt; 0 else 0\n</code></pre> <p>At this step:</p> <ul> <li>maximum acceptable loss is converted to pips</li> <li>protection against division by zero is added</li> </ul> <p>This is entirely a user-level decision.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/tick_value_with_size_HOW/#6-output-and-result-return","title":"6\ufe0f\u20e3 Output and Result Return","text":"<pre><code>return max_pips\n</code></pre> <p>The function returns an already interpreted value, ready for use in trading decisions.</p>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/tick_value_with_size_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>tick_value_with_size()</code>:</p> <ul> <li>returns tick value and size parameters</li> <li>does not know the position volume</li> <li>does not know the acceptable risk</li> <li>does not calculate Stop Loss</li> </ul> <p>User code:</p> <ul> <li>sets volume and risk</li> <li>performs all calculations</li> <li>makes trading decisions</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/3.%20Position_Orders_Information_HOW/tick_value_with_size_HOW/#summary","title":"Summary","text":"<p>This example illustrates a basic risk pattern:</p> <p>get market parameters \u2192 calculate risk \u2192 determine trading levels</p> <p>The <code>tick_value_with_size()</code> method provides the source data, while all risk management logic is implemented on the user side.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_add_HOW/","title":"market book add HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_add_HOW/#market_book_add-market_book_get-market_book_release-how-it-works","title":"market_book_add / market_book_get / market_book_release \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_add_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows the complete lifecycle of working with Depth of Market (DOM):</p> <ol> <li>subscribing to DOM for a symbol</li> <li>periodically retrieving the current order book state</li> <li>displaying order levels</li> <li>properly closing the subscription</li> </ol> <p>Here DOM is used as a live market state that updates over time, while low-level methods serve as data sources and control operations.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_add_HOW/#methods-used","title":"Methods Used","text":"<p>This example uses three low-level methods:</p> <pre><code>market_book_add(symbol)\nmarket_book_get(symbol)\nmarket_book_release(symbol)\n</code></pre> <p>Their roles:</p> <ul> <li><code>market_book_add</code> \u2014 opens DOM and registers subscription</li> <li><code>market_book_get</code> \u2014 returns current order book snapshot</li> <li><code>market_book_release</code> \u2014 closes DOM and releases resources</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_add_HOW/#code-example-subscribe-and-monitor-dom","title":"\ud83e\udde9 Code Example \u2014 Subscribe and Monitor DOM","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def monitor_dom(symbol: str, duration: int = 10):\n    \"\"\"Subscribe and monitor DOM for specified duration\"\"\"\n\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        # 1. Subscribe to DOM\n        result = await account.market_book_add(symbol)\n\n        if not result.opened_successfully:\n            print(f\"[FAILED] Could not subscribe to {symbol} DOM\")\n            return\n\n        print(f\"[SUBSCRIBED] Monitoring {symbol} DOM for {duration} seconds\\n\")\n\n        start_time = asyncio.get_event_loop().time()\n\n        # 2. Periodically read DOM snapshot\n        while (asyncio.get_event_loop().time() - start_time) &lt; duration:\n            dom_data = await account.market_book_get(symbol)\n\n            print(\"\\033[2J\\033[H\")  # clear screen\n\n            print(f\"=== {symbol} Market Depth ===\")\n            print(f\"Total levels: {len(dom_data.mql_book_infos)}\\n\")\n\n            print(f\"{'Type':&lt;10} {'Price':&lt;15} {'Volume':&lt;15}\")\n            print(\"-\" * 45)\n\n            for book_entry in dom_data.mql_book_infos[:10]:\n                entry_type = \"BUY\" if book_entry.type in [1, 3] else \"SELL\"\n                print(\n                    f\"{entry_type:&lt;10} \"\n                    f\"{book_entry.price:&lt;15.5f} \"\n                    f\"{book_entry.volume_real:&lt;15.2f}\"\n                )\n\n            await asyncio.sleep(1)\n\n        # 3. Unsubscribe from DOM\n        await account.market_book_release(symbol)\n        print(f\"\\n[UNSUBSCRIBED] Stopped monitoring {symbol} DOM\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(monitor_dom(\"EURUSD\", duration=10))\n</code></pre>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_add_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_add_HOW/#1-subscribing-to-dom","title":"1\ufe0f\u20e3 Subscribing to DOM","text":"<pre><code>result = await account.market_book_add(symbol)\n</code></pre> <p>At this step:</p> <ul> <li>the terminal opens the order book for the symbol</li> <li>the server starts maintaining DOM state</li> <li>an operation success flag is returned</li> </ul> <p>Without this step, <code>market_book_get</code> will not work.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_add_HOW/#2-monitoring-loop","title":"2\ufe0f\u20e3 Monitoring Loop","text":"<pre><code>while (asyncio.get_event_loop().time() - start_time) &lt; duration:\n</code></pre> <p>The loop:</p> <ul> <li>runs for the specified time</li> <li>regularly requests the current DOM state</li> <li>does not store history \u2014 only the current snapshot</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_add_HOW/#3-getting-current-order-book-state","title":"3\ufe0f\u20e3 Getting Current Order Book State","text":"<pre><code>dom_data = await account.market_book_get(symbol)\n</code></pre> <p>The method returns:</p> <ul> <li>a list of order levels</li> <li>each level contains price, volume, and type</li> </ul> <p>This is a snapshot of the market state at the current moment in time.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_add_HOW/#4-displaying-levels","title":"4\ufe0f\u20e3 Displaying Levels","text":"<pre><code>for book_entry in dom_data.mql_book_infos[:10]:\n</code></pre> <p>User code:</p> <ul> <li>chooses how many levels to display</li> <li>interprets the order type (BUY / SELL)</li> <li>formats the output</li> </ul> <p>The API does not participate in visualization.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_add_HOW/#5-closing-subscription","title":"5\ufe0f\u20e3 Closing Subscription","text":"<pre><code>await account.market_book_release(symbol)\n</code></pre> <p>Important:</p> <ul> <li>DOM must be explicitly closed</li> <li>this releases resources on the server and terminal</li> <li>without this, the subscription will remain active</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_add_HOW/#the-role-of-low-level-methods","title":"The Role of Low-Level Methods","text":"<p>Clear boundary of responsibility:</p> <p><code>market_book_add</code>:</p> <ul> <li>opens DOM</li> <li>registers subscription</li> </ul> <p><code>market_book_get</code>:</p> <ul> <li>returns current order book snapshot</li> <li>does not stream data</li> </ul> <p><code>market_book_release</code>:</p> <ul> <li>closes DOM</li> <li>releases resources</li> </ul> <p>User code:</p> <ul> <li>determines polling frequency</li> <li>formats data</li> <li>decides how long to monitor the market</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_add_HOW/#summary","title":"Summary","text":"<p>This example illustrates the standard DOM pattern:</p> <p>subscribe \u2192 regularly retrieve state \u2192 process \u2192 properly unsubscribe</p> <p>Low-level methods control DOM access, while all monitoring and data usage logic remains on the user side.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_get_HOW/","title":"market book get HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_get_HOW/#market_book_get-how-it-works","title":"market_book_get \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_get_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level asynchronous method <code>market_book_get()</code> to get the current Depth of Market (DOM) snapshot and perform custom liquidity calculations by BUY and SELL sides.</p> <p>In this scenario, DOM is used as a source of instantaneous market state, while all analytics and interpretation are performed on the client side.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_get_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def market_book_get(\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>the method is asynchronous and called with <code>await</code></li> <li>returns the current DOM snapshot, not a stream of updates</li> <li>does not aggregate or analyze data</li> <li>assumes that DOM subscription is already open</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_get_HOW/#code-example-calculating-total-liquidity","title":"\ud83e\udde9 Code Example \u2014 Calculating Total Liquidity","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def calculate_liquidity():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        symbol = \"EURUSD\"\n\n        # 1. Open DOM\n        await account.market_book_add(symbol)\n\n        # 2. Get current DOM snapshot\n        dom_data = await account.market_book_get(symbol)\n\n        # 3. Calculate total volume by side\n        sell_volume = sum(\n            e.volume_real for e in dom_data.mql_book_infos if e.type in [0, 2]\n        )\n        buy_volume = sum(\n            e.volume_real for e in dom_data.mql_book_infos if e.type in [1, 3]\n        )\n        total_volume = sell_volume + buy_volume\n\n        print(f\"[LIQUIDITY] {symbol}\")\n        print(f\"  Total DOM levels: {len(dom_data.mql_book_infos)}\")\n        print(f\"  BUY side volume: {buy_volume:.2f} lots\")\n        print(f\"  SELL side volume: {sell_volume:.2f} lots\")\n        print(f\"  Total volume: {total_volume:.2f} lots\")\n\n        if total_volume &gt; 0:\n            buy_percent = (buy_volume / total_volume) * 100\n            sell_percent = (sell_volume / total_volume) * 100\n\n            print(f\"\\n  BUY: {buy_percent:.1f}% | SELL: {sell_percent:.1f}%\")\n\n            if buy_percent &gt; 60:\n                print(\"  [SIGNAL] Strong BUY side liquidity\")\n            elif sell_percent &gt; 60:\n                print(\"  [SIGNAL] Strong SELL side liquidity\")\n            else:\n                print(\"  [SIGNAL] Balanced liquidity\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(calculate_liquidity())\n</code></pre> <p>This example demonstrates a complete user-level liquidity calculation based on DOM data.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_get_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_get_HOW/#1-opening-dom","title":"1\ufe0f\u20e3 Opening DOM","text":"<pre><code>await account.market_book_add(symbol)\n</code></pre> <p>At this step:</p> <ul> <li>the terminal starts maintaining the order book for the symbol</li> <li>without this call, <code>market_book_get</code> may return empty data</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_get_HOW/#2-getting-dom-snapshot","title":"2\ufe0f\u20e3 Getting DOM Snapshot","text":"<pre><code>dom_data = await account.market_book_get(symbol)\n</code></pre> <p>The method returns:</p> <ul> <li>a list of order levels <code>mql_book_infos</code></li> <li>each element represents one order book level</li> </ul> <p>This is an instantaneous snapshot, not a stream.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_get_HOW/#3-separating-orders-by-sides","title":"3\ufe0f\u20e3 Separating Orders by Sides","text":"<pre><code>e.type in [0, 2]  # SELL\ne.type in [1, 3]  # BUY\n</code></pre> <p>Order type determines the market side:</p> <ul> <li>SELL \u2014 liquidity offers</li> <li>BUY \u2014 liquidity demand</li> </ul> <p>Type interpretation is performed by the user.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_get_HOW/#4-volume-aggregation","title":"4\ufe0f\u20e3 Volume Aggregation","text":"<pre><code>sell_volume = sum(...)\nbuy_volume = sum(...)\n</code></pre> <p>At this step:</p> <ul> <li>volumes are summed by sides</li> <li>the API does not perform aggregation</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_get_HOW/#5-user-level-analytics","title":"5\ufe0f\u20e3 User-Level Analytics","text":"<pre><code>if buy_percent &gt; 60:\n    ...\nelif sell_percent &gt; 60:\n    ...\n</code></pre> <p>Threshold values:</p> <ul> <li>are chosen by the user</li> <li>do not have fixed values in the API</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_get_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>market_book_get()</code>:</p> <ul> <li>returns the current order book state</li> <li>does not store history</li> <li>does not calculate liquidity</li> <li>does not generate signals</li> </ul> <p>User code:</p> <ul> <li>aggregates volumes</li> <li>calculates percentages</li> <li>interprets the balance of supply and demand</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_get_HOW/#summary","title":"Summary","text":"<p>This example illustrates the DOM analysis pattern:</p> <p>get order book snapshot \u2192 aggregate levels \u2192 evaluate liquidity \u2192 make conclusions</p> <p>The <code>market_book_get()</code> method provides raw DOM data, while all analytics and signals are fully formed on the user side.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_release_HOW/","title":"market book release HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_release_HOW/#market_book_release-how-it-works","title":"market_book_release \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_release_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>The <code>market_book_release()</code> method is designed for explicitly terminating work with the Depth of Market (DOM) for a symbol.</p> <p>It does not exist for data retrieval or market analysis, but for correct lifecycle management of DOM as a resource.</p> <p>This method must be called always when work with the order book is completed.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_release_HOW/#why-market_book_release-exists","title":"Why market_book_release exists","text":"<p>DOM is not a one-time request, but an active resource:</p> <ul> <li>it is opened by calling <code>market_book_add()</code></li> <li>maintained by the server and terminal</li> <li>consumes resources</li> <li>exists over time</li> </ul> <p><code>market_book_release()</code> is needed to explicitly tell the system that:</p> <p>\"This order book is no longer needed, resources can be freed\"</p> <p>Without this call, DOM is considered active.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_release_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def market_book_release(\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n</code></pre> <p>Key points:</p> <ul> <li>the method is asynchronous</li> <li>works within an already established connection</li> <li>does not return market data</li> <li>does not close the connection to the server</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_release_HOW/#code-example-guaranteed-unsubscribe-via-context-manager","title":"\ud83e\udde9 Code Example \u2014 Guaranteed Unsubscribe via Context Manager","text":"<pre><code>from contextlib import asynccontextmanager\n\n@asynccontextmanager\nasync def dom_subscription(account, symbol):\n    try:\n        result = await account.market_book_add(symbol)\n        if not result.opened_successfully:\n            raise Exception(f\"Failed to subscribe to {symbol} DOM\")\n\n        print(f\"[SUBSCRIBED] {symbol} DOM\")\n        yield\n    finally:\n        await account.market_book_release(symbol)\n        print(f\"[RELEASED] {symbol} DOM\")\n</code></pre> <p>This example demonstrates the correct usage pattern for <code>market_book_release()</code>.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_release_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_release_HOW/#1-opening-dom","title":"1\ufe0f\u20e3 Opening DOM","text":"<pre><code>await account.market_book_add(symbol)\n</code></pre> <p>DOM is transferred to active state:</p> <ul> <li>the terminal starts maintaining the order book</li> <li>data becomes available through <code>market_book_get()</code></li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_release_HOW/#2-working-with-order-book-inside-context","title":"2\ufe0f\u20e3 Working with Order Book Inside Context","text":"<pre><code>yield\n</code></pre> <p>In this block:</p> <ul> <li>DOM is guaranteed to be open</li> <li>you can safely request its state</li> <li>user code can terminate in any way</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_release_HOW/#3-automatic-unsubscribe","title":"3\ufe0f\u20e3 Automatic Unsubscribe","text":"<pre><code>await account.market_book_release(symbol)\n</code></pre> <p>This code is executed always:</p> <ul> <li>on normal exit</li> <li>on <code>return</code></li> <li>on exception</li> </ul> <p>This is a key guarantee of correct resource release.</p>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_release_HOW/#what-market_book_release-does-and-does-not-do","title":"What market_book_release does and does NOT do","text":"<p>Does:</p> <ul> <li>closes DOM for the symbol</li> <li>releases terminal and server resources</li> <li>terminates order book subscription</li> </ul> <p>Does NOT:</p> <ul> <li>does not close the connection</li> <li>does not terminate the trading session</li> <li>does not affect other symbols</li> <li>does not return data</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_release_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>market_book_release()</code>:</p> <ul> <li>manages DOM lifecycle</li> <li>terminates resource work</li> </ul> <p>User code:</p> <ul> <li>decides when DOM is no longer needed</li> <li>guarantees the release call</li> <li>defines architecture (try/finally, context manager, etc.)</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/4.%20Market_Depth%28DOM%29_HOW/market_book_release_HOW/#summary","title":"Summary","text":"<p>The <code>market_book_release()</code> method was created for one specific purpose:</p> <p>explicitly and safely terminate work with the order book</p> <p>It is not optional and should be considered a mandatory step in any work with DOM.</p> <p>Correct usage pattern:</p> <p>open DOM \u2192 work \u2192 always release resource</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_margin_HOW/","title":"order calc margin HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_margin_HOW/#order_calc_margin-how-it-works","title":"order_calc_margin \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_margin_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level method <code>order_calc_margin()</code> to estimate acceptable position size based on specified risk.</p> <p>Important: in this example no trading operation is performed. The method is used exclusively for calculation \u2014 as a calculator, not as an action.</p> <p>The main task of the example:</p> <p>understand what position volume can be opened without exceeding the specified account risk.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_margin_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def order_calc_margin(\n    request: OrderCalcMarginRequest,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; OrderCalcMarginData\n</code></pre> <p>Key points:</p> <ul> <li>the method is asynchronous</li> <li>does not open trades</li> <li>does not reserve funds</li> <li>does not change account state</li> <li>returns only the calculated margin value</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_margin_HOW/#code-example-risk-based-position-sizing","title":"\ud83e\udde9 Code Example \u2014 Risk-based position sizing","text":"<pre><code>async def risk_based_sizing(symbol: str, risk_percent: float = 2.0):\n    \"\"\"Calculate position size based on risk percentage\"\"\"\n\n    # Get account summary information\n    summary = await account.account_summary()\n\n    # Maximum acceptable risk in money\n    max_risk_amount = summary.account_balance * (risk_percent / 100.0)\n\n    print(f\"Risk-based position sizing for {symbol}:\")\n    print(f\"  Account balance: ${summary.account_balance:,.2f}\")\n    print(f\"  Risk: {risk_percent}% = ${max_risk_amount:,.2f}\\n\")\n\n    # Check several possible volumes\n    volumes = [0.01, 0.05, 0.10, 0.20, 0.50, 1.00]\n\n    print(f\"{'Volume':&lt;10} {'Margin':&lt;15} {'% of Balance':&lt;15}\")\n    print(\"-\" * 45)\n\n    for volume in volumes:\n        request = OrderCalcMarginRequest(\n            symbol=symbol,\n            order_type=ORDER_TYPE_TF_BUY,\n            volume=volume,\n            open_price=1.0  # calculated price\n        )\n\n        result = await account.order_calc_margin(request)\n\n        margin_percent = (result.margin / summary.account_balance) * 100\n        status = \"[OK]\" if margin_percent &lt;= risk_percent else \"[OVER]\"\n\n        print(f\"{volume:&lt;10.2f} ${result.margin:&gt;12,.2f} {margin_percent:&gt;13.2f}% {status}\")\n</code></pre>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_margin_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_margin_HOW/#1-getting-account-balance","title":"1\ufe0f\u20e3 Getting Account Balance","text":"<pre><code>summary = await account.account_summary()\n</code></pre> <p>At this step:</p> <ul> <li>the current account balance is obtained</li> <li>it is used as the base for risk calculation</li> </ul> <p>This is source data, not related to trading.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_margin_HOW/#2-converting-risk-from-percentage-to-money","title":"2\ufe0f\u20e3 Converting Risk from Percentage to Money","text":"<pre><code>max_risk_amount = summary.account_balance * (risk_percent / 100.0)\n</code></pre> <p>Example:</p> <ul> <li>balance = $10,000</li> <li>risk = 2%</li> <li>acceptable risk = $200</li> </ul> <p>This is pure user business logic, not part of the API.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_margin_HOW/#3-forming-hypothetical-trade","title":"3\ufe0f\u20e3 Forming Hypothetical Trade","text":"<pre><code>request = OrderCalcMarginRequest(\n    symbol=symbol,\n    order_type=ORDER_TYPE_TF_BUY,\n    volume=volume,\n    open_price=1.0\n)\n</code></pre> <p>Important to understand:</p> <ul> <li>the trade is not opened</li> <li>parameters are used only for calculation</li> <li><code>open_price</code> can be a conditional value</li> </ul> <p>The request describes a planned, not a real operation.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_margin_HOW/#4-calculating-required-margin","title":"4\ufe0f\u20e3 Calculating Required Margin","text":"<pre><code>result = await account.order_calc_margin(request)\n</code></pre> <p>At this step:</p> <ul> <li>the server calculates the margin</li> <li>account settings, symbol, and order type are taken into account</li> <li>a single number is returned \u2014 <code>result.margin</code></li> </ul> <p>No account state is changed in the process.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_margin_HOW/#5-comparing-with-acceptable-risk","title":"5\ufe0f\u20e3 Comparing with Acceptable Risk","text":"<pre><code>margin_percent = (result.margin / summary.account_balance) * 100\n</code></pre> <p>Here user code:</p> <ul> <li>compares the calculated margin with acceptable risk</li> <li>makes a decision whether this volume is acceptable</li> </ul> <p>The API does not participate in this step.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_margin_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>order_calc_margin()</code>:</p> <ul> <li>performs server-side margin calculation</li> <li>opens nothing</li> <li>does not affect the account</li> </ul> <p>User code:</p> <ul> <li>defines risk</li> <li>selects volumes</li> <li>interprets the result</li> <li>makes trading decisions</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_margin_HOW/#summary","title":"Summary","text":"<p>This example illustrates a safe and correct pattern:</p> <p>plan trade \u2192 calculate margin \u2192 assess risk \u2192 make decision</p> <p>The <code>order_calc_margin()</code> method is intended precisely for the planning stage and should be used before opening a trade, not after.</p> <p>It allows making informed decisions without risking account state.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_profit_HOW/","title":"order calc profit HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_profit_HOW/#order_calc_profit-how-it-works","title":"order_calc_profit \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_profit_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level method <code>order_calc_profit()</code> to calculate potential profit or loss before executing a trade.</p> <p>Important: in this example no trading operation is performed. The method is used exclusively for calculation \u2014 as a calculator, not as an action.</p> <p>The main task of the example:</p> <p>calculate risk/reward ratio to assess trade viability before opening a position.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_profit_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def order_calc_profit(\n    request: OrderCalcProfitRequest,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; OrderCalcProfitData\n</code></pre> <p>Key points:</p> <ul> <li>the method is asynchronous</li> <li>does not open trades</li> <li>does not reserve funds</li> <li>does not change account state</li> <li>returns only the calculated profit/loss value</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_profit_HOW/#code-example-riskreward-calculation","title":"\ud83e\udde9 Code Example \u2014 Risk/Reward calculation","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\nimport MetaRpcMT5.mt5_term_api_trade_functions_pb2 as trade_pb2\n\nasync def calc_risk_reward():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    try:\n        entry = 1.10000\n        stop_loss = 1.09950  # 50 pips SL\n        take_profit = 1.10100  # 100 pips TP\n\n        # Calculate potential loss (hitting SL)\n        loss_req = trade_pb2.OrderCalcProfitRequest(\n            order_type=trade_pb2.ORDER_TYPE_BUY,\n            symbol=\"EURUSD\",\n            volume=0.10,\n            open_price=entry,\n            close_price=stop_loss\n        )\n\n        loss_result = await account.order_calc_profit(loss_req)\n        risk = abs(loss_result.profit)\n\n        # Calculate potential profit (hitting TP)\n        profit_req = trade_pb2.OrderCalcProfitRequest(\n            order_type=trade_pb2.ORDER_TYPE_BUY,\n            symbol=\"EURUSD\",\n            volume=0.10,\n            open_price=entry,\n            close_price=take_profit\n        )\n\n        profit_result = await account.order_calc_profit(profit_req)\n        reward = profit_result.profit\n\n        rr_ratio = reward / risk\n\n        print(f\"[RISK/REWARD ANALYSIS]\")\n        print(f\"  Entry: {entry}\")\n        print(f\"  SL: {stop_loss} (Risk: ${risk:.2f})\")\n        print(f\"  TP: {take_profit} (Reward: ${reward:.2f})\")\n        print(f\"  R:R Ratio: 1:{rr_ratio:.2f}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(calc_risk_reward())\n</code></pre>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_profit_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_profit_HOW/#1-connection-and-setup","title":"1\ufe0f\u20e3 Connection and Setup","text":"<pre><code>account = MT5Account(\n    user=12345,\n    password=\"password\",\n    grpc_server=\"mt5.mrpc.pro:443\"\n)\n\nawait account.connect_by_server_name(\n    server_name=\"YourBroker-Demo\",\n    base_chart_symbol=\"EURUSD\"\n)\n</code></pre> <p>At this step:</p> <ul> <li>MT5Account instance is created with connection credentials</li> <li>connection to MetaTrader 5 terminal is established via gRPC</li> <li>base chart symbol is specified for initialization</li> </ul> <p>This is standard connection procedure required before any operations.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_profit_HOW/#2-defining-trade-parameters","title":"2\ufe0f\u20e3 Defining Trade Parameters","text":"<pre><code>entry = 1.10000\nstop_loss = 1.09950  # 50 pips SL\ntake_profit = 1.10100  # 100 pips TP\n</code></pre> <p>Here:</p> <ul> <li>entry price is defined (planned opening price)</li> <li>stop loss level is set 50 pips below entry</li> <li>take profit level is set 100 pips above entry</li> </ul> <p>These are hypothetical values for planning purposes. No trade is opened yet.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_profit_HOW/#3-calculating-potential-loss-risk","title":"3\ufe0f\u20e3 Calculating Potential Loss (Risk)","text":"<pre><code>loss_req = trade_pb2.OrderCalcProfitRequest(\n    order_type=trade_pb2.ORDER_TYPE_BUY,\n    symbol=\"EURUSD\",\n    volume=0.10,\n    open_price=entry,\n    close_price=stop_loss\n)\n\nloss_result = await account.order_calc_profit(loss_req)\nrisk = abs(loss_result.profit)\n</code></pre> <p>Important to understand:</p> <ul> <li>the trade is not opened</li> <li>we calculate what would happen if stop loss is hit</li> <li><code>open_price=entry</code> and <code>close_price=stop_loss</code> simulate worst-case scenario</li> <li><code>abs()</code> is used because loss returns negative value</li> </ul> <p>The request describes a planned, not a real operation.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_profit_HOW/#4-calculating-potential-profit-reward","title":"4\ufe0f\u20e3 Calculating Potential Profit (Reward)","text":"<pre><code>profit_req = trade_pb2.OrderCalcProfitRequest(\n    order_type=trade_pb2.ORDER_TYPE_BUY,\n    symbol=\"EURUSD\",\n    volume=0.10,\n    open_price=entry,\n    close_price=take_profit\n)\n\nprofit_result = await account.order_calc_profit(profit_req)\nreward = profit_result.profit\n</code></pre> <p>At this step:</p> <ul> <li>the server calculates profit if take profit is hit</li> <li>same trade parameters (symbol, volume, order type)</li> <li>only <code>close_price</code> differs \u2014 now it's the take profit level</li> <li>result is positive value representing potential gain</li> </ul> <p>No account state is changed in the process.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_profit_HOW/#5-calculating-riskreward-ratio","title":"5\ufe0f\u20e3 Calculating Risk/Reward Ratio","text":"<pre><code>rr_ratio = reward / risk\n</code></pre> <p>Here user code:</p> <ul> <li>divides potential reward by potential risk</li> <li>produces the Risk/Reward ratio</li> <li>example: if reward=$100 and risk=$50, R:R = 2.0 (or 1:2)</li> </ul> <p>The API does not participate in this step \u2014 it's pure business logic.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_profit_HOW/#6-displaying-results","title":"6\ufe0f\u20e3 Displaying Results","text":"<pre><code>print(f\"[RISK/REWARD ANALYSIS]\")\nprint(f\"  Entry: {entry}\")\nprint(f\"  SL: {stop_loss} (Risk: ${risk:.2f})\")\nprint(f\"  TP: {take_profit} (Reward: ${reward:.2f})\")\nprint(f\"  R:R Ratio: 1:{rr_ratio:.2f}\")\n</code></pre> <p>Output example:</p> <pre><code>[RISK/REWARD ANALYSIS]\n  Entry: 1.1\n  SL: 1.0995 (Risk: $50.00)\n  TP: 1.101 (Reward: $100.00)\n  R:R Ratio: 1:2.00\n</code></pre> <p>This shows the trader that for every $1 risked, they could gain $2 \u2014 a favorable 1:2 risk/reward ratio.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_profit_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>order_calc_profit()</code>:</p> <ul> <li>performs server-side profit calculation</li> <li>takes into account symbol properties, lot size, and price movement</li> <li>opens nothing</li> <li>does not affect the account</li> </ul> <p>User code:</p> <ul> <li>defines entry, stop loss, and take profit levels</li> <li>makes two calculations (risk and reward)</li> <li>interprets the result</li> <li>makes trading decisions based on R:R ratio</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_calc_profit_HOW/#summary","title":"Summary","text":"<p>This example illustrates a professional trading pattern:</p> <p>plan trade \u2192 calculate risk \u2192 calculate reward \u2192 assess ratio \u2192 make decision</p> <p>The <code>order_calc_profit()</code> method is intended precisely for the planning stage and should be used before opening a trade, not after.</p> <p>It allows making informed decisions without risking account state.</p> <p>Typical use cases:</p> <ul> <li>Calculate risk/reward ratio before entering trade</li> <li>Determine if trade setup meets your trading rules (e.g., minimum 1:2 R:R)</li> <li>Calculate pip value for different lot sizes</li> <li>Compare profitability across different symbols</li> <li>Plan exit strategies based on expected profit/loss</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_check_HOW/","title":"order check HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_check_HOW/#order_check-how-it-works","title":"order_check \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_check_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level method <code>order_check()</code> to verify trade request executability before actually sending it to the server.</p> <p>The method is used at the pre-trade validation stage and answers a key question:</p> <p>\"Will the server accept such a trade right now under current conditions?\"</p> <p>Important: <code>order_check()</code> does not open a trade and does not change account state. It is used exclusively for verification.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_check_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def order_check(\n    request: OrderCheckRequest,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; OrderCheckData\n</code></pre> <p>Key points:</p> <ul> <li>the method is asynchronous</li> <li>accepts an almost complete trade request</li> <li>performs server-side validation</li> <li>does not create an order and does not reserve funds</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_check_HOW/#code-example-checking-multiple-volumes","title":"\ud83e\udde9 Code Example \u2014 Checking multiple volumes","text":"<pre><code>async def check_multiple_volumes():\n    volumes = [0.01, 0.05, 0.10, 0.50, 1.00]\n\n    print(\"Checking volumes for EURUSD BUY:\")\n    print(\"-\" * 60)\n\n    for volume in volumes:\n        request = OrderCheckRequest()\n        request.mql_trade_request.action = TRADE_ACTION_DEAL\n        request.mql_trade_request.symbol = \"EURUSD\"\n        request.mql_trade_request.volume = volume\n        request.mql_trade_request.order_type = ORDER_TYPE_TF_BUY\n        request.mql_trade_request.price = 0.0\n        request.mql_trade_request.deviation = 20\n        request.mql_trade_request.type_filling = ORDER_FILLING_FOK\n        request.mql_trade_request.type_time = ORDER_TIME_GTC\n\n        result = await account.order_check(request)\n\n        if result.mql_trade_check_result.returned_code == 0:\n            print(\n                f\"[OK] {volume:&gt;6.2f} lots - \"\n                f\"Margin: ${result.mql_trade_check_result.margin:&gt;10,.2f}, \"\n                f\"Free: ${result.mql_trade_check_result.free_margin:&gt;10,.2f}\"\n            )\n        else:\n            print(\n                f\"[FAIL] {volume:&gt;6.2f} lots - \"\n                f\"{result.mql_trade_check_result.comment}\"\n            )\n</code></pre>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_check_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_check_HOW/#1-iterating-through-potential-volumes","title":"1\ufe0f\u20e3 Iterating Through Potential Volumes","text":"<pre><code>volumes = [0.01, 0.05, 0.10, 0.50, 1.00]\n</code></pre> <p>Here user code:</p> <ul> <li>defines possible position sizes</li> <li>does not know in advance which are acceptable</li> <li>uses <code>order_check()</code> as a verification tool</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_check_HOW/#2-forming-trade-request","title":"2\ufe0f\u20e3 Forming Trade Request","text":"<pre><code>request.mql_trade_request.action = TRADE_ACTION_DEAL\nrequest.mql_trade_request.symbol = \"EURUSD\"\nrequest.mql_trade_request.volume = volume\nrequest.mql_trade_request.order_type = ORDER_TYPE_TF_BUY\n</code></pre> <p>Important:</p> <ul> <li>the request structure matches a real order</li> <li>all critically important parameters are set</li> <li>this is a planned, not an actual trade</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_check_HOW/#3-server-side-order-validation","title":"3\ufe0f\u20e3 Server-Side Order Validation","text":"<pre><code>result = await account.order_check(request)\n</code></pre> <p>At this stage the server checks:</p> <ul> <li>parameter correctness</li> <li>fund sufficiency</li> <li>broker trading restrictions</li> <li>current market conditions</li> <li>execution possibility (filling, deviation)</li> </ul> <p>No account state changes occur.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_check_HOW/#4-analyzing-validation-result","title":"4\ufe0f\u20e3 Analyzing Validation Result","text":"<pre><code>result.mql_trade_check_result.returned_code\n</code></pre> <p>Interpretation:</p> <ul> <li><code>0</code> \u2014 order can be executed</li> <li>non-zero value \u2014 order will be rejected</li> </ul> <p>Additionally returned:</p> <ul> <li>calculated margin</li> <li>free margin after the trade</li> <li>text comment explaining rejection reason</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_check_HOW/#5-identifying-acceptable-volume-range","title":"5\ufe0f\u20e3 Identifying Acceptable Volume Range","text":"<p>By iterating through volumes, user code:</p> <ul> <li>finds the maximum acceptable volume</li> <li>sees where rejection begins</li> <li>gets the exact reason for the limitation</li> </ul> <p>This is the final stage before actual trading.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_check_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>order_check()</code>:</p> <ul> <li>validates trade request on the server</li> <li>returns technical validation result</li> <li>does not make trading decisions</li> </ul> <p>User code:</p> <ul> <li>forms trade parameters</li> <li>iterates through volumes</li> <li>interprets the result</li> <li>decides whether to send the order</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_check_HOW/#summary","title":"Summary","text":"<p>This example illustrates the last safe step before trading:</p> <p>check executability \u2192 analyze result \u2192 make decision</p> <p>The <code>order_check()</code> method is designed for strict pre-trade validation and should be used before <code>order_send()</code>, especially when dynamically selecting volume and in automated trading.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_close_HOW/","title":"order close HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_close_HOW/#order_close-how-it-works","title":"order_close \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_close_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level method <code>order_close()</code> for actually closing an already open trading position.</p> <p>Unlike calculation and validation methods, <code>order_close()</code> initiates an actual trading operation that:</p> <ul> <li>changes account state</li> <li>closes the position</li> <li>locks in the financial result</li> </ul> <p>The method is used when a position already exists and its <code>ticket</code> is known.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_close_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def order_close(\n    request: OrderCloseRequest,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; OrderCloseData\n</code></pre> <p>Key points:</p> <ul> <li>the method is asynchronous</li> <li>executes a trading operation</li> <li>works with a specific ticket</li> <li>returns the execution result</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_close_HOW/#code-example-closing-entire-position","title":"\ud83e\udde9 Code Example \u2014 Closing entire position","text":"<pre><code>request = OrderCloseRequest(\n    ticket=123456,\n    volume=0,        # 0 = close position completely\n    slippage=20      # maximum acceptable slippage\n)\n\nresult = await account.order_close(request)\n\nif result.returned_code == 10009:\n    print(\"[SUCCESS] Position closed\")\nelse:\n    print(f\"[FAILED] Code: {result.returned_code}\")\n    print(f\"Description: {result.returned_code_description}\")\n</code></pre>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_close_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_close_HOW/#1-specifying-position-ticket","title":"1\ufe0f\u20e3 Specifying Position Ticket","text":"<pre><code>ticket=123456\n</code></pre> <p>The ticket uniquely identifies the position:</p> <ul> <li>the method does not search for the position automatically</li> <li>does not check its existence beforehand</li> <li>responsibility for ticket correctness lies with the user</li> </ul> <p>If the ticket is incorrect \u2014 the server will return an error.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_close_HOW/#2-full-position-close-via-volume-0","title":"2\ufe0f\u20e3 Full Position Close via <code>volume = 0</code>","text":"<pre><code>volume=0\n</code></pre> <p>Parameter feature:</p> <ul> <li><code>0</code> means close position completely</li> <li>the server determines the current position volume itself</li> <li>no need to know the actual size</li> </ul> <p>If you specify <code>volume &gt; 0</code>, a partial close will be executed.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_close_HOW/#3-slippage-control","title":"3\ufe0f\u20e3 Slippage Control","text":"<pre><code>slippage=20\n</code></pre> <p>This parameter sets:</p> <ul> <li>maximum acceptable price deviation</li> <li>protection against unfavorable execution</li> <li>trading constraint, not API logic</li> </ul> <p>If the price moved beyond the acceptable range \u2014 the close may be rejected.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_close_HOW/#4-executing-trading-operation","title":"4\ufe0f\u20e3 Executing Trading Operation","text":"<pre><code>result = await account.order_close(request)\n</code></pre> <p>At this stage:</p> <ul> <li>a trading command is sent to the server</li> <li>an attempt to close the position at market occurs</li> <li>account state may change</li> </ul> <p>This is an unsafe operation in the sense that it affects the trading result.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_close_HOW/#5-checking-execution-result","title":"5\ufe0f\u20e3 Checking Execution Result","text":"<pre><code>result.returned_code\n</code></pre> <p>The return code determines the operation outcome:</p> <ul> <li><code>10009</code> \u2014 successful execution</li> <li>any other value \u2014 rejection</li> </ul> <p>Additionally, a text description of the rejection reason is returned.</p> <p>Checking the result is a mandatory part of correct method usage.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_close_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>order_close()</code>:</p> <ul> <li>sends the position close command</li> <li>attempts to execute it on the server</li> <li>returns the technical result</li> </ul> <p>User code:</p> <ul> <li>selects the position to close</li> <li>determines the close volume</li> <li>sets acceptable slippage</li> <li>analyzes the result</li> <li>makes further decisions</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_close_HOW/#summary","title":"Summary","text":"<p>The <code>order_close()</code> method is used for explicit and controlled position closing.</p> <p>Correct usage pattern:</p> <p>form request \u2192 send \u2192 check result \u2192 act further</p> <p>This is a basic building block for automated trading systems, risk management, and market exit strategies.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_modify_HOW/","title":"order modify HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_modify_HOW/#order_modify-how-it-works","title":"order_modify \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_modify_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level method <code>order_modify()</code> to modify parameters of an already existing order, specifically \u2014 changing the entry price of a pending order.</p> <p>Important to understand:</p> <ul> <li>the order already exists</li> <li>it has a <code>ticket</code></li> <li>the method does not create a new order</li> <li>the method does not open a position</li> </ul> <p>It is used when you need to adapt a previously placed order to the current market situation.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_modify_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def order_modify(\n    request: OrderModifyRequest,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; OrderModifyData\n</code></pre> <p>Key points:</p> <ul> <li>the method is asynchronous</li> <li>executes a real trading action</li> <li>works with an existing order by <code>ticket</code></li> <li>modifies only explicitly specified parameters</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_modify_HOW/#code-example-modify-pending-order-price","title":"\ud83e\udde9 Code Example \u2014 Modify pending order price","text":"<pre><code># Get current instrument price\ntick_data = await account.symbol_info_tick(\"EURUSD\")\ncurrent_bid = tick_data.bid\n\n# Calculate new price (15 pips below market)\npip_size = 0.0001\nnew_price = current_bid - (15 * pip_size)\n\n# Form order modification request\nrequest = OrderModifyRequest(\n    ticket=789012,      # ticket of existing pending order\n    stop_loss=0,        # SL is not changed\n    take_profit=0,      # TP is not changed\n    price=new_price     # new entry price\n)\n\nresult = await account.order_modify(request)\n</code></pre>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_modify_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_modify_HOW/#1-getting-current-market-price","title":"1\ufe0f\u20e3 Getting Current Market Price","text":"<pre><code>tick_data = await account.symbol_info_tick(\"EURUSD\")\ncurrent_bid = tick_data.bid\n</code></pre> <p>At this step:</p> <ul> <li>the last tick for the symbol is requested</li> <li>current Bid price is used</li> <li>the API returns only market data, without trading logic</li> </ul> <p>The price is used as the basis for calculating the new order price.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_modify_HOW/#2-calculating-new-price-for-pending-order","title":"2\ufe0f\u20e3 Calculating New Price for Pending Order","text":"<pre><code>new_price = current_bid - (15 * pip_size)\n</code></pre> <p>This is user trading logic:</p> <ul> <li>the order is shifted below the current price</li> <li>typical scenario for BUY LIMIT</li> <li>the shift amount (15 pips) is set by the strategy</li> </ul> <p>The API does not participate in this step.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_modify_HOW/#3-forming-ordermodifyrequest","title":"3\ufe0f\u20e3 Forming OrderModifyRequest","text":"<pre><code>request = OrderModifyRequest(\n    ticket=789012,\n    stop_loss=0,\n    take_profit=0,\n    price=new_price\n)\n</code></pre> <p>Key points:</p> <ul> <li><code>ticket</code> \u2014 identifier of the order being modified</li> <li>only the <code>price</code> parameter is being changed</li> <li>SL and TP parameters are explicitly indicated as unchanged</li> </ul> <p>The <code>order_modify()</code> method does not make assumptions and does not change parameters that were not passed.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_modify_HOW/#4-sending-modification-command","title":"4\ufe0f\u20e3 Sending Modification Command","text":"<pre><code>result = await account.order_modify(request)\n</code></pre> <p>At this stage:</p> <ul> <li>a trading command is sent to the server</li> <li>the server checks the validity of the new price</li> <li>broker restrictions and trading rules are taken into account</li> </ul> <p>The order is either modified or the operation is rejected.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_modify_HOW/#5-operation-result","title":"5\ufe0f\u20e3 Operation Result","text":"<p>The response contains:</p> <ul> <li>operation execution code</li> <li>result description</li> <li>updated order information</li> </ul> <p>The result must be checked by user code.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_modify_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>order_modify()</code>:</p> <ul> <li>accepts order modification request</li> <li>attempts to apply changes on the server</li> <li>returns the technical result</li> <li>does not calculate trading logic</li> </ul> <p>User code:</p> <ul> <li>decides when and why to change the order</li> <li>calculates the new price</li> <li>selects parameters to modify</li> <li>analyzes the operation result</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_modify_HOW/#summary","title":"Summary","text":"<p>The <code>order_modify()</code> method is used for precise modification of existing order parameters.</p> <p>Correct usage pattern:</p> <p>get market data \u2192 calculate new parameters \u2192 send modification \u2192 check result</p> <p>It is a key tool for dynamic management of pending orders in automated trading strategies.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_send_HOW/","title":"order send HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_send_HOW/#order_send-how-it-works","title":"order_send \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_send_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level method <code>order_send()</code> for actually sending a trading order to the server with result handling and retry logic.</p> <p>The <code>order_send()</code> method is the key point of the entire trading chain:</p> <ul> <li>calculations and checks are performed before it</li> <li>account state may change after it</li> </ul> <p>This is where the trading decision turns into action.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_send_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def order_send(\n    request: OrderSendRequest,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[asyncio.Event] = None,\n) -&gt; OrderSendData\n</code></pre> <p>Key points:</p> <ul> <li>the method is asynchronous</li> <li>executes a real trading operation</li> <li>sends order to the server</li> <li>returns the execution result</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_send_HOW/#code-example-order-with-retry-logic","title":"\ud83e\udde9 Code Example \u2014 Order with retry logic","text":"<pre><code>request = OrderSendRequest(\n    symbol=\"EURUSD\",\n    operation=ORDER_TYPE_BUY,\n    volume=0.01,\n    price=0,\n    slippage=20,\n    comment=\"Order with retry\",\n    expert_id=12345\n)\n\nmax_retries = 3\nretry_delay = 1.0\n\nfor attempt in range(1, max_retries + 1):\n    print(f\"[ATTEMPT {attempt}/{max_retries}]\")\n\n    result = await account.order_send(request)\n\n    if result.returned_code == 10009:\n        print(f\"[SUCCESS] Order executed on attempt {attempt}\")\n        print(f\"Deal: #{result.deal}, Price: {result.price}\")\n        break\n    else:\n        print(f\"[FAILED] Code: {result.returned_code}\")\n        print(f\"Reason: {result.returned_code_description}\")\n\n        if attempt &lt; max_retries:\n            await asyncio.sleep(retry_delay)\n</code></pre>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_send_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_send_HOW/#1-forming-trading-request","title":"1\ufe0f\u20e3 Forming Trading Request","text":"<pre><code>request = OrderSendRequest(...)\n</code></pre> <p>At this stage:</p> <ul> <li>a complete trading order is formed</li> <li>all required parameters are specified</li> <li>the request fully describes the future trade</li> </ul> <p>This is the same object used in actual trading.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_send_HOW/#2-sending-order-to-server","title":"2\ufe0f\u20e3 Sending Order to Server","text":"<pre><code>result = await account.order_send(request)\n</code></pre> <p>On each call:</p> <ul> <li>the request is sent to the trading server</li> <li>the server attempts to execute the order</li> <li>the execution result is returned</li> </ul> <p>Important: absence of exception does not mean success.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_send_HOW/#3-checking-execution-result","title":"3\ufe0f\u20e3 Checking Execution Result","text":"<pre><code>result.returned_code\n</code></pre> <p>The return code determines the operation outcome:</p> <ul> <li><code>10009</code> \u2014 order successfully executed</li> <li>any other value \u2014 rejection</li> </ul> <p>Additionally, the server returns:</p> <ul> <li>deal number (<code>deal</code>)</li> <li>execution price (<code>price</code>)</li> <li>text description of rejection reason</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_send_HOW/#4-retry-logic","title":"4\ufe0f\u20e3 Retry Logic","text":"<pre><code>for attempt in range(...)\n</code></pre> <p>Retry logic is implemented entirely in user code:</p> <ul> <li>the API does not retry automatically</li> <li>the user decides how many times to try</li> <li>a pause is maintained between attempts</li> </ul> <p>This allows adaptation to changing market conditions.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_send_HOW/#5-loop-completion","title":"5\ufe0f\u20e3 Loop Completion","text":"<p>The loop terminates:</p> <ul> <li>on successful order execution</li> <li>or after exhausting all attempts</li> </ul> <p>In both cases, user code knows exactly the operation outcome.</p>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_send_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>order_send()</code>:</p> <ul> <li>sends the trading order</li> <li>attempts to execute it on the server</li> <li>returns the technical result</li> <li>does not guarantee success</li> <li>does not retry attempts</li> </ul> <p>User code:</p> <ul> <li>forms the trading decision</li> <li>defines retry strategy</li> <li>analyzes the result</li> <li>manages the risk of repeated submissions</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/5.%20Trading_Operations_HOW/order_send_HOW/#summary","title":"Summary","text":"<p>The <code>order_send()</code> method is the final step of the trading chain:</p> <p>calculation \u2192 validation \u2192 sending \u2192 result</p> <p>Correct usage always implies:</p> <ul> <li>checking <code>returned_code</code></li> <li>handling rejections</li> <li>conscious management of retry attempts</li> </ul> <p>This approach makes trading systems robust and predictable in real market conditions.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/","title":"on position profit HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#on_position_profit-how-it-works","title":"on_position_profit \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example shows how to use the low-level streaming method <code>on_position_profit()</code> for reacting to profit changes of open positions in real time and executing automatic trading actions when a specified condition is met.</p> <p>In this case, a logical take-profit is implemented:</p> <p>if position profit reaches a specified value \u2014 the position is automatically closed.</p> <p>Important: this is not a server-side TP, but user logic built on top of the update stream.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def on_position_profit(\n    interval_ms: int,\n    ignore_empty: bool = True,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    -&gt; AsyncIterator[OnPositionProfitData]\n</code></pre> <p>Key points:</p> <ul> <li>the method is asynchronous and streaming (<code>async for</code>)</li> <li>works over time, not as a one-time call</li> <li>returns updates, not a complete state snapshot</li> <li>does not make trading decisions</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#code-example-auto-take-profit-on-profit-target","title":"\ud83e\udde9 Code Example \u2014 Auto take-profit on profit target","text":"<pre><code>async for update in account.on_position_profit(\n    interval_ms=500,\n    ignore_empty=True\n):\n    for pos in update.updated_positions:\n        if pos.profit &gt;= target_profit:\n            close_req = OrderCloseRequest(\n                ticket=pos.ticket,\n                volume=0,\n                slippage=20,\n                comment=\"Auto TP\"\n            )\n\n            result = await account.order_close(close_req)\n\n            if result.returned_code == 10009:\n                print(f\"[SUCCESS] Position #{pos.ticket} closed\")\n            else:\n                print(f\"[FAILED] Code: {result.returned_code}\")\n                print(f\"Description: {result.returned_code_description}\")\n</code></pre>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#1-subscribing-to-profit-update-stream","title":"1\ufe0f\u20e3 Subscribing to Profit Update Stream","text":"<pre><code>async for update in account.on_position_profit(...):\n</code></pre> <p>At this stage:</p> <ul> <li>a subscription to profit updates is created</li> <li>the server periodically sends data</li> <li>the loop runs until explicitly stopped</li> </ul> <p>This is a stream, not a regular request.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#2-update-interval","title":"2\ufe0f\u20e3 Update Interval","text":"<pre><code>interval_ms=500\n</code></pre> <p>The parameter sets:</p> <ul> <li>server polling frequency</li> <li>balance between freshness and load</li> </ul> <p>The method does not work \"on market event\", but at a specified interval.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#3-filtering-empty-updates","title":"3\ufe0f\u20e3 Filtering Empty Updates","text":"<pre><code>ignore_empty=True\n</code></pre> <p>When enabled:</p> <ul> <li>frames without changes are skipped</li> <li>user code receives only meaningful events</li> </ul> <p>This simplifies processing and reduces noise.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#4-working-only-with-changed-positions","title":"4\ufe0f\u20e3 Working Only with Changed Positions","text":"<pre><code>for pos in update.updated_positions:\n</code></pre> <p>Important:</p> <ul> <li>not all positions come in every update</li> <li>only those whose profit has changed</li> <li>this is a typical event-driven pattern</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#5-checking-user-condition","title":"5\ufe0f\u20e3 Checking User Condition","text":"<pre><code>if pos.profit &gt;= target_profit:\n</code></pre> <p>Here user business logic is executed:</p> <ul> <li>the API does not know what target profit is</li> <li>the API does not compare values</li> <li>the API only reports facts</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#6-initiating-trading-action","title":"6\ufe0f\u20e3 Initiating Trading Action","text":"<pre><code>result = await account.order_close(close_req)\n</code></pre> <p>When condition is met:</p> <ul> <li>a position close command is sent</li> <li>account state may change</li> <li>a real trading operation is executed</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#7-checking-close-result","title":"7\ufe0f\u20e3 Checking Close Result","text":"<pre><code>if result.returned_code == 10009:\n</code></pre> <p>Even automatic closing:</p> <ul> <li>is not considered successful by default</li> <li>requires result verification (code 10009 = successful execution)</li> <li>may be rejected by the server</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#the-role-of-low-level-method","title":"The Role of Low-Level Method","text":"<p>Clear boundary of responsibility:</p> <p><code>on_position_profit()</code>:</p> <ul> <li>supplies profit update stream</li> <li>does not make decisions</li> <li>does not close positions</li> </ul> <p><code>order_close()</code>:</p> <ul> <li>executes trading action</li> <li>attempts to close position</li> <li>returns result</li> </ul> <p>User code:</p> <ul> <li>sets target profit</li> <li>makes closing decision</li> <li>connects event and action</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#architectural-pattern","title":"Architectural Pattern","text":"<p>This example illustrates a fundamental pattern:</p> <p>stream \u2192 condition \u2192 action</p> <p>Or in trading strategy terms:</p> <p>observation \u2192 trigger \u2192 execution</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_position_profit_HOW/#summary","title":"Summary","text":"<p>The <code>on_position_profit()</code> method is designed for reactive position state control.</p> <p>It allows building custom management strategies:</p> <ul> <li>take-profit</li> <li>trailing logic</li> <li>risk-based exits</li> </ul> <p>while remaining strictly a low-level data source, not a decision-making mechanism.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/","title":"on positions and pending orders tickets HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#on_positions_and_pending_orders_tickets-how-it-works","title":"on_positions_and_pending_orders_tickets \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p>This example demonstrates a complete usage scenario of the streaming low-level method <code>on_positions_and_pending_orders_tickets()</code> for tracking changes in account trading state and transforming these changes into user-defined events.</p> <p>Key idea of the example:</p> <p>The server does not report what exactly happened \u2014 it only returns the current state. All interpretation is performed on the client side.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def on_positions_and_pending_orders_tickets(\n    interval_ms: int,\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    -&gt; AsyncIterator[OnPositionsAndPendingOrdersTicketsData]\n</code></pre>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#code-example-ticket-change-logger-to-file","title":"\ud83e\udde9 Code Example \u2014 Ticket change logger to file","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom MetaRpcMT5 import MT5Account\n\nasync def log_ticket_changes():\n    prev_positions = set()\n    prev_orders = set()\n\n    with open('ticket_changes.log', 'w') as logfile:\n        logfile.write(\"Timestamp,Event,Ticket\\n\")\n\n        async for update in account.on_positions_and_pending_orders_tickets(\n            interval_ms=1000\n        ):\n            timestamp = datetime.now().isoformat()\n\n            current_positions = set(update.position_tickets)\n            current_orders = set(update.pending_order_tickets)\n\n            for ticket in current_positions - prev_positions:\n                logfile.write(f\"{timestamp},POSITION_OPENED,{ticket}\\n\")\n                logfile.flush()\n\n            for ticket in prev_positions - current_positions:\n                logfile.write(f\"{timestamp},POSITION_CLOSED,{ticket}\\n\")\n                logfile.flush()\n\n            for ticket in current_orders - prev_orders:\n                logfile.write(f\"{timestamp},ORDER_CREATED,{ticket}\\n\")\n                logfile.flush()\n\n            for ticket in prev_orders - current_orders:\n                logfile.write(f\"{timestamp},ORDER_REMOVED,{ticket}\\n\")\n                logfile.flush()\n\n            prev_positions = current_positions\n            prev_orders = current_orders\n\nasyncio.run(log_ticket_changes())\n</code></pre>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#detailed-step-by-step-explanation","title":"\ud83d\udfe2 Detailed Step-by-Step Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#1-user-state-initialization","title":"1\ufe0f\u20e3 User state initialization","text":"<pre><code>prev_positions = set()\nprev_orders = set()\n</code></pre> <p>User code creates local state upfront, which will be used for comparison.</p> <p>The API method does not store history and has no knowledge of previous calls.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#2-opening-log-file","title":"2\ufe0f\u20e3 Opening log file","text":"<pre><code>with open('ticket_changes.log', 'w') as logfile:\n</code></pre> <p>This is purely user responsibility:</p> <ul> <li>file format</li> <li>storage method</li> <li>write policy</li> </ul> <p>The API does not participate in this.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#3-subscribing-to-streaming-updates","title":"3\ufe0f\u20e3 Subscribing to streaming updates","text":"<pre><code>async for update in account.on_positions_and_pending_orders_tickets(...):\n</code></pre> <p>At this stage:</p> <ul> <li>a long-lived stream is created</li> <li>server periodically sends full snapshot</li> <li>loop continues until cancellation</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#4-receiving-current-snapshot","title":"4\ufe0f\u20e3 Receiving current snapshot","text":"<pre><code>current_positions = set(update.position_tickets)\ncurrent_orders = set(update.pending_order_tickets)\n</code></pre> <p>Each update contains:</p> <ul> <li>full list of position ticket IDs</li> <li>full list of pending order ticket IDs</li> </ul> <p>This is state, not an event.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#5-user-diff-logic","title":"5\ufe0f\u20e3 User diff logic","text":"<pre><code>current_positions - prev_positions\nprev_positions - current_positions\n</code></pre> <p>This is where key user work happens:</p> <ul> <li>determine what appeared</li> <li>determine what disappeared</li> </ul> <p>The API intentionally does not do this for the user.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#6-interpreting-diff-as-events","title":"6\ufe0f\u20e3 Interpreting diff as events","text":"<pre><code>POSITION_OPENED\nPOSITION_CLOSED\nORDER_CREATED\nORDER_REMOVED\n</code></pre> <p>At this stage the user:</p> <ul> <li>gives meaning to changes</li> <li>introduces custom event types</li> <li>decides what is considered important</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#7-recording-result","title":"7\ufe0f\u20e3 Recording result","text":"<pre><code>logfile.write(...)\nlogfile.flush()\n</code></pre> <p>Processing result:</p> <ul> <li>is saved</li> <li>can be passed further</li> <li>can be used for auditing</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#8-updating-base-state","title":"8\ufe0f\u20e3 Updating base state","text":"<pre><code>prev_positions = current_positions\nprev_orders = current_orders\n</code></pre> <p>This closes the processing loop and prepares the code for the next snapshot.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#role-of-low-level-method","title":"Role of low-level method","text":"<p><code>on_positions_and_pending_orders_tickets()</code>:</p> <ul> <li>returns current state of ticket IDs</li> <li>does not analyze changes</li> <li>does not classify events</li> </ul> <p>User logic:</p> <ul> <li>stores state</li> <li>calculates diff</li> <li>interprets events</li> <li>decides what to do with them</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_positions_and_pending_orders_tickets_HOW/#summary","title":"Summary","text":"<p>This method is the foundation for building state-based logic:</p> <ul> <li>loggers</li> <li>audit</li> <li>alerts</li> <li>external systems synchronization</li> </ul> <p>It deliberately remains low-level and delegates all semantics to the user.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/","title":"on symbol tick HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#on_symbol_tick-how-it-works","title":"on_symbol_tick \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p><code>on_symbol_tick()</code> is a low-level streaming method designed to receive raw tick data in real-time for one or multiple symbols.</p> <p>The method provides access to each market tick (bid / ask), but does not perform any calculations or maintain state. All derived metrics, analytics, and trading logic are implemented exclusively on the user side.</p> <p>In this example, the tick stream is used to collect bid-ask spread statistics over a fixed time period.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def on_symbol_tick(\n    symbols: list[str],\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    -&gt; AsyncIterator[OnSymbolTickData]\n</code></pre> <p>Key features:</p> <ul> <li>asynchronous streaming method (<code>async for</code>)</li> <li>returns stream of tick updates</li> <li>has no built-in stop mechanism</li> <li>lifetime is fully controlled by the user</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#code-example-track-bid-ask-spread-statistics","title":"\ud83e\udde9 Code Example \u2014 Track bid-ask spread statistics","text":"<pre><code>import asyncio\nfrom collections import defaultdict\nfrom MetaRpcMT5 import MT5Account\n\nasync def track_spread_stats():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    spreads = defaultdict(list)\n    cancel_event = asyncio.Event()\n\n    async def stop_after(seconds: int):\n        await asyncio.sleep(seconds)\n        cancel_event.set()\n\n    try:\n        asyncio.create_task(stop_after(60))\n\n        symbols = [\"EURUSD\", \"GBPUSD\"]\n\n        async for tick_data in account.on_symbol_tick(\n            symbols=symbols,\n            cancellation_event=cancel_event\n        ):\n            tick = tick_data.symbol_tick\n            spread = tick.ask - tick.bid\n            spreads[tick.symbol].append(spread)\n\n        print(\"\\n=== Spread Statistics ===\")\n        for symbol, values in spreads.items():\n            avg_spread = sum(values) / len(values)\n            print(f\"\\n{symbol}:\")\n            print(f\"  Ticks received: {len(values)}\")\n            print(f\"  Average spread: {avg_spread * 10000:.1f} pips\")\n            print(f\"  Min spread: {min(values) * 10000:.1f} pips\")\n            print(f\"  Max spread: {max(values) * 10000:.1f} pips\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(track_spread_stats())\n</code></pre>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#1-data-storage-preparation","title":"1\ufe0f\u20e3 Data Storage Preparation","text":"<pre><code>spreads = defaultdict(list)\n</code></pre> <p>A structure is created to accumulate user data:</p> <ul> <li>key \u2014 trading symbol name</li> <li>value \u2014 list of recorded spread values</li> </ul> <p>The <code>on_symbol_tick()</code> method does not aggregate or store history, so all statistics are collected manually.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#2-stream-lifetime-management","title":"2\ufe0f\u20e3 Stream Lifetime Management","text":"<pre><code>cancel_event = asyncio.Event()\n</code></pre> <p>The stream has no built-in termination mechanism.</p> <p>The stream lifetime is fully controlled by the user via <code>cancellation_event</code>.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#3-asynchronous-timer-based-termination","title":"3\ufe0f\u20e3 Asynchronous Timer-Based Termination","text":"<pre><code>async def stop_after(seconds: int):\n    await asyncio.sleep(seconds)\n    cancel_event.set()\n</code></pre> <p>Helper coroutine:</p> <ul> <li>runs in parallel with tick processing</li> <li>waits for the specified time interval</li> <li>properly terminates the stream without exceptions</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#4-subscribing-to-tick-stream","title":"4\ufe0f\u20e3 Subscribing to Tick Stream","text":"<pre><code>async for tick_data in account.on_symbol_tick(\n    symbols=symbols,\n    cancellation_event=cancel_event\n):\n</code></pre> <p>At this stage:</p> <ul> <li>subscription is created for the specified symbols</li> <li>server starts sending tick updates</li> <li>each loop iteration corresponds to one market tick</li> </ul> <p>The method returns an event stream, not market state.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#5-user-side-tick-processing","title":"5\ufe0f\u20e3 User-Side Tick Processing","text":"<pre><code>spread = tick.ask - tick.bid\nspreads[tick.symbol].append(spread)\n</code></pre> <p>This is where all business logic is executed:</p> <ul> <li>calculation of derived values</li> <li>data aggregation</li> <li>analytics preparation</li> </ul> <p>The API acts exclusively as a data source in this process.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#6-stream-termination-and-post-processing","title":"6\ufe0f\u20e3 Stream Termination and Post-Processing","text":"<p>After <code>cancel_event</code> is set:</p> <ul> <li>data stream terminates properly</li> <li>user code proceeds to analysis</li> <li>any necessary calculations are performed</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#7-post-processing-and-statistics-output","title":"7\ufe0f\u20e3 Post-Processing and Statistics Output","text":"<pre><code>print(\"\\n=== Spread Statistics ===\")\nfor symbol, values in spreads.items():\n    avg_spread = sum(values) / len(values)\n    print(f\"\\n{symbol}:\")\n    print(f\"  Ticks received: {len(values)}\")\n    print(f\"  Average spread: {avg_spread * 10000:.1f} pips\")\n    print(f\"  Min spread: {min(values) * 10000:.1f} pips\")\n    print(f\"  Max spread: {max(values) * 10000:.1f} pips\")\n</code></pre> <p>At this stage, the stream is already completed, and the code works exclusively with accumulated data.</p> <p>The following is performed here:</p> <ul> <li>iteration through all symbols for which ticks were received</li> <li>analysis of collected spread values</li> <li>calculation of aggregated metrics</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#number-of-received-ticks","title":"Number of Received Ticks","text":"<pre><code>len(values)\n</code></pre> <p>Shows:</p> <ul> <li>how many market events were received</li> <li>actual stream density</li> <li>indirect assessment of symbol liquidity for the selected period</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#average-spread","title":"Average Spread","text":"<pre><code>avg_spread = sum(values) / len(values)\n</code></pre> <p>The average value is calculated after stream completion:</p> <ul> <li>API does not provide ready-made aggregates</li> <li>calculations are performed on the user side</li> <li>formula can be modified for any requirements</li> </ul> <p>Conversion to pips:</p> <pre><code>avg_spread * 10000\n</code></pre> <p>\u2014 this is a user convention, not part of the API.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#minimum-and-maximum-spread","title":"Minimum and Maximum Spread","text":"<pre><code>min(values)\nmax(values)\n</code></pre> <p>Allows to:</p> <ul> <li>assess the range of spread fluctuations</li> <li>identify extreme values</li> <li>compare behavior of different symbols</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#final-responsibility-model","title":"Final Responsibility Model","text":"<p><code>on_symbol_tick()</code>:</p> <ul> <li>delivers raw market events</li> <li>does not interpret data</li> <li>does not manage lifetime</li> <li>does not store history</li> </ul> <p>User code:</p> <ul> <li>manages subscription</li> <li>determines processing duration</li> <li>calculates metrics</li> <li>builds analytics or strategies</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_symbol_tick_HOW/#summary","title":"Summary","text":"<p>This example illustrates the raw data streaming pattern:</p> <p>subscribe \u2192 receive raw ticks \u2192 accumulate data \u2192 calculate statistics</p> <p>Key points:</p> <ul> <li><code>on_symbol_tick()</code> delivers raw market ticks (bid/ask), not derived metrics</li> <li>each tick is an atomic market event</li> <li>user code is responsible for:</li> <li>storing tick history</li> <li>calculating derived values (spread, averages, min/max)</li> <li>determining stream lifetime</li> <li>post-processing accumulated data</li> </ul> <p>The API acts purely as a data source, while all analytics, aggregation, and interpretation remain entirely on the user side.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_HOW/","title":"on trade HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_HOW/#on_trade-how-it-works","title":"on_trade \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p><code>on_trade()</code> is a low-level streaming method for subscribing to all account trading events in real-time.</p> <p>It provides a unified stream of changes related to:</p> <ul> <li>positions</li> <li>orders</li> <li>deals</li> </ul> <p>The method does not separate events into different streams and does not perform business logic. It only records the fact of trading state changes, leaving interpretation and reaction entirely on the user side.</p> <p>In this example, <code>on_trade()</code> is used as a universal trading logger, tracking and displaying all types of trading events.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def on_trade(\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    -&gt; AsyncIterator[OnTradeData]\n</code></pre> <p>Key features:</p> <ul> <li>asynchronous streaming method (<code>async for</code>)</li> <li>returns stream of account trading events</li> <li>combines positions, orders, and deals</li> <li>has no built-in timeout</li> <li>can be stopped via <code>cancellation_event</code> or external interruption</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_HOW/#code-example-trade-event-logger","title":"\ud83e\udde9 Code Example \u2014 Trade event logger","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom MetaRpcMT5 import MT5Account\n\nasync def log_trade_events():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    event_count = 0\n\n    try:\n        async for trade_data in account.on_trade():\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            event = trade_data.event_data\n\n            for pos in event.new_positions:\n                event_count += 1\n                print(f\"[{timestamp}] NEW_POSITION | Index: {pos.index}\")\n\n            for pos in event.disappeared_positions:\n                event_count += 1\n                print(f\"[{timestamp}] CLOSED_POSITION | Index: {pos.index}\")\n\n            for pos in event.updated_positions:\n                event_count += 1\n                print(f\"[{timestamp}] UPDATED_POSITION | Index: {pos.index}\")\n\n            for order in event.new_orders:\n                event_count += 1\n                print(f\"[{timestamp}] NEW_ORDER | Index: {order.index}\")\n\n            for order in event.state_changed_orders:\n                event_count += 1\n                print(f\"[{timestamp}] ORDER_STATE_CHANGE | Index: {order.index}\")\n\n            for deal in event.new_history_deals:\n                event_count += 1\n                print(f\"[{timestamp}] NEW_DEAL | Index: {deal.index}\")\n\n            if event_count % 10 == 0:\n                print(f\"\\n--- Total events logged: {event_count} ---\\n\")\n\n    except KeyboardInterrupt:\n        print(f\"\\nStopping logger. Total events: {event_count}\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(log_trade_events())\n</code></pre>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_HOW/#1-subscribing-to-trading-events","title":"1\ufe0f\u20e3 Subscribing to Trading Events","text":"<pre><code>async for trade_data in account.on_trade():\n</code></pre> <p>A subscription to the trading changes stream is created:</p> <ul> <li>server sends updates on any trading event</li> <li>stream operates continuously</li> <li>each iteration is a batch of changes, not a single event</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_HOW/#2-event-container-event_data","title":"2\ufe0f\u20e3 Event Container <code>event_data</code>","text":"<pre><code>event = trade_data.event_data\n</code></pre> <p><code>event_data</code> contains lists of changes grouped by types:</p> <ul> <li><code>new_positions</code></li> <li><code>disappeared_positions</code></li> <li><code>updated_positions</code></li> <li><code>new_orders</code></li> <li><code>state_changed_orders</code></li> <li><code>new_history_deals</code></li> </ul> <p>Each list can be empty or contain multiple elements.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_HOW/#3-processing-events-as-lists","title":"3\ufe0f\u20e3 Processing Events as Lists","text":"<pre><code>for pos in event.new_positions:\n</code></pre> <p>A single trading update can include multiple events of the same type.</p> <p>Therefore:</p> <ul> <li>processing is always done through loops</li> <li>cannot assume one object per update</li> <li>code is resilient to high trading activity</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_HOW/#4-logging-event-facts","title":"4\ufe0f\u20e3 Logging Event Facts","text":"<p>For each detected event:</p> <ul> <li>local time is recorded</li> <li>event counter is incremented</li> <li>event type and its index are displayed</li> </ul> <p>Log example:</p> <pre><code>[2026-02-05 12:01:22] NEW_POSITION | Index: 123456\n</code></pre>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_HOW/#5-event-counter","title":"5\ufe0f\u20e3 Event Counter","text":"<pre><code>event_count += 1\n</code></pre> <p>Counter is used for:</p> <ul> <li>monitoring stream activity</li> <li>debugging statistics</li> <li>periodic logger state output</li> </ul> <pre><code>if event_count % 10 == 0:\n</code></pre> <p>Every 10 events, an intermediate summary is displayed.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_HOW/#6-stream-termination","title":"6\ufe0f\u20e3 Stream Termination","text":"<p>In this example, the stream is considered infinite:</p> <ul> <li>termination is done manually (<code>Ctrl+C</code>)</li> <li><code>KeyboardInterrupt</code> is explicitly caught</li> <li>connection is closed properly</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_HOW/#final-responsibility-model","title":"Final Responsibility Model","text":"<p><code>on_trade()</code>:</p> <ul> <li>delivers trading events</li> <li>combines positions, orders, and deals</li> <li>does not interpret changes</li> <li>does not make trading decisions</li> </ul> <p>User code:</p> <ul> <li>chooses which events to process</li> <li>implements reaction or logging logic</li> <li>manages stream lifetime</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_HOW/#summary","title":"Summary","text":"<p>This example illustrates the unified trading event streaming pattern:</p> <p>subscribe \u2192 receive trade events \u2192 classify by type \u2192 process each category</p> <p>Key points:</p> <ul> <li><code>on_trade()</code> delivers unified stream of all trading activity (positions, orders, deals)</li> <li>each update may contain multiple event types simultaneously</li> <li>user code is responsible for:</li> <li>iterating through event lists (<code>new_positions</code>, <code>disappeared_positions</code>, etc.)</li> <li>classifying event types</li> <li>implementing business logic per event type</li> <li>logging or reacting to changes</li> </ul> <p>The API acts as a comprehensive trading event source, combining positions, orders, and deals into a single stream, while all event handling and business logic remain entirely on the user side.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/","title":"on trade transaction HOW","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/#on_trade_transaction-how-it-works","title":"on_trade_transaction \u2014 How it works","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/#overview","title":"\ud83d\udccc Overview","text":"<p><code>on_trade_transaction()</code> is a low-level streaming method for receiving atomic trading transactions in real-time.</p> <p>Each transaction reflects one specific trading action or state transition, for example:</p> <ul> <li>order appearance</li> <li>order state change</li> <li>execution</li> <li>closing</li> </ul> <p>Unlike aggregated trading streams, this method is designed for auditing, debugging, and restoring complete event history.</p> <p>In this example, <code>on_trade_transaction()</code> is used to track order lifecycle, recording all their states by <code>order_ticket</code>.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/#method-signature","title":"Method Signature","text":"<pre><code>async def on_trade_transaction(\n    cancellation_event: Optional[asyncio.Event] = None,\n):\n    -&gt; AsyncIterator[OnTradeTransactionData]\n</code></pre> <p>Key features:</p> <ul> <li>asynchronous stream (<code>async for</code>)</li> <li>returns atomic trading transactions</li> <li>does not aggregate events</li> <li>does not store history</li> <li>designed for detailed analysis of trading processes</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/#code-example-order-lifecycle-tracker","title":"\ud83e\udde9 Code Example \u2014 Order lifecycle tracker","text":"<pre><code>import asyncio\nfrom MetaRpcMT5 import MT5Account\n\nasync def track_order_lifecycle():\n    account = MT5Account(\n        user=12345,\n        password=\"password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    await account.connect_by_server_name(\n        server_name=\"YourBroker-Demo\",\n        base_chart_symbol=\"EURUSD\"\n    )\n\n    order_states = {}  # order_ticket -&gt; list of states\n\n    try:\n        async for tx_data in account.on_trade_transaction():\n            tx = tx_data.trade_transaction\n\n            if tx.order_ticket &gt; 0:\n                if tx.order_ticket not in order_states:\n                    order_states[tx.order_ticket] = []\n\n                order_states[tx.order_ticket].append({\n                    'state': tx.order_state,\n                    'type': tx.type,\n                    'price': tx.price,\n                    'volume': tx.volume\n                })\n\n                print(f\"\\n[LIFECYCLE] Order #{tx.order_ticket}:\")\n                for i, state in enumerate(order_states[tx.order_ticket], 1):\n                    print(f\"   {i}. State: {state['state']}, \"\n                          f\"Type: {state['type']}, \"\n                          f\"Price: {state['price']}\")\n\n    except KeyboardInterrupt:\n        print(\"\\nStopping lifecycle tracker...\")\n        print(f\"\\nTracked {len(order_states)} orders\")\n\n    finally:\n        await account.channel.close()\n\nasyncio.run(track_order_lifecycle())\n</code></pre>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/#detailed-explanation","title":"\ud83d\udfe2 Detailed Explanation","text":""},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/#1-subscribing-to-trade-transaction-stream","title":"1\ufe0f\u20e3 Subscribing to Trade Transaction Stream","text":"<pre><code>async for tx_data in account.on_trade_transaction():\n</code></pre> <p>A subscription to the low-level trading stream is created:</p> <ul> <li>server sends each trading transaction</li> <li>events arrive as they occur</li> <li>stream does not aggregate or filter data</li> </ul> <p>Each loop iteration is one atomic event.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/#2-extracting-transaction","title":"2\ufe0f\u20e3 Extracting Transaction","text":"<pre><code>tx = tx_data.trade_transaction\n</code></pre> <p><code>trade_transaction</code> describes a single trading action and contains:</p> <ul> <li>order identifier (<code>order_ticket</code>)</li> <li>current order state (<code>order_state</code>)</li> <li>operation type</li> <li>price and volume</li> </ul> <p>This is the minimal unit of trading history.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/#3-filtering-order-transactions","title":"3\ufe0f\u20e3 Filtering Order Transactions","text":"<pre><code>if tx.order_ticket &gt; 0:\n</code></pre> <p>Not every trading transaction relates to orders.</p> <p>Filtering allows to:</p> <ul> <li>exclude service and irrelevant events</li> <li>focus on order lifecycle</li> <li>not mix different types of trading entities</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/#4-initializing-order-history","title":"4\ufe0f\u20e3 Initializing Order History","text":"<pre><code>if tx.order_ticket not in order_states:\n    order_states[tx.order_ticket] = []\n</code></pre> <p>On first appearance of <code>order_ticket</code>:</p> <ul> <li>a new record is created</li> <li>state history collection begins</li> <li>subsequent events are added sequentially</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/#5-recording-order-state","title":"5\ufe0f\u20e3 Recording Order State","text":"<pre><code>order_states[tx.order_ticket].append({...})\n</code></pre> <p>Each transaction is saved as a lifecycle step:</p> <ul> <li>order state</li> <li>operation type</li> <li>deal parameters</li> </ul> <p>The <code>on_trade_transaction()</code> method does not store history \u2014 this is the user's responsibility.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/#6-reconstructing-lifecycle","title":"6\ufe0f\u20e3 Reconstructing Lifecycle","text":"<pre><code>for i, state in enumerate(order_states[tx.order_ticket], 1):\n</code></pre> <p>Order history is displayed completely on each new event:</p> <ul> <li>transition sequence is visible</li> <li>convenient for analyzing order behavior</li> <li>useful for diagnostics and auditing</li> </ul> <p>This is a diagnostic technique, not a mandatory pattern.</p>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/#7-stream-termination","title":"7\ufe0f\u20e3 Stream Termination","text":"<p>In this example, the stream runs indefinitely:</p> <ul> <li>termination is manual (<code>Ctrl+C</code>)</li> <li><code>KeyboardInterrupt</code> is caught</li> <li>connection is closed properly</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/#final-responsibility-model","title":"Final Responsibility Model","text":"<p><code>on_trade_transaction()</code>:</p> <ul> <li>delivers atomic trading transactions</li> <li>reflects each step of the trading process</li> <li>does not aggregate or interpret events</li> <li>does not store history</li> </ul> <p>User code:</p> <ul> <li>groups transactions</li> <li>reconstructs lifecycles</li> <li>performs auditing and analysis</li> <li>builds diagnostic tools</li> </ul>"},{"location":"MT5Account/HOW_IT_WORK/6.%20Streaming_Methods_HOW/on_trade_transaction_HOW/#summary","title":"Summary","text":"<p>This example illustrates the transaction-level event sourcing pattern:</p> <p>subscribe \u2192 receive atomic events \u2192 group by entity \u2192 reconstruct lifecycle</p> <p>Key points:</p> <ul> <li><code>on_trade_transaction()</code> delivers atomic trade events, not aggregated state</li> <li>each event represents a single step in the trading process</li> <li>user code is responsible for:</li> <li>grouping events (by <code>order_ticket</code>)</li> <li>preserving their order</li> <li>reconstructing higher-level meaning (order lifecycle)</li> </ul> <p>The API acts purely as a source of facts, while all interpretation, history building, and analysis remain entirely on the user side.</p>"},{"location":"MT5Service/1.%20Account_Information/","title":"\u2705 MT5Service - Account Methods (Mid-Level API)","text":""},{"location":"MT5Service/1.%20Account_Information/#important-read-this-first","title":"Important: Read This First","text":"<p>MT5Service is an architectural layer between high-level (Sugar) and low-level (Account) APIs.</p>"},{"location":"MT5Service/1.%20Account_Information/#understanding-the-4-methods","title":"Understanding the 4 Methods:","text":"Method Direct Use Value Architectural Role <code>get_account_summary()</code> HIGH - Aggregates 14 props + datetime conversion Used by Sugar <code>get_account_double()</code> NONE - Just calls <code>account.account_info_double()</code> Used by Sugar <code>get_account_integer()</code> NONE - Just calls <code>account.account_info_integer()</code> Used by Sugar <code>get_account_string()</code> NONE - Just calls <code>account.account_info_string()</code> Used by Sugar"},{"location":"MT5Service/1.%20Account_Information/#what-this-means","title":"What This Means:","text":"<p>\ud83c\udfd7\ufe0f Architecture (3 layers):</p> <pre><code>MT5Sugar (HIGH)     service.get_account_double()  Sugar uses Service methods\nMT5Service (MID)    account.account_info_double()  Service is a pass-through layer\nMT5Account (LOW)    gRPC call to MT5 server\n</code></pre> <p>For direct MT5Service usage:</p> <ul> <li>Use <code>get_account_summary()</code> - real improvement (1 call vs 14 calls)</li> <li>Skip other 3 methods - no value, just call MT5Account directly</li> </ul> <p>For MT5Sugar users:</p> <ul> <li>All methods work perfectly - the layer serves its architectural purpose</li> </ul> <p>API Layer: MID-LEVEL - wrappers over MT5Account with Python native types</p> <p>Implementation:</p> <p>These methods are implemented in <code>src/pymt5/mt5_service.py</code>, which wraps <code>package/MetaRpcMT5/helpers/mt5_account.py</code> low-level API.</p> <p>Example files:</p> <ul> <li><code>examples/2_service/04_service_demo.py</code> - comprehensive demo of all MT5Service methods including account information (STEP 2)</li> </ul>"},{"location":"MT5Service/1.%20Account_Information/#why-these-methods-exist","title":"Why These Methods Exist","text":""},{"location":"MT5Service/1.%20Account_Information/#real-value-get_account_summary","title":"Real Value: get_account_summary()","text":"<p>The main benefit of MT5Service for account information is <code>get_account_summary()</code>:</p> <p>What it does: - Makes 5 internal RPC calls (1 summary + 4 individual properties) - Converts protobuf <code>Timestamp</code> Python <code>datetime</code> - Aggregates 14 fields into one clean <code>AccountSummary</code> dataclass - Single method call instead of 14 separate <code>account_info_*()</code> calls</p> <p>Example: <pre><code># MT5Service - ONE call gets everything\nsummary = await service.get_account_summary()\nprint(f\"Balance: {summary.balance}, Equity: {summary.equity}\")\nprint(f\"Leverage: {summary.leverage}, Server time: {summary.server_time}\")  # datetime!\n\n# vs MT5Account - 14 separate calls needed\nbalance = await account.account_info_double(account_info_pb2.ACCOUNT_BALANCE)\nequity = await account.account_info_double(account_info_pb2.ACCOUNT_EQUITY)\nleverage = await account.account_info_integer(account_info_pb2.ACCOUNT_LEVERAGE)\n# ... 11 more calls ...\n</code></pre></p>"},{"location":"MT5Service/1.%20Account_Information/#other-methods-architectural-layer","title":"Other Methods: Architectural Layer","text":"<p><code>get_account_double()</code>, <code>get_account_integer()</code>, <code>get_account_string()</code> are thin wrappers that serve as architectural layer:</p> <p>Why they exist: - MT5Sugar (high-level) uses them - maintains layered architecture (Sugar Service Account) - Unified interface - all methods accessible through one class - Consistent naming - <code>get_*</code> prefix across all Service methods - No processing - direct pass-through to <code>account.account_info_*()</code></p> <p>For end users: If you're using MT5Service directly (not Sugar), calling MT5Account is identical. These wrappers add no value.</p> <p>For MT5Sugar: These are essential - Sugar must work through Service, not directly with Account (layered architecture).</p>"},{"location":"MT5Service/1.%20Account_Information/#all-4-methods","title":"All 4 Methods","text":"Method Returns Implementation <code>get_account_summary()</code> <code>AccountSummary</code> dataclass Aggregates 5 RPC calls + converts Timestamp datetime <code>get_account_double(property_id)</code> <code>float</code> <code>return await self._account.account_info_double(property_id)</code> <code>get_account_integer(property_id)</code> <code>int</code> <code>return await self._account.account_info_integer(property_id)</code> <code>get_account_string(property_id)</code> <code>str</code> <code>return await self._account.account_info_string(property_id)</code>"},{"location":"MT5Service/1.%20Account_Information/#accountsummary-dataclass-dto","title":"\u2795 AccountSummary Dataclass (DTO)","text":"<pre><code>@dataclass\nclass AccountSummary:\n    \"\"\"Complete account information in one convenient structure.\"\"\"\n\n    login: int                                      # Account login number\n    balance: float                                  # Account balance in deposit currency\n    equity: float                                   # Account equity (Balance + Floating P&amp;L)\n    user_name: str                                  # Client name\n    leverage: int                                   # Account leverage (e.g., 100 for 1:100)\n    trade_mode: Any                                 # Account trade mode (demo/real/contest)\n    company_name: str                               # Broker company name\n    currency: str                                   # Deposit currency (USD, EUR, etc.)\n    server_time: Optional[datetime]                 # Server time (already datetime!)\n    utc_timezone_shift_minutes: int                 # UTC timezone shift in minutes\n    credit: float                                   # Credit facility amount\n    margin: float                                   # Margin used for open positions\n    free_margin: float                              # Free margin available for trading\n    margin_level: float                             # Margin level percentage (equity/margin * 100)\n    profit: float                                   # Current floating profit/loss\n</code></pre> <p>Advantage: All 14 important properties in one dataclass, <code>server_time</code> is already <code>datetime</code> (no need for manual conversion).</p>"},{"location":"MT5Service/1.%20Account_Information/#method-signatures","title":"Method Signatures","text":""},{"location":"MT5Service/1.%20Account_Information/#1-get_account_summary","title":"1) get_account_summary","text":"<pre><code>async def get_account_summary(\n    self,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; AccountSummary\n</code></pre> <p>Returns all account information in a single call (14 fields in one dataclass).</p> <p>Technical: Makes 5 internal RPC calls: 1. <code>account_summary()</code> - gets 11 basic fields 2-5. <code>account_info_double()</code> x 4 - gets margin, free_margin, margin_level, profit</p> <p>Result: AccountSummary dataclass with 14 fields in native Python types.</p> <p>Advantage: Single method call vs 14 separate AccountInfo* calls (93% code reduction).</p>"},{"location":"MT5Service/1.%20Account_Information/#2-get_account_double","title":"2) get_account_double","text":"<pre><code>async def get_account_double(\n    self,\n    property_id: account_info_pb2.AccountInfoDoublePropertyType,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; float\n</code></pre> <p>Available property_id:</p> <pre><code>from MetaRpcMT5 import mt5_term_api_account_information_pb2 as account_info_pb2\n\n# Available properties:\nACCOUNT_BALANCE = 0          # Account balance\nACCOUNT_CREDIT = 1           # Credit\nACCOUNT_PROFIT = 2           # Current profit/loss\nACCOUNT_EQUITY = 3           # Equity (balance + floating P&amp;L)\nACCOUNT_MARGIN = 4           # Used margin\nACCOUNT_MARGIN_FREE = 5      # Free margin\nACCOUNT_MARGIN_LEVEL = 6     # Margin level (%)\nACCOUNT_MARGIN_SO_CALL = 7   # Margin call level\nACCOUNT_MARGIN_SO_SO = 8     # Stop out level\nACCOUNT_MARGIN_INITIAL = 9   # Initial margin\nACCOUNT_MARGIN_MAINTENANCE = 10  # Maintenance margin\nACCOUNT_ASSETS = 11          # Current assets\nACCOUNT_LIABILITIES = 12     # Current liabilities\nACCOUNT_COMMISSION_BLOCKED = 13  # Blocked commission\n</code></pre> <p>Returns: <code>float</code> value directly.</p> <p>Technical: Thin wrapper over <code>account.account_info_double()</code> which already returns float. Provides consistent <code>get_*</code> naming convention.</p>"},{"location":"MT5Service/1.%20Account_Information/#3-get_account_integer","title":"3) get_account_integer","text":"<pre><code>async def get_account_integer(\n    self,\n    property_id: account_info_pb2.AccountInfoIntegerPropertyType,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; int\n</code></pre> <p>Available property_id:</p> <pre><code>ACCOUNT_LOGIN = 0            # Account number\nACCOUNT_TRADE_MODE = 1       # Trade mode (0=demo, 2=real)\nACCOUNT_LEVERAGE = 2         # Leverage (e.g., 100 for 1:100)\nACCOUNT_LIMIT_ORDERS = 3     # Max pending orders\nACCOUNT_MARGIN_SO_MODE = 4   # Margin SO mode\nACCOUNT_TRADE_ALLOWED = 5    # Trading allowed (0/1)\nACCOUNT_TRADE_EXPERT = 6     # EA trading allowed (0/1)\nACCOUNT_MARGIN_MODE = 7      # Margin calculation mode\nACCOUNT_CURRENCY_DIGITS = 8  # Currency decimal places\nACCOUNT_FIFO_CLOSE = 9       # FIFO close mandatory (0/1)\nACCOUNT_HEDGE_ALLOWED = 10   # Hedging allowed (0/1)\n</code></pre> <p>Returns: <code>int</code> value directly.</p> <p>Technical: Thin wrapper over <code>account.account_info_integer()</code> which already returns int. Provides consistent <code>get_*</code> naming convention.</p>"},{"location":"MT5Service/1.%20Account_Information/#4-get_account_string","title":"4) get_account_string","text":"<pre><code>async def get_account_string(\n    self,\n    property_id: account_info_pb2.AccountInfoStringPropertyType,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; str\n</code></pre> <p>Available property_id:</p> <pre><code>ACCOUNT_NAME = 0             # Account owner name\nACCOUNT_SERVER = 1           # Trading server name\nACCOUNT_CURRENCY = 2         # Deposit currency (USD, EUR, etc.)\nACCOUNT_COMPANY = 3          # Broker company name\n</code></pre> <p>Returns: <code>str</code> value directly.</p> <p>Technical: Thin wrapper over <code>account.account_info_string()</code> which already returns str. Provides consistent <code>get_*</code> naming convention.</p>"},{"location":"MT5Service/1.%20Account_Information/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Service/1.%20Account_Information/#recommended-get_account_summary-for-multiple-properties","title":"Recommended: get_account_summary() for Multiple Properties","text":"<pre><code>async def display_account_info(service: MT5Service):\n    # BEST way - use get_account_summary for multiple properties\n    summary = await service.get_account_summary()\n\n    print(f\"Account: {summary.login}\")\n    print(f\"Balance: ${summary.balance:.2f} {summary.currency}\")\n    print(f\"Equity: ${summary.equity:.2f}\")\n    print(f\"Floating P/L: ${summary.profit:.2f}\")\n    print(f\"Margin: ${summary.margin:.2f}\")\n    print(f\"Free Margin: ${summary.free_margin:.2f}\")\n    print(f\"Margin Level: {summary.margin_level:.2f}%\")\n    print(f\"Leverage: 1:{summary.leverage}\")\n    print(f\"Broker: {summary.company_name}\")\n\n    # server_time is already datetime (no conversion needed!)\n    if summary.server_time:\n        print(f\"Server time: {summary.server_time.strftime('%Y-%m-%d %H:%M:%S')}\")\n</code></pre>"},{"location":"MT5Service/1.%20Account_Information/#building-a-dashboard","title":"Building a Dashboard","text":"<pre><code>async def display_dashboard(service: MT5Service):\n    \"\"\"Display comprehensive account dashboard.\"\"\"\n\n    summary = await service.get_account_summary()\n\n    print(\"=\" * 60)\n    print(f\"{'ACCOUNT DASHBOARD':^60}\")\n    print(\"=\" * 60)\n\n    # Account Info\n    print(f\"\\nAccount Information:\")\n    print(f\"   Login:          {summary.login}\")\n    print(f\"   Name:           {summary.user_name}\")\n    print(f\"   Broker:         {summary.company_name}\")\n    print(f\"   Currency:       {summary.currency}\")\n    print(f\"   Leverage:       1:{summary.leverage}\")\n\n    # Financial Status\n    print(f\"\\nFinancial Status:\")\n    print(f\"   Balance:        ${summary.balance:,.2f}\")\n    print(f\"   Equity:         ${summary.equity:,.2f}\")\n    print(f\"   Floating P/L:   ${summary.profit:+,.2f}\")\n    print(f\"   Credit:         ${summary.credit:,.2f}\")\n\n    # Margin Status\n    print(f\"\\nMargin Status:\")\n    print(f\"   Used Margin:    ${summary.margin:,.2f}\")\n    print(f\"   Free Margin:    ${summary.free_margin:,.2f}\")\n    print(f\"   Margin Level:   {summary.margin_level:.2f}%\")\n\n    # Warning if margin level is low\n    if summary.margin_level &lt; 100 and summary.margin &gt; 0:\n        print(f\"\\nWARNING: Low margin level!\")\n\n    print(\"=\" * 60)\n</code></pre>"},{"location":"MT5Service/1.%20Account_Information/#quick-reference","title":"Quick Reference","text":"<p>For multiple account properties: Use <code>get_account_summary()</code> <pre><code>summary = await service.get_account_summary()  # Gets all 14 fields in one call\n</code></pre></p> <p>For single property (rare use case): Use <code>get_account_double/integer/string()</code> or call MT5Account directly <pre><code># Both are identical:\nbalance = await service.get_account_double(account_info_pb2.ACCOUNT_BALANCE)\nbalance = await account.account_info_double(account_info_pb2.ACCOUNT_BALANCE)\n</code></pre></p>"},{"location":"MT5Service/1.%20Account_Information/#related-sections","title":"\ud83d\udcda Related Sections","text":"<ul> <li>MT5Service Overview - mid-level API overview</li> <li>MT5Sugar Overview - high-level convenience API</li> <li>Symbol Methods (Mid-Level) - methods for working with symbols</li> <li>Account Information (Low-Level) - low-level account API</li> <li>Trading Methods (Mid-Level) - trading methods</li> <li>Streaming Methods (Mid-Level) - streaming methods</li> <li>MT5Account API Reference - complete low-level API reference</li> <li>MT5Service API Reference - complete mid-level API reference</li> </ul>"},{"location":"MT5Service/1.%20Account_Information/#summary","title":"Summary","text":"<p>Real value for end users: - <code>get_account_summary()</code> - Aggregates 14 properties in one call + converts <code>datetime</code> (93% code reduction)</p> <p>Architectural layer (for MT5Sugar): - <code>get_account_double/integer/string()</code> - Direct pass-through to MT5Account - Used by MT5Sugar to maintain layered architecture (Sugar Service Account) - For direct MT5Service usage: no value, call MT5Account instead</p> <p>Recommendation: - Using MT5Sugar? These methods work seamlessly through the architecture - Using MT5Service directly? Only use <code>get_account_summary()</code>. For single properties, call MT5Account.</p>"},{"location":"MT5Service/2.%20Symbol_Information/","title":"\u2705 MT5Service - Symbol Methods (Mid-Level API)","text":""},{"location":"MT5Service/2.%20Symbol_Information/#important-read-this-first","title":"Important: Read This First","text":"<p>MT5Service is an architectural layer between high-level (Sugar) and low-level (Account) APIs.</p>"},{"location":"MT5Service/2.%20Symbol_Information/#understanding-the-13-methods","title":"Understanding the 13 Methods:","text":"Method Direct Use Value Architectural Role <code>get_symbol_params_many()</code> VERY HIGH - Aggregates 17 fields + unpacks protobuf list Used by Sugar <code>get_symbol_tick()</code> HIGH - Unix timestamp datetime + unpacks 8 fields Used by Sugar <code>get_symbol_session_quote()</code> HIGH - 2x protobuf Timestamp datetime Used by Sugar <code>get_symbol_session_trade()</code> HIGH - 2x protobuf Timestamp datetime Used by Sugar <code>get_symbol_margin_rate()</code> MEDIUM - Unpacks protobuf + creates dataclass Used by Sugar <code>get_symbols_total()</code> LOW - Unpacks <code>data.total</code> from protobuf Used by Sugar <code>symbol_exist()</code> LOW - Unpacks <code>(data.exists, data.is_custom)</code> Used by Sugar <code>get_symbol_name()</code> LOW - Unpacks <code>data.name</code> from protobuf Used by Sugar <code>symbol_select()</code> LOW - Unpacks <code>data.success</code> from protobuf Used by Sugar <code>is_symbol_synchronized()</code> LOW - Unpacks <code>data.synchronized</code> from protobuf Used by Sugar <code>get_symbol_double()</code> LOW - Unpacks <code>data.value</code> from protobuf Used by Sugar <code>get_symbol_integer()</code> LOW - Unpacks <code>data.value</code> from protobuf Used by Sugar <code>get_symbol_string()</code> LOW - Unpacks <code>data.value</code> from protobuf Used by Sugar"},{"location":"MT5Service/2.%20Symbol_Information/#what-this-means","title":"What This Means:","text":"<p>\ud83c\udfd7\ufe0f Architecture (3 layers): <pre><code>MT5Sugar (HIGH)     service.get_symbol_tick()      Sugar uses Service methods\nMT5Service (MID)    account.symbol_info_tick()     Service unpacks protobuf + converts datetime\nMT5Account (LOW)    gRPC call protobuf Data\n</code></pre></p> <p>Key difference from Account methods:</p> <ul> <li>ALL symbol methods have value - MT5Account returns protobuf Data objects that need unpacking</li> <li>Protobuf unpacking - Service extracts values from <code>data.value</code>, <code>data.total</code>, etc.</li> <li>Datetime conversion - 3 methods convert timestamps/protobuf Timestamps to Python datetime</li> <li>Dataclass creation - Cleaner API with typed dataclasses instead of protobuf messages</li> </ul> <p>For direct MT5Service usage:</p> <ul> <li>Use all methods - they all add value through protobuf unpacking</li> <li>High-value methods - <code>get_symbol_params_many()</code>, <code>get_symbol_tick()</code>, session methods</li> <li>Low-value methods - simple unpacking, but still saves you from manual <code>data.value</code> extraction</li> </ul> <p>For MT5Sugar users:</p> <ul> <li>All methods work perfectly - the layer serves its architectural purpose</li> </ul> <p>API Layer: MID-LEVEL - wrappers over MT5Account with Python native types</p> <p>Implementation:</p> <p>These methods are implemented in <code>src/pymt5/mt5_service.py</code>, which wraps <code>package/MetaRpcMT5/helpers/mt5_account.py</code> low-level API with convenient dataclasses and automatic type conversion.</p> <p>Example files:</p> <ul> <li><code>examples/2_service/04_service_demo.py</code> - comprehensive demo of all MT5Service methods including symbol information</li> </ul>"},{"location":"MT5Service/2.%20Symbol_Information/#why-these-methods-exist","title":"Why These Methods Exist","text":""},{"location":"MT5Service/2.%20Symbol_Information/#real-value-protobuf-unpacking-datetime-conversion","title":"Real Value: Protobuf Unpacking + Datetime Conversion","text":"<p>Unlike Account methods, Symbol methods in MT5Service all add real value because MT5Account returns protobuf Data objects:</p> <p>Problem with MT5Account (Low-level): <pre><code># MT5Account returns protobuf Data objects - need manual unpacking\ndata = await account.symbol_info_double(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_BID\n)\nbid = data.value  # Manual extraction from protobuf wrapper\n\n# Tick time is Unix timestamp - need manual conversion\ntick_data = await account.symbol_info_tick(\"EURUSD\")\ntick_time = datetime.fromtimestamp(tick_data.time)  # Manual datetime conversion\n</code></pre></p> <p>Solution with MT5Service (Mid-level): <pre><code># Service unpacks protobuf automatically - returns native types\nbid = await service.get_symbol_double(\n    symbol=\"EURUSD\",\n    property=market_info_pb2.SYMBOL_BID\n)  # Already float, not protobuf Data!\n\n# Tick with datetime already converted\ntick = await service.get_symbol_tick(\"EURUSD\")\nprint(tick.time)  # Already datetime object!\n</code></pre></p> <p>What MT5Service provides:</p> <ol> <li> <p>Protobuf unpacking (all 13 methods):</p> </li> <li> <p>MT5Account: <code>return res.data</code> (protobuf object)</p> </li> <li> <p>MT5Service: <code>return data.value</code> (native Python type)</p> </li> <li> <p>Datetime conversion (3 methods):</p> </li> <li> <p><code>get_symbol_tick()</code>: Unix timestamp <code>datetime.fromtimestamp()</code></p> </li> <li><code>get_symbol_session_quote()</code>: protobuf Timestamp <code>ToDatetime()</code> x2</li> <li> <p><code>get_symbol_session_trade()</code>: protobuf Timestamp <code>ToDatetime()</code> x2</p> </li> <li> <p>Data aggregation (1 method):</p> </li> <li> <p><code>get_symbol_params_many()</code>: 17 fields in one call instead of 17 separate calls</p> </li> <li> <p>Clean dataclasses:</p> </li> <li> <p><code>SymbolTick</code>, <code>SymbolParams</code>, <code>SessionTime</code>, <code>SymbolMarginRate</code> instead of protobuf messages</p> </li> </ol> <p>Architectural purpose:</p> <ul> <li>MT5Sugar uses these methods to maintain layered architecture (Sugar Service Account)</li> <li>Direct users also benefit - all methods add value through unpacking and conversion</li> </ul>"},{"location":"MT5Service/2.%20Symbol_Information/#all-13-methods","title":"All 13 Methods","text":"Method Returns Description <code>get_symbols_total()</code> <code>int</code> Get count of available symbols <code>symbol_exist()</code> <code>Tuple[bool, bool]</code> Check if symbol exists (exists, is_custom) <code>get_symbol_name()</code> <code>str</code> Get symbol name by index <code>symbol_select()</code> <code>bool</code> Add/remove symbol from Market Watch <code>is_symbol_synchronized()</code> <code>bool</code> Check if symbol data is synchronized <code>get_symbol_double()</code> <code>float</code> Get double property (Bid, Ask, Point, etc.) <code>get_symbol_integer()</code> <code>int</code> Get integer property (Digits, Spread, etc.) <code>get_symbol_string()</code> <code>str</code> Get string property (Description, Currency, etc.) <code>get_symbol_margin_rate()</code> <code>SymbolMarginRate</code> Get margin rates for order type <code>get_symbol_tick()</code> <code>SymbolTick</code> Get current tick (time auto-converted to datetime) <code>get_symbol_session_quote()</code> <code>SessionTime</code> Get quote session times (as datetime) <code>get_symbol_session_trade()</code> <code>SessionTime</code> Get trading session times (as datetime) <code>get_symbol_params_many()</code> <code>Tuple[List[SymbolParams], int]</code> Get comprehensive data for multiple symbols"},{"location":"MT5Service/2.%20Symbol_Information/#dataclasses-dtos","title":"\u2795 Dataclasses (DTOs)","text":""},{"location":"MT5Service/2.%20Symbol_Information/#symboltick","title":"SymbolTick","text":"<pre><code>@dataclass\nclass SymbolTick:\n    \"\"\"\n    Current tick information for a symbol.\n\n    ADVANTAGE: Time is already converted from Unix timestamp to datetime.\n    \"\"\"\n    time: datetime          # Tick time (converted from Unix timestamp)\n    bid: float              # Current Bid price\n    ask: float              # Current Ask price\n    last: float             # Last deal price\n    volume: int             # Tick volume\n    time_ms: int            # Tick time in milliseconds\n    flags: int              # Tick flags\n    volume_real: float      # Tick volume with decimal precision\n</code></pre>"},{"location":"MT5Service/2.%20Symbol_Information/#symbolmarginrate","title":"SymbolMarginRate","text":"<pre><code>@dataclass\nclass SymbolMarginRate:\n    \"\"\"Margin rate information for a symbol.\"\"\"\n    initial_margin_rate: float          # Initial margin rate\n    maintenance_margin_rate: float      # Maintenance margin requirement\n</code></pre>"},{"location":"MT5Service/2.%20Symbol_Information/#sessiontime","title":"SessionTime","text":"<pre><code>@dataclass\nclass SessionTime:\n    \"\"\"Trading session time range.\"\"\"\n    from_time: datetime     # Session start time (already datetime)\n    to_time: datetime       # Session end time (already datetime)\n</code></pre>"},{"location":"MT5Service/2.%20Symbol_Information/#symbolparams","title":"SymbolParams","text":"<pre><code>@dataclass\nclass SymbolParams:\n    \"\"\"\n    Comprehensive symbol information.\n\n    ADVANTAGE: All 17 important symbol parameters in one structure.\n    Much more convenient than making multiple calls to SymbolInfoDouble/Integer/String.\n    \"\"\"\n    name: str                   # Symbol name\n    bid: float                  # Current Bid price\n    ask: float                  # Current Ask price\n    last: float                 # Last deal price\n    point: float                # Point size (minimal price change)\n    digits: int                 # Number of decimal places\n    spread: int                 # Current spread in points\n    volume_min: float           # Minimum volume for trading\n    volume_max: float           # Maximum volume for trading\n    volume_step: float          # Volume step\n    trade_tick_size: float      # Trade tick size\n    trade_tick_value: float     # Trade tick value\n    trade_contract_size: float  # Contract size\n    swap_long: float            # Swap for long positions\n    swap_short: float           # Swap for short positions\n    margin_initial: float       # Initial margin requirement\n    margin_maintenance: float   # Maintenance margin requirement\n</code></pre>"},{"location":"MT5Service/2.%20Symbol_Information/#method-signatures","title":"Method Signatures","text":""},{"location":"MT5Service/2.%20Symbol_Information/#1-get_symbols_total","title":"1) get_symbols_total","text":"<pre><code>async def get_symbols_total(\n    self,\n    selected_only: bool,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; int\n</code></pre> <p>Get count of available symbols.</p> <p>Args: - <code>selected_only</code>: <code>True</code> to count only Market Watch symbols, <code>False</code> for all</p> <p>Returns: <code>int</code> count directly (no Data struct)</p> <p>Technical: Low-level returns SymbolsTotalData with <code>data.total</code> wrapper. This auto-extracts the count.</p>"},{"location":"MT5Service/2.%20Symbol_Information/#2-symbol_exist","title":"2) symbol_exist","text":"<pre><code>async def symbol_exist(\n    self,\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; Tuple[bool, bool]\n</code></pre> <p>Check if symbol exists in terminal.</p> <p>Args: - <code>symbol</code>: Symbol name to check</p> <p>Returns: <code>Tuple[exists, is_custom]</code> - <code>exists</code>: True if symbol exists - <code>is_custom</code>: True if custom symbol</p>"},{"location":"MT5Service/2.%20Symbol_Information/#3-get_symbol_name","title":"3) get_symbol_name","text":"<pre><code>async def get_symbol_name(\n    self,\n    index: int,\n    selected_only: bool,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; str\n</code></pre> <p>Get symbol name by index position.</p> <p>Args: - <code>index</code>: Symbol index (starting at 0) - <code>selected_only</code>: True to use only Market Watch symbols</p> <p>Returns: Symbol name string directly</p> <p>Usage: Iterate through all symbols with <code>range(get_symbols_total())</code>.</p>"},{"location":"MT5Service/2.%20Symbol_Information/#4-symbol_select","title":"4) symbol_select","text":"<pre><code>async def symbol_select(\n    self,\n    symbol: str,\n    select: bool,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; bool\n</code></pre> <p>Add/remove symbol from Market Watch.</p> <p>Args: - <code>symbol</code>: Symbol name - <code>select</code>: True to add, False to remove</p> <p>Returns: Success status</p>"},{"location":"MT5Service/2.%20Symbol_Information/#5-is_symbol_synchronized","title":"5) is_symbol_synchronized","text":"<pre><code>async def is_symbol_synchronized(\n    self,\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; bool\n</code></pre> <p>Check if symbol data is synchronized with broker server.</p> <p>Args: - <code>symbol</code>: Symbol name to check</p> <p>Returns: <code>True</code> if synchronized, <code>False</code> otherwise</p> <p>Usage: Check before requesting tick data to ensure it's up-to-date.</p>"},{"location":"MT5Service/2.%20Symbol_Information/#6-get_symbol_double","title":"6) get_symbol_double","text":"<pre><code>async def get_symbol_double(\n    self,\n    symbol: str,\n    property: market_info_pb2.SymbolInfoDoubleProperty,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; float\n</code></pre> <p>Get individual symbol double property.</p> <p>Available properties:</p> <pre><code>from MetaRpcMT5 import mt5_term_api_market_info_pb2 as market_info_pb2\n\n# Price properties:\nSYMBOL_BID                  # Current Bid price\nSYMBOL_ASK                  # Current Ask price\nSYMBOL_LAST                 # Last deal price\n\n# Size properties:\nSYMBOL_POINT                # Point size (0.00001 for EURUSD)\nSYMBOL_TRADE_TICK_VALUE     # Tick value in deposit currency\nSYMBOL_TRADE_TICK_SIZE      # Tick size in points\nSYMBOL_TRADE_CONTRACT_SIZE  # Contract size (100000 for forex)\n\n# Volume properties:\nSYMBOL_VOLUME_MIN           # Minimum volume\nSYMBOL_VOLUME_MAX           # Maximum volume\nSYMBOL_VOLUME_STEP          # Volume step\n\n# Swap properties:\nSYMBOL_SWAP_LONG            # Swap for long positions\nSYMBOL_SWAP_SHORT           # Swap for short positions\n\n# Margin properties:\nSYMBOL_MARGIN_INITIAL       # Initial margin\nSYMBOL_MARGIN_MAINTENANCE   # Maintenance margin\n</code></pre> <p>Returns: <code>float</code> value directly</p> <p>Technical: Low-level returns SymbolInfoDoubleResponse with <code>data.value</code>. This extracts the float.</p>"},{"location":"MT5Service/2.%20Symbol_Information/#7-get_symbol_integer","title":"7) get_symbol_integer","text":"<pre><code>async def get_symbol_integer(\n    self,\n    symbol: str,\n    property: market_info_pb2.SymbolInfoIntegerProperty,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; int\n</code></pre> <p>Get individual symbol integer property.</p> <p>Available properties:</p> <pre><code>SYMBOL_DIGITS               # Number of decimal places (5 for EURUSD)\nSYMBOL_SPREAD               # Current spread in points\nSYMBOL_TRADE_MODE           # Trade mode (0=disabled, 4=full)\nSYMBOL_TRADE_EXEMODE        # Execution mode (instant/market/exchange)\nSYMBOL_START_TIME           # Symbol start time (Unix timestamp)\nSYMBOL_EXPIRATION_TIME      # Symbol expiration time (Unix timestamp)\nSYMBOL_FILLING_MODE         # Filling mode flags\nSYMBOL_ORDER_MODE           # Allowed order types flags\n</code></pre> <p>Returns: <code>int</code> value directly</p>"},{"location":"MT5Service/2.%20Symbol_Information/#8-get_symbol_string","title":"8) get_symbol_string","text":"<pre><code>async def get_symbol_string(\n    self,\n    symbol: str,\n    property: market_info_pb2.SymbolInfoStringProperty,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; str\n</code></pre> <p>Get individual symbol string property.</p> <p>Available properties:</p> <pre><code>SYMBOL_DESCRIPTION          # Symbol description (\"Euro vs US Dollar\")\nSYMBOL_CURRENCY_BASE        # Base currency (\"EUR\" for EURUSD)\nSYMBOL_CURRENCY_PROFIT      # Profit currency (\"USD\" for EURUSD)\nSYMBOL_CURRENCY_MARGIN      # Margin currency\nSYMBOL_BANK                 # Source of quotes\nSYMBOL_ISIN                 # ISIN code\nSYMBOL_CATEGORY             # Symbol category (Forex, Stocks, etc.)\nSYMBOL_PATH                 # Path in symbol tree\n</code></pre> <p>Returns: <code>str</code> value directly</p>"},{"location":"MT5Service/2.%20Symbol_Information/#9-get_symbol_margin_rate","title":"9) get_symbol_margin_rate","text":"<pre><code>async def get_symbol_margin_rate(\n    self,\n    symbol: str,\n    order_type: market_info_pb2.ENUM_ORDER_TYPE,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; SymbolMarginRate\n</code></pre> <p>Get margin rates for a symbol and order type.</p> <p>Args: - <code>symbol</code>: Symbol name - <code>order_type</code>: Order type (BUY, SELL, etc.)</p> <p>Returns: <code>SymbolMarginRate</code> dataclass with initial and maintenance rates</p>"},{"location":"MT5Service/2.%20Symbol_Information/#10-get_symbol_tick","title":"10) get_symbol_tick","text":"<pre><code>async def get_symbol_tick(\n    self,\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; SymbolTick\n</code></pre> <p>Get current market prices for a symbol.</p> <p>Returns: <code>SymbolTick</code> dataclass with time already converted to datetime</p> <p>Technical: Low-level returns SymbolInfoTickData with Unix timestamp (<code>data.time</code>). This wrapper converts time field from Unix seconds to Python datetime via <code>fromtimestamp()</code>.</p> <p>Advantage: No manual timestamp conversion needed - just use <code>tick.time</code> as datetime object!</p>"},{"location":"MT5Service/2.%20Symbol_Information/#11-get_symbol_session_quote","title":"11) get_symbol_session_quote","text":"<pre><code>async def get_symbol_session_quote(\n    self,\n    symbol: str,\n    day_of_week: market_info_pb2.DayOfWeek,\n    session_index: int,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; SessionTime\n</code></pre> <p>Get quote session times.</p> <p>Args: - <code>symbol</code>: Symbol name - <code>day_of_week</code>: Day of the week (MONDAY, TUESDAY, etc.) - <code>session_index</code>: Session index (starting at 0, most symbols have 1 session)</p> <p>Returns: <code>SessionTime</code> with start/end times as datetime</p> <p>Technical: Low-level returns protobuf Timestamps. This wrapper converts both to Python datetimes via <code>ToDatetime()</code>.</p>"},{"location":"MT5Service/2.%20Symbol_Information/#12-get_symbol_session_trade","title":"12) get_symbol_session_trade","text":"<pre><code>async def get_symbol_session_trade(\n    self,\n    symbol: str,\n    day_of_week: market_info_pb2.DayOfWeek,\n    session_index: int,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; SessionTime\n</code></pre> <p>Get trading session times.</p> <p>Args: - <code>symbol</code>: Symbol name - <code>day_of_week</code>: Day of the week - <code>session_index</code>: Session index (starting at 0)</p> <p>Returns: <code>SessionTime</code> with start/end times as datetime</p> <p>Usage: Shows when you can trade the symbol (different from quote session which shows when prices are updated).</p>"},{"location":"MT5Service/2.%20Symbol_Information/#13-get_symbol_params_many","title":"13) get_symbol_params_many","text":"<pre><code>async def get_symbol_params_many(\n    self,\n    name_filter: Optional[str] = None,\n    sort_mode: Optional[int] = None,\n    page_number: Optional[int] = None,\n    items_per_page: Optional[int] = None,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; Tuple[List[SymbolParams], int]\n</code></pre> <p>Get parameters of multiple symbols at once.</p> <p>Args: - <code>name_filter</code>: Optional symbol name filter (e.g., \"EUR*\" for all EUR pairs) - <code>sort_mode</code>: Optional sort mode - <code>page_number</code>: Optional page number for pagination - <code>items_per_page</code>: Optional items per page</p> <p>Returns: <code>Tuple[List[SymbolParams], total_count]</code></p> <p>Technical: Low-level returns protobuf repeated field. This wrapper unpacks each SymbolInfo into SymbolParams dataclass with 17 fields.</p> <p>Advantage: Much faster than 17 separate SymbolInfoDouble/Integer/String calls per symbol!</p>"},{"location":"MT5Service/2.%20Symbol_Information/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Service/2.%20Symbol_Information/#example-1-getting-symbol-tick-with-auto-converted-time","title":"Example 1: Getting Symbol Tick with Auto-Converted Time","text":"<pre><code>async def monitor_tick(service: MT5Service, symbol: str):\n    # Get tick - time is already datetime!\n    tick = await service.get_symbol_tick(symbol)\n\n    print(f\"Symbol: {symbol}\")\n    print(f\"Time: {tick.time.strftime('%Y-%m-%d %H:%M:%S')}\")  # Already datetime\n    print(f\"Bid: {tick.bid:.5f}\")\n    print(f\"Ask: {tick.ask:.5f}\")\n    print(f\"Last: {tick.last:.5f}\")\n    print(f\"Volume: {tick.volume}\")\n\n    # No manual timestamp conversion needed!\n</code></pre>"},{"location":"MT5Service/2.%20Symbol_Information/#example-2-checking-symbol-availability","title":"Example 2: Checking Symbol Availability","text":"<pre><code>async def check_symbol(service: MT5Service, symbol: str):\n    exists, is_custom = await service.symbol_exist(symbol)\n\n    if not exists:\n        print(f\"Symbol {symbol} does not exist\")\n        return False\n\n    if is_custom:\n        print(f\"{symbol} is a custom symbol\")\n\n    # Check if synchronized\n    synced = await service.is_symbol_synchronized(symbol)\n    if not synced:\n        print(f\"WARNING: {symbol} data is not synchronized\")\n        return False\n\n    print(f\"{symbol} is available and synchronized\")\n    return True\n</code></pre>"},{"location":"MT5Service/2.%20Symbol_Information/#example-3-getting-trading-session-times","title":"Example 3: Getting Trading Session Times","text":"<pre><code>from MetaRpcMT5 import mt5_term_api_market_info_pb2 as market_info_pb2\n\nasync def check_trading_hours(service: MT5Service, symbol: str):\n    \"\"\"Check if symbol is currently in trading session.\"\"\"\n\n    from datetime import datetime\n\n    now = datetime.now()\n    day_of_week = market_info_pb2.DayOfWeek.Value(\n        f\"DAY_{now.strftime('%A').upper()}\"\n    )\n\n    try:\n        # Get trading session for today (session_index=0 for main session)\n        session = await service.get_symbol_session_trade(\n            symbol=symbol,\n            day_of_week=day_of_week,\n            session_index=0\n        )\n\n        print(f\"Trading session for {symbol} today:\")\n        print(f\"  From: {session.from_time.strftime('%H:%M:%S')}\")\n        print(f\"  To: {session.to_time.strftime('%H:%M:%S')}\")\n\n        # Times are already datetime objects!\n        if session.from_time &lt;= now &lt;= session.to_time:\n            print(\"  Status: OPEN\")\n        else:\n            print(\"  Status: CLOSED\")\n\n    except Exception as e:\n        print(f\"No trading session for {symbol} today: {e}\")\n</code></pre>"},{"location":"MT5Service/2.%20Symbol_Information/#example-4-bulk-symbol-data-retrieval-get_symbol_params_many","title":"Example 4: Bulk Symbol Data Retrieval (get_symbol_params_many)","text":"<pre><code>async def get_all_eur_symbols(service: MT5Service):\n    \"\"\"Get comprehensive data for all EUR symbols efficiently.\"\"\"\n\n    # Get all symbols starting with \"EUR\" in one call\n    symbols, total = await service.get_symbol_params_many(\n        name_filter=\"EUR*\",\n        items_per_page=100\n    )\n\n    print(f\"Found {total} EUR symbols\\n\")\n\n    for sym in symbols:\n        print(f\"{sym.name}:\")\n        print(f\"  Bid: {sym.bid:.5f}, Ask: {sym.ask:.5f}\")\n        print(f\"  Spread: {sym.spread} points\")\n        print(f\"  Digits: {sym.digits}\")\n        print(f\"  Volume: {sym.volume_min} - {sym.volume_max} (step: {sym.volume_step})\")\n        print(f\"  Contract size: {sym.trade_contract_size}\")\n        print(f\"  Swap long/short: {sym.swap_long}/{sym.swap_short}\")\n        print()\n\n    # This is MUCH faster than calling get_symbol_double/integer/string\n    # 17 times for each symbol!\n</code></pre>"},{"location":"MT5Service/2.%20Symbol_Information/#when-to-use-which-method","title":"When to Use Which Method","text":""},{"location":"MT5Service/2.%20Symbol_Information/#use-get_symbol_tick","title":"Use get_symbol_tick()","text":"<p>Use when: - You need current Bid/Ask prices with timestamp - Want complete tick data in one call - Need time as datetime (auto-converted)</p> <p>Example: <pre><code>tick = await service.get_symbol_tick(\"EURUSD\")\nprint(f\"Bid: {tick.bid}, Time: {tick.time}\")\n</code></pre></p>"},{"location":"MT5Service/2.%20Symbol_Information/#use-get_symbol_doubleintegerstring","title":"Use get_symbol_double/integer/string()","text":"<p>Use when: - You need ONE specific property - Writing validation checks - Performance matters (single property faster than tick)</p> <p>Example: <pre><code>spread = await service.get_symbol_integer(\n    \"EURUSD\", market_info_pb2.SYMBOL_SPREAD\n)\n</code></pre></p>"},{"location":"MT5Service/2.%20Symbol_Information/#use-get_symbol_params_many","title":"Use get_symbol_params_many()","text":"<p>Use when: - You need data for MULTIPLE symbols - Building symbol scanner/screener - Need comprehensive symbol info (17 fields) - Want to minimize API calls</p> <p>Example: <pre><code># Get all forex symbols at once\nsymbols, _ = await service.get_symbol_params_many(name_filter=\"*USD\")\n</code></pre></p> <p>Advantage: 100x faster than individual calls for each symbol!</p>"},{"location":"MT5Service/2.%20Symbol_Information/#recommendations","title":"Recommendations","text":"<ol> <li>For current prices + time - use <code>get_symbol_tick()</code> (Bid/Ask + datetime in one call, no manual unpacking)</li> <li>For multiple symbols - use <code>get_symbol_params_many()</code> (17 fields per symbol in one call - 100x faster!)</li> <li>For single property - use <code>get_symbol_double/integer/string()</code> (unpacks protobuf <code>data.value</code> for you)</li> <li>For session times - use <code>get_symbol_session_quote/trade()</code> (datetime conversion included)</li> <li>Before trading - always check with <code>symbol_exist()</code> and <code>is_symbol_synchronized()</code> (cleaner than manual protobuf)</li> </ol> <p>Bottom line: Use MT5Service for all symbol operations - it unpacks protobuf Data objects and converts datetime automatically.</p>"},{"location":"MT5Service/2.%20Symbol_Information/#related-sections","title":"\ud83d\udcda Related Sections","text":"<ul> <li>MT5Service Overview - mid-level API overview</li> <li>Account Methods (Mid-Level) - account information methods</li> <li>Trading Methods (Mid-Level) - trading methods</li> <li>Streaming Methods (Mid-Level) - real-time tick streaming</li> <li>Symbol Information (Low-Level) - low-level symbol API</li> <li>MT5Service API Reference - complete mid-level API reference</li> </ul>"},{"location":"MT5Service/2.%20Symbol_Information/#summary","title":"Summary","text":"<p>Real value for end users: - ALL 13 methods add value - MT5Account returns protobuf Data objects that need unpacking - <code>get_symbol_params_many()</code> - Aggregates 17 fields in one call (100x faster for multiple symbols) - <code>get_symbol_tick()</code> - Unix timestamp datetime + unpacks 8 fields - <code>get_symbol_session_quote/trade()</code> - Protobuf Timestamps datetime x2 - Other 9 methods - Protobuf unpacking (<code>data.value</code> native type)</p> <p>Architectural layer (for MT5Sugar): - All methods used by MT5Sugar to maintain layered architecture (Sugar Service Account) - Provides unified interface with consistent naming (<code>get_*</code> prefix)</p> <p>Key difference from Account methods: - Account methods: MT5Account already returns native types Service adds no value (just pass-through) - Symbol methods: MT5Account returns protobuf Data Service unpacks + converts real value</p> <p>Recommendation: - Using MT5Sugar? These methods work seamlessly through the architecture - Using MT5Service directly? All methods add value - use them all!   - High priority: <code>get_symbol_params_many()</code>, <code>get_symbol_tick()</code>, session methods   - Medium priority: Other methods save you from manual protobuf unpacking</p>"},{"location":"MT5Service/3.%20Positions_Orders/","title":"MT5Service - Positions &amp; Orders Methods (Mid-Level API)","text":""},{"location":"MT5Service/3.%20Positions_Orders/#important-read-this-first","title":"\u26a0\ufe0f Important: Read This First","text":"<p>MT5Service is an architectural layer between high-level (Sugar) and low-level (Account) APIs.</p>"},{"location":"MT5Service/3.%20Positions_Orders/#understanding-the-5-methods","title":"Understanding the 5 Methods:","text":"Method Direct Use Value Architectural Role <code>get_opened_tickets()</code> \u2705 MEDIUM - Converts protobuf repeated \u2192 Python lists \u2705 Used by Sugar <code>get_positions_total()</code> \u26aa LOW - Unpacks <code>data.total_positions</code> from protobuf \u2705 Used by Sugar <code>get_opened_orders()</code> \u26aa NONE - Just calls <code>account.opened_orders()</code> \u2705 Used by Sugar <code>get_order_history()</code> \u26aa NONE - Just calls <code>account.order_history()</code> \u2705 Used by Sugar <code>get_positions_history()</code> \u26aa NONE - Just calls <code>account.positions_history()</code> \u2705 Used by Sugar"},{"location":"MT5Service/3.%20Positions_Orders/#what-this-means","title":"What This Means:","text":"<p>Architecture (3 layers): <pre><code>MT5Sugar (HIGH)     \u2192  service.get_opened_tickets()   \u2190 Sugar uses Service methods\nMT5Service (MID)    \u2192  account.opened_orders_tickets() \u2190 Service converts to Python lists\nMT5Account (LOW)    \u2192  gRPC call \u2192 protobuf repeated fields\n</code></pre></p> <p>Key difference from Symbol methods:</p> <ul> <li>\u2705 Only 1 method has real value - <code>get_opened_tickets()</code> converts protobuf repeated fields to Python lists</li> <li>\u26aa 4 methods are pass-through - identical to calling MT5Account directly</li> <li>\u26aa Protobuf unpacking - only <code>get_positions_total()</code> unpacks one field (<code>data.total_positions</code>)</li> </ul> <p>For direct MT5Service usage:</p> <ul> <li>\u2705 Use <code>get_opened_tickets()</code> - converts to Python lists (cleaner than protobuf repeated fields)</li> <li>\u26aa Other 4 methods - no value, just call MT5Account directly</li> </ul> <p>For MT5Sugar users:</p> <ul> <li>\u2705 All methods work perfectly - the layer serves its architectural purpose</li> </ul> <p>API Layer: MID-LEVEL - wrappers over MT5Account with Python native types</p> <p>Implementation:</p> <p>These methods are implemented in <code>src/pymt5/mt5_service.py</code>, which wraps <code>package/MetaRpcMT5/helpers/mt5_account.py</code> low-level API.</p> <p>Example files:</p> <ul> <li><code>examples/2_service/04_service_demo.py</code> - comprehensive demo of all MT5Service methods including positions/orders</li> </ul>"},{"location":"MT5Service/3.%20Positions_Orders/#why-these-methods-exist","title":"Why These Methods Exist","text":""},{"location":"MT5Service/3.%20Positions_Orders/#real-value-get_opened_tickets","title":"Real Value: get_opened_tickets()","text":"<p>Only <code>get_opened_tickets()</code> adds real value by converting protobuf repeated fields to Python lists:</p> <p>Problem with MT5Account (Low-level):</p> <pre><code># MT5Account returns protobuf repeated fields - need manual list conversion\ntickets_data = await account.opened_orders_tickets()\nposition_tickets = list(tickets_data.opened_position_tickets)  # \u2190 Manual conversion\norder_tickets = list(tickets_data.opened_orders_tickets)       # \u2190 Manual conversion\n</code></pre> <p>Solution with MT5Service (Mid-level):</p> <pre><code># Service converts to Python lists automatically\nposition_tickets, order_tickets = await service.get_opened_tickets()\n# \u2190 Already lists, not protobuf repeated fields!\n</code></pre>"},{"location":"MT5Service/3.%20Positions_Orders/#other-methods-pass-through-layer","title":"Other Methods: Pass-Through Layer","text":"<p><code>get_opened_orders()</code>, <code>get_order_history()</code>, <code>get_positions_history()</code> are pass-through wrappers:</p> <p>Implementation:</p> <pre><code># get_opened_orders - direct pass-through\nasync def get_opened_orders(...):\n    return await self._account.opened_orders(...)  # \u2190 No processing!\n\n# get_order_history - direct pass-through\nasync def get_order_history(...):\n    return await self._account.order_history(...)  # \u2190 No processing!\n\n# get_positions_history - direct pass-through\nasync def get_positions_history(...):\n    return await self._account.positions_history(...)  # \u2190 No processing!\n</code></pre> <p>Why they exist:</p> <ul> <li>\u2705 MT5Sugar (high-level) uses them - maintains layered architecture (Sugar \u2192 Service \u2192 Account)</li> <li>\u2705 Unified interface - all methods accessible through one class</li> <li>\u2705 Consistent naming - <code>get_*</code> prefix across all Service methods</li> <li>\u26aa No processing - direct pass-through to MT5Account</li> </ul> <p>For end users: If you're using MT5Service directly (not Sugar), calling MT5Account is identical. These wrappers add no value.</p> <p>For MT5Sugar: These are essential - Sugar must work through Service, not directly with Account (layered architecture).</p>"},{"location":"MT5Service/3.%20Positions_Orders/#all-5-methods","title":"All 5 Methods","text":"Method Returns Implementation <code>get_opened_tickets()</code> <code>Tuple[List[int], List[int]]</code> \u2705 Converts protobuf repeated \u2192 <code>(list(...), list(...))</code> <code>get_positions_total()</code> <code>int</code> \u26aa Unpacks <code>data.total_positions</code> from protobuf <code>get_opened_orders()</code> <code>OpenedOrdersData</code> \u26aa <code>return await self._account.opened_orders(...)</code> <code>get_order_history()</code> <code>OrdersHistoryData</code> \u26aa <code>return await self._account.order_history(...)</code> <code>get_positions_history()</code> <code>PositionsHistoryData</code> \u26aa <code>return await self._account.positions_history(...)</code>"},{"location":"MT5Service/3.%20Positions_Orders/#key-concepts","title":"Key Concepts","text":""},{"location":"MT5Service/3.%20Positions_Orders/#positions-vs-orders","title":"Positions vs Orders","text":"<ul> <li>Position: An open market position (BUY or SELL) that is currently active</li> <li>Pending Order: A limit/stop order waiting to be executed</li> <li>Historical Order: Past orders (executed, cancelled, or rejected)</li> <li>Closed Position: Position that was opened and then closed (has P&amp;L data)</li> </ul>"},{"location":"MT5Service/3.%20Positions_Orders/#ticket-numbers","title":"Ticket Numbers","text":"<ul> <li>Every position and order has a unique ticket number (int64)</li> <li>Ticket numbers are used to identify, modify, and close positions/orders</li> <li>Use <code>get_opened_tickets()</code> for fast existence checks (much faster than full data)</li> </ul>"},{"location":"MT5Service/3.%20Positions_Orders/#method-signatures","title":"Method Signatures","text":""},{"location":"MT5Service/3.%20Positions_Orders/#1-get_positions_total","title":"1) get_positions_total","text":"<pre><code>async def get_positions_total(\n    self,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; int\n</code></pre> <p>Get total number of open positions.</p> <p>Returns: <code>int</code> count directly (no Data struct)</p> <p>Usage: Quick check if there are any open positions before closing all.</p> <p>Technical: Low-level returns protobuf with <code>data.total_positions</code> wrapper. This auto-extracts the count.</p>"},{"location":"MT5Service/3.%20Positions_Orders/#2-get_opened_orders","title":"2) get_opened_orders","text":"<pre><code>async def get_opened_orders(\n    self,\n    sort_mode: account_helper_pb2.BMT5_ENUM_OPENED_ORDER_SORT_TYPE =\n        account_helper_pb2.BMT5_OPENED_ORDER_SORT_BY_OPEN_TIME_ASC,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; Any  # OpenedOrdersData\n</code></pre> <p>Get all open positions and pending orders with full details.</p> <p>Args:</p> <ul> <li><code>sort_mode</code>: Sort mode for results (default: by open time ascending)</li> </ul> <p>Returns: <code>OpenedOrdersData</code> protobuf with:</p> <ul> <li><code>position_infos</code>: List of PositionInfo (ticket, symbol, volume, profit, SL/TP, etc.)</li> <li><code>order_infos</code>: List of OrderInfo (ticket, symbol, volume, type, SL/TP, etc.)</li> </ul> <p>Available sort modes:</p> <pre><code>BMT5_OPENED_ORDER_SORT_BY_OPEN_TIME_ASC     # Oldest first\nBMT5_OPENED_ORDER_SORT_BY_OPEN_TIME_DESC    # Newest first\nBMT5_OPENED_ORDER_SORT_BY_TICKET_ASC        # By ticket ascending\nBMT5_OPENED_ORDER_SORT_BY_TICKET_DESC       # By ticket descending\n</code></pre> <p>Technical: Returns full protobuf data with all position/order details. For tickets only (faster), use <code>get_opened_tickets()</code>.</p>"},{"location":"MT5Service/3.%20Positions_Orders/#3-get_opened_tickets","title":"3) get_opened_tickets","text":"<pre><code>async def get_opened_tickets(\n    self,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; Tuple[List[int], List[int]]\n</code></pre> <p>Get only ticket numbers (lightweight and fast).</p> <p>Returns: <code>Tuple[position_tickets, order_tickets]</code></p> <ul> <li><code>position_tickets</code>: List of position ticket numbers</li> <li><code>order_tickets</code>: List of pending order ticket numbers</li> </ul> <p>Technical: Low-level returns OpenedOrdersTicketsData with two repeated int64 fields. This extracts both lists without parsing full position/order details.</p> <p>Advantage: 10-20x faster than <code>get_opened_orders()</code> when you only need ticket IDs for existence checks or counting.</p> <p>Use cases:</p> <ul> <li>Check if specific ticket exists</li> <li>Count positions/orders quickly</li> <li>Monitor for new positions (compare ticket lists)</li> <li>Validate ticket before modification</li> </ul>"},{"location":"MT5Service/3.%20Positions_Orders/#4-get_order_history","title":"4) get_order_history","text":"<pre><code>async def get_order_history(\n    self,\n    from_dt: datetime,\n    to_dt: datetime,\n    sort_mode: account_helper_pb2.BMT5_ENUM_ORDER_HISTORY_SORT_TYPE =\n        account_helper_pb2.BMT5_SORT_BY_CLOSE_TIME_DESC,\n    page_number: int = 0,\n    items_per_page: int = 50,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; Any  # OrdersHistoryData\n</code></pre> <p>Get historical orders and deals for a time period.</p> <p>Args:</p> <ul> <li><code>from_dt</code>: Start time (datetime)</li> <li><code>to_dt</code>: End time (datetime)</li> <li><code>sort_mode</code>: Sort mode (default: by close time descending)</li> <li><code>page_number</code>: Page number for pagination (0-based)</li> <li><code>items_per_page</code>: Items per page (default: 50)</li> </ul> <p>Returns: <code>OrdersHistoryData</code> protobuf with: - <code>order_history_infos</code>: List of OrderHistoryInfo (orders + related deals)</p> <p>Available sort modes:</p> <pre><code>BMT5_SORT_BY_CLOSE_TIME_DESC    # Most recent first (default)\nBMT5_SORT_BY_CLOSE_TIME_ASC     # Oldest first\nBMT5_SORT_BY_TICKET_DESC        # By ticket descending\nBMT5_SORT_BY_TICKET_ASC         # By ticket ascending\n</code></pre> <p>Technical: Returns protobuf OrdersHistoryData with repeated field. Supports pagination for large result sets.</p> <p>Note: For closed positions with P&amp;L calculations, use <code>get_positions_history()</code> instead (more detailed profit tracking).</p>"},{"location":"MT5Service/3.%20Positions_Orders/#5-get_positions_history","title":"5) get_positions_history","text":"<pre><code>async def get_positions_history(\n    self,\n    sort_type: account_helper_pb2.AH_ENUM_POSITIONS_HISTORY_SORT_TYPE,\n    open_from: Optional[datetime] = None,\n    open_to: Optional[datetime] = None,\n    page: int = 0,\n    size: int = 10,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; Any  # PositionsHistoryData\n</code></pre> <p>Get closed positions history with P&amp;L details.</p> <p>Args:</p> <ul> <li><code>sort_type</code>: Sort type (required)</li> <li><code>open_from</code>: Start of open time filter (optional)</li> <li><code>open_to</code>: End of open time filter (optional)</li> <li><code>page</code>: Page number (0-based, default: 0)</li> <li><code>size</code>: Items per page (default: 10)</li> </ul> <p>Returns: <code>PositionsHistoryData</code> protobuf with:</p> <ul> <li> <p><code>history_positions</code>: List of PositionHistoryInfo with:</p> </li> <li> <p>Ticket, symbol, volume, type</p> </li> <li>Open time, close time</li> <li>Open price, close price</li> <li>Profit, commission, swap</li> <li>SL, TP</li> </ul> <p>Available sort types:</p> <pre><code>AH_SORT_BY_OPEN_TIME_ASC        # Oldest first\nAH_SORT_BY_OPEN_TIME_DESC       # Most recent first\nAH_SORT_BY_CLOSE_TIME_ASC       # By close time ascending\nAH_SORT_BY_CLOSE_TIME_DESC      # By close time descending\nAH_SORT_BY_PROFIT_ASC           # Lowest profit first\nAH_SORT_BY_PROFIT_DESC          # Highest profit first\n</code></pre> <p>Technical: Returns protobuf PositionsHistoryData. Each PositionHistoryInfo includes profit, commission, swap, open/close times and prices.</p> <p>Note: Filters by position open time (not close time). Better than <code>get_order_history()</code> for profit calculations and closed position analysis.</p>"},{"location":"MT5Service/3.%20Positions_Orders/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Service/3.%20Positions_Orders/#example-1-get-ticket-numbers-fast-method-with-real-value","title":"Example 1: Get Ticket Numbers (Fast Method with Real Value)","text":"<pre><code>async def list_open_tickets(service: MT5Service):\n    \"\"\"Get ticket numbers only (10-20x faster than full data).\"\"\"\n\n    # Fast method - only ticket numbers\n    position_tickets, order_tickets = await service.get_opened_tickets()\n\n    print(f\"Open positions ({len(position_tickets)}):\")\n    for ticket in position_tickets:\n        print(f\"  Position #{ticket}\")\n\n    print(f\"\\nPending orders ({len(order_tickets)}):\")\n    for ticket in order_tickets:\n        print(f\"  Order #{ticket}\")\n\n    return position_tickets, order_tickets\n</code></pre>"},{"location":"MT5Service/3.%20Positions_Orders/#example-2-getting-full-position-details","title":"Example 2: Getting Full Position Details","text":"<pre><code>from MetaRpcMT5 import mt5_term_api_account_helper_pb2 as account_helper_pb2\n\nasync def display_open_positions(service: MT5Service):\n    \"\"\"Get full details for all open positions and orders.\"\"\"\n\n    # Get full data (sorted by open time, newest first)\n    data = await service.get_opened_orders(\n        sort_mode=account_helper_pb2.BMT5_OPENED_ORDER_SORT_BY_OPEN_TIME_DESC\n    )\n\n    print(\"OPEN POSITIONS:\")\n    print(\"-\" * 80)\n\n    for pos in data.position_infos:\n        print(f\"Ticket: {pos.ticket}\")\n        print(f\"  Symbol: {pos.symbol}\")\n        print(f\"  Type: {'BUY' if pos.type == 0 else 'SELL'}\")\n        print(f\"  Volume: {pos.volume}\")\n        print(f\"  Open Price: {pos.price_open}\")\n        print(f\"  Current Price: {pos.price_current}\")\n        print(f\"  Profit: ${pos.profit:.2f}\")\n        print(f\"  SL: {pos.sl}, TP: {pos.tp}\")\n        print()\n\n    print(\"\\nPENDING ORDERS:\")\n    print(\"-\" * 80)\n\n    for order in data.order_infos:\n        print(f\"Ticket: {order.ticket}\")\n        print(f\"  Symbol: {order.symbol}\")\n        print(f\"  Type: {order.type}\")\n        print(f\"  Volume: {order.volume_current}\")\n        print(f\"  Price: {order.price_open}\")\n        print(f\"  SL: {order.sl}, TP: {order.tp}\")\n        print()\n</code></pre>"},{"location":"MT5Service/3.%20Positions_Orders/#example-3-getting-closed-positions-with-pl","title":"Example 3: Getting Closed Positions with P&amp;L","text":"<pre><code>from datetime import datetime, timedelta\nfrom MetaRpcMT5 import mt5_term_api_account_helper_pb2 as account_helper_pb2\n\nasync def analyze_closed_positions(service: MT5Service):\n    \"\"\"Analyze closed positions from last 30 days.\"\"\"\n\n    to_dt = datetime.now()\n    from_dt = to_dt - timedelta(days=30)\n\n    # Get positions history sorted by profit (highest first)\n    history = await service.get_positions_history(\n        sort_type=account_helper_pb2.AH_SORT_BY_PROFIT_DESC,\n        open_from=from_dt,\n        open_to=to_dt,\n        page=0,\n        size=50\n    )\n\n    total_profit = 0.0\n    wins = 0\n    losses = 0\n\n    print(\"CLOSED POSITIONS (Last 30 days):\")\n    print(\"-\" * 80)\n\n    for pos in history.history_positions:\n        profit = pos.profit + pos.swap - pos.commission\n\n        print(f\"Ticket: {pos.ticket}\")\n        print(f\"  Symbol: {pos.symbol}\")\n        print(f\"  Type: {'BUY' if pos.type == 0 else 'SELL'}\")\n        print(f\"  Volume: {pos.volume}\")\n        print(f\"  Open: {pos.price_open} -&gt; Close: {pos.price_close}\")\n        print(f\"  Profit: ${pos.profit:.2f}\")\n        print(f\"  Swap: ${pos.swap:.2f}\")\n        print(f\"  Commission: ${pos.commission:.2f}\")\n        print(f\"  Net P&amp;L: ${profit:.2f}\")\n        print()\n\n        total_profit += profit\n        if profit &gt; 0:\n            wins += 1\n        else:\n            losses += 1\n\n    # Statistics\n    print(\"=\" * 80)\n    print(f\"Total Trades: {wins + losses}\")\n    print(f\"Wins: {wins}, Losses: {losses}\")\n    print(f\"Win Rate: {wins / (wins + losses) * 100:.1f}%\")\n    print(f\"Total P&amp;L: ${total_profit:.2f}\")\n</code></pre>"},{"location":"MT5Service/3.%20Positions_Orders/#when-to-use-which-method","title":"When to Use Which Method","text":""},{"location":"MT5Service/3.%20Positions_Orders/#use-get_opened_tickets","title":"Use get_opened_tickets()","text":"<p>Use when:</p> <ul> <li>You only need ticket numbers (not full details)</li> <li>Checking if specific ticket exists</li> <li>Counting positions/orders</li> <li>Monitoring for new positions (polling)</li> <li>Performance is critical</li> </ul> <p>Advantage: 10-20x faster than <code>get_opened_orders()</code></p> <p>Example:</p> <pre><code>pos_tickets, order_tickets = await service.get_opened_tickets()\nif 12345 in pos_tickets:\n    print(\"Position exists\")\n</code></pre>"},{"location":"MT5Service/3.%20Positions_Orders/#use-get_opened_orders","title":"Use get_opened_orders()","text":"<p>Use when:</p> <ul> <li>You need full position/order details</li> <li>Displaying position information (profit, SL/TP, prices)</li> <li>Analyzing open trades</li> <li>Building a dashboard</li> </ul> <p>Example:</p> <pre><code>data = await service.get_opened_orders()\nfor pos in data.position_infos:\n    print(f\"{pos.symbol}: Profit ${pos.profit:.2f}\")\n</code></pre>"},{"location":"MT5Service/3.%20Positions_Orders/#use-get_positions_total","title":"Use get_positions_total()","text":"<p>Use when:</p> <ul> <li>Quick count check</li> <li>Simple yes/no check (any positions open?)</li> <li>Before closing all positions</li> </ul> <p>Example:</p> <pre><code>if await service.get_positions_total() == 0:\n    print(\"All clear - no positions\")\n</code></pre>"},{"location":"MT5Service/3.%20Positions_Orders/#use-get_order_history","title":"Use get_order_history()","text":"<p>Use when:</p> <ul> <li>Analyzing order execution history</li> <li>Checking order states (filled, cancelled, rejected)</li> <li>Reviewing all trading activity (orders + deals)</li> </ul> <p>Example:</p> <pre><code>history = await service.get_order_history(from_dt, to_dt)\n</code></pre>"},{"location":"MT5Service/3.%20Positions_Orders/#use-get_positions_history","title":"Use get_positions_history()","text":"<p>Use when:</p> <ul> <li>Calculating trading performance (P&amp;L)</li> <li>Analyzing closed positions only</li> <li>Need profit/commission/swap details</li> <li>Building trade journal</li> </ul> <p>Example:</p> <pre><code>history = await service.get_positions_history(\n    sort_type=account_helper_pb2.AH_SORT_BY_PROFIT_DESC\n)\n</code></pre>"},{"location":"MT5Service/3.%20Positions_Orders/#recommendations","title":"Recommendations","text":"<ol> <li>For ticket lists - use <code>get_opened_tickets()</code> (converts protobuf repeated fields to Python lists)</li> <li>For displaying positions - use <code>get_opened_orders()</code> or call MT5Account directly (identical)</li> <li>For quick count - use <code>get_positions_total()</code> or call MT5Account directly (identical)</li> <li>For P&amp;L analysis - use <code>get_positions_history()</code> or call MT5Account directly (identical)</li> <li>For order tracking - use <code>get_order_history()</code> or call MT5Account directly (identical)</li> </ol> <p>Bottom line: Only <code>get_opened_tickets()</code> adds value through list conversion. Other methods are pass-through - call MT5Account if using Service directly.</p>"},{"location":"MT5Service/3.%20Positions_Orders/#related-sections","title":"\ud83d\udcda Related Sections","text":"<ul> <li>MT5Service Overview - mid-level API overview</li> <li>Account Methods (Mid-Level) - account information methods</li> <li>Symbol Methods (Mid-Level) - symbol information methods</li> <li>Trading Methods (Mid-Level) - placing and modifying orders</li> <li>Streaming Methods (Mid-Level) - real-time position updates</li> <li>Positions &amp; Orders (Low-Level) - low-level API</li> <li>MT5Service API Reference - complete mid-level API reference</li> </ul>"},{"location":"MT5Service/3.%20Positions_Orders/#summary","title":"Summary","text":"<p>Real value for end users:</p> <ul> <li>\u2705 <code>get_opened_tickets()</code> - Converts protobuf repeated fields \u2192 Python lists (cleaner than manual <code>list()</code> conversion)</li> <li>\u26aa <code>get_positions_total()</code> - Simple unpacking (<code>data.total_positions</code>)</li> </ul> <p>Architectural layer (for MT5Sugar):</p> <ul> <li>\u26aa <code>get_opened_orders()</code>, <code>get_order_history()</code>, <code>get_positions_history()</code> - Direct pass-through to MT5Account</li> <li>Used by MT5Sugar to maintain layered architecture (Sugar \u2192 Service \u2192 Account)</li> <li>For direct MT5Service usage: no value, call MT5Account instead</li> </ul> <p>Key difference from Symbol methods:</p> <ul> <li>Symbol methods: MT5Account returns protobuf Data \u2192 Service unpacks + converts \u2192 real value</li> <li>Positions methods: MT5Account returns protobuf Data \u2192 Service mostly pass-through \u2192 minimal value</li> </ul> <p>Recommendation:</p> <ul> <li>Using MT5Sugar? These methods work seamlessly through the architecture</li> <li>Using MT5Service directly? Only use <code>get_opened_tickets()</code> for cleaner list conversion. For other operations, call MT5Account.</li> </ul>"},{"location":"MT5Service/4.%20Market_Depth/","title":"MT5Service - Market Depth Methods (Mid-Level API)","text":""},{"location":"MT5Service/4.%20Market_Depth/#important-read-this-first","title":"\u26a0\ufe0f Important: Read This First","text":"<p>MT5Service is an architectural layer between high-level (Sugar) and low-level (Account) APIs.</p>"},{"location":"MT5Service/4.%20Market_Depth/#understanding-the-3-methods","title":"Understanding the 3 Methods:","text":"Method Direct Use Value Architectural Role <code>get_market_depth()</code> \u2705 HIGH - Converts protobuf repeated \u2192 List[BookInfo] dataclass \u2705 Used by Sugar <code>subscribe_market_depth()</code> \u2705 MEDIUM - Unpacks <code>data.success</code> from protobuf \u2705 Used by Sugar <code>unsubscribe_market_depth()</code> \u2705 MEDIUM - Unpacks <code>data.success</code> from protobuf \u2705 Used by Sugar"},{"location":"MT5Service/4.%20Market_Depth/#what-this-means","title":"What This Means:","text":"<p>Architecture (3 layers): <pre><code>MT5Sugar (HIGH)     \u2192  service.get_market_depth()      \u2190 Sugar uses Service methods\nMT5Service (MID)    \u2192  account.market_book_get()       \u2190 Service unpacks protobuf + creates dataclasses\nMT5Account (LOW)    \u2192  gRPC call \u2192 protobuf Data objects\n</code></pre></p> <p>Key difference from Account methods:</p> <ul> <li>\u2705 ALL 3 methods have value - MT5Account returns protobuf Data objects that need unpacking</li> <li>\u2705 Protobuf unpacking - Service extracts <code>data.success</code> and converts <code>data.books</code> to Python lists</li> <li>\u2705 Dataclass creation - <code>BookInfo</code> dataclass instead of protobuf <code>BookRecord</code> messages</li> <li>\u2705 Cleaner API - Direct bool/list returns instead of manual Data struct extraction</li> </ul> <p>For direct MT5Service usage:</p> <ul> <li>\u2705 Use all 3 methods - they all add value through protobuf unpacking</li> <li>\u2705 High value: <code>get_market_depth()</code> - converts protobuf repeated field to clean List[BookInfo]</li> <li>\u2705 Medium value: subscription methods - unpack bool from Data struct</li> </ul> <p>For MT5Sugar users:</p> <ul> <li>\u2705 All methods work perfectly - the layer serves its architectural purpose</li> </ul> <p>API Layer: MID-LEVEL - wrappers over MT5Account with Python native types</p> <p>Implementation:</p> <p>These methods are implemented in <code>src/pymt5/mt5_service.py</code>, which wraps <code>package/MetaRpcMT5/helpers/mt5_account.py</code> low-level API with dataclass conversion for order book entries.</p> <p>Example files:</p> <ul> <li><code>examples/2_service/04_service_demo.py</code> - comprehensive demo of all MT5Service methods including market depth (STEP 4)</li> </ul>"},{"location":"MT5Service/4.%20Market_Depth/#why-these-methods-exist","title":"Why These Methods Exist","text":""},{"location":"MT5Service/4.%20Market_Depth/#real-value-protobuf-unpacking-dataclass-conversion","title":"Real Value: Protobuf Unpacking + Dataclass Conversion","text":"<p>ALL 3 methods add real value because MT5Account returns protobuf Data objects that need manual unpacking:</p> <p>Problem with MT5Account (Low-level):</p> <pre><code># MT5Account returns protobuf Data objects - need manual unpacking\n# Subscribe\nadd_data = await account.market_book_add(\"EURUSD\", None, None)\nsuccess = add_data.success  # \u2190 Manual extraction from protobuf wrapper\n\n# Get DOM\ndom_data = await account.market_book_get(\"EURUSD\", None, None)\nbooks = dom_data.books  # \u2190 Protobuf repeated field (not Python list!)\nfor book in books:\n    # book is protobuf BookRecord, not clean dataclass\n    print(f\"{book.type}: {book.price} x {book.volume}\")\n\n# Unsubscribe\nrelease_data = await account.market_book_release(\"EURUSD\", None, None)\nsuccess = release_data.success  # \u2190 Manual extraction again\n</code></pre> <p>Solution with MT5Service (Mid-level):</p> <pre><code># Service unpacks protobuf automatically - clean Python types\n# Subscribe\nsuccess = await service.subscribe_market_depth(\"EURUSD\")  # \u2190 Already bool, not Data!\n\n# Get DOM - returns List[BookInfo] dataclass\nbooks = await service.get_market_depth(\"EURUSD\")  # \u2190 Python list, not protobuf repeated!\nfor book in books:\n    # Clean dataclass with type hints\n    print(f\"{book.type}: {book.price} x {book.volume_real}\")\n\n# Unsubscribe\nsuccess = await service.unsubscribe_market_depth(\"EURUSD\")  # \u2190 Already bool!\n</code></pre> <p>What MT5Service provides:</p> <ol> <li> <p>Protobuf unpacking (all 3 methods):</p> </li> <li> <p>MT5Account: <code>return res.data</code> (protobuf Data objects)</p> </li> <li> <p>MT5Service: <code>return data.success</code> or <code>List[BookInfo]</code> (native Python types)</p> </li> <li> <p>Dataclass conversion (1 method):</p> </li> <li> <p><code>get_market_depth()</code>: Converts protobuf repeated <code>BookRecord</code> \u2192 clean <code>List[BookInfo]</code> dataclass</p> </li> <li> <p>Cleaner API:</p> </li> <li> <p>No need to manually extract <code>.success</code> from Data wrappers</p> </li> <li>No need to work with protobuf repeated fields</li> <li>Type hints for IDE autocomplete</li> </ol> <p>Architectural purpose:</p> <ul> <li>\u2705 MT5Sugar uses these methods to maintain layered architecture (Sugar \u2192 Service \u2192 Account)</li> <li>\u2705 Direct users also benefit - all methods add value through unpacking and conversion</li> </ul>"},{"location":"MT5Service/4.%20Market_Depth/#all-3-methods","title":"All 3 Methods","text":"Method Returns Description <code>subscribe_market_depth()</code> <code>bool</code> Subscribe to DOM updates for a symbol <code>unsubscribe_market_depth()</code> <code>bool</code> Unsubscribe from DOM updates <code>get_market_depth()</code> <code>List[BookInfo]</code> Get current DOM snapshot (order book)"},{"location":"MT5Service/4.%20Market_Depth/#key-concepts","title":"Key Concepts","text":""},{"location":"MT5Service/4.%20Market_Depth/#what-is-market-depth-dom","title":"What is Market Depth (DOM)?","text":"<p>Market Depth (Depth of Market, DOM, Order Book) shows: - Bid levels: Buy orders waiting at different price levels - Ask levels: Sell orders waiting at different price levels - Volume: How much volume is available at each price level</p>"},{"location":"MT5Service/4.%20Market_Depth/#how-it-works","title":"How it works:","text":"<ol> <li>Subscribe to a symbol (<code>subscribe_market_depth</code>)</li> <li>Get snapshots whenever needed (<code>get_market_depth</code>)</li> <li>Unsubscribe when done (<code>unsubscribe_market_depth</code>)</li> </ol>"},{"location":"MT5Service/4.%20Market_Depth/#important-notes","title":"Important notes:","text":"<ul> <li>You MUST subscribe before calling <code>get_market_depth()</code></li> <li>Always unsubscribe when done to free terminal resources</li> <li>Brokers may limit concurrent DOM subscriptions (typically 5-10 symbols)</li> <li>Not all symbols support DOM (check with broker)</li> </ul>"},{"location":"MT5Service/4.%20Market_Depth/#dataclass-dto","title":"\u2795 Dataclass (DTO)","text":""},{"location":"MT5Service/4.%20Market_Depth/#bookinfo","title":"BookInfo","text":"<pre><code>@dataclass\nclass BookInfo:\n    \"\"\"Single Depth of Market (DOM) price level entry.\"\"\"\n    type: Any           # SELL (ask) or BUY (bid)\n    price: float        # Price level\n    volume: int         # Volume in lots (integer)\n    volume_real: float  # Volume with decimal precision\n</code></pre> <p>Fields explained:</p> <ul> <li>type: <code>1</code> = BUY (bid level), <code>2</code> = SELL (ask level)</li> <li>price: Price level (e.g., 1.08550 for EURUSD)</li> <li>volume: Volume in integer lots (e.g., 5 lots)</li> <li>volume_real: Volume with decimals (e.g., 5.75 lots)</li> </ul> <p>Book order:</p> <ul> <li>Bid levels: sorted from highest to lowest (best bid first)</li> <li>Ask levels: sorted from lowest to highest (best ask first)</li> </ul>"},{"location":"MT5Service/4.%20Market_Depth/#method-signatures","title":"Method Signatures","text":""},{"location":"MT5Service/4.%20Market_Depth/#1-subscribe_market_depth","title":"1) subscribe_market_depth","text":"<pre><code>async def subscribe_market_depth(\n    self,\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; bool\n</code></pre> <p>Subscribe to Depth of Market (DOM) updates.</p> <p>Args:</p> <ul> <li><code>symbol</code>: Symbol name to subscribe (e.g., \"EURUSD\", \"BTCUSD\")</li> </ul> <p>Returns: <code>bool</code> - <code>True</code> if subscription successful, <code>False</code> otherwise</p> <p>Technical: Low-level returns MarketBookAddData with <code>data.success</code> wrapper. This auto-extracts bool.</p> <p>Important:</p> <ul> <li>Required before calling <code>get_market_depth()</code> to receive DOM snapshots</li> <li>Terminal maintains subscription - call <code>unsubscribe_market_depth()</code> when done</li> <li>Brokers limit concurrent subscriptions (typically 5-10 symbols max)</li> </ul> <p>Usage pattern:</p> <pre><code># Subscribe first\nif await service.subscribe_market_depth(\"EURUSD\"):\n    # Now you can get DOM data\n    books = await service.get_market_depth(\"EURUSD\")\n</code></pre>"},{"location":"MT5Service/4.%20Market_Depth/#2-unsubscribe_market_depth","title":"2) unsubscribe_market_depth","text":"<pre><code>async def unsubscribe_market_depth(\n    self,\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; bool\n</code></pre> <p>Unsubscribe from DOM updates.</p> <p>Args:</p> <ul> <li><code>symbol</code>: Symbol name to unsubscribe</li> </ul> <p>Returns: <code>bool</code> - <code>True</code> if unsubscription successful, <code>False</code> otherwise</p> <p>Technical: Low-level returns MarketBookReleaseData with <code>data.success</code> wrapper. This auto-extracts bool.</p> <p>Important:</p> <ul> <li>Always unsubscribe when done to free terminal resources</li> <li>Brokers may limit concurrent DOM subscriptions</li> <li>Failing to unsubscribe may prevent subscribing to other symbols</li> </ul> <p>Usage pattern:</p> <pre><code>try:\n    # Work with DOM\n    books = await service.get_market_depth(\"EURUSD\")\n    # ... process data ...\nfinally:\n    # Always cleanup\n    await service.unsubscribe_market_depth(\"EURUSD\")\n</code></pre>"},{"location":"MT5Service/4.%20Market_Depth/#3-get_market_depth","title":"3) get_market_depth","text":"<pre><code>async def get_market_depth(\n    self,\n    symbol: str,\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; List[BookInfo]\n</code></pre> <p>Get current DOM snapshot (order book).</p> <p>Args:</p> <ul> <li><code>symbol</code>: Symbol name</li> </ul> <p>Returns: <code>List[BookInfo]</code> - List of order book entries (bid and ask levels)</p> <p>Technical: Low-level returns MarketBookGetData with <code>data.books</code> (repeated BookRecord protobuf). This wrapper unpacks each BookRecord into BookInfo dataclass.</p> <p>Important:</p> <ul> <li>Requires prior <code>subscribe_market_depth()</code> subscription</li> <li>Returns current snapshot (not streaming)</li> <li>BookInfo.type: <code>1</code> = BUY (bid), <code>2</code> = SELL (ask)</li> </ul> <p>Book structure:</p> <pre><code>SELL levels (asks) - sorted low to high:\n  1.08570 x 10.0 lots (type=2)\n  1.08560 x 15.5 lots (type=2)\n  1.08550 x 8.0 lots  (type=2)  &lt;- Best ask\n--------------------\n  1.08540 x 12.0 lots (type=1) &lt;- Best bid\n  1.08530 x 20.0 lots (type=1)\n  1.08520 x 5.0 lots  (type=1)\nBUY levels (bids) - sorted high to low\n</code></pre>"},{"location":"MT5Service/4.%20Market_Depth/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Service/4.%20Market_Depth/#example-1-basic-dom-subscription-and-retrieval","title":"Example 1: Basic DOM Subscription and Retrieval","text":"<pre><code>from pymt5 import MT5Service\n\nasync def get_dom(service: MT5Service, symbol: str):\n    \"\"\"Basic DOM usage pattern.\"\"\"\n\n    try:\n        # Step 1: Subscribe\n        success = await service.subscribe_market_depth(symbol)\n        if not success:\n            print(f\"Failed to subscribe to {symbol} DOM\")\n            return\n\n        print(f\"Subscribed to {symbol} DOM\")\n\n        # Step 2: Get DOM data\n        books = await service.get_market_depth(symbol)\n\n        print(f\"\\nMarket Depth for {symbol}:\")\n        print(\"-\" * 60)\n\n        # Separate bids and asks\n        bids = [b for b in books if b.type == 1]\n        asks = [b for b in books if b.type == 2]\n\n        # Display asks (reversed to show best ask last)\n        print(\"\\nASKS (Sell orders):\")\n        for book in reversed(asks):\n            print(f\"  {book.price:.5f} x {book.volume_real:.2f} lots\")\n\n        print(\"\\n\" + \"=\" * 60)\n\n        # Display bids\n        print(\"\\nBIDS (Buy orders):\")\n        for book in bids:\n            print(f\"  {book.price:.5f} x {book.volume_real:.2f} lots\")\n\n    finally:\n        # Step 3: Always unsubscribe\n        await service.unsubscribe_market_depth(symbol)\n        print(f\"\\nUnsubscribed from {symbol} DOM\")\n</code></pre>"},{"location":"MT5Service/4.%20Market_Depth/#example-2-getting-best-bid-and-ask","title":"Example 2: Getting Best Bid and Ask","text":"<pre><code>async def get_best_prices(service: MT5Service, symbol: str):\n    \"\"\"Get best bid and ask from DOM.\"\"\"\n\n    try:\n        # Subscribe\n        if not await service.subscribe_market_depth(symbol):\n            return None, None\n\n        # Get DOM\n        books = await service.get_market_depth(symbol)\n\n        # Separate bids and asks\n        bids = [b for b in books if b.type == 1]\n        asks = [b for b in books if b.type == 2]\n\n        # Best bid = highest bid price (first in sorted list)\n        best_bid = bids[0] if bids else None\n\n        # Best ask = lowest ask price (first in sorted list)\n        best_ask = asks[0] if asks else None\n\n        if best_bid and best_ask:\n            print(f\"{symbol}:\")\n            print(f\"  Best Bid: {best_bid.price:.5f} ({best_bid.volume_real:.2f} lots)\")\n            print(f\"  Best Ask: {best_ask.price:.5f} ({best_ask.volume_real:.2f} lots)\")\n            print(f\"  Spread: {(best_ask.price - best_bid.price):.5f}\")\n\n            return best_bid, best_ask\n\n    finally:\n        await service.unsubscribe_market_depth(symbol)\n\n    return None, None\n</code></pre>"},{"location":"MT5Service/4.%20Market_Depth/#example-3-calculating-total-volume-at-each-side","title":"Example 3: Calculating Total Volume at Each Side","text":"<pre><code>async def analyze_dom_liquidity(service: MT5Service, symbol: str):\n    \"\"\"Analyze total bid/ask volume in DOM.\"\"\"\n\n    try:\n        await service.subscribe_market_depth(symbol)\n        books = await service.get_market_depth(symbol)\n\n        # Calculate totals\n        total_bid_volume = sum(b.volume_real for b in books if b.type == 1)\n        total_ask_volume = sum(b.volume_real for b in books if b.type == 2)\n\n        bid_count = len([b for b in books if b.type == 1])\n        ask_count = len([b for b in books if b.type == 2])\n\n        print(f\"{symbol} DOM Liquidity:\")\n        print(f\"  Bid side: {total_bid_volume:.2f} lots across {bid_count} levels\")\n        print(f\"  Ask side: {total_ask_volume:.2f} lots across {ask_count} levels\")\n        print(f\"  Bid/Ask ratio: {total_bid_volume / total_ask_volume:.2f}\")\n\n        # Imbalance analysis\n        if total_bid_volume &gt; total_ask_volume * 1.5:\n            print(\"  Status: Strong buying pressure\")\n        elif total_ask_volume &gt; total_bid_volume * 1.5:\n            print(\"  Status: Strong selling pressure\")\n        else:\n            print(\"  Status: Balanced\")\n\n    finally:\n        await service.unsubscribe_market_depth(symbol)\n</code></pre>"},{"location":"MT5Service/4.%20Market_Depth/#example-4-displaying-dom-table","title":"Example 4: Displaying DOM Table","text":"<pre><code>async def display_dom_table(service: MT5Service, symbol: str, levels: int = 5):\n    \"\"\"Display DOM as a formatted table.\"\"\"\n\n    try:\n        await service.subscribe_market_depth(symbol)\n        books = await service.get_market_depth(symbol)\n\n        bids = [b for b in books if b.type == 1][:levels]\n        asks = [b for b in books if b.type == 2][:levels]\n\n        print(f\"\\n{symbol} - Market Depth (Top {levels} levels)\")\n        print(\"=\" * 70)\n        print(f\"{'BID Volume':&lt;15} {'BID Price':&lt;15} {'ASK Price':&lt;15} {'ASK Volume':&lt;15}\")\n        print(\"-\" * 70)\n\n        # Reverse asks to show best ask at bottom\n        asks_reversed = list(reversed(asks))\n\n        max_levels = max(len(bids), len(asks_reversed))\n\n        for i in range(max_levels):\n            bid_vol = f\"{bids[i].volume_real:.2f}\" if i &lt; len(bids) else \"\"\n            bid_price = f\"{bids[i].price:.5f}\" if i &lt; len(bids) else \"\"\n            ask_price = f\"{asks_reversed[i].price:.5f}\" if i &lt; len(asks_reversed) else \"\"\n            ask_vol = f\"{asks_reversed[i].volume_real:.2f}\" if i &lt; len(asks_reversed) else \"\"\n\n            print(f\"{bid_vol:&lt;15} {bid_price:&lt;15} {ask_price:&lt;15} {ask_vol:&lt;15}\")\n\n        print(\"=\" * 70)\n\n    finally:\n        await service.unsubscribe_market_depth(symbol)\n</code></pre>"},{"location":"MT5Service/4.%20Market_Depth/#example-5-monitoring-dom-changes","title":"Example 5: Monitoring DOM Changes","text":"<pre><code>import asyncio\n\nasync def monitor_dom_changes(\n    service: MT5Service,\n    symbol: str,\n    interval_seconds: int = 1,\n    duration_seconds: int = 60\n):\n    \"\"\"Monitor DOM changes over time.\"\"\"\n\n    try:\n        # Subscribe\n        if not await service.subscribe_market_depth(symbol):\n            print(f\"Failed to subscribe to {symbol}\")\n            return\n\n        print(f\"Monitoring {symbol} DOM for {duration_seconds} seconds...\")\n\n        start_time = asyncio.get_event_loop().time()\n\n        while True:\n            elapsed = asyncio.get_event_loop().time() - start_time\n            if elapsed &gt;= duration_seconds:\n                break\n\n            # Get current DOM\n            books = await service.get_market_depth(symbol)\n\n            bids = [b for b in books if b.type == 1]\n            asks = [b for b in books if b.type == 2]\n\n            if bids and asks:\n                best_bid = bids[0]\n                best_ask = asks[0]\n\n                print(f\"[{elapsed:.1f}s] Bid: {best_bid.price:.5f} ({best_bid.volume_real:.2f}) | \"\n                      f\"Ask: {best_ask.price:.5f} ({best_ask.volume_real:.2f}) | \"\n                      f\"Spread: {(best_ask.price - best_bid.price):.5f}\")\n\n            await asyncio.sleep(interval_seconds)\n\n    finally:\n        await service.unsubscribe_market_depth(symbol)\n        print(f\"\\nStopped monitoring {symbol}\")\n</code></pre>"},{"location":"MT5Service/4.%20Market_Depth/#example-6-multiple-symbols-dom","title":"Example 6: Multiple Symbols DOM","text":"<pre><code>async def monitor_multiple_symbols(service: MT5Service, symbols: list):\n    \"\"\"Monitor DOM for multiple symbols (respecting broker limits).\"\"\"\n\n    subscribed = []\n\n    try:\n        # Subscribe to all symbols\n        for symbol in symbols:\n            success = await service.subscribe_market_depth(symbol)\n            if success:\n                subscribed.append(symbol)\n                print(f\"Subscribed: {symbol}\")\n            else:\n                print(f\"Failed: {symbol} (broker limit reached?)\")\n\n        print(f\"\\nSuccessfully subscribed to {len(subscribed)} symbols\")\n\n        # Get DOM for all subscribed symbols\n        for symbol in subscribed:\n            books = await service.get_market_depth(symbol)\n\n            bids = [b for b in books if b.type == 1]\n            asks = [b for b in books if b.type == 2]\n\n            if bids and asks:\n                print(f\"\\n{symbol}:\")\n                print(f\"  Best Bid: {bids[0].price:.5f} x {bids[0].volume_real:.2f}\")\n                print(f\"  Best Ask: {asks[0].price:.5f} x {asks[0].volume_real:.2f}\")\n                print(f\"  Total levels: {len(bids)} bids, {len(asks)} asks\")\n\n    finally:\n        # Unsubscribe from all\n        for symbol in subscribed:\n            await service.unsubscribe_market_depth(symbol)\n            print(f\"Unsubscribed: {symbol}\")\n</code></pre>"},{"location":"MT5Service/4.%20Market_Depth/#example-7-finding-large-orders","title":"Example 7: Finding Large Orders","text":"<pre><code>async def find_large_orders(\n    service: MT5Service,\n    symbol: str,\n    min_volume: float = 10.0\n):\n    \"\"\"Find large orders in DOM (potential resistance/support).\"\"\"\n\n    try:\n        await service.subscribe_market_depth(symbol)\n        books = await service.get_market_depth(symbol)\n\n        # Find large orders\n        large_bids = [b for b in books if b.type == 1 and b.volume_real &gt;= min_volume]\n        large_asks = [b for b in books if b.type == 2 and b.volume_real &gt;= min_volume]\n\n        print(f\"\\n{symbol} - Large Orders (&gt;= {min_volume} lots):\")\n        print(\"=\" * 60)\n\n        if large_bids:\n            print(f\"\\nLarge BID orders (potential support):\")\n            for book in large_bids:\n                print(f\"  {book.price:.5f} x {book.volume_real:.2f} lots\")\n\n        if large_asks:\n            print(f\"\\nLarge ASK orders (potential resistance):\")\n            for book in large_asks:\n                print(f\"  {book.price:.5f} x {book.volume_real:.2f} lots\")\n\n        if not large_bids and not large_asks:\n            print(f\"\\nNo large orders found (min: {min_volume} lots)\")\n\n    finally:\n        await service.unsubscribe_market_depth(symbol)\n</code></pre>"},{"location":"MT5Service/4.%20Market_Depth/#when-to-use-each-method","title":"When to Use Each Method","text":""},{"location":"MT5Service/4.%20Market_Depth/#use-subscribe_market_depth","title":"Use subscribe_market_depth()","text":"<p>Use when:</p> <ul> <li>Starting DOM monitoring for a symbol</li> <li>Need to receive order book updates</li> <li>Before calling <code>get_market_depth()</code></li> </ul> <p>Important:</p> <ul> <li>Always call BEFORE <code>get_market_depth()</code></li> <li>Check return value (False = subscription failed)</li> </ul> <p>Example:</p> <pre><code>if await service.subscribe_market_depth(\"EURUSD\"):\n    # Now you can get DOM data\n    pass\n</code></pre>"},{"location":"MT5Service/4.%20Market_Depth/#use-get_market_depth","title":"Use get_market_depth()","text":"<p>Use when:</p> <ul> <li>Need current order book snapshot</li> <li>Analyzing market liquidity</li> <li>Finding best bid/ask prices</li> <li>Looking for large orders</li> </ul> <p>Important:</p> <ul> <li>Requires prior subscription</li> <li>Returns snapshot (not streaming)</li> <li>Call repeatedly for monitoring</li> </ul> <p>Example:</p> <pre><code>books = await service.get_market_depth(\"EURUSD\")\nbest_bid = [b for b in books if b.type == 1][0]\n</code></pre>"},{"location":"MT5Service/4.%20Market_Depth/#use-unsubscribe_market_depth","title":"Use unsubscribe_market_depth()","text":"<p>Use when:</p> <ul> <li>Done monitoring symbol</li> <li>Cleaning up resources</li> <li>Want to subscribe to different symbol</li> </ul> <p>Important:</p> <ul> <li>ALWAYS call when done</li> <li>Free up subscription slot for other symbols</li> <li>Use in <code>finally</code> block for guaranteed cleanup</li> </ul> <p>Example:</p> <pre><code>try:\n    await service.subscribe_market_depth(\"EURUSD\")\n    # ... work with DOM ...\nfinally:\n    await service.unsubscribe_market_depth(\"EURUSD\")\n</code></pre>"},{"location":"MT5Service/4.%20Market_Depth/#recommendations","title":"Recommendations","text":"<ol> <li>Always unsubscribe - Use <code>try/finally</code> to ensure cleanup</li> <li>Check subscription limits - Brokers typically allow 5-10 concurrent subscriptions</li> <li>Check return values - <code>subscribe_market_depth()</code> returns False if failed</li> <li>Not all symbols support DOM - Check with your broker</li> <li>DOM is a snapshot - Call <code>get_market_depth()</code> repeatedly for monitoring</li> <li>Use context manager pattern - Ensures proper cleanup</li> </ol> <p>Example pattern:</p> <pre><code>async def with_dom(service, symbol):\n    try:\n        if not await service.subscribe_market_depth(symbol):\n            return\n        # Work with DOM\n        books = await service.get_market_depth(symbol)\n        # ... process ...\n    finally:\n        await service.unsubscribe_market_depth(symbol)\n</code></pre>"},{"location":"MT5Service/4.%20Market_Depth/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Forgetting to subscribe - <code>get_market_depth()</code> will fail without subscription</li> <li>Not unsubscribing - Wastes resources, may prevent other subscriptions</li> <li>Exceeding broker limits - Most brokers limit concurrent DOM subscriptions</li> <li>Assuming all symbols support DOM - Not all symbols have market depth data</li> </ol>"},{"location":"MT5Service/4.%20Market_Depth/#related-sections","title":"\ud83d\udcda Related Sections","text":"<ul> <li>MT5Service Overview - mid-level API overview</li> <li>Symbol Methods (Mid-Level) - symbol information methods</li> <li>Streaming Methods (Mid-Level) - real-time tick streaming</li> <li>Market Depth (Low-Level) - low-level DOM API</li> <li>MT5Service API Reference - complete mid-level API reference</li> </ul>"},{"location":"MT5Service/4.%20Market_Depth/#summary","title":"Summary","text":""},{"location":"MT5Service/4.%20Market_Depth/#real-value-assessment","title":"Real Value Assessment","text":"<p>ALL 3 methods add real value through protobuf unpacking and dataclass conversion:</p> Method Value Level What It Does <code>get_market_depth()</code> \u2705 HIGH Converts protobuf repeated <code>BookRecord</code> \u2192 clean <code>List[BookInfo]</code> dataclass <code>subscribe_market_depth()</code> \u2705 MEDIUM Unpacks <code>data.success</code> from protobuf <code>MarketBookAddData</code> \u2192 bool <code>unsubscribe_market_depth()</code> \u2705 MEDIUM Unpacks <code>data.success</code> from protobuf <code>MarketBookReleaseData</code> \u2192 bool <p>Why these methods have value:</p> <p>MT5Account returns protobuf Data objects: <pre><code># Low-level returns:\nadd_data: MarketBookAddData = await account.market_book_add(...)\ndom_data: MarketBookGetData = await account.market_book_get(...)\nrelease_data: MarketBookReleaseData = await account.market_book_release(...)\n</code></pre></p> <p>MT5Service unpacks to native Python types: <pre><code># Mid-level returns:\nsuccess: bool = await service.subscribe_market_depth(...)           # Unpacks data.success\nbooks: List[BookInfo] = await service.get_market_depth(...)         # Unpacks + converts data.books\nsuccess: bool = await service.unsubscribe_market_depth(...)         # Unpacks data.success\n</code></pre></p> <p>Key advantages:</p> <ol> <li>Protobuf unpacking - No need to manually extract <code>.success</code> or <code>.books</code></li> <li>Dataclass conversion - <code>BookInfo</code> dataclass instead of protobuf <code>BookRecord</code> messages</li> <li>Clean Python types - <code>bool</code> and <code>List[BookInfo]</code> instead of Data wrappers</li> <li>Type hints - Full IDE autocomplete support</li> <li>Easier to use - No protobuf knowledge required</li> </ol> <p>Best practices:</p> <ul> <li>Always use <code>try/finally</code> for guaranteed cleanup</li> <li>Check subscription return values</li> <li>Respect broker subscription limits (typically 5-10 symbols)</li> <li>Not all symbols support DOM - verify with broker</li> </ul> <p>Bottom line:</p> <ul> <li>\u2705 For direct users: All 3 methods add value - use them for cleaner API</li> <li>\u2705 For Sugar users: Methods serve architectural purpose perfectly</li> <li>\u2705 vs MT5Account: Significant improvement through unpacking and dataclass conversion</li> </ul>"},{"location":"MT5Service/5.%20Trading_Operations/","title":"MT5Service - Trading Operations Methods (Mid-Level API)","text":""},{"location":"MT5Service/5.%20Trading_Operations/#important-read-this-first","title":"\u26a0\ufe0f Important: Read This First","text":"<p>MT5Service is an architectural layer between high-level (Sugar) and low-level (Account) APIs.</p>"},{"location":"MT5Service/5.%20Trading_Operations/#understanding-the-6-methods","title":"Understanding the 6 Methods:","text":"Method Direct Use Value Architectural Role <code>check_order()</code> \u2705 VERY HIGH - Extracts deeply nested protobuf \u2192 OrderCheckResult dataclass (8 fields) \u2705 Used by Sugar <code>place_order()</code> \u2705 HIGH - Flattens protobuf \u2192 OrderResult dataclass (10 fields) \u2705 Used by Sugar <code>modify_order()</code> \u2705 HIGH - Flattens protobuf \u2192 OrderResult dataclass (10 fields) \u2705 Used by Sugar <code>close_order()</code> \u26aa LOW - Unpacks <code>data.returned_code</code> from protobuf \u2192 int \u2705 Used by Sugar <code>calculate_margin()</code> \u26aa LOW - Unpacks <code>data.margin</code> from protobuf \u2192 float \u2705 Used by Sugar <code>calculate_profit()</code> \u26aa LOW - Unpacks <code>data.profit</code> from protobuf \u2192 float \u2705 Used by Sugar"},{"location":"MT5Service/5.%20Trading_Operations/#what-this-means","title":"What This Means:","text":"<p>Architecture (3 layers):</p> <pre><code>MT5Sugar (HIGH)     \u2192  service.place_order()           \u2190 Sugar uses Service methods\nMT5Service (MID)    \u2192  account.order_send()            \u2190 Service unpacks protobuf + creates dataclasses\nMT5Account (LOW)    \u2192  gRPC call \u2192 protobuf Data objects\n</code></pre> <p>Value breakdown:</p> <ul> <li>\u2705 VERY HIGH (1 method): <code>check_order()</code> - extracts deeply nested <code>mrpc_mql_trade_check_result</code> structure</li> <li>\u2705 HIGH (2 methods): <code>place_order()</code>, <code>modify_order()</code> - flatten 10 protobuf fields into clean dataclass</li> <li>\u26aa LOW (3 methods): Simple unpacking of single protobuf field (<code>returned_code</code>, <code>margin</code>, <code>profit</code>)</li> </ul> <p>For direct MT5Service usage:</p> <ul> <li>\u2705 Highly recommended: Use <code>check_order()</code>, <code>place_order()</code>, <code>modify_order()</code> - significant dataclass conversion value</li> <li>\u26aa Optional: <code>close_order()</code>, <code>calculate_margin()</code>, <code>calculate_profit()</code> - minor unpacking value</li> </ul> <p>For MT5Sugar users:</p> <ul> <li>\u2705 All methods work perfectly - the layer serves its architectural purpose</li> </ul> <p>API Layer: MID-LEVEL - wrappers over MT5Account with clean dataclass returns</p> <p>Implementation:</p> <p>These methods are implemented in <code>src/pymt5/mt5_service.py</code>, which wraps <code>package/MetaRpcMT5/helpers/mt5_account.py</code> low-level API with dataclass conversion for trading results.</p> <p>Example files:</p> <ul> <li><code>examples/2_service/04_service_demo.py</code> - comprehensive demo of all MT5Service methods including trading operations (STEP 5)</li> </ul>"},{"location":"MT5Service/5.%20Trading_Operations/#why-these-methods-exist","title":"Why These Methods Exist","text":""},{"location":"MT5Service/5.%20Trading_Operations/#real-value-protobuf-unpacking-dataclass-conversion","title":"Real Value: Protobuf Unpacking + Dataclass Conversion","text":"<p>3 methods add VERY HIGH/HIGH value through complex dataclass conversion, 3 methods add LOW value through simple unpacking:</p> <p>Problem with MT5Account (Low-level):</p> <pre><code># MT5Account returns complex protobuf objects\nrequest = trading_helper_pb2.OrderSendRequest()\nrequest.symbol = \"EURUSD\"\nrequest.volume = 0.1\nrequest.action = 1  # TRADE_ACTION_DEAL\nrequest.type = 0    # ORDER_TYPE_BUY\n\nresult_data = await account.order_send(request, None, None)\n# result_data is protobuf OrderSendData with 10 nested fields\nif result_data.returned_code == 10009:  # TRADE_RETCODE_DONE\n    print(f\"Deal: {result_data.deal}, Order: {result_data.order}\")\n    # Must manually access each of 10 protobuf fields\n\n# Checking order requires extracting DEEPLY NESTED structure:\ncheck_response = await account.order_check(request, None, None)\nresult = check_response.mrpc_mql_trade_check_result  # \u2190 Deeply nested!\nif result.returned_code == 0:\n    print(f\"Valid! Margin: {result.margin}\")\n</code></pre> <p>Solution with MT5Service (Mid-level):</p> <pre><code># Service creates clean dataclasses - no manual field extraction\nrequest = trading_helper_pb2.OrderSendRequest()\nrequest.symbol = \"EURUSD\"\nrequest.volume = 0.1\nrequest.action = 1\nrequest.type = 0\n\nresult = await service.place_order(request)\n# result is OrderResult dataclass with 10 clear fields\nif result.returned_code == 10009:\n    print(f\"Deal: {result.deal}, Order: {result.order}\")\n    # Clean dataclass access with type hints\n\n# Check order returns clean dataclass - no nesting:\ncheck = await service.check_order(request)\n# check is OrderCheckResult dataclass with 8 fields - already extracted!\nif check.returned_code == 0:\n    print(f\"Valid! Margin: {check.margin}\")\n</code></pre> <p>What MT5Service provides:</p> <ol> <li> <p>Complex dataclass conversion (3 methods with HIGH/VERY HIGH value):</p> </li> <li> <p><code>check_order()</code>: Extracts deeply nested <code>mrpc_mql_trade_check_result</code> \u2192 OrderCheckResult (8 fields)</p> </li> <li><code>place_order()</code>: Flattens 10 protobuf fields \u2192 OrderResult dataclass</li> <li> <p><code>modify_order()</code>: Flattens 10 protobuf fields \u2192 OrderResult dataclass</p> </li> <li> <p>Simple unpacking (3 methods with LOW value):</p> </li> <li> <p><code>close_order()</code>: Unpacks <code>data.returned_code</code> \u2192 int</p> </li> <li><code>calculate_margin()</code>: Unpacks <code>data.margin</code> \u2192 float</li> <li> <p><code>calculate_profit()</code>: Unpacks <code>data.profit</code> \u2192 float</p> </li> <li> <p>Cleaner API:</p> </li> <li> <p>No need to manually access nested protobuf structures</p> </li> <li>Type hints for IDE autocomplete</li> <li>Clear field names in dataclasses</li> </ol> <p>Architectural purpose:</p> <ul> <li>\u2705 MT5Sugar uses these methods to maintain layered architecture (Sugar \u2192 Service \u2192 Account)</li> <li>\u2705 Direct users benefit significantly from dataclass conversion (especially check_order/place_order/modify_order)</li> </ul>"},{"location":"MT5Service/5.%20Trading_Operations/#all-6-methods","title":"All 6 Methods","text":"Method Returns Description <code>place_order()</code> <code>OrderResult</code> Send market/pending order to broker <code>modify_order()</code> <code>OrderResult</code> Modify existing order or position (SL/TP) <code>close_order()</code> <code>int</code> Close position or delete pending order <code>check_order()</code> <code>OrderCheckResult</code> Validate order before sending <code>calculate_margin()</code> <code>float</code> Calculate required margin for an order <code>calculate_profit()</code> <code>float</code> Calculate potential profit for a trade"},{"location":"MT5Service/5.%20Trading_Operations/#key-concepts","title":"Key Concepts","text":""},{"location":"MT5Service/5.%20Trading_Operations/#order-types","title":"Order Types","text":"<ul> <li>Market Order: Executes immediately at current market price (BUY/SELL)</li> <li>Pending Order: Executes when price reaches specified level (BUY_LIMIT, SELL_LIMIT, BUY_STOP, SELL_STOP)</li> </ul>"},{"location":"MT5Service/5.%20Trading_Operations/#return-codes","title":"Return Codes","text":"<p>All trading operations return a return code indicating success/failure:</p> <ul> <li>10009 (TRADE_RETCODE_DONE): Success - order placed/modified/closed</li> <li>10004 (TRADE_RETCODE_REQUOTE): Requote - price changed, retry</li> <li>10006 (TRADE_RETCODE_REJECT): Rejected by broker</li> <li>10007 (TRADE_RETCODE_CANCEL): Cancelled by trader</li> <li>10013 (TRADE_RETCODE_INVALID_VOLUME): Invalid volume</li> <li>10014 (TRADE_RETCODE_INVALID_PRICE): Invalid price</li> <li>10015 (TRADE_RETCODE_INVALID_STOPS): Invalid SL/TP</li> </ul> <p>Always check returned_code == 10009 for success!</p>"},{"location":"MT5Service/5.%20Trading_Operations/#pre-trade-validation","title":"Pre-Trade Validation","text":"<p>Before sending orders, use <code>check_order()</code> to validate: - Sufficient margin - Valid volume/price/stops - Trading allowed</p>"},{"location":"MT5Service/5.%20Trading_Operations/#dataclasses-dtos","title":"\u2795 Dataclasses (DTOs)","text":""},{"location":"MT5Service/5.%20Trading_Operations/#orderresult","title":"OrderResult","text":"<pre><code>@dataclass\nclass OrderResult:\n    \"\"\"\n    Result of a trading operation.\n\n    ADVANTAGE: Clean dataclass instead of protobuf OrderSendData/OrderModifyData.\n    \"\"\"\n    returned_code: int      # Operation return code (10009 = TRADE_RETCODE_DONE)\n    deal: int               # Deal ticket number (if executed)\n    order: int              # Order ticket number (if placed)\n    volume: float           # Executed volume confirmed by broker\n    price: float            # Execution price confirmed by broker\n    bid: float              # Current Bid price\n    ask: float              # Current Ask price\n    comment: str            # Broker comment or error description\n    request_id: int         # Request ID set by terminal\n    ret_code_external: int  # External return code\n</code></pre> <p>Usage:</p> <pre><code>result = await service.place_order(request)\nif result.returned_code == 10009:\n    print(f\"Success! Deal: {result.deal}, Order: {result.order}\")\nelse:\n    print(f\"Failed: {result.comment}\")\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#ordercheckresult","title":"OrderCheckResult","text":"<pre><code>@dataclass\nclass OrderCheckResult:\n    \"\"\"Result of order validation.\"\"\"\n    returned_code: int      # Validation code (0 = success)\n    balance: float          # Balance after deal\n    equity: float           # Equity after deal\n    profit: float           # Profit\n    margin: float           # Required margin\n    margin_free: float      # Free margin after\n    margin_level: float     # Margin level after (%)\n    comment: str            # Error description\n</code></pre> <p>Usage:</p> <pre><code>check = await service.check_order(request)\nif check.returned_code == 0:\n    print(f\"Valid! Required margin: ${check.margin:.2f}\")\nelse:\n    print(f\"Invalid: {check.comment}\")\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#method-signatures","title":"Method Signatures","text":""},{"location":"MT5Service/5.%20Trading_Operations/#1-place_order","title":"1) place_order","text":"<pre><code>async def place_order(\n    self,\n    request: Any,  # trading_helper_pb2.OrderSendRequest\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; OrderResult\n</code></pre> <p>Send market/pending order to broker.</p> <p>Args:</p> <ul> <li><code>request</code>: OrderSendRequest protobuf with order parameters</li> </ul> <p>Returns: <code>OrderResult</code> dataclass with deal/order tickets and execution details</p> <p>Technical: Low-level returns OrderSendData protobuf with nested broker response fields. This wrapper flattens protobuf into OrderResult dataclass with 10 fields.</p> <p>Check returned_code == 10009 (TRADE_RETCODE_DONE) for successful execution.</p> <p>OrderSendRequest fields:</p> <pre><code>request.symbol = \"EURUSD\"           # Symbol\nrequest.volume = 0.1                # Volume in lots\nrequest.action = 1                  # TRADE_ACTION_DEAL (market order)\nrequest.type = 0                    # ORDER_TYPE_BUY\nrequest.price = 0.0                 # 0 for market orders\nrequest.sl = 1.08000                # Stop Loss (optional)\nrequest.tp = 1.09000                # Take Profit (optional)\nrequest.deviation = 20              # Max price deviation in points\nrequest.comment = \"My order\"        # Optional comment\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#2-modify_order","title":"2) modify_order","text":"<pre><code>async def modify_order(\n    self,\n    request: Any,  # trading_helper_pb2.OrderModifyRequest\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; OrderResult\n</code></pre> <p>Modify existing order or position (SL/TP).</p> <p>Args:</p> <ul> <li><code>request</code>: OrderModifyRequest protobuf with modification parameters</li> </ul> <p>Returns: <code>OrderResult</code> with modification details</p> <p>Technical: Low-level returns OrderModifyData protobuf (same structure as OrderSendData). This wrapper flattens into OrderResult.</p> <p>Used to:</p> <ul> <li>Change SL/TP on open positions</li> <li>Modify pending order price/SL/TP</li> </ul> <p>OrderModifyRequest fields:</p> <pre><code>request.order = 12345678            # Ticket number to modify\nrequest.sl = 1.08500                # New Stop Loss\nrequest.tp = 1.09500                # New Take Profit\nrequest.price = 1.08000             # New order price (pending orders only)\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#3-close_order","title":"3) close_order","text":"<pre><code>async def close_order(\n    self,\n    request: Any,  # trading_helper_pb2.OrderCloseRequest\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; int\n</code></pre> <p>Close position or delete pending order.</p> <p>Args:</p> <ul> <li><code>request</code>: OrderCloseRequest protobuf with ticket to close</li> </ul> <p>Returns: <code>int</code> return code directly (10009 = success)</p> <p>Technical: Low-level returns OrderCloseData with <code>data.returned_code</code> wrapper. This auto-extracts the int return code.</p> <p>How it works:</p> <ul> <li>For positions: Creates opposite market order</li> <li>For pending orders: Sends delete request</li> </ul> <p>OrderCloseRequest fields:</p> <pre><code>request.order = 12345678            # Ticket number to close\nrequest.volume = 0.0                # 0 = close all, or partial volume\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#4-check_order","title":"4) check_order","text":"<pre><code>async def check_order(\n    self,\n    request: Any,  # trade_functions_pb2.OrderCheckRequest\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; OrderCheckResult\n</code></pre> <p>Validate order before sending to broker.</p> <p>Args:</p> <ul> <li><code>request</code>: OrderCheckRequest protobuf (similar to OrderSendRequest)</li> </ul> <p>Returns: <code>OrderCheckResult</code> dataclass with validation details</p> <p>Technical: Low-level returns OrderCheckResponse with deeply nested <code>mrpc_mql_trade_check_result</code>. This wrapper extracts 8 validation fields.</p> <p>Use this before place_order() to:</p> <ul> <li>Pre-validate margin requirements without sending to broker</li> <li>Check if order parameters are valid</li> <li>See impact on account (balance, equity, margin)</li> </ul> <p>OrderCheckRequest fields:</p> <pre><code>request.symbol = \"EURUSD\"\nrequest.volume = 0.1\nrequest.action = 1                  # TRADE_ACTION_DEAL\nrequest.type = 0                    # ORDER_TYPE_BUY\nrequest.price = 0.0\n</code></pre> <p>returned_code = 0 means valid order</p>"},{"location":"MT5Service/5.%20Trading_Operations/#5-calculate_margin","title":"5) calculate_margin","text":"<pre><code>async def calculate_margin(\n    self,\n    request: Any,  # trade_functions_pb2.OrderCalcMarginRequest\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; float\n</code></pre> <p>Calculate required margin for an order.</p> <p>Args: - <code>request</code>: OrderCalcMarginRequest protobuf</p> <p>Returns: <code>float</code> margin value directly (no Data struct)</p> <p>Technical: Low-level returns OrderCalcMarginResponse with <code>data.margin</code> wrapper. This auto-extracts margin float.</p> <p>Use to:</p> <ul> <li>Check margin requirements before placing order</li> <li>Validate if you have enough free margin</li> <li>Calculate position sizing</li> </ul> <p>OrderCalcMarginRequest fields:</p> <pre><code>request.symbol = \"EURUSD\"\nrequest.volume = 0.1\nrequest.action = 1                  # TRADE_ACTION_DEAL\nrequest.type = 0                    # ORDER_TYPE_BUY\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#6-calculate_profit","title":"6) calculate_profit","text":"<pre><code>async def calculate_profit(\n    self,\n    request: Any,  # trade_functions_pb2.OrderCalcProfitRequest\n    deadline: Optional[datetime] = None,\n    cancellation_event: Optional[Any] = None,\n) -&gt; float\n</code></pre> <p>Calculate potential profit for a trade.</p> <p>Args:</p> <ul> <li><code>request</code>: OrderCalcProfitRequest protobuf</li> </ul> <p>Returns: <code>float</code> profit value directly (no Data struct)</p> <p>Technical: Low-level returns OrderCalcProfitResponse with <code>data.profit</code> wrapper. This auto-extracts profit float.</p> <p>Use to:</p> <ul> <li>Calculate P&amp;L for hypothetical trade given entry/exit prices and volume</li> <li>Validate risk/reward ratio</li> <li>Calculate TP target profit</li> </ul> <p>OrderCalcProfitRequest fields:</p> <pre><code>request.symbol = \"EURUSD\"\nrequest.volume = 0.1\nrequest.action = 1                  # TRADE_ACTION_DEAL\nrequest.type = 0                    # ORDER_TYPE_BUY\nrequest.price_open = 1.08000        # Entry price\nrequest.price_close = 1.09000       # Exit price\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Service/5.%20Trading_Operations/#example-1-placing-market-buy-order","title":"Example 1: Placing Market Buy Order","text":"<pre><code>from pymt5 import MT5Service\nfrom MetaRpcMT5 import mt5_term_api_trading_helper_pb2 as trading_helper_pb2\n\nasync def place_market_buy(service: MT5Service, symbol: str, volume: float):\n    \"\"\"Place a market BUY order.\"\"\"\n\n    # Create request\n    request = trading_helper_pb2.OrderSendRequest()\n    request.symbol = symbol\n    request.volume = volume\n    request.action = 1              # TRADE_ACTION_DEAL (market order)\n    request.type = 0                # ORDER_TYPE_BUY\n    request.price = 0.0             # 0 for market orders\n    request.deviation = 20          # Max 20 points deviation\n    request.comment = \"Market BUY\"\n\n    # Send order\n    result = await service.place_order(request)\n\n    # Check result\n    if result.returned_code == 10009:  # TRADE_RETCODE_DONE\n        print(f\"SUCCESS!\")\n        print(f\"  Deal: {result.deal}\")\n        print(f\"  Order: {result.order}\")\n        print(f\"  Price: {result.price}\")\n        print(f\"  Volume: {result.volume}\")\n    else:\n        print(f\"FAILED: {result.comment}\")\n        print(f\"  Return code: {result.returned_code}\")\n\n    return result\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#example-2-placing-order-with-sltp","title":"Example 2: Placing Order with SL/TP","text":"<pre><code>async def place_order_with_stops(\n    service: MT5Service,\n    symbol: str,\n    volume: float,\n    sl: float,\n    tp: float\n):\n    \"\"\"Place market order with Stop Loss and Take Profit.\"\"\"\n\n    request = trading_helper_pb2.OrderSendRequest()\n    request.symbol = symbol\n    request.volume = volume\n    request.action = 1              # TRADE_ACTION_DEAL\n    request.type = 0                # ORDER_TYPE_BUY\n    request.price = 0.0\n    request.sl = sl                 # Stop Loss\n    request.tp = tp                 # Take Profit\n    request.deviation = 20\n    request.comment = \"Order with SL/TP\"\n\n    result = await service.place_order(request)\n\n    if result.returned_code == 10009:\n        print(f\"Order placed: {result.order}\")\n        print(f\"  SL: {sl}, TP: {tp}\")\n    else:\n        print(f\"Failed: {result.comment}\")\n\n    return result\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#example-3-validating-order-before-placing","title":"Example 3: Validating Order Before Placing","text":"<pre><code>from MetaRpcMT5 import mt5_term_api_trade_functions_pb2 as trade_functions_pb2\n\nasync def safe_place_order(\n    service: MT5Service,\n    symbol: str,\n    volume: float\n) -&gt; bool:\n    \"\"\"Validate order before placing.\"\"\"\n\n    # Step 1: Check order\n    check_request = trade_functions_pb2.OrderCheckRequest()\n    check_request.symbol = symbol\n    check_request.volume = volume\n    check_request.action = 1\n    check_request.type = 0\n    check_request.price = 0.0\n\n    check_result = await service.check_order(check_request)\n\n    if check_result.returned_code != 0:\n        print(f\"Order validation FAILED: {check_result.comment}\")\n        return False\n\n    print(\"Order validation PASSED:\")\n    print(f\"  Required margin: ${check_result.margin:.2f}\")\n    print(f\"  Free margin after: ${check_result.margin_free:.2f}\")\n    print(f\"  Margin level after: {check_result.margin_level:.2f}%\")\n\n    # Step 2: Place order\n    order_request = trading_helper_pb2.OrderSendRequest()\n    order_request.symbol = symbol\n    order_request.volume = volume\n    order_request.action = 1\n    order_request.type = 0\n    order_request.price = 0.0\n    order_request.deviation = 20\n\n    result = await service.place_order(order_request)\n\n    if result.returned_code == 10009:\n        print(f\"Order placed successfully: {result.order}\")\n        return True\n    else:\n        print(f\"Order placement failed: {result.comment}\")\n        return False\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#example-4-modifying-position-sltp","title":"Example 4: Modifying Position SL/TP","text":"<pre><code>async def modify_position_stops(\n    service: MT5Service,\n    ticket: int,\n    new_sl: float,\n    new_tp: float\n):\n    \"\"\"Modify Stop Loss and Take Profit of existing position.\"\"\"\n\n    request = trading_helper_pb2.OrderModifyRequest()\n    request.order = ticket          # Ticket to modify\n    request.sl = new_sl             # New Stop Loss\n    request.tp = new_tp             # New Take Profit\n\n    result = await service.modify_order(request)\n\n    if result.returned_code == 10009:\n        print(f\"Position {ticket} modified successfully\")\n        print(f\"  New SL: {new_sl}\")\n        print(f\"  New TP: {new_tp}\")\n    else:\n        print(f\"Modification failed: {result.comment}\")\n\n    return result\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#example-5-closing-position","title":"Example 5: Closing Position","text":"<pre><code>async def close_position(service: MT5Service, ticket: int):\n    \"\"\"Close an open position.\"\"\"\n\n    request = trading_helper_pb2.OrderCloseRequest()\n    request.order = ticket\n    request.volume = 0.0            # 0 = close entire position\n\n    return_code = await service.close_order(request)\n\n    if return_code == 10009:\n        print(f\"Position {ticket} closed successfully\")\n        return True\n    else:\n        print(f\"Failed to close position {ticket}, code: {return_code}\")\n        return False\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#example-6-calculating-required-margin","title":"Example 6: Calculating Required Margin","text":"<pre><code>async def check_margin_requirement(\n    service: MT5Service,\n    symbol: str,\n    volume: float\n):\n    \"\"\"Calculate required margin for a trade.\"\"\"\n\n    request = trade_functions_pb2.OrderCalcMarginRequest()\n    request.symbol = symbol\n    request.volume = volume\n    request.action = 1              # TRADE_ACTION_DEAL\n    request.type = 0                # ORDER_TYPE_BUY\n\n    margin = await service.calculate_margin(request)\n\n    print(f\"Required margin for {volume} lots of {symbol}: ${margin:.2f}\")\n\n    # Check if we have enough free margin\n    from MetaRpcMT5 import mt5_term_api_account_information_pb2 as account_info_pb2\n    free_margin = await service.get_account_double(\n        account_info_pb2.ACCOUNT_MARGIN_FREE\n    )\n\n    if free_margin &gt;= margin:\n        print(f\"OK: You have ${free_margin:.2f} free margin\")\n        return True\n    else:\n        print(f\"INSUFFICIENT: You need ${margin:.2f} but only have ${free_margin:.2f}\")\n        return False\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#example-7-calculating-potential-profit","title":"Example 7: Calculating Potential Profit","text":"<pre><code>async def calculate_trade_profit(\n    service: MT5Service,\n    symbol: str,\n    volume: float,\n    entry_price: float,\n    exit_price: float\n):\n    \"\"\"Calculate potential profit for a trade.\"\"\"\n\n    request = trade_functions_pb2.OrderCalcProfitRequest()\n    request.symbol = symbol\n    request.volume = volume\n    request.action = 1              # TRADE_ACTION_DEAL\n    request.type = 0                # ORDER_TYPE_BUY\n    request.price_open = entry_price\n    request.price_close = exit_price\n\n    profit = await service.calculate_profit(request)\n\n    print(f\"Trade Calculation for {symbol}:\")\n    print(f\"  Volume: {volume} lots\")\n    print(f\"  Entry: {entry_price}\")\n    print(f\"  Exit: {exit_price}\")\n    print(f\"  Profit: ${profit:.2f}\")\n\n    return profit\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#example-8-complete-safe-trading-flow","title":"Example 8: Complete Safe Trading Flow","text":"<pre><code>async def safe_trade_with_validation(\n    service: MT5Service,\n    symbol: str,\n    volume: float,\n    sl_points: int,\n    tp_points: int\n):\n    \"\"\"Complete safe trading flow with all validations.\"\"\"\n\n    from MetaRpcMT5 import mt5_term_api_market_info_pb2 as market_info_pb2\n\n    # Step 1: Get current price\n    tick = await service.get_symbol_tick(symbol)\n    print(f\"Current price: {tick.ask}\")\n\n    # Step 2: Calculate SL/TP prices\n    point = await service.get_symbol_double(\n        symbol, market_info_pb2.SYMBOL_POINT\n    )\n    sl = tick.ask - (sl_points * point)\n    tp = tick.ask + (tp_points * point)\n\n    print(f\"Calculated SL: {sl:.5f}, TP: {tp:.5f}\")\n\n    # Step 3: Calculate required margin\n    margin_request = trade_functions_pb2.OrderCalcMarginRequest()\n    margin_request.symbol = symbol\n    margin_request.volume = volume\n    margin_request.action = 1\n    margin_request.type = 0\n\n    required_margin = await service.calculate_margin(margin_request)\n    print(f\"Required margin: ${required_margin:.2f}\")\n\n    # Step 4: Check free margin\n    from MetaRpcMT5 import mt5_term_api_account_information_pb2 as account_info_pb2\n    free_margin = await service.get_account_double(\n        account_info_pb2.ACCOUNT_MARGIN_FREE\n    )\n\n    if free_margin &lt; required_margin:\n        print(f\"INSUFFICIENT MARGIN: Need ${required_margin:.2f}, have ${free_margin:.2f}\")\n        return None\n\n    # Step 5: Calculate potential profit\n    profit_request = trade_functions_pb2.OrderCalcProfitRequest()\n    profit_request.symbol = symbol\n    profit_request.volume = volume\n    profit_request.action = 1\n    profit_request.type = 0\n    profit_request.price_open = tick.ask\n    profit_request.price_close = tp\n\n    potential_profit = await service.calculate_profit(profit_request)\n    print(f\"Potential TP profit: ${potential_profit:.2f}\")\n\n    # Step 6: Validate order\n    check_request = trade_functions_pb2.OrderCheckRequest()\n    check_request.symbol = symbol\n    check_request.volume = volume\n    check_request.action = 1\n    check_request.type = 0\n    check_request.price = 0.0\n\n    check_result = await service.check_order(check_request)\n\n    if check_result.returned_code != 0:\n        print(f\"Order validation failed: {check_result.comment}\")\n        return None\n\n    print(\"Order validation passed!\")\n\n    # Step 7: Place order\n    order_request = trading_helper_pb2.OrderSendRequest()\n    order_request.symbol = symbol\n    order_request.volume = volume\n    order_request.action = 1\n    order_request.type = 0\n    order_request.price = 0.0\n    order_request.sl = sl\n    order_request.tp = tp\n    order_request.deviation = 20\n    order_request.comment = \"Safe validated order\"\n\n    result = await service.place_order(order_request)\n\n    if result.returned_code == 10009:\n        print(f\"\\nSUCCESS! Order placed:\")\n        print(f\"  Ticket: {result.order}\")\n        print(f\"  Price: {result.price}\")\n        print(f\"  SL: {sl:.5f}, TP: {tp:.5f}\")\n        return result\n    else:\n        print(f\"\\nFAILED: {result.comment}\")\n        return None\n</code></pre>"},{"location":"MT5Service/5.%20Trading_Operations/#when-to-use-each-method","title":"When to Use Each Method","text":""},{"location":"MT5Service/5.%20Trading_Operations/#use-place_order","title":"Use place_order()","text":"<p>Use when:</p> <ul> <li>Opening new positions (market or pending orders)</li> <li>Need to specify SL/TP with order</li> <li>Ready to send order to broker</li> </ul> <p>Important:</p> <ul> <li>Always check <code>returned_code == 10009</code> for success</li> <li>Use <code>check_order()</code> first for validation</li> </ul>"},{"location":"MT5Service/5.%20Trading_Operations/#use-modify_order","title":"Use modify_order()","text":"<p>Use when:</p> <ul> <li>Changing SL/TP on open position</li> <li>Modifying pending order price</li> <li>Adjusting stops based on market conditions</li> </ul>"},{"location":"MT5Service/5.%20Trading_Operations/#use-close_order","title":"Use close_order()","text":"<p>Use when:</p> <ul> <li>Closing open position</li> <li>Deleting pending order</li> <li>Emergency exit from trade</li> </ul>"},{"location":"MT5Service/5.%20Trading_Operations/#use-check_order","title":"Use check_order()","text":"<p>Use when:</p> <ul> <li>Pre-validating order before placing</li> <li>Checking margin requirements</li> <li>Seeing impact on account before trading</li> </ul> <p>ALWAYS use before place_order() for safety!</p>"},{"location":"MT5Service/5.%20Trading_Operations/#use-calculate_margin","title":"Use calculate_margin()","text":"<p>Use when:</p> <ul> <li>Planning position size</li> <li>Checking if you have enough margin</li> <li>Calculating max position size</li> </ul>"},{"location":"MT5Service/5.%20Trading_Operations/#use-calculate_profit","title":"Use calculate_profit()","text":"<p>Use when:</p> <ul> <li>Calculating risk/reward ratio</li> <li>Setting TP targets</li> <li>Analyzing trade potential</li> </ul>"},{"location":"MT5Service/5.%20Trading_Operations/#recommendations","title":"Recommendations","text":"<ol> <li>Always validate first - Use <code>check_order()</code> before <code>place_order()</code></li> <li>Check return codes - <code>returned_code == 10009</code> means success</li> <li>Calculate margin - Ensure sufficient free margin before trading</li> <li>Use SL/TP - Always set Stop Loss and Take Profit</li> <li>Handle errors - Check <code>result.comment</code> for error descriptions</li> <li>Validate volumes - Check symbol's <code>VOLUME_MIN</code>, <code>VOLUME_MAX</code>, <code>VOLUME_STEP</code></li> </ol> <p>Safe trading pattern: <pre><code># 1. Calculate margin\nmargin = await service.calculate_margin(margin_request)\n\n# 2. Check order\ncheck = await service.check_order(check_request)\nif check.returned_code != 0:\n    return\n\n# 3. Place order\nresult = await service.place_order(order_request)\nif result.returned_code == 10009:\n    print(\"Success!\")\n</code></pre></p>"},{"location":"MT5Service/5.%20Trading_Operations/#common-return-codes","title":"Common Return Codes","text":"Code Name Meaning 10009 TRADE_RETCODE_DONE Success - request completed 10004 TRADE_RETCODE_REQUOTE Requote - price changed 10006 TRADE_RETCODE_REJECT Request rejected 10013 TRADE_RETCODE_INVALID_VOLUME Invalid volume 10014 TRADE_RETCODE_INVALID_PRICE Invalid price 10015 TRADE_RETCODE_INVALID_STOPS Invalid SL/TP 10016 TRADE_RETCODE_INVALID_FILL Invalid filling mode 10018 TRADE_RETCODE_MARKET_CLOSED Market is closed 10019 TRADE_RETCODE_NO_MONEY Not enough money"},{"location":"MT5Service/5.%20Trading_Operations/#related-sections","title":"\ud83d\udcda Related Sections","text":"<ul> <li>MT5Service Overview - mid-level API overview</li> <li>Account Methods (Mid-Level) - checking margin/balance</li> <li>Symbol Methods (Mid-Level) - getting prices and symbol specs</li> <li>Positions &amp; Orders (Mid-Level) - checking open positions</li> <li>Trading Operations (Low-Level) - low-level trading API</li> <li>MT5Service API Reference - complete mid-level API reference</li> </ul>"},{"location":"MT5Service/5.%20Trading_Operations/#summary","title":"Summary","text":""},{"location":"MT5Service/5.%20Trading_Operations/#real-value-assessment","title":"Real Value Assessment","text":"<p>6 methods with mixed value levels - 3 with HIGH/VERY HIGH value (dataclass conversion), 3 with LOW value (simple unpacking):</p> Method Value Level What It Does <code>check_order()</code> \u2705 VERY HIGH Extracts deeply nested <code>mrpc_mql_trade_check_result</code> \u2192 OrderCheckResult (8 fields) <code>place_order()</code> \u2705 HIGH Flattens 10 protobuf fields \u2192 OrderResult dataclass <code>modify_order()</code> \u2705 HIGH Flattens 10 protobuf fields \u2192 OrderResult dataclass <code>close_order()</code> \u26aa LOW Unpacks <code>data.returned_code</code> from protobuf \u2192 int <code>calculate_margin()</code> \u26aa LOW Unpacks <code>data.margin</code> from protobuf \u2192 float <code>calculate_profit()</code> \u26aa LOW Unpacks <code>data.profit</code> from protobuf \u2192 float <p>Why these methods have value:</p> <p>MT5Account returns protobuf objects: <pre><code># Low-level returns:\nresult_data: OrderSendData = await account.order_send(...)  # 10 protobuf fields\ncheck_response: OrderCheckResponse = await account.order_check(...)  # Deeply nested!\nclose_data: OrderCloseData = await account.order_close(...)  # data.returned_code wrapper\nmargin_response: OrderCalcMarginResponse = await account.order_calc_margin(...)  # data.margin\n</code></pre></p> <p>MT5Service unpacks and converts: <pre><code># Mid-level returns:\nresult: OrderResult = await service.place_order(...)              # Flattened dataclass (10 fields)\ncheck: OrderCheckResult = await service.check_order(...)          # Extracted dataclass (8 fields)\ncode: int = await service.close_order(...)                        # Unpacked int\nmargin: float = await service.calculate_margin(...)               # Unpacked float\n</code></pre></p> <p>Key advantages:</p> <ol> <li> <p>Complex dataclass conversion (HIGH/VERY HIGH value):</p> </li> <li> <p><code>check_order()</code> - Extracts deeply nested protobuf structure (VERY valuable!)</p> </li> <li> <p><code>place_order()</code>, <code>modify_order()</code> - Flatten 10 fields into clean OrderResult dataclass</p> </li> <li> <p>Simple unpacking (LOW value):</p> </li> <li> <p><code>close_order()</code>, <code>calculate_margin()</code>, <code>calculate_profit()</code> - Simple single-field extraction</p> </li> <li> <p>Type hints - Full IDE autocomplete support for all dataclass fields</p> </li> <li> <p>Clear return codes - All methods return standardized codes for error handling</p> </li> </ol> <p>Best practices:</p> <ol> <li>\u2705 ALWAYS use <code>check_order()</code> before <code>place_order()</code> for safety - it extracts complex validation data</li> <li>\u2705 ALWAYS check <code>returned_code == 10009</code> for success</li> <li>\u2705 ALWAYS calculate margin before trading</li> <li>\u2705 ALWAYS use Stop Loss and Take Profit</li> <li>\u2705 ALWAYS handle errors (check <code>result.comment</code>)</li> </ol> <p>Bottom line:</p> <ul> <li>\u2705 For direct users: Highly recommend using <code>check_order()</code>, <code>place_order()</code>, <code>modify_order()</code> - significant dataclass conversion value</li> <li>\u26aa Optional: <code>close_order()</code>, <code>calculate_margin()</code>, <code>calculate_profit()</code> - minor unpacking, could call Account directly</li> <li>\u2705 For Sugar users: Methods serve architectural purpose perfectly</li> <li>\u2705 vs MT5Account: Significant improvement through dataclass conversion, especially for check_order()</li> </ul>"},{"location":"MT5Service/6.%20Streaming_Methods/","title":"MT5Service - Streaming Methods (Mid-Level API)","text":""},{"location":"MT5Service/6.%20Streaming_Methods/#important-read-this-first","title":"\u26a0\ufe0f Important: Read This First","text":"<p>MT5Service is an architectural layer between high-level (Sugar) and low-level (Account) APIs.</p>"},{"location":"MT5Service/6.%20Streaming_Methods/#understanding-the-5-streaming-methods","title":"Understanding the 5 Streaming Methods:","text":"Method Direct Use Value Architectural Role <code>stream_ticks()</code> \u2705 HIGH - Converts protobuf Timestamp \u2192 datetime + creates SymbolTick dataclass (8 fields) \u2705 Used by Sugar <code>stream_trade_updates()</code> \u26aa NONE - Direct pass-through (<code>yield data</code>) without conversion \u2705 Used by Sugar <code>stream_position_profits()</code> \u26aa NONE - Direct pass-through (<code>yield data</code>) without conversion \u2705 Used by Sugar <code>stream_opened_tickets()</code> \u26aa NONE - Direct pass-through (<code>yield data</code>) without conversion \u2705 Used by Sugar <code>stream_transactions()</code> \u26aa NONE - Direct pass-through (<code>yield data</code>) without conversion \u2705 Used by Sugar"},{"location":"MT5Service/6.%20Streaming_Methods/#what-this-means","title":"What This Means:","text":"<p>Architecture (3 layers):</p> <pre><code>MT5Sugar (HIGH)     \u2192  service.stream_ticks()          \u2190 Sugar uses Service methods\nMT5Service (MID)    \u2192  account.on_symbol_tick()        \u2190 Service converts datetime + creates dataclass\nMT5Account (LOW)    \u2192  gRPC stream \u2192 protobuf objects\n</code></pre> <p>Value breakdown:</p> <ul> <li>\u2705 HIGH (1 method): <code>stream_ticks()</code> - protobuf Timestamp \u2192 datetime + SymbolTick dataclass conversion</li> <li>\u26aa NONE (4 methods): Direct pass-through - just <code>yield data</code> from Account layer</li> </ul> <p>For direct MT5Service usage:</p> <ul> <li>\u2705 Use <code>stream_ticks()</code> - saves you from manual Timestamp conversion</li> <li>\u26aa Optional: Other 4 methods - no conversion, could call Account directly</li> </ul> <p>For MT5Sugar users:</p> <ul> <li>\u2705 All methods work perfectly - the layer serves its architectural purpose</li> </ul> <p>API Layer: MID-LEVEL - wrappers over MT5Account with automatic datetime conversion</p> <p>Implementation:</p> <p>These methods are implemented in <code>src/pymt5/mt5_service.py</code>, which wraps <code>package/MetaRpcMT5/helpers/mt5_account.py</code> low-level API with dataclass conversion and automatic reconnection.</p> <p>Example files:</p> <ul> <li><code>examples/2_service/05_service_streaming.py</code> - comprehensive demo of all MT5Service streaming methods</li> </ul>"},{"location":"MT5Service/6.%20Streaming_Methods/#why-these-methods-exist","title":"Why These Methods Exist","text":""},{"location":"MT5Service/6.%20Streaming_Methods/#real-value-mixed-processing","title":"Real Value: Mixed Processing","text":"<p>Only 1 method adds value through datetime conversion + dataclass creation, 4 methods are direct pass-through:</p> <p>Problem with MT5Account (Low-level):</p> <pre><code># stream_ticks() - MT5Account returns protobuf with Timestamp\nasync for data in account.on_symbol_tick([\"EURUSD\"], None):\n    # data.symbol_tick.time is protobuf Timestamp - need manual conversion!\n    tick_time = data.symbol_tick.time.ToDatetime()  # \u2190 Manual datetime conversion\n    bid = data.symbol_tick.bid\n    ask = data.symbol_tick.ask\n    # ... manual field extraction from protobuf\n\n# Other streams - already clean protobuf objects:\nasync for data in account.on_trade(None):\n    # data is OnTradeData - already has all fields accessible\n    if data.HasField(\"position_info\"):\n        print(f\"Position: {data.position_info.ticket}\")\n</code></pre> <p>Solution with MT5Service (Mid-level):</p> <pre><code># stream_ticks() - automatic datetime conversion + dataclass:\nasync for tick in service.stream_ticks([\"EURUSD\"]):\n    # tick is SymbolTick dataclass with time already datetime!\n    print(f\"{tick.time}: Bid={tick.bid}, Ask={tick.ask}\")\n    # \u2705 VALUE: No manual ToDatetime() needed, clean dataclass\n\n# Other streams - direct pass-through (NO conversion):\nasync for trade in service.stream_trade_updates():\n    # \u26aa NO VALUE: Same OnTradeData protobuf as Account layer\n    if trade.HasField(\"position_info\"):\n        print(f\"Position: {trade.position_info.ticket}\")\n</code></pre> <p>What MT5Service provides:</p> <ol> <li> <p>Datetime conversion + dataclass (1 method with HIGH value):</p> </li> <li> <p><code>stream_ticks()</code>: Converts protobuf Timestamp \u2192 Python datetime + creates SymbolTick dataclass (8 fields)</p> </li> <li> <p>Implementation: <code>tick_time = data.symbol_tick.time.ToDatetime()</code> + <code>yield SymbolTick(...)</code></p> </li> <li> <p>Direct pass-through (4 methods with NO value):</p> </li> <li> <p><code>stream_trade_updates()</code>: <code>async for data in account.on_trade(): yield data</code></p> </li> <li><code>stream_position_profits()</code>: <code>async for data in account.on_position_profit(): yield data</code></li> <li><code>stream_opened_tickets()</code>: <code>async for data in account.on_positions_and_pending_orders_tickets(): yield data</code></li> <li><code>stream_transactions()</code>: <code>async for data in account.on_trade_transaction(): yield data</code></li> <li> <p>These literally just forward protobuf objects without any processing</p> </li> <li> <p>Auto-reconnection (ALL methods):</p> </li> <li> <p>All streaming methods benefit from <code>execute_stream_with_reconnect()</code> infrastructure</p> </li> <li>But this is also available on Account layer</li> </ol> <p>Architectural purpose:</p> <ul> <li>\u2705 MT5Sugar uses these methods to maintain layered architecture (Sugar \u2192 Service \u2192 Account)</li> <li>\u2705 stream_ticks() adds real value through datetime conversion</li> <li>\u26aa Other 4 methods - architectural consistency only, no processing</li> </ul>"},{"location":"MT5Service/6.%20Streaming_Methods/#all-5-streaming-methods","title":"All 5 Streaming Methods","text":"Method Yields Description <code>stream_ticks()</code> <code>SymbolTick</code> Real-time tick data stream (time auto-converted) <code>stream_trade_updates()</code> <code>OnTradeData</code> Trade events (new/closed positions) <code>stream_position_profits()</code> <code>OnPositionProfitData</code> Real-time position P&amp;L updates <code>stream_opened_tickets()</code> <code>OnPositionsAndPendingOrdersTicketsData</code> Position/order ticket updates (lightweight) <code>stream_transactions()</code> <code>OnTradeTransactionData</code> Detailed trade transaction events"},{"location":"MT5Service/6.%20Streaming_Methods/#key-concepts","title":"Key Concepts","text":""},{"location":"MT5Service/6.%20Streaming_Methods/#async-generators","title":"Async Generators","text":"<p>All streaming methods are async generators - use <code>async for</code> to iterate:</p> <pre><code>async for item in service.stream_ticks([\"EURUSD\"]):\n    print(item)  # Process each tick as it arrives\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#cancellation","title":"Cancellation","text":"<p>Use <code>cancellation_event</code> (asyncio.Event) to stop streaming:</p> <pre><code>import asyncio\n\ncancel_event = asyncio.Event()\n\nasync for tick in service.stream_ticks([\"EURUSD\"], cancel_event):\n    print(tick)\n    if some_condition:\n        cancel_event.set()  # Stop streaming\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#automatic-reconnection","title":"Automatic Reconnection","text":"<p>All streaming methods use <code>execute_stream_with_reconnect()</code> internally - automatic reconnection on connection loss!</p>"},{"location":"MT5Service/6.%20Streaming_Methods/#method-signatures","title":"Method Signatures","text":""},{"location":"MT5Service/6.%20Streaming_Methods/#1-stream_ticks","title":"1) stream_ticks","text":"<pre><code>async def stream_ticks(\n    self,\n    symbols: List[str],\n    cancellation_event: Optional[Any] = None,\n) -&gt; AsyncIterator[SymbolTick]\n</code></pre> <p>Real-time tick data stream.</p> <p>Args:</p> <ul> <li><code>symbols</code>: List of symbol names to stream (e.g., <code>[\"EURUSD\", \"GBPUSD\"]</code>)</li> <li><code>cancellation_event</code>: Optional asyncio.Event for stopping stream</li> </ul> <p>Yields: <code>SymbolTick</code> dataclass with:</p> <ul> <li><code>time</code>: datetime (already converted from protobuf Timestamp!)</li> <li><code>bid</code>, <code>ask</code>, <code>last</code>: float prices</li> <li><code>volume</code>, <code>time_ms</code>, <code>flags</code>, <code>volume_real</code>: tick details</li> </ul> <p>Technical: Low-level streams OnSymbolTickData with <code>symbol_tick.time</code> as protobuf Timestamp. This wrapper converts each Timestamp to Python datetime via <code>ToDatetime()</code> for every tick.</p> <p>Auto-reconnection: Stream continues until <code>cancellation_event.set()</code> or connection loss (auto-reconnects via <code>execute_stream_with_reconnect</code>).</p> <p>Usage:</p> <pre><code>async for tick in service.stream_ticks([\"EURUSD\"]):\n    print(f\"{tick.time}: {tick.bid}/{tick.ask}\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#2-stream_trade_updates","title":"2) stream_trade_updates","text":"<pre><code>async def stream_trade_updates(\n    self,\n    cancellation_event: Optional[Any] = None,\n) -&gt; AsyncIterator[Any]\n</code></pre> <p>Real-time trade events stream (new/closed positions).</p> <p>Args:</p> <ul> <li><code>cancellation_event</code>: Optional asyncio.Event for stopping stream</li> </ul> <p>Yields: <code>OnTradeData</code> protobuf events with:</p> <ul> <li><code>position_info</code>: Position details when position opens/closes</li> <li><code>order_info</code>: Order details when pending order placed/deleted</li> </ul> <p>Technical: Server pushes OnTradeData when:</p> <ul> <li>Position opens or closes</li> <li>Pending order placed or deleted</li> </ul> <p>Each event contains either <code>position_info</code> or <code>order_info</code> with full details (ticket, symbol, volume, type, etc.).</p> <p>Thin wrapper: Passes through protobuf OnTradeData without conversion (minimal overhead).</p> <p>Usage:</p> <pre><code>async for trade in service.stream_trade_updates():\n    if trade.HasField(\"position_info\"):\n        print(f\"Position: {trade.position_info.ticket}\")\n    if trade.HasField(\"order_info\"):\n        print(f\"Order: {trade.order_info.ticket}\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#3-stream_position_profits","title":"3) stream_position_profits","text":"<pre><code>async def stream_position_profits(\n    self,\n    interval_ms: int = 1000,\n    ignore_empty: bool = True,\n    cancellation_event: Optional[Any] = None,\n) -&gt; AsyncIterator[Any]\n</code></pre> <p>Real-time position profit updates stream.</p> <p>Args:</p> <ul> <li><code>interval_ms</code>: Polling interval in milliseconds (default: 1000ms = 1 second)</li> <li><code>ignore_empty</code>: Skip frames with no changes (default: True)</li> <li><code>cancellation_event</code>: Optional asyncio.Event for stopping stream</li> </ul> <p>Yields: <code>OnPositionProfitData</code> protobuf with:</p> <ul> <li><code>position_profits</code>: Repeated field with ticket \u20ac\u2122 profit mapping</li> </ul> <p>Technical: Server polls positions every <code>interval_ms</code> and pushes updates when profit changes.</p> <p>ignore_empty=True filters out frames where no position P&amp;L changed, reducing bandwidth.</p> <p>Each OnPositionProfitData contains <code>position_profits</code> repeated field with ticket\u20ac\u2122profit mapping.</p> <p>Usage:</p> <pre><code>async for profit_data in service.stream_position_profits(interval_ms=500):\n    for pos_profit in profit_data.position_profits:\n        print(f\"Ticket {pos_profit.ticket}: ${pos_profit.profit:.2f}\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#4-stream_opened_tickets","title":"4) stream_opened_tickets","text":"<pre><code>async def stream_opened_tickets(\n    self,\n    interval_ms: int = 1000,\n    cancellation_event: Optional[Any] = None,\n) -&gt; AsyncIterator[Any]\n</code></pre> <p>Real-time position/order ticket updates stream (lightweight).</p> <p>Args:</p> <ul> <li><code>interval_ms</code>: Polling interval in milliseconds (default: 1000ms = 1 second)</li> <li><code>cancellation_event</code>: Optional asyncio.Event for stopping stream</li> </ul> <p>Yields: <code>OnPositionsAndPendingOrdersTicketsData</code> protobuf with:</p> <ul> <li><code>opened_position_tickets</code>: List of position ticket numbers (repeated int64)</li> <li><code>opened_orders_tickets</code>: List of pending order ticket numbers (repeated int64)</li> </ul> <p>Technical: Server polls every <code>interval_ms</code> and pushes OnPositionsAndPendingOrdersTicketsData.</p> <p>Advantage: 10-20x less bandwidth than <code>stream_trade_updates()</code> - use when you only need to track ticket changes.</p> <p>Usage:</p> <pre><code>async for tickets in service.stream_opened_tickets(interval_ms=2000):\n    print(f\"Positions: {list(tickets.opened_position_tickets)}\")\n    print(f\"Orders: {list(tickets.opened_orders_tickets)}\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#5-stream_transactions","title":"5) stream_transactions","text":"<pre><code>async def stream_transactions(\n    self,\n    cancellation_event: Optional[Any] = None,\n) -&gt; AsyncIterator[Any]\n</code></pre> <p>Real-time trade transaction stream (detailed).</p> <p>Args:</p> <ul> <li><code>cancellation_event</code>: Optional asyncio.Event for stopping stream</li> </ul> <p>Yields: <code>OnTradeTransactionData</code> protobuf events with:</p> <ul> <li><code>transaction_type</code>: Transaction type (DEAL_ADD, ORDER_DELETE, etc.)</li> <li>Request details and results</li> </ul> <p>Technical: Server pushes OnTradeTransactionData for every trade operation step (request\u20ac\u2122broker\u20ac\u2122result).</p> <p>More detailed than stream_trade_updates(): Includes <code>transaction_type</code> (DEAL_ADD, ORDER_DELETE, etc.) and request details.</p> <p>Thin wrapper: Passes through protobuf OnTradeTransactionData without conversion.</p> <p>Usage:</p> <pre><code>async for transaction in service.stream_transactions():\n    print(f\"Transaction type: {transaction.transaction_type}\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Service/6.%20Streaming_Methods/#example-1-streaming-ticks-with-auto-converted-datetime","title":"Example 1: Streaming Ticks with Auto-Converted Datetime","text":"<pre><code>import asyncio\nfrom pymt5 import MT5Service\n\nasync def stream_eurusd_ticks(service: MT5Service, duration_seconds: int = 60):\n    \"\"\"Stream EURUSD ticks for specified duration.\"\"\"\n\n    cancel_event = asyncio.Event()\n\n    # Auto-stop after duration\n    async def auto_stop():\n        await asyncio.sleep(duration_seconds)\n        cancel_event.set()\n\n    asyncio.create_task(auto_stop())\n\n    print(f\"Streaming EURUSD ticks for {duration_seconds} seconds...\")\n\n    try:\n        async for tick in service.stream_ticks([\"EURUSD\"], cancel_event):\n            # tick.time is already datetime - no conversion needed!\n            timestamp = tick.time.strftime('%H:%M:%S.%f')[:-3]\n            spread = tick.ask - tick.bid\n\n            print(f\"[{timestamp}] Bid: {tick.bid:.5f} | \"\n                  f\"Ask: {tick.ask:.5f} | \"\n                  f\"Spread: {spread:.5f}\")\n\n    except asyncio.CancelledError:\n        print(\"Stream cancelled\")\n\n    print(\"Streaming stopped\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#example-2-monitoring-multiple-symbols","title":"Example 2: Monitoring Multiple Symbols","text":"<pre><code>async def monitor_multiple_symbols(\n    service: MT5Service,\n    symbols: list,\n    duration_seconds: int = 30\n):\n    \"\"\"Stream ticks for multiple symbols simultaneously.\"\"\"\n\n    cancel_event = asyncio.Event()\n\n    # Auto-stop after duration\n    asyncio.create_task(auto_cancel(cancel_event, duration_seconds))\n\n    print(f\"Monitoring {len(symbols)} symbols: {', '.join(symbols)}\")\n\n    tick_counts = {symbol: 0 for symbol in symbols}\n\n    async for tick in service.stream_ticks(symbols, cancel_event):\n        # Track which symbol this tick is for\n        # Note: tick doesn't have symbol field, need to track via subscription\n        tick_counts[symbols[0]] += 1  # Simplified\n\n        if tick_counts[symbols[0]] % 10 == 0:\n            print(f\"Received {tick_counts[symbols[0]]} ticks for {symbols[0]}\")\n\n    print(f\"\\nTotal ticks received: {sum(tick_counts.values())}\")\n\n\nasync def auto_cancel(event, seconds):\n    await asyncio.sleep(seconds)\n    event.set()\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#example-3-detecting-new-positions-with-stream_trade_updates","title":"Example 3: Detecting New Positions with stream_trade_updates","text":"<pre><code>async def monitor_trades(service: MT5Service):\n    \"\"\"Monitor for new positions and closed positions.\"\"\"\n\n    print(\"Monitoring trade events (Ctrl+C to stop)...\")\n\n    try:\n        async for trade in service.stream_trade_updates():\n            # Check if this is a position update\n            if trade.HasField(\"position_info\"):\n                pos = trade.position_info\n                print(f\"\\nPOSITION UPDATE:\")\n                print(f\"  Ticket: {pos.ticket}\")\n                print(f\"  Symbol: {pos.symbol}\")\n                print(f\"  Type: {'BUY' if pos.type == 0 else 'SELL'}\")\n                print(f\"  Volume: {pos.volume}\")\n                print(f\"  Profit: ${pos.profit:.2f}\")\n\n            # Check if this is an order update\n            if trade.HasField(\"order_info\"):\n                order = trade.order_info\n                print(f\"\\nORDER UPDATE:\")\n                print(f\"  Ticket: {order.ticket}\")\n                print(f\"  Symbol: {order.symbol}\")\n                print(f\"  Type: {order.type}\")\n                print(f\"  Volume: {order.volume_current}\")\n\n    except KeyboardInterrupt:\n        print(\"\\nMonitoring stopped\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#example-4-real-time-pl-monitoring","title":"Example 4: Real-time P&amp;L Monitoring","text":"<pre><code>async def monitor_position_profits(\n    service: MT5Service,\n    update_interval_ms: int = 500\n):\n    \"\"\"Monitor position profits in real-time.\"\"\"\n\n    print(f\"Monitoring position profits (update every {update_interval_ms}ms)...\")\n    print(\"Press Ctrl+C to stop\\n\")\n\n    total_profit = 0.0\n\n    try:\n        async for profit_data in service.stream_position_profits(\n            interval_ms=update_interval_ms,\n            ignore_empty=True  # Only show when profit changes\n        ):\n            # Calculate total profit across all positions\n            current_total = 0.0\n\n            print(\"\\n\" + \"=\" * 60)\n            print(\"POSITION PROFITS:\")\n            print(\"-\" * 60)\n\n            for pos_profit in profit_data.position_profits:\n                current_total += pos_profit.profit\n                print(f\"Ticket #{pos_profit.ticket}: ${pos_profit.profit:+.2f}\")\n\n            print(\"-\" * 60)\n            print(f\"TOTAL PROFIT: ${current_total:+.2f}\")\n\n            # Alert on significant changes\n            if abs(current_total - total_profit) &gt; 10.0:\n                print(\"ALERT: Significant P&amp;L change!\")\n\n            total_profit = current_total\n\n    except KeyboardInterrupt:\n        print(\"\\n\\nMonitoring stopped\")\n        print(f\"Final total profit: ${total_profit:+.2f}\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#example-5-lightweight-ticket-monitoring","title":"Example 5: Lightweight Ticket Monitoring","text":"<pre><code>async def monitor_opened_tickets(service: MT5Service):\n    \"\"\"Monitor for new/closed positions using lightweight ticket stream.\"\"\"\n\n    known_position_tickets = set()\n    known_order_tickets = set()\n\n    print(\"Monitoring opened tickets (lightweight)...\")\n\n    try:\n        async for tickets in service.stream_opened_tickets(interval_ms=1000):\n            # Convert to sets for easy comparison\n            current_positions = set(tickets.opened_position_tickets)\n            current_orders = set(tickets.opened_orders_tickets)\n\n            # Detect new positions\n            new_positions = current_positions - known_position_tickets\n            if new_positions:\n                for ticket in new_positions:\n                    print(f\"NEW POSITION: #{ticket}\")\n\n            # Detect closed positions\n            closed_positions = known_position_tickets - current_positions\n            if closed_positions:\n                for ticket in closed_positions:\n                    print(f\"CLOSED POSITION: #{ticket}\")\n\n            # Detect new pending orders\n            new_orders = current_orders - known_order_tickets\n            if new_orders:\n                for ticket in new_orders:\n                    print(f\"NEW ORDER: #{ticket}\")\n\n            # Detect deleted orders\n            deleted_orders = known_order_tickets - current_orders\n            if deleted_orders:\n                for ticket in deleted_orders:\n                    print(f\"DELETED ORDER: #{ticket}\")\n\n            # Update known tickets\n            known_position_tickets = current_positions\n            known_order_tickets = current_orders\n\n            # Show current status\n            print(f\"[Status] Positions: {len(current_positions)}, \"\n                  f\"Orders: {len(current_orders)}\")\n\n    except KeyboardInterrupt:\n        print(\"\\nMonitoring stopped\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#example-6-detailed-transaction-monitoring","title":"Example 6: Detailed Transaction Monitoring","text":"<pre><code>async def monitor_transactions(service: MT5Service):\n    \"\"\"Monitor detailed trade transactions.\"\"\"\n\n    print(\"Monitoring trade transactions (detailed)...\")\n\n    try:\n        async for transaction in service.stream_transactions():\n            print(f\"\\nTRANSACTION:\")\n            print(f\"  Type: {transaction.transaction_type}\")\n\n            if transaction.HasField(\"trade\"):\n                trade = transaction.trade\n                print(f\"  Action: {trade.action}\")\n                print(f\"  Order: {trade.order}\")\n                print(f\"  Symbol: {trade.symbol}\")\n                print(f\"  Volume: {trade.volume}\")\n                print(f\"  Price: {trade.price}\")\n\n            if transaction.HasField(\"request\"):\n                req = transaction.request\n                print(f\"  Request: {req}\")\n\n    except KeyboardInterrupt:\n        print(\"\\nMonitoring stopped\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#example-7-combined-monitoring-dashboard","title":"Example 7: Combined Monitoring Dashboard","text":"<pre><code>import asyncio\nfrom datetime import datetime\n\nasync def trading_dashboard(service: MT5Service):\n    \"\"\"Comprehensive trading dashboard with multiple streams.\"\"\"\n\n    cancel_event = asyncio.Event()\n\n    # Task 1: Monitor ticks\n    async def tick_monitor():\n        async for tick in service.stream_ticks([\"EURUSD\"], cancel_event):\n            spread = tick.ask - tick.bid\n            print(f\"[TICK] {tick.time.strftime('%H:%M:%S')}: \"\n                  f\"Bid={tick.bid:.5f}, Ask={tick.ask:.5f}, Spread={spread:.5f}\")\n\n    # Task 2: Monitor trades\n    async def trade_monitor():\n        async for trade in service.stream_trade_updates(cancel_event):\n            if trade.HasField(\"position_info\"):\n                pos = trade.position_info\n                print(f\"[TRADE] Position {pos.ticket}: {pos.symbol} \"\n                      f\"{'BUY' if pos.type == 0 else 'SELL'} {pos.volume} lots\")\n\n    # Task 3: Monitor profits\n    async def profit_monitor():\n        async for profit_data in service.stream_position_profits(\n            interval_ms=2000,\n            ignore_empty=True,\n            cancellation_event=cancel_event\n        ):\n            total = sum(p.profit for p in profit_data.position_profits)\n            print(f\"[PROFIT] Total P&amp;L: ${total:+.2f}\")\n\n    # Run all monitors concurrently\n    print(\"Starting trading dashboard...\")\n    print(\"Press Ctrl+C to stop\\n\")\n\n    try:\n        await asyncio.gather(\n            tick_monitor(),\n            trade_monitor(),\n            profit_monitor()\n        )\n    except KeyboardInterrupt:\n        print(\"\\n\\nShutting down dashboard...\")\n        cancel_event.set()\n        await asyncio.sleep(1)  # Give streams time to close\n\n    print(\"Dashboard stopped\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#when-to-use-each-method","title":"When to Use Each Method","text":""},{"location":"MT5Service/6.%20Streaming_Methods/#use-stream_ticks","title":"Use stream_ticks()","text":"<p>Use when:</p> <ul> <li>Need real-time price updates</li> <li>Building price charts or indicators</li> <li>Monitoring market movements</li> <li>Time precision is important</li> </ul> <p>Advantage: Time already converted to datetime!</p> <p>Example:</p> <pre><code>async for tick in service.stream_ticks([\"EURUSD\"]):\n    print(f\"{tick.time}: {tick.bid}\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#use-stream_trade_updates","title":"Use stream_trade_updates()","text":"<p>Use when:</p> <ul> <li>Monitoring position opens/closes</li> <li>Tracking new orders</li> <li>Building trade notifications</li> <li>Need full position/order details</li> </ul> <p>Example:</p> <pre><code>async for trade in service.stream_trade_updates():\n    if trade.HasField(\"position_info\"):\n        print(f\"New position: {trade.position_info.ticket}\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#use-stream_position_profits","title":"Use stream_position_profits()","text":"<p>Use when:</p> <ul> <li>Real-time P&amp;L monitoring</li> <li>Automatic stop-loss triggers</li> <li>Profit alerts</li> <li>Building P&amp;L dashboards</li> </ul> <p>Example:</p> <pre><code>async for profit_data in service.stream_position_profits():\n    total = sum(p.profit for p in profit_data.position_profits)\n    if total &lt; -100:\n        print(\"ALERT: Large loss!\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#use-stream_opened_tickets","title":"Use stream_opened_tickets()","text":"<p>Use when:</p> <ul> <li>Lightweight position monitoring</li> <li>Only need ticket numbers (not full details)</li> <li>Bandwidth is limited</li> <li>High-frequency monitoring</li> </ul> <p>Advantage: 10-20x less bandwidth than stream_trade_updates()</p> <p>Example:</p> <pre><code>async for tickets in service.stream_opened_tickets():\n    print(f\"Open positions: {len(tickets.opened_position_tickets)}\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#use-stream_transactions","title":"Use stream_transactions()","text":"<p>Use when:</p> <ul> <li>Need detailed transaction history</li> <li>Debugging trade execution</li> <li>Logging all trading activity</li> <li>Building audit trail</li> </ul> <p>More detailed than stream_trade_updates()</p> <p>Example:</p> <pre><code>async for tx in service.stream_transactions():\n    print(f\"Transaction: {tx.transaction_type}\")\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#recommendations","title":"Recommendations","text":"<ol> <li>Use cancellation_event - Always provide way to stop streams gracefully</li> <li>Handle KeyboardInterrupt - Use try/except for clean shutdown</li> <li>Don't block the loop - Process data quickly in async for loop</li> <li>Use stream_opened_tickets() for monitoring - 10-20x more efficient</li> <li>Use stream_ticks() for prices - Time already datetime!</li> <li>Set appropriate intervals - Balance between latency and performance</li> <li>Use ignore_empty=True - Reduce bandwidth for profit streaming</li> </ol> <p>Cancellation pattern:</p> <pre><code>cancel_event = asyncio.Event()\n\ntry:\n    async for item in service.stream_ticks([\"EURUSD\"], cancel_event):\n        if should_stop:\n            cancel_event.set()\nexcept KeyboardInterrupt:\n    cancel_event.set()\n</code></pre>"},{"location":"MT5Service/6.%20Streaming_Methods/#performance-comparison","title":"Performance Comparison","text":"Method Bandwidth Update Frequency Use Case stream_ticks() High Every tick Price monitoring stream_trade_updates() Medium On event Position changes stream_position_profits() Low Configurable P&amp;L monitoring stream_opened_tickets() Very Low Configurable Lightweight monitoring stream_transactions() High Every transaction Detailed logging <p>Best for monitoring: <code>stream_opened_tickets()</code> (very low bandwidth, configurable interval)</p> <p>Best for prices: <code>stream_ticks()</code> (real-time, datetime auto-converted)</p> <p>Best for P&amp;L: <code>stream_position_profits()</code> with <code>ignore_empty=True</code></p>"},{"location":"MT5Service/6.%20Streaming_Methods/#related-sections","title":"\ud83d\udcda Related Sections","text":"<ul> <li>MT5Service Overview - mid-level API overview</li> <li>Symbol Methods (Mid-Level) - getting tick snapshots</li> <li>Positions &amp; Orders (Mid-Level) - getting position snapshots</li> <li>Trading Methods (Mid-Level) - placing orders</li> <li>Streaming Methods (Low-Level) - low-level streaming API</li> <li>MT5Service API Reference - complete mid-level API reference</li> </ul>"},{"location":"MT5Service/6.%20Streaming_Methods/#summary","title":"Summary","text":""},{"location":"MT5Service/6.%20Streaming_Methods/#real-value-assessment","title":"Real Value Assessment","text":"<p>5 streaming methods with minimal processing - only 1 adds value, 4 are direct pass-through:</p> Method Value Level What It Does <code>stream_ticks()</code> \u2705 HIGH Converts protobuf Timestamp \u2192 datetime + creates SymbolTick dataclass (8 fields) <code>stream_trade_updates()</code> \u26aa NONE Direct pass-through: <code>async for data in account.on_trade(): yield data</code> <code>stream_position_profits()</code> \u26aa NONE Direct pass-through: <code>async for data in account.on_position_profit(): yield data</code> <code>stream_opened_tickets()</code> \u26aa NONE Direct pass-through: <code>async for data in account.on_positions_and_pending_orders_tickets(): yield data</code> <code>stream_transactions()</code> \u26aa NONE Direct pass-through: <code>async for data in account.on_trade_transaction(): yield data</code> <p>Why these methods have value (or don't):</p> <p>MT5Account streams protobuf objects: <pre><code># Low-level streams:\nasync for data in account.on_symbol_tick(...):  # OnSymbolTickData with protobuf Timestamp\nasync for data in account.on_trade(...):  # OnTradeData protobuf (already accessible)\nasync for data in account.on_position_profit(...):  # OnPositionProfitData protobuf (already accessible)\n</code></pre></p> <p>MT5Service processing: <pre><code># Only stream_ticks() has processing:\nasync for tick in service.stream_ticks(...):\n    # \u2705 Converts: data.symbol_tick.time.ToDatetime() + SymbolTick dataclass\n\n# Other 4 methods - no processing:\nasync for trade in service.stream_trade_updates(...):\n    # \u26aa Just yields: Same OnTradeData protobuf from Account\n</code></pre></p> <p>Key insights:</p> <ol> <li> <p>Only 1 method adds value (stream_ticks):</p> </li> <li> <p>Automatic datetime conversion saves calling <code>.ToDatetime()</code> manually</p> </li> <li>SymbolTick dataclass with 8 fields is cleaner than protobuf access</li> <li> <p>Real functional improvement</p> </li> <li> <p>4 methods add NO value (direct pass-through):</p> </li> <li> <p>Literally just <code>async for data in account.method(): yield data</code></p> </li> <li>No conversion, no processing, no unpacking</li> <li>Same protobuf objects as Account layer</li> <li> <p>Exist only for architectural consistency (MT5Sugar needs them)</p> </li> <li> <p>All methods have auto-reconnection:</p> </li> <li> <p>But this is available on Account layer too via <code>execute_stream_with_reconnect()</code></p> </li> </ol> <p>Performance tips:</p> <ul> <li>Use <code>stream_opened_tickets()</code> for frequent monitoring (very efficient - low bandwidth)</li> <li>Use <code>ignore_empty=True</code> for profit streaming (reduce bandwidth)</li> <li>Set appropriate <code>interval_ms</code> (balance latency vs performance)</li> <li>Always provide <code>cancellation_event</code> for graceful shutdown</li> </ul> <p>Cancellation pattern:</p> <pre><code>cancel_event = asyncio.Event()\nasync for item in service.stream_ticks(symbols, cancel_event):\n    if should_stop:\n        cancel_event.set()\n</code></pre> <p>Bottom line:</p> <ul> <li>\u2705 For direct users: Only <code>stream_ticks()</code> adds value - other 4 methods could call Account directly</li> <li>\u26aa Other 4 methods: No processing - consider calling Account layer directly for these</li> <li>\u2705 For Sugar users: All methods serve architectural purpose perfectly</li> <li>\u2705 vs MT5Account: Significant improvement only for stream_ticks() through datetime conversion</li> </ul>"},{"location":"MT5Service/MT5Service.Overview/","title":"MT5Service - Mid-Level API Overview","text":""},{"location":"MT5Service/MT5Service.Overview/#critical-understanding","title":"\u26a0\ufe0f Critical Understanding","text":"<p>MT5Service is an architectural middleware - it sits between MT5Account (gRPC protobuf) and MT5Sugar (business logic).</p>"},{"location":"MT5Service/MT5Service.Overview/#three-layer-architecture","title":"Three-Layer Architecture:","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502  MT5Sugar (HIGH)                                        \n\u2502  Business logic, ready patterns, high-level operations  \n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                     \u2502 Uses Service methods\n                     \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502  MT5Service (MID) \u2190 YOU ARE HERE                        \n\u2502  Unpacks protobuf + creates dataclasses                 \n\u2502  SOME methods add value, SOME are pass-through          \n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                     \u2502 Calls Account methods\n                     \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502  MT5Account (LOW)                                      \n\u2502  Direct gRPC calls, returns protobuf Data objects       \n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                     \u2502 gRPC stream\n                     \u2193\n                  MT5 Terminal\n</code></pre>"},{"location":"MT5Service/MT5Service.Overview/#value-reality-check","title":"Value Reality Check","text":"<p>Not all MT5Service methods add the same value:</p> <ul> <li> <p>\u2705 HIGH/VERY HIGH value - Complex protobuf unpacking + dataclass conversion</p> </li> <li> <p>\u26aa MEDIUM/LOW value - Simple protobuf field extraction</p> </li> <li> <p>\u26aa NONE value - Direct pass-through (<code>return await account.method()</code> or <code>yield data</code>)</p> </li> </ul> <p>Key insight: MT5Service exists primarily for MT5Sugar's architectural needs. For direct usage, evaluate each method's actual processing value.</p>"},{"location":"MT5Service/MT5Service.Overview/#quick-navigation-section-overviews","title":"Quick Navigation - Section Overviews","text":""},{"location":"MT5Service/MT5Service.Overview/#1-account-information","title":"1. Account Information","text":"<p>4 methods - Account balance/equity/margin/leverage</p> <ul> <li> <p>\u2705 1 HIGH value: <code>get_account_summary()</code> - aggregates 5 RPC calls + datetime conversion</p> </li> <li> <p>\u26aa 3 NONE value: Simple pass-through wrappers for architectural consistency</p> </li> </ul>"},{"location":"MT5Service/MT5Service.Overview/#2-symbol-information","title":"2. Symbol Information","text":"<p>13 methods - Symbol properties, quotes, trading conditions</p> <ul> <li>\u2705 9 methods have value - MT5Account returns protobuf Data that needs unpacking (VERY HIGH to LOW)</li> <li>\u26aa 4 methods NONE value - Direct pass-through for architectural consistency</li> </ul>"},{"location":"MT5Service/MT5Service.Overview/#3-positions-orders","title":"3. Positions &amp; Orders","text":"<p>5 methods - Open positions, pending orders, history</p> <ul> <li> <p>\u2705 1 MEDIUM value: <code>get_opened_tickets()</code> - converts protobuf repeated \u2192 Python lists</p> </li> <li> <p>\u26aa 1 LOW value: Simple unpacking</p> </li> <li> <p>\u26aa 3 NONE value: Direct pass-through</p> </li> </ul>"},{"location":"MT5Service/MT5Service.Overview/#4-market-depth","title":"4. Market Depth","text":"<p>3 methods - Level II quotes, order book (DOM)</p> <ul> <li> <p>\u2705 1 HIGH value: <code>get_market_depth()</code> - converts protobuf repeated \u2192 List[BookInfo]</p> </li> <li> <p>\u26aa 2 MEDIUM value: Simple bool unpacking</p> </li> </ul>"},{"location":"MT5Service/MT5Service.Overview/#5-trading-operations","title":"5. Trading Operations","text":"<p>6 methods - Order execution, margin calculations</p> <ul> <li> <p>\u2705 1 VERY HIGH value: <code>check_order()</code> - extracts deeply nested protobuf structure</p> </li> <li> <p>\u2705 2 HIGH value: <code>place_order()</code>, <code>modify_order()</code> - flatten 10 fields \u2192 dataclass</p> </li> <li> <p>\u26aa 3 LOW value: Simple single-field extraction</p> </li> </ul>"},{"location":"MT5Service/MT5Service.Overview/#6-streaming-methods","title":"6. Streaming Methods","text":"<p>5 async generators - Real-time ticks, trades, profits</p> <ul> <li> <p>\u2705 1 HIGH value: <code>stream_ticks()</code> - datetime conversion + dataclass creation</p> </li> <li> <p>\u26aa 4 NONE value: Direct pass-through (<code>yield data</code>)</p> </li> </ul>"},{"location":"MT5Service/MT5Service.Overview/#all-36-methods-grouped-by-value","title":"All 36 Methods - Grouped by Value","text":""},{"location":"MT5Service/MT5Service.Overview/#methods-worth-using-directly","title":"\u2705 Methods Worth Using Directly","text":"<p>VERY HIGH Value (1 method):</p> <ul> <li><code>check_order()</code> - Extracts deeply nested <code>mrpc_mql_trade_check_result</code> \u2192 OrderCheckResult</li> </ul> <p>HIGH Value (7 methods):</p> <ul> <li><code>get_account_summary()</code> - Aggregates 5 RPC calls + datetime conversion</li> <li><code>get_symbol_params_many()</code> - Aggregates 17 fields + unpacks protobuf list</li> <li><code>get_symbol_tick()</code> - Unix timestamp \u2192 datetime + unpacks 8 fields</li> <li><code>get_symbol_session_quote()</code> - 2x protobuf Timestamp \u2192 datetime</li> <li><code>get_symbol_session_trade()</code> - 2x protobuf Timestamp \u2192 datetime</li> <li><code>place_order()</code> - Flattens 10 protobuf fields \u2192 OrderResult dataclass</li> <li><code>modify_order()</code> - Flattens 10 protobuf fields \u2192 OrderResult dataclass</li> <li><code>get_market_depth()</code> - Converts protobuf repeated \u2192 List[BookInfo] dataclass</li> <li><code>stream_ticks()</code> - Converts protobuf Timestamp \u2192 datetime + SymbolTick dataclass</li> </ul> <p>MEDIUM Value (3 methods):</p> <ul> <li><code>get_symbol_margin_rate()</code> - Unpacks protobuf + creates dataclass</li> <li><code>get_opened_tickets()</code> - Converts protobuf repeated \u2192 Python lists</li> <li><code>subscribe_market_depth()</code> - Unpacks <code>data.success</code> from protobuf</li> <li><code>unsubscribe_market_depth()</code> - Unpacks <code>data.success</code> from protobuf</li> </ul>"},{"location":"MT5Service/MT5Service.Overview/#methods-with-minimalno-value","title":"\u26aa Methods with Minimal/No Value","text":"<p>LOW Value (8 methods) - Simple single-field extraction:</p> <ul> <li><code>get_symbols_total()</code> - Unpacks <code>data.total</code></li> <li><code>get_symbol_double()</code> - Unpacks <code>data.value</code></li> <li><code>get_symbol_integer()</code> - Unpacks <code>data.value</code></li> <li><code>get_symbol_string()</code> - Unpacks <code>data.value</code></li> <li><code>get_positions_total()</code> - Unpacks <code>data.total_positions</code></li> <li><code>close_order()</code> - Unpacks <code>data.returned_code</code></li> <li><code>calculate_margin()</code> - Unpacks <code>data.margin</code></li> <li><code>calculate_profit()</code> - Unpacks <code>data.profit</code></li> </ul> <p>NONE Value (18 methods) - Direct pass-through:</p> <ul> <li><code>get_account_double()</code> - Just calls <code>account.account_info_double()</code></li> <li><code>get_account_integer()</code> - Just calls <code>account.account_info_integer()</code></li> <li><code>get_account_string()</code> - Just calls <code>account.account_info_string()</code></li> <li><code>symbol_exist()</code> - Just calls <code>account.symbol_exist()</code></li> <li><code>get_symbol_name()</code> - Just calls <code>account.symbol_name()</code></li> <li><code>symbol_select()</code> - Just calls <code>account.symbol_select()</code></li> <li><code>is_symbol_synchronized()</code> - Just calls <code>account.symbol_is_synchronized()</code></li> <li><code>get_opened_orders()</code> - Just calls <code>account.opened_orders()</code></li> <li><code>get_order_history()</code> - Just calls <code>account.order_history()</code></li> <li><code>get_positions_history()</code> - Just calls <code>account.positions_history()</code></li> <li><code>stream_trade_updates()</code> - Just <code>yield data</code></li> <li><code>stream_position_profits()</code> - Just <code>yield data</code></li> <li><code>stream_opened_tickets()</code> - Just <code>yield data</code></li> <li><code>stream_transactions()</code> - Just <code>yield data</code></li> </ul>"},{"location":"MT5Service/MT5Service.Overview/#when-to-use-mt5service-vs-mt5account","title":"When to Use MT5Service vs MT5Account","text":""},{"location":"MT5Service/MT5Service.Overview/#use-mt5service-when","title":"Use MT5Service When:","text":"<ul> <li>\u2705 Method adds significant value (HIGH/VERY HIGH from list above)</li> <li>\u2705 You need cleaner API than protobuf (datetime conversion, dataclasses)</li> <li>\u2705 Working with MT5Sugar (architectural requirement)</li> </ul>"},{"location":"MT5Service/MT5Service.Overview/#use-mt5account-directly-when","title":"Use MT5Account Directly When:","text":"<ul> <li>Method has NONE/LOW value (direct pass-through or simple unpacking)</li> <li>Need full control over protobuf structures</li> <li>Performance critical (avoid extra layer)</li> <li>Method not available in MT5Service</li> </ul> <p>Access MT5Account from MT5Service:</p> <pre><code>account = service.get_account()\n# Now call low-level methods directly\n</code></pre>"},{"location":"MT5Service/MT5Service.Overview/#usage-pattern","title":"Usage Pattern","text":"<pre><code>import asyncio\nfrom uuid import uuid4\nfrom MetaRpcMT5 import MT5Account  # Low-level gRPC client\nfrom pymt5.mt5_service import MT5Service  # Mid-level wrapper\nfrom MetaRpcMT5 import mt5_term_api_account_information_pb2 as account_info_pb2\n\nasync def main():\n    # 1. Create MT5Account (low-level gRPC client)\n    account = MT5Account(\n        user=12345678,  # MT5 login number\n        password=\"password\",\n        grpc_server=\"127.0.0.1:9999\",  # optional, default \"mt5.mrpc.pro:443\"\n        id_=uuid4()  # optional UUID for terminal instance\n    )\n\n    # 2. Connect to MT5 server\n    await account.connect_by_server_name(\n        server_name=\"MetaQuotes-Demo\",  # MT5 broker server/cluster name\n        base_chart_symbol=\"EURUSD\",  # symbol for chart initialization\n        timeout_seconds=120\n    )\n\n    # 3. Wrap in MT5Service (mid-level)\n    service = MT5Service(account)\n\n    # 4. Use HIGH-value methods\n    summary = await service.get_account_summary()\n    print(f\"Balance: ${summary.balance:.2f}, Equity: ${summary.equity:.2f}\")\n\n    # 5. For NONE-value methods, consider calling Account directly\n    # Instead of: balance = await service.get_account_double(account_info_pb2.ACCOUNT_BALANCE)\n    # Direct call: balance = await account.account_info_double(account_info_pb2.ACCOUNT_BALANCE)\n\n    # 6. Close connection when done\n    await account.channel.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"MT5Service/MT5Service.Overview/#complete-method-index","title":"Complete Method Index","text":""},{"location":"MT5Service/MT5Service.Overview/#1-account-information-4-methods","title":"1. Account Information (4 methods)","text":"<p>Overview: Account_Information.md</p> Method Value What It Does <code>get_account_summary()</code> \u2705 HIGH Aggregates 5 RPC calls + datetime conversion <code>get_account_double()</code> \u26aa NONE Pass-through: <code>return await account.account_info_double()</code> <code>get_account_integer()</code> \u26aa NONE Pass-through: <code>return await account.account_info_integer()</code> <code>get_account_string()</code> \u26aa NONE Pass-through: <code>return await account.account_info_string()</code>"},{"location":"MT5Service/MT5Service.Overview/#2-symbol-information-13-methods","title":"2. Symbol Information (13 methods)","text":"<p>Overview: Symbol_Information.md</p> Method Value What It Does <code>get_symbol_params_many()</code> \u2705 VERY HIGH Aggregates 17 fields + unpacks protobuf list <code>get_symbol_tick()</code> \u2705 HIGH Unix timestamp \u2192 datetime + unpacks 8 fields <code>get_symbol_session_quote()</code> \u2705 HIGH 2x protobuf Timestamp \u2192 datetime <code>get_symbol_session_trade()</code> \u2705 HIGH 2x protobuf Timestamp \u2192 datetime <code>get_symbol_margin_rate()</code> \u26aa MEDIUM Unpacks protobuf + creates dataclass <code>get_symbols_total()</code> \u26aa LOW Unpacks <code>data.total</code> from protobuf <code>get_symbol_double()</code> \u26aa LOW Unpacks <code>data.value</code> from protobuf <code>get_symbol_integer()</code> \u26aa LOW Unpacks <code>data.value</code> from protobuf <code>get_symbol_string()</code> \u26aa LOW Unpacks <code>data.value</code> from protobuf <code>symbol_exist()</code> \u26aa NONE Pass-through: <code>return await account.symbol_exist()</code> <code>get_symbol_name()</code> \u26aa NONE Pass-through: <code>return await account.symbol_name()</code> <code>symbol_select()</code> \u26aa NONE Pass-through: <code>return await account.symbol_select()</code> <code>is_symbol_synchronized()</code> \u26aa NONE Pass-through: <code>return await account.symbol_is_synchronized()</code>"},{"location":"MT5Service/MT5Service.Overview/#3-positions-orders-5-methods","title":"3. Positions &amp; Orders (5 methods)","text":"<p>Overview: Positions_Orders.md</p> Method Value What It Does <code>get_opened_tickets()</code> \u2705 MEDIUM Converts protobuf repeated \u2192 Python lists <code>get_positions_total()</code> \u26aa LOW Unpacks <code>data.total_positions</code> from protobuf <code>get_opened_orders()</code> \u26aa NONE Pass-through: <code>return await account.opened_orders()</code> <code>get_order_history()</code> \u26aa NONE Pass-through: <code>return await account.order_history()</code> <code>get_positions_history()</code> \u26aa NONE Pass-through: <code>return await account.positions_history()</code>"},{"location":"MT5Service/MT5Service.Overview/#4-market-depth-3-methods","title":"4. Market Depth (3 methods)","text":"<p>Overview: Market_Depth.md</p> Method Value What It Does <code>get_market_depth()</code> \u2705 HIGH Converts protobuf repeated \u2192 List[BookInfo] dataclass <code>subscribe_market_depth()</code> \u26aa MEDIUM Unpacks <code>data.success</code> from protobuf <code>unsubscribe_market_depth()</code> \u26aa MEDIUM Unpacks <code>data.success</code> from protobuf"},{"location":"MT5Service/MT5Service.Overview/#5-trading-operations-6-methods","title":"5. Trading Operations (6 methods)","text":"<p>Overview: Trading_Operations.md</p> Method Value What It Does <code>check_order()</code> \u2705 VERY HIGH Extracts deeply nested <code>mrpc_mql_trade_check_result</code> \u2192 OrderCheckResult (8 fields) <code>place_order()</code> \u2705 HIGH Flattens 10 protobuf fields \u2192 OrderResult dataclass <code>modify_order()</code> \u2705 HIGH Flattens 10 protobuf fields \u2192 OrderResult dataclass <code>close_order()</code> \u26aa LOW Unpacks <code>data.returned_code</code> from protobuf \u2192 int <code>calculate_margin()</code> \u26aa LOW Unpacks <code>data.margin</code> from protobuf \u2192 float <code>calculate_profit()</code> \u26aa LOW Unpacks <code>data.profit</code> from protobuf \u2192 float"},{"location":"MT5Service/MT5Service.Overview/#6-streaming-methods-5-async-generators","title":"6. Streaming Methods (5 async generators)","text":"<p>Overview: Streaming_Methods.md</p> Method Value What It Does <code>stream_ticks()</code> \u2705 HIGH Converts protobuf Timestamp \u2192 datetime + creates SymbolTick dataclass (8 fields) <code>stream_trade_updates()</code> \u26aa NONE Pass-through: <code>async for data in account.on_trade(): yield data</code> <code>stream_position_profits()</code> \u26aa NONE Pass-through: <code>async for data in account.on_position_profit(): yield data</code> <code>stream_opened_tickets()</code> \u26aa NONE Pass-through: <code>async for data in account.on_positions_and_pending_orders_tickets(): yield data</code> <code>stream_transactions()</code> \u26aa NONE Pass-through: <code>async for data in account.on_trade_transaction(): yield data</code>"},{"location":"MT5Service/MT5Service.Overview/#best-practices","title":"Best Practices","text":""},{"location":"MT5Service/MT5Service.Overview/#1-use-high-value-methods","title":"1. Use HIGH-value Methods","text":"<pre><code># GOOD - use methods that add real value\nsummary = await service.get_account_summary()  # Aggregates 5 RPC calls\nsymbols, _ = await service.get_symbol_params_many(\"EURUSD\")  # Aggregates 17 fields\nresult = await service.check_order(request)  # Extracts deeply nested protobuf\n\n# CONSIDER - for NONE-value methods, call Account directly\nbalance = await account.account_info_double(account_info_pb2.ACCOUNT_BALANCE)\n# Instead of: balance = await service.get_account_double(account_info_pb2.ACCOUNT_BALANCE)\n</code></pre>"},{"location":"MT5Service/MT5Service.Overview/#2-validate-trading-operations","title":"2. Validate Trading Operations","text":"<pre><code># ALWAYS use check_order() before place_order() - it has VERY HIGH value!\ncheck = await service.check_order(request)\nif check.returned_code == 0:\n    result = await service.place_order(request)\n    if result.returned_code == 10009:\n        print(f\"Success! Order: {result.order}\")\n</code></pre>"},{"location":"MT5Service/MT5Service.Overview/#3-handle-errors","title":"3. Handle Errors","text":"<pre><code>try:\n    summary = await service.get_account_summary()\nexcept Exception as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"MT5Service/MT5Service.Overview/#4-use-cancellation-events-for-streams","title":"4. Use Cancellation Events for Streams","text":"<pre><code>import asyncio\n\ncancel_event = asyncio.Event()\n\n# Use HIGH-value stream_ticks()\nasync for tick in service.stream_ticks([\"EURUSD\"], cancel_event):\n    print(f\"{tick.time}: {tick.bid:.5f}\")  # time is already datetime!\n    if should_stop:\n        cancel_event.set()\n</code></pre> <p>Choose wisely based on actual processing value, not just API level!</p>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/","title":"MT5Sugar - Master Overview","text":"<p>High-level convenience methods for MetaTrader 5 trading automation in Python</p> <p>MT5Sugar extends <code>MT5Service</code> with convenient methods for:</p> <ul> <li>Risk-based position sizing (percentage risk, pip-based SL/TP)</li> <li>Automatic volume and price normalization</li> <li>Bulk operations (close all positions, manage multiple trades)</li> <li>Historical analysis and statistics</li> <li>Pre-trade validation and margin checking</li> <li>Real-time P/L monitoring and position tracking</li> <li>Simplified connection management</li> </ul>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#navigation-by-category","title":"Navigation by Category","text":""},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#01-connection","title":"\ud83d\udd0c [01] CONNECTION","text":"<p>Connect to MT5 terminal and check connection status</p> Method Description Documentation <code>quick_connect()</code> Connect using cluster name (RECOMMENDED) Docs <code>is_connected()</code> Check if connected to MT5 Docs <code>ping()</code> Verify connection is alive Docs"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#02-account-properties","title":"\ud83d\udcb0 [02] ACCOUNT PROPERTIES","text":"<p>Quick access to account balance and margin metrics</p> Method Description Documentation <code>get_balance()</code> Account balance (realized profit only) Docs <code>get_equity()</code> Current equity (balance + floating P/L) Docs <code>get_margin()</code> Currently used margin Docs <code>get_free_margin()</code> Available margin for new positions Docs <code>get_margin_level()</code> Margin level percent (Equity / Margin x 100) Docs <code>get_floating_profit()</code> Total floating profit/loss from all open positions Docs <code>get_account_info()</code> Complete account snapshot in one call Docs <p>Property syntax:</p> <ul> <li><code>balance</code> -- async property, equivalent to <code>get_balance()</code> | Docs</li> </ul> <p>Data structures:</p> <ul> <li><code>AccountInfo</code> -- login, balance, equity, profit, margin, free_margin, margin_level, leverage, currency, company, trade_allowed, trade_expert, server_name, server_time</li> </ul>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#03-prices-and-quotes","title":"\ud83d\udcb9 [03] PRICES AND QUOTES","text":"<p>Working with current market prices</p> Method Description Documentation <code>get_bid()</code> Current BID price for symbol Docs <code>get_ask()</code> Current ASK price for symbol Docs <code>get_spread()</code> Current spread (ASK - BID) in price units Docs <code>get_price_info()</code> Complete price snapshot (bid, ask, spread, time) Docs <code>wait_for_price()</code> Wait for valid price with timeout Docs <p>Data structures:</p> <ul> <li><code>PriceInfo</code> -- symbol, bid, ask, spread, time</li> </ul>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#04-simple-trading","title":"\ud83d\udce6 [04] SIMPLE TRADING","text":"<p>Place market and pending orders without SL/TP</p>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#market-orders","title":"Market Orders","text":"Method Description Documentation <code>buy_market()</code> BUY at current ASK price Docs <code>sell_market()</code> SELL at current BID price Docs"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#pending-orders","title":"Pending Orders","text":"Method Description Documentation <code>buy_limit()</code> Buy Limit -- buy below current price Docs <code>sell_limit()</code> Sell Limit -- sell above current price Docs <code>buy_stop()</code> Buy Stop -- buy above current price (breakout) Docs <code>sell_stop()</code> Sell Stop -- sell below current price (breakdown) Docs"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#05-trading-with-sltp","title":"\ud83c\udfaf [05] TRADING WITH SL/TP","text":"<p>Place orders with Stop Loss and Take Profit in one call</p> <p>Supports both absolute price values and pip-based notation via <code>sl_pips</code> / <code>tp_pips</code> parameters.</p>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#market-orders-with-sltp","title":"Market Orders with SL/TP","text":"Method Description Documentation <code>buy_market_with_sltp()</code> BUY with SL/TP (prices or pips) Docs <code>sell_market_with_sltp()</code> SELL with SL/TP (prices or pips) Docs"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#pending-orders-with-sltp","title":"Pending Orders with SL/TP","text":"Method Description Documentation <code>buy_limit_with_sltp()</code> Buy Limit with SL/TP Docs <code>sell_limit_with_sltp()</code> Sell Limit with SL/TP Docs <p>Example: <pre><code># BUY EURUSD: 50 pip SL, 100 pip TP (1:2 R:R)\nticket = await sugar.buy_market_with_sltp(\"EURUSD\", volume=0.1, sl_pips=50, tp_pips=100)\n</code></pre></p>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#06-position-management","title":"\u2699\ufe0f [06] POSITION MANAGEMENT","text":"<p>Modify and close existing positions</p> Method Description Documentation <code>close_position()</code> Close entire position by ticket Docs <code>close_position_partial()</code> Partial close with specified volume Docs <code>close_all_positions()</code> Close all open positions (optionally by symbol) Docs <code>modify_position_sltp()</code> Modify SL and/or TP (pass None to keep) Docs <code>modify_position_sl()</code> Modify only Stop Loss Docs <code>modify_position_tp()</code> Modify only Take Profit Docs"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#07-position-information","title":"\ud83d\udccb [07] POSITION INFORMATION","text":"<p>Query and analyze open positions</p> Method Description Documentation <code>get_open_positions()</code> Get all open positions Docs <code>get_position_by_ticket()</code> Get specific position by ticket (None if not found) Docs <code>get_positions_by_symbol()</code> Get all positions for specific symbol Docs <code>has_open_position()</code> Check if positions exist (optionally by symbol) Docs <code>count_open_positions()</code> Total number of open positions Docs <code>get_total_profit()</code> Total floating P/L across all positions Docs <code>get_profit_by_symbol()</code> Floating P/L for specific symbol Docs <p>Data structures:</p> <ul> <li><code>PositionInfo</code> -- ticket, symbol, volume, type, profit, sl, tp, open_price, open_time</li> </ul>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#08-history-and-statistics","title":"\ud83d\udcca [08] HISTORY AND STATISTICS","text":"<p>Retrieve trading history and performance analytics</p> Method Description Documentation <code>get_deals()</code> Closed positions for specified period Docs <code>get_profit()</code> Total realized P/L for specified period Docs <code>get_daily_stats()</code> Comprehensive daily statistics Docs <p>Convenience wrappers for <code>get_deals()</code>:</p> <ul> <li><code>get_deals_today()</code> -- Period.TODAY</li> <li><code>get_deals_yesterday()</code> -- Period.YESTERDAY</li> <li><code>get_deals_this_week()</code> -- Period.THIS_WEEK (Monday to now)</li> <li><code>get_deals_this_month()</code> -- Period.THIS_MONTH</li> <li><code>get_deals_date_range(from_date, to_date)</code> -- Period.CUSTOM</li> </ul> <p>Convenience wrappers for <code>get_profit()</code>:</p> <ul> <li><code>get_profit_today()</code> -- Period.TODAY</li> <li><code>get_profit_this_week()</code> -- Period.THIS_WEEK</li> <li><code>get_profit_this_month()</code> -- Period.THIS_MONTH</li> </ul> <p>Data structures:</p> <ul> <li><code>DailyStats</code> -- date, deals_count, profit, commission, swap, volume</li> </ul>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#09-symbol-information","title":"\ud83c\udff7\ufe0f [09] SYMBOL INFORMATION","text":"<p>Symbol properties and trading conditions</p> Method Description Documentation <code>get_symbol_info()</code> Complete symbol parameters in one call Docs <code>get_all_symbols()</code> List of all available symbols on broker Docs <code>is_symbol_available()</code> Check if symbol exists and is available Docs <code>get_min_stop_level()</code> Minimum SL/TP distance in points Docs <code>get_symbol_digits()</code> Decimal precision for symbol price Docs <p>Data structures:</p> <ul> <li><code>SymbolInfo</code> -- name, bid, ask, spread, digits, point, volume_min, volume_max, volume_step, contract_size</li> </ul>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#10-risk-management","title":"\ud83d\udee1\ufe0f [10] RISK MANAGEMENT","text":"<p>Position sizing, margin calculations, and pre-trade validation</p> Method Description Documentation <code>calculate_position_size()</code> Auto-calculate lot size by risk percent Docs <code>calculate_required_margin()</code> Margin needed for a specific position Docs <code>can_open_position()</code> Full pre-trade validation via MT5 order_check Docs <code>get_max_lot_size()</code> Maximum tradeable volume for symbol Docs <p>Example: <pre><code># Auto-calculate lot size to risk 2% with 50 pip SL\nvolume = await sugar.calculate_position_size(\"EURUSD\", 2.0, 50)\n</code></pre></p>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#common-use-cases","title":"Common Use Cases","text":""},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#1-simple-market-order","title":"1. Simple market order","text":"<pre><code>ticket = await sugar.buy_market(\"EURUSD\", volume=0.10)\nprint(f\"Position opened: #{ticket}\")\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#2-market-order-with-sltp-in-pips","title":"2. Market order with SL/TP in pips","text":"<pre><code>ticket = await sugar.buy_market_with_sltp(\n    \"EURUSD\", volume=0.10,\n    sl_pips=50, tp_pips=100\n)\nprint(f\"BUY #{ticket} opened (1:2 R:R)\")\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#3-risk-based-position-sizing","title":"3. Risk-based position sizing","text":"<pre><code>symbol = \"EURUSD\"\nrisk_percent = 2.0      # Risk 2% of balance\nsl_pips = 50            # 50 pip stop loss\n\n# Calculate lot size automatically\nvolume = await sugar.calculate_position_size(symbol, risk_percent, sl_pips)\n\n# Validate before trading\ncan_open, reason = await sugar.can_open_position(symbol, volume)\nif not can_open:\n    print(f\"Cannot trade: {reason}\")\nelse:\n    ticket = await sugar.buy_market_with_sltp(symbol, volume, sl_pips=50, tp_pips=100)\n    print(f\"Position #{ticket} opened (risking {risk_percent}%)\")\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#4-complete-trading-workflow","title":"4. Complete trading workflow","text":"<pre><code># Step 1: Connect\nawait sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n# Step 2: Check symbol\nif not await sugar.is_symbol_available(\"EURUSD\"):\n    raise ValueError(\"Symbol not available\")\n\n# Step 3: Calculate position size (risk 2%)\nvolume = await sugar.calculate_position_size(\"EURUSD\", 2.0, 50)\n\n# Step 4: Validate\ncan_open, reason = await sugar.can_open_position(\"EURUSD\", volume)\nif not can_open:\n    raise RuntimeError(f\"Cannot trade: {reason}\")\n\n# Step 5: Trade\nticket = await sugar.buy_market_with_sltp(\"EURUSD\", volume, sl_pips=50, tp_pips=100)\nprint(f\"Position #{ticket} opened\")\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#5-monitor-positions-and-close-on-drawdown","title":"5. Monitor positions and close on drawdown","text":"<pre><code>total_profit = await sugar.get_total_profit()\nprint(f\"Floating P/L: ${total_profit:.2f}\")\n\nif total_profit &lt; -500:\n    print(\"Drawdown $500 -- closing all positions\")\n    closed_count = await sugar.close_all_positions()\n    print(f\"Closed {closed_count} positions\")\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#6-daily-performance-report","title":"6. Daily performance report","text":"<pre><code>info = await sugar.get_account_info()\nprint(f\"Account: #{info.login}, Balance: ${info.balance:.2f}, Equity: ${info.equity:.2f}\")\n\nstats = await sugar.get_daily_stats()\nprint(f\"Today -- Deals: {stats.deals_count}, Profit: ${stats.profit:.2f}\")\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#7-symbol-specific-analysis","title":"7. Symbol-specific analysis","text":"<pre><code>symbol = \"EURUSD\"\n\nhas_pos = await sugar.has_open_position(symbol)\nprint(f\"{symbol} has open position: {has_pos}\")\n\nif has_pos:\n    profit = await sugar.get_profit_by_symbol(symbol)\n    print(f\"{symbol} floating P/L: ${profit:.2f}\")\n\n    if profit &lt; -100:\n        closed = await sugar.close_all_positions(symbol)\n        print(f\"Closed {closed} positions for {symbol}\")\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#8-pending-order-with-validation","title":"8. Pending order with validation","text":"<pre><code>symbol = \"EURUSD\"\nvolume = 0.1\nlimit_price = 1.08500\n\n# Get current price\nprice_info = await sugar.get_price_info(symbol)\nprint(f\"Current bid: {price_info.bid}, ask: {price_info.ask}\")\n\n# Validate margin\nmargin_needed = await sugar.calculate_required_margin(symbol, volume)\nfree_margin = await sugar.get_free_margin()\n\nif margin_needed &gt; free_margin:\n    raise RuntimeError(\"Insufficient margin\")\n\n# Place Buy Limit below current price\nif limit_price &lt; price_info.ask:\n    ticket = await sugar.buy_limit_with_sltp(\n        symbol, volume, price=limit_price,\n        sl=1.08000, tp=1.09000\n    )\n    print(f\"Buy Limit placed: #{ticket}\")\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#9-weekly-performance-tracking","title":"9. Weekly performance tracking","text":"<pre><code>deals = await sugar.get_deals_this_week()\nprint(f\"Trades this week: {len(deals)}\")\n\nif deals:\n    total_profit = sum(d.profit for d in deals)\n    winners = sum(1 for d in deals if d.profit &gt; 0)\n    win_rate = (winners / len(deals)) * 100\n\n    print(f\"Win rate: {win_rate:.1f}%\")\n    print(f\"Total profit: ${total_profit:.2f}\")\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#10-multi-symbol-portfolio","title":"10. Multi-symbol portfolio","text":"<pre><code>symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\n\nprint(\"PORTFOLIO STATUS\")\nprint(\"=\" * 40)\n\ntotal_floating = 0.0\n\nfor symbol in symbols:\n    positions = await sugar.get_positions_by_symbol(symbol)\n    count = len(positions)\n    profit = 0.0\n\n    if count &gt; 0:\n        profit = await sugar.get_profit_by_symbol(symbol)\n        total_floating += profit\n\n    print(f\"{symbol}: {count} positions, P/L: ${profit:.2f}\")\n\nprint(f\"\\nTotal floating P/L: ${total_floating:.2f}\")\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#related-documentation","title":"Related Documentation","text":"<ul> <li>MT5Account -- Low-level gRPC/Proto methods | MT5Account Overview</li> <li>MT5Service -- Mid-level service layer | MT5Service Overview</li> <li>MT5Sugar (this document) -- High-level convenience methods</li> </ul>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#architecture","title":"Architecture","text":"<pre><code>MT5Sugar (High-level)  &lt;-- You are here\n    |  Simplified trading, risk management, analytics\n    v\nMT5Service (Mid-level)\n    |  Type conversion, timeout management\n    v\nMT5Account (Low-level)\n    |  Direct gRPC/Protobuf calls\n    v\nMetaTrader 5 Terminal\n</code></pre> <p>Layer Comparison:</p> Feature MT5Account MT5Service MT5Sugar Complexity Low-level Proto Mid-level typed High-level convenience Learning curve Steep Moderate Gentle Verbosity High Medium Low Risk management Manual Manual Built-in Position sizing Manual Manual Automatic SL/TP Prices only Prices only Pips or prices Use case Custom wrappers Standard apps Trading bots"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#conventions","title":"Conventions","text":"<ul> <li>All methods are async -- always use <code>await</code></li> <li>Prices are always absolute (e.g., 1.08500), not relative</li> <li>Volumes are always in lots (e.g., 0.1), not currency units</li> <li>Points -- minimum price increment (for 5-digit: 0.00001)</li> <li>Pips -- standard trader unit (for 5-digit: 1 pip = 10 points = 0.0001)</li> <li><code>sl_pips</code> / <code>tp_pips</code> parameters accept pips</li> <li><code>get_min_stop_level()</code> returns points (not pips)</li> <li>Timeouts are built-in (typically 5 seconds) -- no need to specify</li> <li>All times are MT5 server time (not local time)</li> <li>Symbol names are case-sensitive -- use uppercase (e.g., \"EURUSD\")</li> <li><code>get_profit()</code> returns gross profit -- does not subtract commission/swap. Use <code>get_daily_stats()</code> for net</li> <li><code>get_deals()</code> returns up to 10,000 positions per request -- split large date ranges</li> </ul>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#best-practices","title":"Best Practices","text":""},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#risk-management","title":"Risk Management","text":"<pre><code># ALWAYS use calculate_position_size for risk-based trading\nvolume = await sugar.calculate_position_size(\"EURUSD\", 2.0, 50)  # Good\n\n# Do not use fixed lot sizes -- does not scale with account size\n# volume = 0.1  # Bad\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#pre-trade-validation","title":"Pre-Trade Validation","text":"<pre><code># ALWAYS validate before trading\ncan_open, reason = await sugar.can_open_position(\"EURUSD\", volume)\nif not can_open:\n    print(f\"Cannot trade: {reason}\")\nelse:\n    ticket = await sugar.buy_market_with_sltp(\"EURUSD\", volume, sl_pips=50, tp_pips=100)\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#error-handling","title":"Error Handling","text":"<pre><code># ALWAYS check errors\ntry:\n    ticket = await sugar.buy_market(\"EURUSD\", volume=0.1)\n    print(f\"Success: #{ticket}\")\nexcept RuntimeError as e:\n    print(f\"Trade failed: {e}\")\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#use-pip-based-methods","title":"Use Pip-Based Methods","text":"<pre><code># Prefer pip-based notation (more intuitive)\nawait sugar.buy_market_with_sltp(\"EURUSD\", 0.1, sl_pips=50, tp_pips=100)  # Good\n\n# Instead of calculating prices manually (error-prone)\n# ask = await sugar.get_ask(\"EURUSD\")\n# sl = ask - 0.00050  # Bad -- manual calculation\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#connection-management","title":"Connection Management","text":"<pre><code># Check connection before trading\nif not await sugar.is_connected():\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n# Verify with ping\nif not await sugar.ping():\n    raise RuntimeError(\"Connection lost\")\n</code></pre>"},{"location":"MT5Sugar/MT5Sugar.Master.Overview/#quick-start","title":"Quick Start","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def main():\n    # 1. Create instances\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    # 2. Connect\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # 3. Calculate position size (risk 2%)\n    volume = await sugar.calculate_position_size(\"EURUSD\", 2.0, 50)\n\n    # 4. Validate\n    can_open, reason = await sugar.can_open_position(\"EURUSD\", volume)\n    if not can_open:\n        raise RuntimeError(f\"Cannot trade: {reason}\")\n\n    # 5. Trade with pips\n    ticket = await sugar.buy_market_with_sltp(\n        \"EURUSD\", volume,\n        sl_pips=50, tp_pips=100\n    )\n    print(f\"Position #{ticket} opened\")\n    print(f\"Risk: 2% | SL: 50 pips | TP: 100 pips | R:R 1:2\")\n</code></pre> <p>Start with <code>buy_market_with_sltp()</code>, <code>calculate_position_size()</code>, and <code>can_open_position()</code> -- these three methods cover 80% of trading needs.</p>"},{"location":"MT5Sugar/1.%20Connection/is_connected/","title":"Check Connection Status (<code>is_connected</code>)","text":"<p>Sugar method: Checks if gRPC connection to MT5 server is active.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.is_connected()</code></li> <li>Returns: <code>True</code> if connected, <code>False</code> otherwise</li> <li>Layer: HIGH (MT5Sugar)</li> <li>Type: Synchronous method (no async/await)</li> </ul>"},{"location":"MT5Sugar/1.%20Connection/is_connected/#method-signature","title":"Method Signature","text":"<pre><code>def is_connected(self) -&gt; bool\n</code></pre>"},{"location":"MT5Sugar/1.%20Connection/is_connected/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"<p>None</p>"},{"location":"MT5Sugar/1.%20Connection/is_connected/#return-value","title":"Return Value","text":"Type Description <code>bool</code> <code>True</code> if gRPC channel is READY or IDLE, <code>False</code> otherwise"},{"location":"MT5Sugar/1.%20Connection/is_connected/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Checks gRPC channel connectivity state</li> <li>Returns True for READY or IDLE states</li> <li>Returns False if channel unavailable or in error state</li> <li>Does not attempt to connect (non-blocking check)</li> </ul> <p>Key behaviors:</p> <ul> <li>Synchronous method (no await needed)</li> <li>Safe to call anytime (catches exceptions)</li> <li>Does not modify connection state</li> <li>Returns False on any exception</li> </ul>"},{"location":"MT5Sugar/1.%20Connection/is_connected/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.is_connected()\n    \u2193 accesses\nMT5Service.get_account()\n    \u2193 checks channel state\ngrpc.Channel.get_state(try_to_connect=False)\n    \u2193 returns\nChannelConnectivity enum (READY/IDLE/...)\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar accesses underlying MT5Account from service</li> <li>Checks if account has channel attribute</li> <li>Calls channel.get_state() with try_to_connect=False</li> <li>Compares state against READY or IDLE</li> <li>Returns True if connected, False otherwise</li> <li>Catches all exceptions and returns False</li> </ol> <p>Related files: - Sugar: <code>src/pymt5/mt5_sugar.py:291</code></p>"},{"location":"MT5Sugar/1.%20Connection/is_connected/#when-to-use","title":"When to Use","text":"<p>Use <code>is_connected()</code> when:</p> <ul> <li>Checking connection before operations</li> <li>Implementing connection health monitoring</li> <li>Validating state before critical operations</li> <li>Building connection retry logic</li> </ul> <p>Don't use when:</p> <ul> <li>You want to ping server (use <code>ping()</code>)</li> <li>Need to test actual server responsiveness</li> <li>Want to establish connection (use quick_connect())</li> </ul>"},{"location":"MT5Sugar/1.%20Connection/is_connected/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/1.%20Connection/is_connected/#example-1-basic-connection-check","title":"Example 1: Basic Connection Check","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\n# Create MT5Sugar instance\naccount = MT5Account.create(\n    user=591129415,\n    password=\"your_password\",\n    grpc_server=\"mt5.mrpc.pro:443\"\n)\nservice = MT5Service(account)\nsugar = MT5Sugar(service)\n\n# Check connection (no await needed - synchronous)\nif sugar.is_connected():\n    print(\"Connected to MT5 server\")\nelse:\n    print(\"Not connected\")\n\n# Output:\n# Connected to MT5 server\n</code></pre>"},{"location":"MT5Sugar/1.%20Connection/is_connected/#example-2-conditional-operations","title":"Example 2: Conditional Operations","text":"<pre><code>async def safe_get_balance():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    # Connect first\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Check before operation\n    if sugar.is_connected():\n        balance = await sugar.get_balance()\n        print(f\"Balance: ${balance}\")\n    else:\n        print(\"Cannot get balance - not connected\")\n</code></pre>"},{"location":"MT5Sugar/1.%20Connection/is_connected/#example-3-connection-monitoring-loop","title":"Example 3: Connection Monitoring Loop","text":"<pre><code>import asyncio\n\nasync def monitor_connection():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Monitor connection every 10 seconds\n    while True:\n        if sugar.is_connected():\n            print(\"Connection OK\")\n        else:\n            print(\"Connection lost - reconnecting...\")\n            await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n        await asyncio.sleep(10)\n</code></pre>"},{"location":"MT5Sugar/1.%20Connection/is_connected/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Confusing with ping <pre><code># is_connected() only checks channel state, not server health\nif sugar.is_connected():\n    # Channel is open, but server might not respond\n    pass\n</code></pre></p> <p>Solution: Use ping() for actual server health check <pre><code># Check channel state\nchannel_ok = sugar.is_connected()\n\n# Check server responsiveness\nserver_ok = await sugar.ping()\n\nif channel_ok and server_ok:\n    print(\"Fully connected and responsive\")\n</code></pre></p> <p>Pitfall 2: Using await (it's synchronous) <pre><code># ERROR: is_connected() is NOT async\nconnected = await sugar.is_connected()  # SyntaxError\n</code></pre></p> <p>Solution: Call without await <pre><code># Correct: synchronous call\nconnected = sugar.is_connected()\n</code></pre></p> <p>Pitfall 3: Assuming False means permanent failure <pre><code>if not sugar.is_connected():\n    print(\"Connection permanently lost\")\n    # Not necessarily true - might just be initializing\n</code></pre></p> <p>Solution: Combine with retry logic <pre><code>if not sugar.is_connected():\n    print(\"Not connected - attempting to connect\")\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n</code></pre></p>"},{"location":"MT5Sugar/1.%20Connection/is_connected/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Quick pre-flight check <pre><code># Check before critical operations\nif not sugar.is_connected():\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n# Proceed with operations\nbalance = await sugar.get_balance()\n</code></pre></p> <p>Tip 2: Use in assertion for debugging <pre><code># Ensure connection in tests\nassert sugar.is_connected(), \"Must be connected before test\"\n\n# Run test operations\nawait sugar.buy_market(volume=0.01)\n</code></pre></p> <p>Tip 3: Log connection state changes <pre><code>previous_state = sugar.is_connected()\n\nwhile True:\n    current_state = sugar.is_connected()\n\n    if current_state != previous_state:\n        if current_state:\n            print(\"Connection restored\")\n        else:\n            print(\"Connection lost\")\n\n        previous_state = current_state\n\n    await asyncio.sleep(5)\n</code></pre></p>"},{"location":"MT5Sugar/1.%20Connection/is_connected/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>ping - Test server responsiveness</li> <li>quick_connect - Connect to MT5 cluster</li> </ul>"},{"location":"MT5Sugar/1.%20Connection/ping/","title":"Ping MT5 Server (<code>ping</code>)","text":"<p>Sugar method: Tests server responsiveness with lightweight request.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.ping(timeout: float = 5.0)</code></li> <li>Returns: <code>True</code> if server responds, <code>False</code> otherwise</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/1.%20Connection/ping/#method-signature","title":"Method Signature","text":"<pre><code>async def ping(self, timeout: float = 5.0) -&gt; bool\n</code></pre>"},{"location":"MT5Sugar/1.%20Connection/ping/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>timeout</code> <code>float</code> No <code>5.0</code> Timeout in seconds for ping attempt"},{"location":"MT5Sugar/1.%20Connection/ping/#return-value","title":"Return Value","text":"Type Description <code>bool</code> <code>True</code> if server responds within timeout, <code>False</code> otherwise"},{"location":"MT5Sugar/1.%20Connection/ping/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Sends lightweight request to MT5 server</li> <li>Waits for response within timeout period</li> <li>Tests actual server health (not just channel state)</li> <li>Returns False on timeout or any error</li> </ul> <p>Key behaviors:</p> <ul> <li>Uses get_symbols_total() as ping request</li> <li>Default 5 second timeout</li> <li>Catches TimeoutError and all exceptions</li> <li>Does not modify any state</li> </ul>"},{"location":"MT5Sugar/1.%20Connection/ping/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.ping()\n    \u2193 wraps with asyncio.timeout\nMT5Service.get_symbols_total(selected_only=True)\n    \u2193 calls\nMT5Account.symbols_total()\n    \u2193 gRPC protobuf\nMarketInfoService.SymbolsTotal()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar wraps request with asyncio.timeout context</li> <li>Calls Service.get_symbols_total() with selected_only=True</li> <li>Service forwards to Account.symbols_total()</li> <li>Account sends gRPC request to terminal</li> <li>If response within timeout, returns True</li> <li>If timeout or exception, returns False</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:318</code></li> <li>Service: <code>src/pymt5/mt5_service.py:377</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:687</code></li> </ul>"},{"location":"MT5Sugar/1.%20Connection/ping/#when-to-use","title":"When to Use","text":"<p>Use <code>ping()</code> when:</p> <ul> <li>Testing actual server responsiveness</li> <li>Validating connection after timeout</li> <li>Health checks in monitoring systems</li> <li>Before critical operations</li> </ul> <p>Don't use when:</p> <ul> <li>Only need channel state (use <code>is_connected()</code>)</li> <li>Performing actual operations (no need to ping first)</li> <li>High-frequency checks (too much overhead)</li> </ul>"},{"location":"MT5Sugar/1.%20Connection/ping/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/1.%20Connection/ping/#example-1-basic-server-ping","title":"Example 1: Basic Server Ping","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def test_connection():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Ping server\n    responsive = await sugar.ping()\n\n    if responsive:\n        print(\"Server is responsive\")\n    else:\n        print(\"Server not responding\")\n\n# Output:\n# Server is responsive\n</code></pre>"},{"location":"MT5Sugar/1.%20Connection/ping/#example-2-ping-with-custom-timeout","title":"Example 2: Ping with Custom Timeout","text":"<pre><code>async def quick_ping():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Quick ping with 2 second timeout\n    responsive = await sugar.ping(timeout=2.0)\n\n    if responsive:\n        print(\"Server responded within 2 seconds\")\n    else:\n        print(\"Server slow or unresponsive\")\n</code></pre>"},{"location":"MT5Sugar/1.%20Connection/ping/#example-3-connection-health-monitor","title":"Example 3: Connection Health Monitor","text":"<pre><code>import asyncio\n\nasync def health_monitor():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    consecutive_failures = 0\n    max_failures = 3\n\n    while True:\n        # Check both channel and server\n        channel_ok = sugar.is_connected()\n        server_ok = await sugar.ping(timeout=3.0)\n\n        if channel_ok and server_ok:\n            print(\"Health: OK\")\n            consecutive_failures = 0\n        else:\n            consecutive_failures += 1\n            print(f\"Health: FAIL ({consecutive_failures}/{max_failures})\")\n\n            if consecutive_failures &gt;= max_failures:\n                print(\"Reconnecting...\")\n                await sugar.quick_connect(\"FxPro-MT5 Demo\")\n                consecutive_failures = 0\n\n        await asyncio.sleep(30)\n</code></pre>"},{"location":"MT5Sugar/1.%20Connection/ping/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Using for every operation <pre><code># BAD: Pinging before every operation\nfor _ in range(100):\n    if await sugar.ping():\n        await sugar.get_balance()\n    # Too much overhead!\n</code></pre></p> <p>Solution: Ping periodically, not before each operation <pre><code># Ping once at start\nif not await sugar.ping():\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n# Then perform operations without pinging\nfor _ in range(100):\n    balance = await sugar.get_balance()\n</code></pre></p> <p>Pitfall 2: Too short timeout <pre><code># ERROR: 0.1 second timeout too short\nresponsive = await sugar.ping(timeout=0.1)\n# May fail even with good connection\n</code></pre></p> <p>Solution: Use reasonable timeout (2-5 seconds) <pre><code># Give enough time for network round-trip\nresponsive = await sugar.ping(timeout=3.0)\n</code></pre></p> <p>Pitfall 3: Not handling False result <pre><code># No action when ping fails\nif not await sugar.ping():\n    pass  # What now?\n</code></pre></p> <p>Solution: Implement recovery logic <pre><code>if not await sugar.ping():\n    print(\"Ping failed - attempting reconnect\")\n    try:\n        await sugar.quick_connect(\"FxPro-MT5 Demo\")\n    except Exception as e:\n        print(f\"Reconnect failed: {e}\")\n</code></pre></p>"},{"location":"MT5Sugar/1.%20Connection/ping/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Combine with is_connected for full check</p> <pre><code># Complete connection check\nasync def is_fully_connected(sugar):\n    channel_ok = sugar.is_connected()  # Fast channel check\n    server_ok = await sugar.ping()     # Actual server test\n\n    return channel_ok and server_ok\n\n# Use before critical operations\nif await is_fully_connected(sugar):\n    await sugar.buy_market(volume=1.0)\n</code></pre> <p>Tip 2: Use progressive timeouts <pre><code># Try quick ping first, then longer\nasync def smart_ping(sugar):\n    # Quick attempt (1 second)\n    if await sugar.ping(timeout=1.0):\n        return True\n\n    # Slower attempt (5 seconds)\n    if await sugar.ping(timeout=5.0):\n        return True\n\n    return False\n</code></pre></p> <p>Tip 3: Log ping latency <pre><code>import time\n\nasync def ping_with_latency(sugar):\n    start = time.time()\n    responsive = await sugar.ping()\n    latency = (time.time() - start) * 1000  # ms\n\n    if responsive:\n        print(f\"Ping: {latency:.1f}ms\")\n    else:\n        print(\"Ping: timeout\")\n\n    return responsive\n</code></pre></p>"},{"location":"MT5Sugar/1.%20Connection/ping/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>is_connected - Check channel state</li> <li>quick_connect - Connect to MT5 cluster</li> </ul>"},{"location":"MT5Sugar/1.%20Connection/quick_connect/","title":"Quick Connect to MT5 Cluster (<code>quick_connect</code>)","text":"<p>Sugar method: Easiest way to connect to MT5 server by cluster name.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.quick_connect(cluster_name, base_symbol)</code></li> <li>Returns: None (raises exception on failure)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/1.%20Connection/quick_connect/#method-signature","title":"Method Signature","text":"<pre><code>async def quick_connect(\n    self,\n    cluster_name: str,\n    base_symbol: str = \"EURUSD\"\n) -&gt; None\n</code></pre>"},{"location":"MT5Sugar/1.%20Connection/quick_connect/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>cluster_name</code> <code>str</code> Yes - MT5 cluster identifier (e.g., \"FxPro-MT5 Demo\") <code>base_symbol</code> <code>str</code> No <code>\"EURUSD\"</code> Base chart symbol for connection"},{"location":"MT5Sugar/1.%20Connection/quick_connect/#return-value","title":"Return Value","text":"Type Description <code>None</code> Returns nothing on success, raises exception on failure <p>Raises:</p> <ul> <li><code>RuntimeError</code> if credentials not accessible in MT5Account</li> <li><code>Exception</code> if connection to cluster fails</li> </ul>"},{"location":"MT5Sugar/1.%20Connection/quick_connect/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Connects to MT5 server using cluster name</li> <li>Uses credentials from MT5Account</li> <li>Validates connection with terminal</li> <li>Waits up to 30 seconds for terminal ready</li> <li>Updates session GUID from server</li> </ul> <p>Key behaviors:</p> <ul> <li>Simplest connection method (just cluster name)</li> <li>Uses connect_by_server_name internally</li> <li>Blocks until terminal ready or timeout</li> <li>Perfect for reconnecting or switching accounts</li> </ul>"},{"location":"MT5Sugar/1.%20Connection/quick_connect/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.quick_connect()\n    \u2193 validates credentials\n    \u2193 calls\nMT5Account.connect_by_server_name()\n    \u2193 gRPC protobuf\nAccountHelperService.ConnectEx()\n    \u2193 MT5 Terminal\n    \u2193 waits for terminal ready (30s timeout)\n    \u2193 updates session GUID\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar accesses underlying MT5Account</li> <li>Validates user and password attributes exist</li> <li>Calls Account.connect_by_server_name() with cluster name</li> <li>Account sends ConnectEx gRPC request to terminal</li> <li>Terminal validates credentials and connects</li> <li>Waits for terminal_is_alive with 30 second timeout</li> <li>Updates session GUID from server response</li> <li>Returns on success or raises exception</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:340</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:436</code></li> </ul>"},{"location":"MT5Sugar/1.%20Connection/quick_connect/#when-to-use","title":"When to Use","text":"<p>Use <code>quick_connect()</code> when:</p> <ul> <li>First connection to MT5 server</li> <li>Reconnecting after disconnection</li> <li>Switching between demo/live clusters</li> <li>Simple connection without complex setup</li> </ul> <p>Don't use when:</p> <ul> <li>Need custom connection parameters</li> <li>Don't know cluster name</li> <li>Want non-blocking connection</li> </ul>"},{"location":"MT5Sugar/1.%20Connection/quick_connect/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/1.%20Connection/quick_connect/#example-1-basic-connection","title":"Example 1: Basic Connection","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def connect_simple():\n    # Create account with credentials\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    # Connect to FxPro demo cluster\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    print(\"Connected successfully\")\n\n    # Check connection\n    if sugar.is_connected():\n        balance = await sugar.get_balance()\n        print(f\"Balance: ${balance}\")\n</code></pre>"},{"location":"MT5Sugar/1.%20Connection/quick_connect/#example-2-connect-with-custom-symbol","title":"Example 2: Connect with Custom Symbol","text":"<pre><code>async def connect_custom_symbol():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    # Connect with GBPUSD as base symbol\n    await sugar.quick_connect(\n        cluster_name=\"ICMarkets-Demo\",\n        base_symbol=\"GBPUSD\"\n    )\n\n    print(\"Connected with GBPUSD chart\")\n</code></pre>"},{"location":"MT5Sugar/1.%20Connection/quick_connect/#example-3-auto-reconnect-on-failure","title":"Example 3: Auto-Reconnect on Failure","text":"<pre><code>import asyncio\n\nasync def connect_with_retry():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    max_retries = 3\n    cluster = \"FxPro-MT5 Demo\"\n\n    for attempt in range(1, max_retries + 1):\n        try:\n            print(f\"Connection attempt {attempt}/{max_retries}...\")\n\n            await sugar.quick_connect(cluster)\n\n            print(\"Connected successfully\")\n            break\n\n        except Exception as e:\n            print(f\"Attempt {attempt} failed: {e}\")\n\n            if attempt &lt; max_retries:\n                wait_time = attempt * 2  # 2, 4, 6 seconds\n                print(f\"Retrying in {wait_time} seconds...\")\n                await asyncio.sleep(wait_time)\n            else:\n                print(\"All connection attempts failed\")\n                raise\n\n    # Verify connection\n    if await sugar.ping():\n        print(\"Server is responsive\")\n</code></pre>"},{"location":"MT5Sugar/1.%20Connection/quick_connect/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Wrong cluster name <pre><code># ERROR: Cluster name doesn't exist or typo\ntry:\n    await sugar.quick_connect(\"FxPro-MT5-Demo\")  # Wrong hyphen\nexcept Exception as e:\n    print(e)  # Connection failed\n</code></pre></p> <p>Solution: Use exact cluster name from broker <pre><code># Get cluster name from your broker's documentation\nawait sugar.quick_connect(\"FxPro-MT5 Demo\")  # Correct\n</code></pre></p> <p>Pitfall 2: Credentials not set <pre><code># ERROR: MT5Account created without credentials\naccount = MT5Account(id_=uuid4())  # No user/password\nservice = MT5Service(account)\nsugar = MT5Sugar(service)\n\ntry:\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\nexcept RuntimeError as e:\n    print(e)  # \"Cannot connect: credentials not accessible\"\n</code></pre></p> <p>Solution: Always use create() with credentials <pre><code>account = MT5Account.create(\n    user=591129415,\n    password=\"your_password\",\n    grpc_server=\"mt5.mrpc.pro:443\"\n)\n</code></pre></p> <p>Pitfall 3: Not handling connection failure</p> <pre><code># No error handling\nawait sugar.quick_connect(\"FxPro-MT5 Demo\")\n# If fails, program crashes\n</code></pre> <p>Solution: Wrap in try-except <pre><code>try:\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n    print(\"Connected\")\nexcept Exception as e:\n    print(f\"Connection failed: {e}\")\n    # Handle gracefully\n</code></pre></p>"},{"location":"MT5Sugar/1.%20Connection/quick_connect/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Store cluster name in config <pre><code># config.py\nCLUSTER_NAME = \"FxPro-MT5 Demo\"\nBASE_SYMBOL = \"EURUSD\"\n\n# main.py\nfrom config import CLUSTER_NAME, BASE_SYMBOL\n\nawait sugar.quick_connect(CLUSTER_NAME, BASE_SYMBOL)\n</code></pre></p> <p>Tip 2: Verify connection after connect <pre><code>await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n# Verify both channel and server\nassert sugar.is_connected(), \"Channel not connected\"\nassert await sugar.ping(), \"Server not responding\"\n\nprint(\"Fully connected and verified\")\n</code></pre></p> <p>Tip 3: Switch between demo and live <pre><code># Connect to demo\nawait sugar.quick_connect(\"FxPro-MT5 Demo\")\nprint(\"Trading on DEMO\")\n\n# Later: switch to live (if using different account)\n# Note: Need to create new MT5Account with live credentials\n# quick_connect() uses existing credentials\n</code></pre></p> <p>Tip 4: Use context for automatic cleanup</p> <pre><code>async def trade_session():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    try:\n        await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n        # Do trading operations\n        balance = await sugar.get_balance()\n        print(f\"Balance: ${balance}\")\n\n    finally:\n        # Cleanup if needed\n        print(\"Session ended\")\n</code></pre>"},{"location":"MT5Sugar/1.%20Connection/quick_connect/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>is_connected - Check connection status</li> <li>ping - Test server responsiveness</li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_position_size/","title":"Calculate Position Size (<code>calculate_position_size</code>)","text":"<p>Sugar method: Calculates optimal position size based on account risk percentage and stop loss.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.calculate_position_size(symbol, risk_percent, sl_pips)</code></li> <li>Returns: Position size in lots (float)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_position_size/#method-signature","title":"Method Signature","text":"<pre><code>async def calculate_position_size(\n    self,\n    symbol: str,\n    risk_percent: float,\n    sl_pips: float\n) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_position_size/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>str</code> Yes - Trading symbol (e.g., \"EURUSD\") <code>risk_percent</code> <code>float</code> Yes - Risk as percentage of balance (e.g., 2.0 for 2%) <code>sl_pips</code> <code>float</code> Yes - Stop Loss distance in pips"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_position_size/#return-value","title":"Return Value","text":"Type Description <code>float</code> Optimal position size in lots, adjusted to symbol constraints"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_position_size/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Calculates position size based on fixed risk percentage</li> <li>Uses standard forex risk management formula</li> <li>Automatically adjusts to symbol volume constraints</li> <li>Returns volume ready to use in orders</li> </ul> <p>Key behaviors:</p> <ul> <li>Formula: <code>volume = (balance \u00d7 risk% / 100) / (sl_pips \u00d7 pip_value)</code></li> <li>Pip value calculated as: <code>point \u00d7 10 \u00d7 contract_size</code></li> <li>Rounds to symbol's volume_step</li> <li>Clamps to volume_min and volume_max</li> <li>Based on current account balance</li> </ul> <p>Risk management formula:</p> <ol> <li>Calculate risk amount in account currency</li> <li>Calculate pip value for 1 lot</li> <li>Calculate volume = risk_amount / (sl_pips \u00d7 pip_value)</li> <li>Round and clamp to symbol constraints</li> </ol>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_position_size/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.calculate_position_size()\n    \u2193 calls\nMT5Sugar.get_balance()\n    \u2193 calls\nMT5Sugar.get_symbol_info(symbol)\n    \u2193 calculates:\n        risk_amount = balance \u00d7 (risk_percent / 100)\n        pip_value = point \u00d7 10 \u00d7 contract_size\n        volume = risk_amount / (sl_pips \u00d7 pip_value)\n    \u2193 rounds to volume_step\n    \u2193 clamps to volume_min/volume_max\n    \u2193 returns adjusted volume\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls get_balance() to get current balance</li> <li>Sugar calls get_symbol_info() for symbol parameters</li> <li>Sugar calculates risk_amount from balance and risk_percent</li> <li>Sugar calculates pip_value using point and contract_size</li> <li>Sugar calculates raw volume using formula</li> <li>Sugar rounds volume to volume_step</li> <li>Sugar clamps to volume_min and volume_max</li> <li>Returns final volume</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1724</code></li> <li>Uses: get_balance (line 386), get_symbol_info (line 1615)</li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_position_size/#when-to-use","title":"When to Use","text":"<p>Use <code>calculate_position_size()</code> when:</p> <ul> <li>Implementing fixed percentage risk management</li> <li>Building automated trading systems</li> <li>Calculating safe position sizes</li> <li>Risk-based position sizing</li> <li>Following money management rules</li> </ul> <p>Don't use when:</p> <ul> <li>Using fixed lot sizes</li> <li>Manual position sizing</li> <li>Not using stop loss</li> <li>Need more complex risk calculations</li> <li>Position size is predetermined</li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_position_size/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/10.%20Risk_Management/calculate_position_size/#example-1-basic-2-risk-per-trade","title":"Example 1: Basic 2% Risk Per Trade","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def risk_based_trading():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n    risk_percent = 2.0  # Risk 2% per trade\n    sl_pips = 50  # 50 pip stop loss\n\n    # Calculate position size\n    volume = await sugar.calculate_position_size(\n        symbol,\n        risk_percent,\n        sl_pips\n    )\n\n    # Get account info\n    balance = await sugar.get_balance()\n\n    print(f\"Account balance: ${balance:.2f}\")\n    print(f\"Risk per trade: {risk_percent}% = ${balance * 0.02:.2f}\")\n    print(f\"Stop loss: {sl_pips} pips\")\n    print(f\"Position size: {volume} lots\")\n\n    # Place order with calculated size\n    current_ask = await sugar.get_ask(symbol)\n    sl_price = current_ask - (sl_pips * 0.0001)\n\n    ticket = await sugar.buy_market_with_sltp(\n        symbol,\n        volume=volume,\n        sl=sl_price\n    )\n    print(f\"Order placed: {ticket}\")\n\n# Output:\n# Account balance: $10000.00\n# Risk per trade: 2.0% = $200.00\n# Stop loss: 50 pips\n# Position size: 0.4 lots\n# Order placed: 123456789\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_position_size/#example-2-different-risk-levels","title":"Example 2: Different Risk Levels","text":"<pre><code>async def compare_risk_levels():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n    sl_pips = 30\n\n    # Try different risk levels\n    risk_levels = [0.5, 1.0, 2.0, 5.0]\n\n    print(f\"Position sizes for {symbol} with {sl_pips} pip SL:\")\n\n    for risk_pct in risk_levels:\n        volume = await sugar.calculate_position_size(\n            symbol,\n            risk_pct,\n            sl_pips\n        )\n\n        print(f\"  {risk_pct}% risk: {volume} lots\")\n\n# Output:\n# Position sizes for EURUSD with 30 pip SL:\n#   0.5% risk: 0.17 lots\n#   1.0% risk: 0.33 lots\n#   2.0% risk: 0.67 lots\n#   5.0% risk: 1.67 lots\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_position_size/#example-3-tight-vs-wide-stop-loss","title":"Example 3: Tight vs Wide Stop Loss","text":"<pre><code>async def compare_stop_losses():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n    risk_percent = 2.0\n\n    # Different stop loss sizes\n    stop_losses = [20, 50, 100, 200]\n\n    print(f\"Position sizes at {risk_percent}% risk:\")\n\n    for sl_pips in stop_losses:\n        volume = await sugar.calculate_position_size(\n            symbol,\n            risk_percent,\n            sl_pips\n        )\n\n        print(f\"  {sl_pips} pip SL: {volume} lots\")\n\n# Output:\n# Position sizes at 2.0% risk:\n#   20 pip SL: 1.0 lots\n#   50 pip SL: 0.4 lots\n#   100 pip SL: 0.2 lots\n#   200 pip SL: 0.1 lots\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_position_size/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Using points instead of pips <pre><code># ERROR: sl_pips expects pips, not points\nsl_points = 200  # 200 points = 20 pips for EURUSD\n\nvolume = await sugar.calculate_position_size(\"EURUSD\", 2.0, sl_points)\n# Calculates for 200 pips instead of 20 pips, volume will be 10x too small\n</code></pre></p> <p>Solution: Convert points to pips <pre><code>sl_points = 200\nsl_pips = sl_points / 10  # 20 pips\n\nvolume = await sugar.calculate_position_size(\"EURUSD\", 2.0, sl_pips)\n</code></pre></p> <p>Pitfall 2: Not checking minimum volume <pre><code># Very tight SL or low risk might give volume &lt; minimum\nvolume = await sugar.calculate_position_size(\"EURUSD\", 0.1, 5)\n# Returns volume_min (0.01) even if calculation gives 0.001\n</code></pre></p> <p>Solution: Check what you get <pre><code>volume = await sugar.calculate_position_size(\"EURUSD\", 0.1, 5)\n\ninfo = await sugar.get_symbol_info(\"EURUSD\")\nif volume == info.volume_min:\n    print(f\"Warning: Using minimum volume {volume}\")\n    print(\"Consider increasing risk% or widening stop loss\")\n</code></pre></p> <p>Pitfall 3: Balance changes during trading <pre><code># Calculated volume based on starting balance\nvolume = await sugar.calculate_position_size(\"EURUSD\", 2.0, 50)\n\n# After several trades, balance changed\n# But using old volume calculation\nawait sugar.buy_market(\"EURUSD\", volume=volume)  # May risk more/less than 2%\n</code></pre></p> <p>Solution: Recalculate before each trade <pre><code># Always calculate fresh before each trade\nvolume = await sugar.calculate_position_size(\"EURUSD\", 2.0, 50)\n\n# Immediately use it\nticket = await sugar.buy_market(\"EURUSD\", volume=volume)\n</code></pre></p>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_position_size/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Safe position sizer with validation <pre><code>async def safe_position_size(sugar, symbol, risk_pct, sl_pips):\n    \"\"\"Calculate position size with validation.\"\"\"\n    # Calculate\n    volume = await sugar.calculate_position_size(symbol, risk_pct, sl_pips)\n\n    # Get constraints\n    info = await sugar.get_symbol_info(symbol)\n\n    # Check if at minimum\n    if volume == info.volume_min:\n        print(f\"WARNING: At minimum volume {volume}\")\n        print(f\"Actual risk may be higher than {risk_pct}%\")\n\n    # Check if at maximum\n    if volume == info.volume_max:\n        print(f\"WARNING: At maximum volume {volume}\")\n        print(f\"Risk exceeds {risk_pct}% - reduce risk or widen SL\")\n\n    return volume\n\n# Usage\nvolume = await safe_position_size(sugar, \"EURUSD\", 2.0, 50)\n</code></pre></p> <p>Tip 2: Calculate actual dollar risk <pre><code>async def show_dollar_risk(sugar, symbol, risk_pct, sl_pips):\n    \"\"\"Calculate and display dollar risk.\"\"\"\n    balance = await sugar.get_balance()\n    volume = await sugar.calculate_position_size(symbol, risk_pct, sl_pips)\n\n    # Get symbol info\n    info = await sugar.get_symbol_info(symbol)\n\n    # Calculate pip value\n    pip_value = info.point * 10 * info.contract_size\n\n    # Calculate dollar risk\n    dollar_risk = sl_pips * pip_value * volume\n\n    print(f\"Balance: ${balance:.2f}\")\n    print(f\"Risk: {risk_pct}% = ${balance * (risk_pct/100):.2f}\")\n    print(f\"Volume: {volume} lots\")\n    print(f\"SL: {sl_pips} pips\")\n    print(f\"Actual risk: ${dollar_risk:.2f}\")\n\n# Usage\nawait show_dollar_risk(sugar, \"EURUSD\", 2.0, 50)\n</code></pre></p> <p>Tip 3: Multi-position risk allocation <pre><code>async def allocate_risk_to_positions(sugar, positions, total_risk_pct):\n    \"\"\"Allocate total risk across multiple positions.\"\"\"\n    # Divide risk equally\n    risk_per_position = total_risk_pct / len(positions)\n\n    sizes = {}\n    for pos in positions:\n        symbol = pos[\"symbol\"]\n        sl_pips = pos[\"sl_pips\"]\n\n        volume = await sugar.calculate_position_size(\n            symbol,\n            risk_per_position,\n            sl_pips\n        )\n\n        sizes[symbol] = volume\n\n    return sizes\n\n# Usage\npositions = [\n    {\"symbol\": \"EURUSD\", \"sl_pips\": 50},\n    {\"symbol\": \"GBPUSD\", \"sl_pips\": 60},\n    {\"symbol\": \"USDJPY\", \"sl_pips\": 40}\n]\n\nsizes = await allocate_risk_to_positions(sugar, positions, total_risk_pct=6.0)\n# Each position risks 2% (6% / 3 positions)\n\nfor symbol, volume in sizes.items():\n    print(f\"{symbol}: {volume} lots\")\n</code></pre></p>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_position_size/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>calculate_required_margin - Calculate margin for position</li> <li>can_open_position - Check if position can be opened</li> <li>get_balance - Get account balance</li> <li>get_symbol_info - Get symbol parameters</li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_required_margin/","title":"Calculate Required Margin (<code>calculate_required_margin</code>)","text":"<p>Sugar method: Calculates margin required to open a position with specified parameters.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.calculate_required_margin(symbol, volume, order_type)</code></li> <li>Returns: Required margin in account currency (float)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_required_margin/#method-signature","title":"Method Signature","text":"<pre><code>async def calculate_required_margin(\n    self,\n    symbol: str,\n    volume: float,\n    order_type: Optional[int] = None\n) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_required_margin/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>str</code> Yes - Trading symbol (e.g., \"EURUSD\") <code>volume</code> <code>float</code> Yes - Position volume in lots <code>order_type</code> <code>Optional[int]</code> No <code>None</code> Order type enum (defaults to BUY)"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_required_margin/#return-value","title":"Return Value","text":"Type Description <code>float</code> Required margin in account currency (e.g., USD)"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_required_margin/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Calculates margin needed to open position</li> <li>Uses MT5's built-in margin calculation</li> <li>Accounts for leverage and symbol specifications</li> <li>Returns amount in account currency</li> </ul> <p>Key behaviors:</p> <ul> <li>Defaults to BUY order if type not specified</li> <li>Uses current market price (ASK for BUY, BID for SELL)</li> <li>Calculation: <code>margin = (volume \u00d7 contract_size \u00d7 price) / leverage</code></li> <li>Bypasses Service layer, calls Account directly</li> <li>Returns actual margin requirement from MT5</li> </ul> <p>Formula:</p> <pre><code>margin = (volume \u00d7 contract_size \u00d7 price) / leverage\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_required_margin/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.calculate_required_margin()\n    \u2193 calls\nMT5Service.get_symbol_tick(symbol)\n    \u2193 creates OrderCalcMarginRequest\n    \u2193 calls\nMT5Account.order_calc_margin(request)\n    \u2193 gRPC protobuf\nTradingService.OrderCalcMargin()\n    \u2193 MT5 Terminal calculates margin\n    \u2193 returns result.margin\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.get_symbol_tick() for current price</li> <li>Sugar determines price based on order_type (ASK for BUY, BID for SELL)</li> <li>Sugar creates OrderCalcMarginRequest with symbol, type, volume, price</li> <li>Sugar gets Account instance from Service</li> <li>Sugar calls Account.order_calc_margin() directly</li> <li>Account sends gRPC margin calculation request</li> <li>Terminal calculates exact margin requirement</li> <li>Returns margin value as float</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1841</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1892</code></li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_required_margin/#when-to-use","title":"When to Use","text":"<p>Use <code>calculate_required_margin()</code> when:</p> <ul> <li>Checking if sufficient margin before trading</li> <li>Calculating maximum affordable position size</li> <li>Risk management calculations</li> <li>Pre-trade validation</li> <li>Margin level monitoring</li> </ul> <p>Don't use when:</p> <ul> <li>Don't need exact margin (use estimate)</li> <li>Already know approximate margin</li> <li>Not margin-constrained</li> <li>Performance is critical</li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_required_margin/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/10.%20Risk_Management/calculate_required_margin/#example-1-check-margin-before-trading","title":"Example 1: Check Margin Before Trading","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def check_margin():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n    volume = 1.0\n\n    # Calculate required margin\n    margin_needed = await sugar.calculate_required_margin(symbol, volume)\n\n    # Get available margin\n    free_margin = await sugar.get_free_margin()\n\n    print(f\"Required margin: ${margin_needed:.2f}\")\n    print(f\"Available margin: ${free_margin:.2f}\")\n\n    if margin_needed &lt;= free_margin:\n        print(\"Sufficient margin - opening position\")\n        ticket = await sugar.buy_market(symbol, volume=volume)\n        print(f\"Order opened: {ticket}\")\n    else:\n        print(\"Insufficient margin\")\n        shortage = margin_needed - free_margin\n        print(f\"Short by: ${shortage:.2f}\")\n\n# Output:\n# Required margin: $1084.32\n# Available margin: $5000.00\n# Sufficient margin - opening position\n# Order opened: 123456789\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_required_margin/#example-2-calculate-maximum-affordable-volume","title":"Example 2: Calculate Maximum Affordable Volume","text":"<pre><code>async def max_affordable_volume():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n\n    # Get available margin\n    free_margin = await sugar.get_free_margin()\n\n    print(f\"Available margin: ${free_margin:.2f}\")\n\n    # Binary search for maximum volume\n    min_vol = 0.01\n    max_vol = 100.0\n    best_volume = 0.01\n\n    while max_vol - min_vol &gt; 0.01:\n        test_vol = (min_vol + max_vol) / 2\n\n        margin_needed = await sugar.calculate_required_margin(symbol, test_vol)\n\n        if margin_needed &lt;= free_margin:\n            best_volume = test_vol\n            min_vol = test_vol\n        else:\n            max_vol = test_vol\n\n    # Round to symbol step\n    info = await sugar.get_symbol_info(symbol)\n    best_volume = round(best_volume / info.volume_step) * info.volume_step\n\n    margin_for_best = await sugar.calculate_required_margin(symbol, best_volume)\n\n    print(f\"Maximum affordable volume: {best_volume} lots\")\n    print(f\"Margin required: ${margin_for_best:.2f}\")\n\n# Output:\n# Available margin: $5000.00\n# Maximum affordable volume: 4.61 lots\n# Margin required: $4998.23\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_required_margin/#example-3-compare-margin-for-different-symbols","title":"Example 3: Compare Margin for Different Symbols","text":"<pre><code>async def compare_margin_requirements():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\", \"XAUUSD\"]\n    volume = 1.0\n\n    print(f\"Margin required for {volume} lot:\")\n\n    for symbol in symbols:\n        margin = await sugar.calculate_required_margin(symbol, volume)\n        print(f\"  {symbol}: ${margin:.2f}\")\n\n    # Get available margin\n    free_margin = await sugar.get_free_margin()\n    print(f\"\\nAvailable margin: ${free_margin:.2f}\")\n\n    # Find cheapest symbol\n    margins = {}\n    for symbol in symbols:\n        margins[symbol] = await sugar.calculate_required_margin(symbol, volume)\n\n    cheapest = min(margins, key=margins.get)\n    print(f\"\\nCheapest to trade: {cheapest} (${margins[cheapest]:.2f})\")\n\n# Output:\n# Margin required for 1.0 lot:\n#   EURUSD: $1084.32\n#   GBPUSD: $1267.89\n#   USDJPY: $1493.85\n#   XAUUSD: $20435.00\n#\n# Available margin: $5000.00\n#\n# Cheapest to trade: EURUSD ($1084.32)\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_required_margin/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Not accounting for existing positions <pre><code># ERROR: Free margin already accounts for open positions\nmargin_needed = await sugar.calculate_required_margin(\"EURUSD\", 1.0)\nfree_margin = await sugar.get_free_margin()\n\n# This is correct - free_margin is already reduced by open positions\nif margin_needed &lt;= free_margin:\n    # Safe to open\n</code></pre></p> <p>Pitfall 2: Using old margin calculation <pre><code># ERROR: Price changes, margin changes\nmargin = await sugar.calculate_required_margin(\"EURUSD\", 1.0)\n\nawait asyncio.sleep(60)\n\n# Margin calculation is now stale\nif margin &lt;= free_margin:  # Old margin value\n    await sugar.buy_market(\"EURUSD\", volume=1.0)\n</code></pre></p> <p>Solution: Calculate immediately before trading <pre><code># Calculate fresh margin right before trade\nmargin = await sugar.calculate_required_margin(\"EURUSD\", 1.0)\nfree_margin = await sugar.get_free_margin()\n\nif margin &lt;= free_margin:\n    # Immediately execute\n    await sugar.buy_market(\"EURUSD\", volume=1.0)\n</code></pre></p> <p>Pitfall 3: Ignoring order_type parameter <pre><code># For most cases, BUY/SELL margin is same\n# But some symbols might have directional margin differences\n\nmargin_buy = await sugar.calculate_required_margin(\"XAUUSD\", 1.0)\n# Defaults to BUY\n</code></pre></p> <p>Solution: Specify order type if needed <pre><code>from MetaRpcMT5 import mt5_term_api_trade_functions_pb2 as trade_pb2\n\n# For BUY\nmargin_buy = await sugar.calculate_required_margin(\n    \"XAUUSD\",\n    1.0,\n    order_type=trade_pb2.ORDER_TYPE_TF_BUY\n)\n\n# For SELL\nmargin_sell = await sugar.calculate_required_margin(\n    \"XAUUSD\",\n    1.0,\n    order_type=trade_pb2.ORDER_TYPE_TF_SELL\n)\n</code></pre></p>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_required_margin/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Margin checker helper <pre><code>async def check_sufficient_margin(sugar, symbol, volume):\n    \"\"\"Check if sufficient margin for position.\"\"\"\n    margin_needed = await sugar.calculate_required_margin(symbol, volume)\n    free_margin = await sugar.get_free_margin()\n\n    if margin_needed &gt; free_margin:\n        shortage = margin_needed - free_margin\n        raise ValueError(\n            f\"Insufficient margin: need ${margin_needed:.2f}, \"\n            f\"have ${free_margin:.2f}, short ${shortage:.2f}\"\n        )\n\n    return True\n\n# Usage\ntry:\n    await check_sufficient_margin(sugar, \"EURUSD\", 10.0)\n    ticket = await sugar.buy_market(\"EURUSD\", volume=10.0)\nexcept ValueError as e:\n    print(f\"Cannot open: {e}\")\n</code></pre></p> <p>Tip 2: Calculate margin level after trade <pre><code>async def simulate_trade_impact(sugar, symbol, volume):\n    \"\"\"Show how margin level would change after trade.\"\"\"\n    # Current state\n    equity = await sugar.get_equity()\n    margin = await sugar.get_margin()\n    free_margin = await sugar.get_free_margin()\n    margin_level = await sugar.get_margin_level()\n\n    # Calculate additional margin needed\n    additional_margin = await sugar.calculate_required_margin(symbol, volume)\n\n    # Simulated state after trade\n    new_margin = margin + additional_margin\n    new_free_margin = free_margin - additional_margin\n    new_margin_level = (equity / new_margin) * 100 if new_margin &gt; 0 else 0\n\n    print(\"Current state:\")\n    print(f\"  Margin: ${margin:.2f}\")\n    print(f\"  Free margin: ${free_margin:.2f}\")\n    print(f\"  Margin level: {margin_level:.2f}%\")\n\n    print(f\"\\nAfter opening {volume} lots of {symbol}:\")\n    print(f\"  Margin: ${new_margin:.2f} (+${additional_margin:.2f})\")\n    print(f\"  Free margin: ${new_free_margin:.2f}\")\n    print(f\"  Margin level: {new_margin_level:.2f}%\")\n\n    if new_margin_level &lt; 100:\n        print(\"\\nWARNING: Margin level would drop below 100%!\")\n\n# Usage\nawait simulate_trade_impact(sugar, \"EURUSD\", 5.0)\n</code></pre></p> <p>Tip 3: Find optimal volume for target margin level <pre><code>async def calculate_volume_for_margin_level(sugar, symbol, target_margin_level=200.0):\n    \"\"\"Calculate volume that maintains target margin level.\"\"\"\n    equity = await sugar.get_equity()\n    current_margin = await sugar.get_margin()\n\n    # Calculate maximum additional margin allowed\n    max_total_margin = equity / (target_margin_level / 100)\n    max_additional_margin = max_total_margin - current_margin\n\n    if max_additional_margin &lt;= 0:\n        print(f\"Already below target margin level\")\n        return 0.0\n\n    # Binary search for volume\n    min_vol = 0.01\n    max_vol = 100.0\n    best_volume = 0.01\n\n    while max_vol - min_vol &gt; 0.01:\n        test_vol = (min_vol + max_vol) / 2\n\n        margin_needed = await sugar.calculate_required_margin(symbol, test_vol)\n\n        if margin_needed &lt;= max_additional_margin:\n            best_volume = test_vol\n            min_vol = test_vol\n        else:\n            max_vol = test_vol\n\n    # Round to symbol step\n    info = await sugar.get_symbol_info(symbol)\n    best_volume = round(best_volume / info.volume_step) * info.volume_step\n\n    return best_volume\n\n# Usage\nvolume = await calculate_volume_for_margin_level(sugar, \"EURUSD\", target_margin_level=200.0)\nprint(f\"Safe volume to maintain 200% margin level: {volume} lots\")\n</code></pre></p>"},{"location":"MT5Sugar/10.%20Risk_Management/calculate_required_margin/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_free_margin - Get available margin</li> <li>get_margin_level - Get margin level percentage</li> <li>can_open_position - Validate if position can be opened</li> <li>calculate_position_size - Calculate position size by risk</li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/can_open_position/","title":"Can Open Position (<code>can_open_position</code>)","text":"<p>Sugar method: Validates if a position can be opened with specified parameters.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.can_open_position(symbol, volume)</code></li> <li>Returns: Tuple of (can_open: bool, reason: str)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/can_open_position/#method-signature","title":"Method Signature","text":"<pre><code>async def can_open_position(\n    self,\n    symbol: str,\n    volume: float\n) -&gt; Tuple[bool, str]\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/can_open_position/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>str</code> Yes - Trading symbol (e.g., \"EURUSD\") <code>volume</code> <code>float</code> Yes - Position volume in lots"},{"location":"MT5Sugar/10.%20Risk_Management/can_open_position/#return-value","title":"Return Value","text":"Type Description <code>Tuple[bool, str]</code> First element: True if can open, False otherwise. Second element: reason string (\"OK\" or error description)"},{"location":"MT5Sugar/10.%20Risk_Management/can_open_position/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Validates order before actual placement</li> <li>Checks margin requirements</li> <li>Checks symbol availability</li> <li>Checks volume constraints</li> <li>Returns validation result with reason</li> </ul> <p>Key behaviors:</p> <ul> <li>Simulates BUY order at current ASK price</li> <li>Does NOT actually place order</li> <li>Uses MT5's order_check function</li> <li>Returns tuple (success, message)</li> <li>Return code 0 = OK</li> <li>Non-zero code = validation failed</li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/can_open_position/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.can_open_position()\n    \u2193 calls\nMT5Service.get_symbol_tick(symbol)\n    \u2193 creates MrpcMqlTradeRequest (BUY at ASK)\n    \u2193 wraps in OrderCheckRequest\n    \u2193 calls\nMT5Service.check_order(request)\n    \u2193 calls\nMT5Account.order_check()\n    \u2193 gRPC protobuf\nTradingService.OrderCheck()\n    \u2193 MT5 Terminal validates order\n    \u2193 returns (returned_code, comment)\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.get_symbol_tick() for current price</li> <li>Sugar creates MrpcMqlTradeRequest with BUY order</li> <li>Sugar wraps request in OrderCheckRequest</li> <li>Sugar calls Service.check_order()</li> <li>Service forwards to Account.order_check()</li> <li>Account sends gRPC order check request</li> <li>Terminal validates order parameters</li> <li>Returns result with code and comment</li> <li>Sugar returns tuple (success: bool, reason: str)</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1774</code></li> <li>Service: <code>src/pymt5/mt5_service.py:1018</code></li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/can_open_position/#when-to-use","title":"When to Use","text":"<p>Use <code>can_open_position()</code> when: - Validating orders before placement - Checking margin availability - Pre-flight checks in trading systems - Error prevention - Building safe trading applications</p> <p>Don't use when: - Already confident order will succeed - Performance is critical (adds extra call) - Order validation is redundant - Testing with demo account</p>"},{"location":"MT5Sugar/10.%20Risk_Management/can_open_position/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/10.%20Risk_Management/can_open_position/#example-1-validate-before-opening","title":"Example 1: Validate Before Opening","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def safe_open():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n    volume = 1.0\n\n    # Check if can open\n    can_open, reason = await sugar.can_open_position(symbol, volume)\n\n    if can_open:\n        print(f\"Validation passed: {reason}\")\n\n        # Safe to open\n        ticket = await sugar.buy_market(symbol, volume=volume)\n        print(f\"Order opened: {ticket}\")\n    else:\n        print(f\"Cannot open position: {reason}\")\n\n# Output:\n# Validation passed: OK\n# Order opened: 123456789\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/can_open_position/#example-2-check-margin-before-trading","title":"Example 2: Check Margin Before Trading","text":"<pre><code>async def check_margin():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n\n    # Want to open large position\n    desired_volume = 10.0\n\n    # Check if possible\n    can_open, reason = await sugar.can_open_position(symbol, desired_volume)\n\n    if not can_open:\n        print(f\"Cannot open {desired_volume} lots: {reason}\")\n\n        # Try smaller size\n        for volume in [5.0, 2.0, 1.0, 0.5]:\n            can_open, reason = await sugar.can_open_position(symbol, volume)\n\n            if can_open:\n                print(f\"Can open {volume} lots\")\n                ticket = await sugar.buy_market(symbol, volume=volume)\n                print(f\"Opened: {ticket}\")\n                break\n    else:\n        print(f\"Can open full {desired_volume} lots\")\n\n# Output:\n# Cannot open 10.0 lots: Check failed: code=1\n# Can open 2.0 lots\n# Opened: 123456789\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/can_open_position/#example-3-validate-multiple-symbols","title":"Example 3: Validate Multiple Symbols","text":"<pre><code>async def validate_watchlist():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Check multiple symbols\n    symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\", \"XAUUSD\"]\n    volume = 0.1\n\n    print(\"Checking which symbols can be traded:\")\n\n    tradable = []\n    not_tradable = []\n\n    for symbol in symbols:\n        can_open, reason = await sugar.can_open_position(symbol, volume)\n\n        if can_open:\n            tradable.append(symbol)\n            print(f\"  {symbol}: OK\")\n        else:\n            not_tradable.append(symbol)\n            print(f\"  {symbol}: {reason}\")\n\n    print(f\"\\nTradable ({len(tradable)}): {tradable}\")\n    print(f\"Not tradable ({len(not_tradable)}): {not_tradable}\")\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/can_open_position/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Expecting detailed error messages <pre><code># ERROR: Reason string may not be very descriptive\ncan_open, reason = await sugar.can_open_position(\"EURUSD\", 100.0)\n\nif not can_open:\n    print(reason)  # May just be \"Check failed: code=1\"\n</code></pre></p> <p>Solution: Check specific conditions separately <pre><code># Check margin separately\nmargin_needed = await sugar.calculate_required_margin(\"EURUSD\", 100.0)\nfree_margin = await sugar.get_free_margin()\n\nif margin_needed &gt; free_margin:\n    print(f\"Insufficient margin: need ${margin_needed:.2f}, have ${free_margin:.2f}\")\n</code></pre></p> <p>Pitfall 2: Assuming validation guarantees success <pre><code># Validation passed but order still might fail\ncan_open, reason = await sugar.can_open_position(\"EURUSD\", 1.0)\n\nif can_open:\n    # Market conditions might change between check and execution\n    ticket = await sugar.buy_market(\"EURUSD\", volume=1.0)  # May still fail\n</code></pre></p> <p>Solution: Handle order errors <pre><code>can_open, reason = await sugar.can_open_position(\"EURUSD\", 1.0)\n\nif can_open:\n    try:\n        ticket = await sugar.buy_market(\"EURUSD\", volume=1.0)\n    except Exception as e:\n        print(f\"Order failed despite validation: {e}\")\n</code></pre></p> <p>Pitfall 3: Validating only BUY orders <pre><code># can_open_position only checks BUY orders\ncan_open, reason = await sugar.can_open_position(\"EURUSD\", 1.0)\n\n# But you might want to open SELL\nticket = await sugar.sell_market(\"EURUSD\", volume=1.0)\n</code></pre></p> <p>Solution: Validation is directional-agnostic for margin <pre><code># For margin purposes, BUY/SELL validation is similar\n# Volume and margin requirements are same\ncan_open, reason = await sugar.can_open_position(\"EURUSD\", 1.0)\n\nif can_open:\n    # Either direction should work\n    ticket = await sugar.sell_market(\"EURUSD\", volume=1.0)\n</code></pre></p>"},{"location":"MT5Sugar/10.%20Risk_Management/can_open_position/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Safe trading wrapper <pre><code>async def safe_buy_market(sugar, symbol, volume):\n    \"\"\"Open BUY position with validation.\"\"\"\n    # Validate first\n    can_open, reason = await sugar.can_open_position(symbol, volume)\n\n    if not can_open:\n        raise ValueError(f\"Cannot open position: {reason}\")\n\n    # Open position\n    ticket = await sugar.buy_market(symbol, volume=volume)\n\n    return ticket\n\n# Usage\ntry:\n    ticket = await safe_buy_market(sugar, \"EURUSD\", 1.0)\n    print(f\"Opened: {ticket}\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</code></pre></p> <p>Tip 2: Find maximum tradable volume <pre><code>async def find_max_volume(sugar, symbol, start_volume=10.0):\n    \"\"\"Find maximum volume that can be opened.\"\"\"\n    volume = start_volume\n\n    # Binary search for maximum\n    while volume &gt; 0.01:\n        can_open, reason = await sugar.can_open_position(symbol, volume)\n\n        if can_open:\n            return volume\n\n        # Try half\n        volume = volume / 2\n\n    return 0.01  # Minimum\n\n# Usage\nmax_vol = await find_max_volume(sugar, \"EURUSD\", start_volume=10.0)\nprint(f\"Maximum volume: {max_vol} lots\")\n</code></pre></p> <p>Tip 3: Pre-trade validation checklist <pre><code>async def validate_trade(sugar, symbol, volume):\n    \"\"\"Complete trade validation.\"\"\"\n    checks = {\n        \"symbol_exists\": False,\n        \"can_open\": False,\n        \"sufficient_margin\": False\n    }\n\n    # Check 1: Symbol exists\n    exists = await sugar.is_symbol_available(symbol)\n    checks[\"symbol_exists\"] = exists\n\n    if not exists:\n        return checks, \"Symbol not available\"\n\n    # Check 2: Can open position\n    can_open, reason = await sugar.can_open_position(symbol, volume)\n    checks[\"can_open\"] = can_open\n\n    if not can_open:\n        return checks, f\"Validation failed: {reason}\"\n\n    # Check 3: Margin check\n    margin_needed = await sugar.calculate_required_margin(symbol, volume)\n    free_margin = await sugar.get_free_margin()\n    checks[\"sufficient_margin\"] = margin_needed &lt;= free_margin\n\n    if margin_needed &gt; free_margin:\n        return checks, f\"Insufficient margin: ${margin_needed:.2f} needed, ${free_margin:.2f} available\"\n\n    return checks, \"All checks passed\"\n\n# Usage\nchecks, message = await validate_trade(sugar, \"EURUSD\", 1.0)\nprint(f\"Validation: {message}\")\nprint(f\"Checks: {checks}\")\n\nif all(checks.values()):\n    ticket = await sugar.buy_market(\"EURUSD\", volume=1.0)\n</code></pre></p>"},{"location":"MT5Sugar/10.%20Risk_Management/can_open_position/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>calculate_required_margin - Calculate margin needed</li> <li>get_free_margin - Check available margin</li> <li>buy_market - Open BUY position</li> <li>calculate_position_size - Calculate safe position size</li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/get_max_lot_size/","title":"Get Maximum Lot Size (<code>get_max_lot_size</code>)","text":"<p>Sugar method: Returns maximum allowed position size for trading symbol.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_max_lot_size(symbol)</code></li> <li>Returns: Maximum volume in lots (float)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/get_max_lot_size/#method-signature","title":"Method Signature","text":"<pre><code>async def get_max_lot_size(self, symbol: str) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/get_max_lot_size/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>str</code> Yes - Trading symbol (e.g., \"EURUSD\")"},{"location":"MT5Sugar/10.%20Risk_Management/get_max_lot_size/#return-value","title":"Return Value","text":"Type Description <code>float</code> Maximum volume in lots (e.g., 100.0 for most forex pairs)"},{"location":"MT5Sugar/10.%20Risk_Management/get_max_lot_size/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Retrieves broker's maximum allowed lot size</li> <li>Symbol-specific constraint</li> <li>Essential for volume validation</li> <li>Part of symbol trading parameters</li> </ul> <p>Key behaviors:</p> <ul> <li>Returns broker-defined maximum</li> <li>Typically 100.0 lots for forex majors</li> <li>Can vary by symbol type</li> <li>Exceeding this limit causes order rejection</li> <li>Same as SymbolInfo.volume_max</li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/get_max_lot_size/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_max_lot_size()\n    \u2193 calls\nMT5Service.get_symbol_double(symbol, SYMBOL_VOLUME_MAX)\n    \u2193 calls\nMT5Account.symbol_info_double()\n    \u2193 gRPC protobuf\nMarketInfoService.SymbolInfoDouble(property=SYMBOL_VOLUME_MAX)\n    \u2193 MT5 Terminal\n    \u2193 returns maximum volume\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.get_symbol_double() with SYMBOL_VOLUME_MAX property</li> <li>Service forwards to Account.symbol_info_double()</li> <li>Account sends gRPC request with property enum</li> <li>Terminal retrieves maximum volume for symbol</li> <li>Returns float value (maximum lots)</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1821</code></li> <li>Service: <code>src/pymt5/mt5_service.py:474</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:906</code></li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/get_max_lot_size/#when-to-use","title":"When to Use","text":"<p>Use <code>get_max_lot_size()</code> when:</p> <ul> <li>Validating large position sizes</li> <li>Building position size validators</li> <li>Checking trading limits</li> <li>Clamping calculated volumes</li> <li>Building risk management systems</li> </ul> <p>Don't use when:</p> <ul> <li>Already have SymbolInfo (use info.volume_max)</li> <li>Trading small positions (unlikely to hit limit)</li> <li>Maximum is hardcoded and known</li> <li>Not validating volumes</li> </ul>"},{"location":"MT5Sugar/10.%20Risk_Management/get_max_lot_size/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/10.%20Risk_Management/get_max_lot_size/#example-1-check-maximum-lot-size","title":"Example 1: Check Maximum Lot Size","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def check_max_lots():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbols = [\"EURUSD\", \"XAUUSD\", \"BTCUSD\"]\n\n    print(\"Maximum lot sizes:\")\n\n    for symbol in symbols:\n        max_lots = await sugar.get_max_lot_size(symbol)\n        print(f\"  {symbol}: {max_lots} lots\")\n\n# Output:\n# Maximum lot sizes:\n#   EURUSD: 100.0 lots\n#   XAUUSD: 50.0 lots\n#   BTCUSD: 10.0 lots\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/get_max_lot_size/#example-2-validate-volume-before-trading","title":"Example 2: Validate Volume Before Trading","text":"<pre><code>async def safe_trade():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n    desired_volume = 150.0  # Too large\n\n    # Get maximum\n    max_volume = await sugar.get_max_lot_size(symbol)\n\n    if desired_volume &gt; max_volume:\n        print(f\"ERROR: {desired_volume} lots exceeds maximum of {max_volume}\")\n        print(f\"Reducing to maximum: {max_volume}\")\n        desired_volume = max_volume\n\n    # Now safe to trade\n    ticket = await sugar.buy_market(symbol, volume=desired_volume)\n    print(f\"Order placed: {ticket} ({desired_volume} lots)\")\n\n# Output:\n# ERROR: 150.0 lots exceeds maximum of 100.0\n# Reducing to maximum: 100.0\n# Order placed: 123456789 (100.0 lots)\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/get_max_lot_size/#example-3-clamp-calculated-volume","title":"Example 3: Clamp Calculated Volume","text":"<pre><code>async def calculate_and_clamp():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n\n    # Calculate position size based on risk\n    calculated_volume = await sugar.calculate_position_size(\n        symbol,\n        risk_percent=10.0,  # High risk\n        sl_pips=10  # Tight SL\n    )\n\n    print(f\"Calculated volume: {calculated_volume} lots\")\n\n    # Get limits\n    info = await sugar.get_symbol_info(symbol)\n    max_volume = info.volume_max\n\n    # Clamp to range\n    final_volume = max(info.volume_min, min(calculated_volume, max_volume))\n\n    if final_volume != calculated_volume:\n        print(f\"Volume clamped to: {final_volume} lots\")\n\n    # Trade with safe volume\n    ticket = await sugar.buy_market(symbol, volume=final_volume)\n    print(f\"Order placed: {ticket}\")\n\n# Output:\n# Calculated volume: 200.0 lots\n# Volume clamped to: 100.0 lots\n# Order placed: 123456789\n</code></pre>"},{"location":"MT5Sugar/10.%20Risk_Management/get_max_lot_size/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Assuming same maximum for all symbols <pre><code># ERROR: Maximum varies by symbol\nmax_forex = 100.0  # Hardcoded for forex\n\n# Crypto might have different max\nticket = await sugar.buy_market(\"BTCUSD\", volume=max_forex)  # May fail\n</code></pre></p> <p>Solution: Always fetch dynamically <pre><code>max_volume = await sugar.get_max_lot_size(\"BTCUSD\")\nticket = await sugar.buy_market(\"BTCUSD\", volume=max_volume)\n</code></pre></p> <p>Pitfall 2: Not checking minimum as well <pre><code># Only checking maximum\ndesired = 0.005\n\nmax_vol = await sugar.get_max_lot_size(\"EURUSD\")\nvolume = min(desired, max_vol)  # 0.005\n\n# But minimum might be 0.01\nawait sugar.buy_market(\"EURUSD\", volume=volume)  # Fails\n</code></pre></p> <p>Solution: Check both min and max <pre><code>info = await sugar.get_symbol_info(\"EURUSD\")\n\nvolume = max(info.volume_min, min(desired, info.volume_max))\n</code></pre></p> <p>Pitfall 3: Exceeding by small rounding error <pre><code># Calculation might slightly exceed due to floating point\ncalculated = 100.00000001\n\nmax_vol = await sugar.get_max_lot_size(\"EURUSD\")  # 100.0\n\n# Strict comparison fails\nif calculated &gt; max_vol:\n    # Rounds down unnecessarily\n</code></pre></p> <p>Solution: Round to volume step first <pre><code>info = await sugar.get_symbol_info(\"EURUSD\")\n\n# Round to step\nvolume = round(calculated / info.volume_step) * info.volume_step\n\n# Then clamp\nvolume = min(volume, info.volume_max)\n</code></pre></p>"},{"location":"MT5Sugar/10.%20Risk_Management/get_max_lot_size/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Volume validator helper <pre><code>async def validate_volume(sugar, symbol, volume):\n    \"\"\"Validate and adjust volume to constraints.\"\"\"\n    info = await sugar.get_symbol_info(symbol)\n\n    # Round to step\n    volume = round(volume / info.volume_step) * info.volume_step\n\n    # Clamp to range\n    volume = max(info.volume_min, min(volume, info.volume_max))\n\n    return volume\n\n# Usage\ndesired = 150.0\nsafe_volume = await validate_volume(sugar, \"EURUSD\", desired)\nprint(f\"Adjusted from {desired} to {safe_volume}\")\n</code></pre></p> <p>Tip 2: Get all volume constraints <pre><code>async def get_volume_constraints(sugar, symbol):\n    \"\"\"Get all volume-related constraints.\"\"\"\n    info = await sugar.get_symbol_info(symbol)\n\n    return {\n        \"min\": info.volume_min,\n        \"max\": info.volume_max,\n        \"step\": info.volume_step,\n        \"range\": f\"{info.volume_min} - {info.volume_max}\",\n        \"step_count\": int((info.volume_max - info.volume_min) / info.volume_step) + 1\n    }\n\n# Usage\nconstraints = await get_volume_constraints(sugar, \"EURUSD\")\nprint(f\"Volume range: {constraints['range']}\")\nprint(f\"Step: {constraints['step']}\")\nprint(f\"Possible values: {constraints['step_count']}\")\n\n# Output:\n# Volume range: 0.01 - 100.0\n# Step: 0.01\n# Possible values: 9991\n</code></pre></p> <p>Tip 3: Safe volume calculator <pre><code>async def calculate_safe_volume(sugar, symbol, desired_volume):\n    \"\"\"Calculate volume ensuring all constraints.\"\"\"\n    info = await sugar.get_symbol_info(symbol)\n\n    # Round to step\n    volume = round(desired_volume / info.volume_step) * info.volume_step\n\n    # Clamp to range\n    if volume &lt; info.volume_min:\n        print(f\"Volume {desired_volume} below minimum {info.volume_min}, using minimum\")\n        volume = info.volume_min\n    elif volume &gt; info.volume_max:\n        print(f\"Volume {desired_volume} above maximum {info.volume_max}, using maximum\")\n        volume = info.volume_max\n\n    # Final validation\n    if volume != desired_volume:\n        print(f\"Adjusted volume: {desired_volume} \u2192 {volume}\")\n\n    return volume\n\n# Usage\nvolume = await calculate_safe_volume(sugar, \"EURUSD\", 150.0)\n# Output: Volume 150.0 above maximum 100.0, using maximum\n# Output: Adjusted volume: 150.0 \u2192 100.0\n</code></pre></p>"},{"location":"MT5Sugar/10.%20Risk_Management/get_max_lot_size/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_symbol_info - Get complete symbol info (includes volume_max)</li> <li>calculate_position_size - Calculate position size with risk</li> <li>can_open_position - Validate if position can be opened</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/","title":"Balance Property (<code>balance</code>)","text":"<p>Async Property: Alternative syntax for <code>get_balance()</code>.</p> <p>API Information:</p> <ul> <li>Property: <code>await sugar.balance</code></li> <li>Returns: Current balance as <code>float</code></li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#property-signature","title":"Property Signature","text":"<pre><code>@property\nasync def balance(self) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#i-input-output","title":"\u2139\ufe0f Input / Output","text":"Input Type Description None - No parameters required Output Type Description <code>balance</code> <code>float</code> Current account balance"},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<ul> <li>What it is: Python property syntax for getting balance.</li> <li>Why use it: Cleaner, more Pythonic syntax than <code>get_balance()</code>.</li> <li>Difference: <code>await sugar.balance</code> vs <code>await sugar.get_balance()</code> - both are identical.</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>await sugar.balance\n    \u2193 internally calls\nsugar.get_balance()\n    \u2193 calls\nMT5Service.get_account_summary()\n    \u2193 calls\nMT5Account.account_summary()\n    \u2193 gRPC protobuf\nMT5 Terminal\n</code></pre> <p>What happens:</p> <ol> <li>Property: Forwards to <code>get_balance()</code> method</li> <li>Same chain: Identical to calling <code>get_balance()</code> directly</li> </ol> <p>Related files: - Sugar: <code>src/pymt5/mt5_sugar.py:451</code></p>"},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#when-to-use","title":"When to Use","text":"<p>Cleaner syntax - When you prefer property style</p> <p>Quick access - Shorter code for balance checks</p> <p>Pythonic code - More natural Python syntax</p>"},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#1-property-vs-method-syntax","title":"1) Property vs method syntax","text":"<pre><code># Using property (cleaner)\nbalance = await sugar.balance\nprint(f\"Balance: ${balance:.2f}\")\n\n# Using method (traditional)\nbalance = await sugar.get_balance()\nprint(f\"Balance: ${balance:.2f}\")\n\n# Both are IDENTICAL\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#2-use-in-expressions","title":"2) Use in expressions","text":"<pre><code># Property syntax looks cleaner\nif await sugar.balance &lt; 1000:\n    print(\"Low balance\")\n\n# vs method syntax\nif await sugar.get_balance() &lt; 1000:\n    print(\"Low balance\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#3-multiple-properties-together","title":"3) Multiple properties together","text":"<pre><code># Very clean with properties\nbalance = await sugar.balance\nequity = await sugar.equity\nprofit = await sugar.profit\n\nprint(f\"Balance: ${balance:.2f}\")\nprint(f\"Equity:  ${equity:.2f}\")\nprint(f\"Profit:  ${profit:+.2f}\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#related-properties","title":"Related Properties","text":"<p>Other async properties:</p> <ul> <li><code>equity</code> - Current equity</li> <li><code>margin</code> - Used margin</li> <li><code>free_margin</code> - Free margin</li> <li><code>margin_level</code> - Margin level %</li> <li><code>profit</code> - Floating profit/loss</li> </ul> <p>Equivalent methods:</p> <ul> <li><code>get_balance()</code> - Same result, different syntax</li> <li><code>get_account_info()</code> - Get all account data at once</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#1-forgetting-await","title":"1) Forgetting await","text":"<pre><code># WRONG - missing await\nbalance = sugar.balance  # Returns coroutine!\n\n# CORRECT - always await properties\nbalance = await sugar.balance\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#2-trying-to-set-property","title":"2) Trying to set property","text":"<pre><code># WRONG - properties are read-only\nsugar.balance = 10000  # Not allowed!\n\n# Properties are for READING only\nbalance = await sugar.balance  # Correct\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#pro-tips","title":"Pro Tips","text":"<ol> <li> <p>Choose your style - Properties vs methods - both work identically</p> </li> <li> <p>Still async - Must await properties just like methods</p> </li> <li> <p>Read-only - Cannot set values via properties</p> </li> <li> <p>IDE support - Properties show up in auto-completion</p> </li> <li> <p>Use get_account_info() - More efficient for multiple values</p> </li> </ol>"},{"location":"MT5Sugar/2.%20Account_Properties/balance_property/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_balance - Method-style access to balance</li> <li>get_equity - Get equity (balance + floating P/L)</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/","title":"Get Account Info (<code>get_account_info</code>)","text":"<p>Sugar method: Returns complete account information as structured dataclass.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_account_info()</code></li> <li>Returns: <code>AccountInfo</code> dataclass with 10 fields</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#method-signature","title":"Method Signature","text":"<pre><code>async def get_account_info(self) -&gt; AccountInfo\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#i-input-output","title":"\u2139\ufe0f Input / Output","text":"Input Type Description None - No parameters required Output Type Description <code>AccountInfo</code> <code>dataclass</code> Complete account information <p>AccountInfo fields:</p> <ul> <li><code>login</code> (int) - Account number</li> <li><code>balance</code> (float) - Account balance</li> <li><code>equity</code> (float) - Current equity</li> <li><code>profit</code> (float) - Floating P/L</li> <li><code>margin</code> (float) - Used margin</li> <li><code>free_margin</code> (float) - Free margin</li> <li><code>margin_level</code> (float) - Margin level %</li> <li><code>leverage</code> (int) - Account leverage</li> <li><code>currency</code> (str) - Account currency</li> <li><code>company</code> (str) - Broker name</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<ul> <li>What it is: Single method to get ALL account data at once.</li> <li>Why you need it: More efficient than calling 10+ separate methods.</li> <li>Advantage: One API call instead of multiple requests.</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_account_info()\n    \u2193 calls\nMT5Service.get_account_summary()\n    \u2193 calls multiple\nMT5Account.account_summary() + account_info_double() \u00d7 4\n    \u2193 gRPC protobuf (5 calls internally)\nAccountHelperService + AccountInformationService\n    \u2193 MT5 Terminal\n</code></pre> <p>What happens:</p> <ol> <li>Sugar Layer: Calls service, wraps result in AccountInfo dataclass</li> <li>Service Layer: Makes 5 internal gRPC calls, returns AccountSummary</li> <li>Account Layer: Combines account_summary() + 4 account_info_double() calls</li> <li>Result: Complete account snapshot in one dataclass</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:2031</code></li> <li>Service: <code>src/pymt5/mt5_service.py:254</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:540</code></li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#when-to-use","title":"When to Use","text":"<p>Account dashboard - Display all account metrics</p> <p>Risk checks - Verify multiple parameters at once</p> <p>Logging - Record complete account state</p> <p>Decision making - Access all data for trading logic</p> <p>Efficiency - Replace multiple individual calls</p>"},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#1-get-all-account-data-at-once","title":"1) Get all account data at once","text":"<pre><code>info = await sugar.get_account_info()\n\nprint(f\"Account:      {info.login}\")\nprint(f\"Balance:      ${info.balance:.2f}\")\nprint(f\"Equity:       ${info.equity:.2f}\")\nprint(f\"Profit:       ${info.profit:+.2f}\")\nprint(f\"Free Margin:  ${info.free_margin:.2f}\")\nprint(f\"Margin Level: {info.margin_level:.2f}%\")\nprint(f\"Leverage:     1:{info.leverage}\")\nprint(f\"Currency:     {info.currency}\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#2-efficient-vs-inefficient-approach","title":"2) Efficient vs inefficient approach","text":"<pre><code># INEFFICIENT - 6 separate calls\nbalance = await sugar.get_balance()\nequity = await sugar.get_equity()\nmargin = await sugar.get_margin()\nfree_margin = await sugar.get_free_margin()\nmargin_level = await sugar.get_margin_level()\nprofit = await sugar.get_floating_profit()\n\n# EFFICIENT - 1 call gets everything\ninfo = await sugar.get_account_info()\n# Access: info.balance, info.equity, info.margin, etc.\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#3-complete-account-health-check","title":"3) Complete account health check","text":"<pre><code>info = await sugar.get_account_info()\n\nprint(\"=\" * 50)\nprint(\"ACCOUNT HEALTH REPORT\")\nprint(\"=\" * 50)\nprint(f\"Broker:        {info.company}\")\nprint(f\"Account:       {info.login}\")\nprint(f\"Currency:      {info.currency}\")\nprint(f\"Leverage:      1:{info.leverage}\")\nprint(\"-\" * 50)\nprint(f\"Balance:       ${info.balance:&gt;12,.2f}\")\nprint(f\"Equity:        ${info.equity:&gt;12,.2f}\")\nprint(f\"Profit/Loss:   ${info.profit:&gt;12,.2f}\")\nprint(\"-\" * 50)\nprint(f\"Used Margin:   ${info.margin:&gt;12,.2f}\")\nprint(f\"Free Margin:   ${info.free_margin:&gt;12,.2f}\")\nprint(f\"Margin Level:  {info.margin_level:&gt;11.2f}%\")\nprint(\"=\" * 50)\n\n# Health assessment\nif info.margin_level &lt; 100:\n    status = \"CRITICAL\"\nelif info.margin_level &lt; 200:\n    status = \"WARNING\"\nelif info.free_margin &lt; 100:\n    status = \"LOW MARGIN\"\nelse:\n    status = \"HEALTHY\"\n\nprint(f\"Status: {status}\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#related-methods","title":"Related Methods","text":"<p>Individual getters (less efficient):</p> <ul> <li><code>get_balance()</code> - Just balance</li> <li><code>get_equity()</code> - Just equity</li> <li><code>get_margin()</code> - Just margin</li> <li><code>get_free_margin()</code> - Just free margin</li> <li><code>get_margin_level()</code> - Just margin level</li> <li><code>get_floating_profit()</code> - Just floating P/L</li> </ul> <p>Best practice:</p> <pre><code># If you need 1-2 values:\nbalance = await sugar.get_balance()\nequity = await sugar.get_equity()\n\n# If you need 3+ values:\ninfo = await sugar.get_account_info()\n# Use info.balance, info.equity, info.margin, etc.\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#1-making-multiple-calls-when-one-is-enough","title":"1) Making multiple calls when one is enough","text":"<pre><code># WRONG - wasteful\nbalance = await sugar.get_balance()\nequity = await sugar.get_equity()\nmargin = await sugar.get_margin()\nfree_margin = await sugar.get_free_margin()\n# 4 separate gRPC roundtrips!\n\n# CORRECT - efficient\ninfo = await sugar.get_account_info()\n# 1 call, access all fields\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#2-not-using-dataclass-properly","title":"2) Not using dataclass properly","text":"<pre><code># WRONG - recreating what's already there\ninfo = await sugar.get_account_info()\nmy_balance = info.balance\nmy_equity = info.equity\n# Just use info directly!\n\n# CORRECT - use dataclass as-is\ninfo = await sugar.get_account_info()\nprint(f\"Balance: ${info.balance:.2f}\")\nprint(f\"Equity: ${info.equity:.2f}\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#pro-tips","title":"Pro Tips","text":"<ol> <li> <p>Use for dashboards - Perfect for displaying complete account state</p> </li> <li> <p>Cache for efficiency - If you need multiple fields, call once and reuse</p> </li> <li> <p>Dataclass benefits - Type hints, auto-completion in IDE</p> </li> <li> <p>Check margin health - Use <code>margin_level</code> and <code>free_margin</code> for risk monitoring</p> </li> <li> <p>Single call advantage - More efficient than multiple individual method calls</p> </li> </ol>"},{"location":"MT5Sugar/2.%20Account_Properties/get_account_info/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_balance - Get current account balance</li> <li>get_equity - Get equity (balance + floating P/L)</li> <li>get_margin - Get used margin</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/","title":"Get Account Balance (<code>get_balance</code>)","text":"<p>Sugar method: Returns current account balance in one line.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_balance()</code></li> <li>Returns: Current balance as <code>float</code></li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#method-signature","title":"Method Signature","text":"<pre><code>async def get_balance(self) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#i-input-output","title":"\u2139\ufe0f Input / Output","text":"Input Type Description None - No parameters required Output Type Description <code>balance</code> <code>float</code> Current account balance"},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<ul> <li>What it is: Gets your account balance - the money you have before considering open positions.</li> <li>Why you need it: Check available funds, calculate risk amounts, validate before trading.</li> <li>Sanity check: Balance &lt;= Equity (equity includes floating P/L).</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#under-the-hood","title":"\u26a1 Under the Hood","text":"<p>This method demonstrates the three-tier architecture in action:</p> <pre><code>MT5Sugar.get_balance()\n    \u2193 calls\nMT5Service.get_account_summary()\n    \u2193 calls\nMT5Account.account_summary()\n    \u2193 gRPC protobuf\nAccountHelperService.AccountSummary()\n    \u2193 MT5 Terminal\n</code></pre> <p>What happens:</p> <ol> <li>Sugar Layer: Simple async method with no parameters</li> <li>Service Layer: Calls <code>account_summary()</code> and extracts <code>balance</code> field from AccountSummary dataclass</li> <li>Account Layer: Makes gRPC call to MT5 terminal, returns protobuf Data object</li> <li>Result: Clean float value ready to use</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:386</code></li> <li>Service: <code>src/pymt5/mt5_service.py:254</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:540</code></li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#when-to-use","title":"When to Use","text":"<p>Before trading - Check if you have enough funds</p> <p>Risk calculation - Calculate position size based on balance</p> <p>Monitoring - Track account value</p> <p>Reporting - Generate account reports</p> <p>Validation - Ensure sufficient funds for trading</p>"},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#1-basic-usage","title":"1) Basic usage","text":"<pre><code>balance = await sugar.get_balance()\nprint(f\"Balance: ${balance:.2f}\")\n# Output: Balance: $10000.00\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#2-check-before-trading","title":"2) Check before trading","text":"<pre><code>balance = await sugar.get_balance()\n\nif balance &lt; 1000:\n    print(\"Insufficient balance for trading\")\n    return\n\nprint(\"Balance sufficient - proceeding with trade\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#3-calculate-risk-amount","title":"3) Calculate risk amount","text":"<pre><code>balance = await sugar.get_balance()\nrisk_percent = 2.0\n\nrisk_amount = balance * risk_percent / 100.0\n\nprint(f\"Balance:     ${balance:.2f}\")\nprint(f\"Risk (2%):   ${risk_amount:.2f}\")\n\n# Better: use calculate_position_size()\nlot_size = await sugar.calculate_position_size(\"EURUSD\", risk_percent, 50)\nprint(f\"Lot size:    {lot_size:.2f}\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#related-methods","title":"Related Methods","text":"<p>Other balance methods:</p> <ul> <li><code>get_equity()</code> - Balance + floating P/L</li> <li><code>get_margin()</code> - Used margin</li> <li><code>get_free_margin()</code> - Available margin for trading</li> <li><code>get_floating_profit()</code> - Current floating profit/loss</li> <li><code>get_account_info()</code> - Get all account data at once</li> </ul> <p>Recommended pattern:</p> <pre><code># Instead of calling get_balance, get_equity, etc separately:\naccount_info = await sugar.get_account_info()\n# Now you have: balance, equity, margin, free_margin, profit, etc.\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#1-confusing-balance-vs-equity","title":"1) Confusing Balance vs Equity","text":"<pre><code># WRONG - using Balance when you need Equity\nbalance = await sugar.get_balance()  # Doesn't include open positions!\n\n# CORRECT - use Equity for total account value\nequity = await sugar.get_equity()  # Includes floating P/L\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#2-not-using-await","title":"2) Not using await","text":"<pre><code># WRONG - forgetting await\nbalance = sugar.get_balance()  # Returns coroutine, not float!\n\n# CORRECT - always await async methods\nbalance = await sugar.get_balance()\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#pro-tips","title":"Pro Tips","text":"<ol> <li> <p>Use get_account_info() - More efficient than calling multiple methods</p> </li> <li> <p>Balance for risk calculation - Use balance (not equity) for position sizing</p> </li> <li> <p>Check before trading - Always verify sufficient balance</p> </li> <li> <p>Track changes - Monitor balance to measure performance</p> </li> <li> <p>Equity is reality - Balance is historical, Equity is current</p> </li> </ol>"},{"location":"MT5Sugar/2.%20Account_Properties/get_balance/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_equity - Get equity (balance + floating P/L)</li> <li>get_account_info - Get all account data at once</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/","title":"Get Account Equity (<code>get_equity</code>)","text":"<p>Sugar method: Returns current equity (balance + floating P/L) in one line.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_equity()</code></li> <li>Returns: Current equity as <code>float</code></li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#method-signature","title":"Method Signature","text":"<pre><code>async def get_equity(self) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#i-input-output","title":"\u2139\ufe0f Input / Output","text":"Input Type Description None - No parameters required Output Type Description <code>equity</code> <code>float</code> Current equity (balance + floating profit)"},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<ul> <li>What it is: Current account value including open positions' floating profit/loss.</li> <li>Why you need it: Real-time account worth, margin level calculations, risk management.</li> <li>Formula: Equity = Balance + Floating Profit - Floating Loss</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_equity()\n    \u2193 calls\nMT5Service.get_account_summary()\n    \u2193 calls\nMT5Account.account_summary()\n    \u2193 gRPC protobuf\nAccountHelperService.AccountSummary()\n    \u2193 MT5 Terminal\n</code></pre> <p>What happens:</p> <ol> <li>Sugar Layer: Simple async method extracts equity field</li> <li>Service Layer: Returns AccountSummary dataclass</li> <li>Account Layer: gRPC call to terminal</li> <li>Result: Balance + all open positions P/L</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:396</code></li> <li>Service: <code>src/pymt5/mt5_service.py:254</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:540</code></li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#when-to-use","title":"When to Use","text":"<p>Risk management - Calculate margin level and available funds</p> <p>Position monitoring - Track real-time account value</p> <p>Stop-out prevention - Monitor equity to avoid margin calls</p> <p>Performance tracking - See total account value including open trades</p> <p>Before trading - Verify sufficient equity for new positions</p>"},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#1-basic-usage","title":"1) Basic usage","text":"<pre><code>equity = await sugar.get_equity()\nprint(f\"Equity: ${equity:.2f}\")\n# Output: Equity: $10250.50\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#2-compare-balance-vs-equity","title":"2) Compare balance vs equity","text":"<pre><code>balance = await sugar.get_balance()\nequity = await sugar.get_equity()\nfloating_pl = equity - balance\n\nprint(f\"Balance:      ${balance:.2f}\")\nprint(f\"Equity:       ${equity:.2f}\")\nprint(f\"Floating P/L: ${floating_pl:+.2f}\")\n\n# Output:\n# Balance:      $10000.00\n# Equity:       $10250.50\n# Floating P/L: +$250.50\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#3-monitor-margin-level","title":"3) Monitor margin level","text":"<pre><code>equity = await sugar.get_equity()\nmargin = await sugar.get_margin()\n\nif margin &gt; 0:\n    margin_level = (equity / margin) * 100\n    print(f\"Equity:        ${equity:.2f}\")\n    print(f\"Margin:        ${margin:.2f}\")\n    print(f\"Margin Level:  {margin_level:.2f}%\")\n\n    if margin_level &lt; 100:\n        print(\"WARNING: Low margin level!\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#related-methods","title":"Related Methods","text":"<p>Account value methods:</p> <ul> <li><code>get_balance()</code> - Balance without open positions</li> <li><code>get_floating_profit()</code> - Only the P/L from open positions</li> <li><code>get_margin()</code> - Used margin</li> <li><code>get_margin_level()</code> - Margin level percentage</li> <li><code>get_account_info()</code> - All account data at once</li> </ul> <p>Key difference: <pre><code># Balance: What you started with + closed trades\nbalance = await sugar.get_balance()\n\n# Equity: Balance + floating P/L (reality check)\nequity = await sugar.get_equity()\n\n# The difference is your open positions P/L\nfloating = equity - balance\n</code></pre></p>"},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#1-using-balance-instead-of-equity-for-margin-checks","title":"1) Using balance instead of equity for margin checks","text":"<pre><code># WRONG - balance doesn't reflect open positions\nbalance = await sugar.get_balance()\nif balance &lt; 1000:\n    print(\"Low funds\")  # Might be wrong!\n\n# CORRECT - equity shows real account value\nequity = await sugar.get_equity()\nif equity &lt; 1000:\n    print(\"Low funds\")  # Accurate check\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#2-not-considering-floating-losses","title":"2) Not considering floating losses","text":"<pre><code># WRONG - only checking balance\nbalance = await sugar.get_balance()\nprint(f\"I have ${balance:.2f}\")  # Misleading if positions are losing\n\n# CORRECT - check equity for reality\nequity = await sugar.get_equity()\nprint(f\"Real value: ${equity:.2f}\")  # Shows true situation\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#pro-tips","title":"Pro Tips","text":"<ol> <li> <p>Equity is reality - Always use equity for current account worth</p> </li> <li> <p>Margin level formula - (Equity / Margin) * 100</p> </li> <li> <p>Stop-out watch - Brokers close positions when margin level drops below threshold (typically 20-50%)</p> </li> <li> <p>Use get_account_info() - Get equity, balance, margin all at once</p> </li> <li> <p>Track equity changes - Monitor equity over time to measure performance</p> </li> </ol>"},{"location":"MT5Sugar/2.%20Account_Properties/get_equity/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_balance - Get current account balance</li> <li>get_floating_profit - Get current floating profit/loss</li> <li>get_margin_level - Get margin level percentage</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/","title":"Get Floating Profit (<code>get_floating_profit</code>)","text":"<p>Sugar method: Returns total unrealized P/L from all open positions.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_floating_profit()</code></li> <li>Returns: Floating profit/loss as <code>float</code></li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#method-signature","title":"Method Signature","text":"<pre><code>async def get_floating_profit(self) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#i-input-output","title":"\u2139\ufe0f Input / Output","text":"Input Type Description None - No parameters required Output Type Description <code>profit</code> <code>float</code> Total floating profit (positive) or loss (negative)"},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<ul> <li>What it is: Sum of unrealized profit/loss from all open positions.</li> <li>Why you need it: Track real-time performance without closing positions.</li> <li>Formula: Floating P/L = Equity - Balance</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_floating_profit()\n    \u2193 calls\nMT5Service.get_account_double(ACCOUNT_PROFIT)\n    \u2193 calls\nMT5Account.account_info_double(property_id=ACCOUNT_PROFIT)\n    \u2193 gRPC protobuf\nAccountInformationService.AccountInfoDouble(property_id=13)\n    \u2193 MT5 Terminal\n</code></pre> <p>What happens:</p> <ol> <li>Sugar Layer: Calls service with ACCOUNT_PROFIT constant</li> <li>Service Layer: Requests profit property from account</li> <li>Account Layer: gRPC call to terminal</li> <li>Result: Sum of all open positions P/L, updates with every tick</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:439</code></li> <li>Service: <code>src/pymt5/mt5_service.py:298</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:578</code></li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#when-to-use","title":"When to Use","text":"<p>Performance tracking - Monitor profits without closing</p> <p>Risk management - Check if losses exceed limits</p> <p>Take profit decisions - Decide when to close profitable positions</p> <p>Stop loss monitoring - Track if losses are acceptable</p> <p>Dashboard display - Show real-time account P/L</p>"},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#1-basic-floating-pl-check","title":"1) Basic floating P/L check","text":"<pre><code>profit = await sugar.get_floating_profit()\n\nif profit &gt; 0:\n    print(f\"Profit: +${profit:.2f}\")\nelse:\n    print(f\"Loss: ${profit:.2f}\")\n\n# Output: Profit: +$125.50\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#2-track-performance-vs-balance","title":"2) Track performance vs balance","text":"<pre><code>balance = await sugar.get_balance()\nequity = await sugar.get_equity()\nfloating_pl = await sugar.get_floating_profit()\n\n# Verify: equity should equal balance + floating_pl\nassert abs(equity - (balance + floating_pl)) &lt; 0.01\n\nprint(f\"Starting Balance: ${balance:.2f}\")\nprint(f\"Floating P/L:     ${floating_pl:+.2f}\")\nprint(f\"Current Equity:   ${equity:.2f}\")\n\nprofit_percent = (floating_pl / balance) * 100\nprint(f\"Return:           {profit_percent:+.2f}%\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#3-risk-management-close-if-loss-limit-exceeded","title":"3) Risk management - close if loss limit exceeded","text":"<pre><code>balance = await sugar.get_balance()\nfloating_pl = await sugar.get_floating_profit()\n\nmax_loss_percent = 5.0\nmax_loss = balance * max_loss_percent / 100\n\nprint(f\"Balance:      ${balance:.2f}\")\nprint(f\"Floating P/L: ${floating_pl:+.2f}\")\nprint(f\"Max Loss:     -${max_loss:.2f}\")\n\nif floating_pl &lt; -max_loss:\n    print(\"Loss limit exceeded - closing all positions\")\n    await sugar.close_all_positions()\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#related-methods","title":"Related Methods","text":"<p>P/L tracking methods:</p> <ul> <li><code>get_balance()</code> - Starting capital + closed trades</li> <li><code>get_equity()</code> - Balance + floating P/L</li> <li><code>get_total_profit()</code> - Alias for get_floating_profit()</li> <li><code>get_profit_by_symbol()</code> - P/L for specific symbol</li> <li><code>get_profit()</code> - Historical profit for period</li> </ul> <p>P/L relationships: <pre><code>balance = await sugar.get_balance()\nfloating_pl = await sugar.get_floating_profit()\nequity = await sugar.get_equity()\n\n# These are equivalent:\nassert abs(equity - (balance + floating_pl)) &lt; 0.01\n</code></pre></p>"},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#1-confusing-floating-vs-realized-profit","title":"1) Confusing floating vs realized profit","text":"<pre><code># WRONG - floating profit is NOT realized\nfloating_pl = await sugar.get_floating_profit()\nprint(f\"I made ${floating_pl:.2f}\")  # Not yet!\n\n# CORRECT - only when positions are closed\nbalance_before = await sugar.get_balance()\n# ... close positions ...\nbalance_after = await sugar.get_balance()\nrealized_profit = balance_after - balance_before\nprint(f\"Realized profit: ${realized_profit:.2f}\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#2-not-handling-negative-values","title":"2) Not handling negative values","text":"<pre><code># WRONG - assuming profit is always positive\nprofit = await sugar.get_floating_profit()\nprint(f\"Profit: ${profit:.2f}\")  # Confusing if negative!\n\n# CORRECT - show sign explicitly\nprofit = await sugar.get_floating_profit()\nif profit &gt;= 0:\n    print(f\"Profit: +${profit:.2f}\")\nelse:\n    print(f\"Loss: ${profit:.2f}\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#pro-tips","title":"Pro Tips","text":"<ol> <li> <p>Updates in real-time - Floating P/L changes with every price tick</p> </li> <li> <p>Not realized until closed - Floating profit can disappear before closing</p> </li> <li> <p>Use for monitoring - Track but don't rely on it for decisions</p> </li> <li> <p>Equity formula - Equity = Balance + Floating P/L (always)</p> </li> <li> <p>Symbol-specific tracking - Use <code>get_profit_by_symbol()</code> for individual symbols</p> </li> </ol>"},{"location":"MT5Sugar/2.%20Account_Properties/get_floating_profit/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_equity - Get equity (balance + floating P/L)</li> <li>get_balance - Get current account balance</li> <li>get_profit_by_symbol - Get profit for specific symbol</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/","title":"Get Free Margin (<code>get_free_margin</code>)","text":"<p>Sugar method: Returns available margin for new positions in one line.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_free_margin()</code></li> <li>Returns: Free margin as <code>float</code></li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#method-signature","title":"Method Signature","text":"<pre><code>async def get_free_margin(self) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#i-input-output","title":"\u2139\ufe0f Input / Output","text":"Input Type Description None - No parameters required Output Type Description <code>free_margin</code> <code>float</code> Available margin for trading"},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<ul> <li>What it is: Equity minus used margin - the funds available for opening new positions.</li> <li>Why you need it: Verify you have enough margin before opening trades.</li> <li>Formula: Free Margin = Equity - Used Margin</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_free_margin()\n    \u2193 calls\nMT5Service.get_account_double(ACCOUNT_MARGIN_FREE)\n    \u2193 calls\nMT5Account.account_info_double(property_id=ACCOUNT_MARGIN_FREE)\n    \u2193 gRPC protobuf\nAccountInformationService.AccountInfoDouble(property_id=11)\n    \u2193 MT5 Terminal\n</code></pre> <p>What happens:</p> <ol> <li>Sugar Layer: Calls service with ACCOUNT_MARGIN_FREE constant</li> <li>Service Layer: Requests specific property from account</li> <li>Account Layer: gRPC call with property enum</li> <li>Result: Available margin calculated by MT5</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:417</code></li> <li>Service: <code>src/pymt5/mt5_service.py:298</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:578</code></li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#when-to-use","title":"When to Use","text":"<p>Before trading - Always check before opening new positions</p> <p>Position sizing - Calculate maximum safe volume</p> <p>Risk management - Ensure sufficient margin buffer</p> <p>Multiple orders - Verify margin for planned trades</p> <p>Prevent failures - Avoid \"not enough money\" errors</p>"},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#1-check-before-opening-position","title":"1) Check before opening position","text":"<pre><code>free_margin = await sugar.get_free_margin()\n\nif free_margin &lt; 100:\n    print(\"Insufficient margin to trade\")\n    return\n\n# Safe to proceed\nticket = await sugar.buy_market(\"EURUSD\", 0.1)\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#2-calculate-maximum-position-size","title":"2) Calculate maximum position size","text":"<pre><code>free_margin = await sugar.get_free_margin()\n# Assume 1 lot requires ~1000 margin\nmax_lots = free_margin / 1000\n\nprint(f\"Free Margin:  ${free_margin:.2f}\")\nprint(f\"Max Lots:     {max_lots:.2f}\")\n\n# Better: use calculate_position_size()\nlot_size = await sugar.calculate_position_size(\"EURUSD\", 2.0, 50)\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#3-monitor-margin-health","title":"3) Monitor margin health","text":"<pre><code>equity = await sugar.get_equity()\nmargin = await sugar.get_margin()\nfree_margin = await sugar.get_free_margin()\n\nmargin_level = (equity / margin * 100) if margin &gt; 0 else 0\n\nprint(f\"Equity:       ${equity:.2f}\")\nprint(f\"Used Margin:  ${margin:.2f}\")\nprint(f\"Free Margin:  ${free_margin:.2f}\")\nprint(f\"Margin Level: {margin_level:.0f}%\")\n\nif free_margin &lt; 500:\n    print(\"WARNING: Low free margin!\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#related-methods","title":"Related Methods","text":"<p>Margin-related methods:</p> <ul> <li><code>get_margin()</code> - Currently used margin</li> <li><code>get_equity()</code> - Total account value</li> <li><code>get_margin_level()</code> - Margin level percentage</li> <li><code>calculate_required_margin()</code> - Calculate margin for planned trade</li> <li><code>can_open_position()</code> - Validate if trade is possible</li> </ul> <p>Margin check pattern: <pre><code># Manual check\nfree_margin = await sugar.get_free_margin()\nrequired_margin = await sugar.calculate_required_margin(\"EURUSD\", 1.0)\n\nif free_margin &gt;= required_margin:\n    # Safe to trade\n    pass\n\n# Or use helper\ncan_trade = await sugar.can_open_position(\"EURUSD\", 1.0)\n</code></pre></p>"},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#1-not-checking-margin-before-trading","title":"1) Not checking margin before trading","text":"<pre><code># WRONG - trading without margin check\nticket = await sugar.buy_market(\"EURUSD\", 1.0)  # Might fail!\n\n# CORRECT - verify free margin first\nfree_margin = await sugar.get_free_margin()\nif free_margin &gt;= 1000:  # Rough estimate\n    ticket = await sugar.buy_market(\"EURUSD\", 1.0)\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#2-using-outdated-margin-value","title":"2) Using outdated margin value","text":"<pre><code># WRONG - checking once and reusing\nfree_margin = await sugar.get_free_margin()\n# ... later ...\nticket = await sugar.buy_market(\"EURUSD\", 0.1)  # Margin might have changed!\n\n# CORRECT - check before each trade\nfree_margin = await sugar.get_free_margin()\nif free_margin &gt;= 100:\n    ticket = await sugar.buy_market(\"EURUSD\", 0.1)\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#pro-tips","title":"Pro Tips","text":"<ol> <li> <p>Always check - Never trade without verifying free margin</p> </li> <li> <p>Use calculate_required_margin() - More accurate than rough estimates</p> </li> <li> <p>Keep buffer - Don't use 100% of free margin (keep 20-30% safety)</p> </li> <li> <p>Margin changes - Free margin updates with every price tick</p> </li> <li> <p>Use can_open_position() - Combines margin check with other validations</p> </li> </ol>"},{"location":"MT5Sugar/2.%20Account_Properties/get_free_margin/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_margin - Get used margin</li> <li>get_margin_level - Get margin level percentage</li> <li>calculate_required_margin - Calculate required margin for a trade</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/","title":"Get Used Margin (<code>get_margin</code>)","text":"<p>Sugar method: Returns currently used margin (locked funds) in one line.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_margin()</code></li> <li>Returns: Used margin as <code>float</code></li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#method-signature","title":"Method Signature","text":"<pre><code>async def get_margin(self) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#i-input-output","title":"\u2139\ufe0f Input / Output","text":"Input Type Description None - No parameters required Output Type Description <code>margin</code> <code>float</code> Currently used margin"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<ul> <li>What it is: Sum of margin locked by all your open positions.</li> <li>Why you need it: Check available margin before opening new trades, calculate margin level.</li> <li>Formula: Total margin required to maintain current open positions.</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_margin()\n    \u2193 calls\nMT5Service.get_account_double(ACCOUNT_MARGIN)\n    \u2193 calls\nMT5Account.account_info_double(property_id=ACCOUNT_MARGIN)\n    \u2193 gRPC protobuf\nAccountInformationService.AccountInfoDouble(property_id=10)\n    \u2193 MT5 Terminal\n</code></pre> <p>What happens:</p> <ol> <li>Sugar Layer: Calls service with ACCOUNT_MARGIN constant</li> <li>Service Layer: Calls account with property_id for margin</li> <li>Account Layer: gRPC call with specific property enum</li> <li>Result: Used margin as float</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:406</code></li> <li>Service: <code>src/pymt5/mt5_service.py:298</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:578</code></li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#when-to-use","title":"When to Use","text":"<p>Before trading - Check if you have free margin for new positions</p> <p>Risk management - Monitor margin usage vs account size</p> <p>Margin level calculation - Calculate (Equity / Margin) * 100</p> <p>Position sizing - Ensure you don't exceed margin limits</p> <p>Multiple positions - Track total margin commitment</p>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#1-basic-usage","title":"1) Basic usage","text":"<pre><code>margin = await sugar.get_margin()\nprint(f\"Used Margin: ${margin:.2f}\")\n# Output: Used Margin: $500.00\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#2-check-available-margin-before-trading","title":"2) Check available margin before trading","text":"<pre><code>equity = await sugar.get_equity()\nmargin = await sugar.get_margin()\nfree_margin = equity - margin\n\nprint(f\"Equity:        ${equity:.2f}\")\nprint(f\"Used Margin:   ${margin:.2f}\")\nprint(f\"Free Margin:   ${free_margin:.2f}\")\n\nif free_margin &lt; 100:\n    print(\"Not enough free margin to trade\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#3-calculate-margin-level","title":"3) Calculate margin level","text":"<pre><code>equity = await sugar.get_equity()\nmargin = await sugar.get_margin()\n\nif margin &gt; 0:\n    margin_level = (equity / margin) * 100\n    print(f\"Margin Level: {margin_level:.2f}%\")\n\n    if margin_level &lt; 200:\n        print(\"WARNING: Low margin level\")\n    elif margin_level &lt; 100:\n        print(\"DANGER: Stop-out risk!\")\nelse:\n    print(\"No open positions\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#related-methods","title":"Related Methods","text":"<p>Margin-related methods:</p> <ul> <li><code>get_free_margin()</code> - Available margin for trading</li> <li><code>get_margin_level()</code> - Margin level percentage</li> <li><code>get_equity()</code> - Current account value</li> <li><code>calculate_required_margin()</code> - Calculate margin for planned trade</li> <li><code>get_account_info()</code> - All account data including margin</li> </ul> <p>Margin calculation:</p> <pre><code># Manual calculation\nequity = await sugar.get_equity()\nmargin = await sugar.get_margin()\nfree_margin = equity - margin\nmargin_level = (equity / margin * 100) if margin &gt; 0 else 0\n\n# Or use dedicated methods\nfree_margin = await sugar.get_free_margin()\nmargin_level = await sugar.get_margin_level()\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#1-confusing-margin-with-balance","title":"1) Confusing margin with balance","text":"<pre><code># WRONG - margin is not balance\nmargin = await sugar.get_margin()\nprint(f\"I have ${margin:.2f}\")  # This is locked, not available!\n\n# CORRECT - use balance or equity\nbalance = await sugar.get_balance()\nprint(f\"Balance: ${balance:.2f}\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#2-not-checking-margin-before-trading","title":"2) Not checking margin before trading","text":"<pre><code># WRONG - opening trade without margin check\nticket = await sugar.buy_market(\"EURUSD\", 1.0)  # Might fail!\n\n# CORRECT - verify free margin first\nfree_margin = await sugar.get_free_margin()\nrequired_margin = await sugar.calculate_required_margin(\"EURUSD\", 1.0)\n\nif free_margin &gt;= required_margin:\n    ticket = await sugar.buy_market(\"EURUSD\", 1.0)\nelse:\n    print(\"Insufficient margin\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#pro-tips","title":"Pro Tips","text":"<ol> <li> <p>Zero margin = No positions - Margin is 0 when you have no open positions</p> </li> <li> <p>Margin increases with leverage - Lower leverage = more margin required</p> </li> <li> <p>Watch margin level - Keep margin level above 200% for safety</p> </li> <li> <p>Use get_free_margin() - Simpler than equity - margin calculation</p> </li> <li> <p>Calculate before trading - Use <code>calculate_required_margin()</code> to plan trades</p> </li> </ol>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_free_margin - Get available margin for trading</li> <li>get_margin_level - Get margin level percentage</li> <li>calculate_required_margin - Calculate required margin for a trade</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/","title":"Get Margin Level (<code>get_margin_level</code>)","text":"<p>Sugar method: Returns margin level percentage (Equity/Margin \u00d7 100) in one line.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_margin_level()</code></li> <li>Returns: Margin level as <code>float</code> (percentage)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#method-signature","title":"Method Signature","text":"<pre><code>async def get_margin_level(self) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#i-input-output","title":"\u2139\ufe0f Input / Output","text":"Input Type Description None - No parameters required Output Type Description <code>margin_level</code> <code>float</code> Margin level percentage"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<ul> <li>What it is: Ratio of equity to used margin expressed as percentage.</li> <li>Why you need it: Monitor account health and avoid margin calls.</li> <li>Formula: Margin Level = (Equity / Used Margin) \u00d7 100</li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_margin_level()\n    \u2193 calls\nMT5Service.get_account_double(ACCOUNT_MARGIN_LEVEL)\n    \u2193 calls\nMT5Account.account_info_double(property_id=ACCOUNT_MARGIN_LEVEL)\n    \u2193 gRPC protobuf\nAccountInformationService.AccountInfoDouble(property_id=12)\n    \u2193 MT5 Terminal\n</code></pre> <p>What happens:</p> <ol> <li>Sugar Layer: Calls service with ACCOUNT_MARGIN_LEVEL constant</li> <li>Service Layer: Requests margin level property</li> <li>Account Layer: gRPC call to terminal</li> <li>Result: Pre-calculated margin level from MT5</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:428</code></li> <li>Service: <code>src/pymt5/mt5_service.py:298</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:578</code></li> </ul>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#when-to-use","title":"When to Use","text":"<p>Risk monitoring - Check account safety continuously</p> <p>Stop-out prevention - Avoid forced position closure</p> <p>Position management - Decide when to close or reduce positions</p> <p>Trading limits - Set minimum margin level thresholds</p> <p>Automated systems - Trigger alerts or actions based on level</p>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#1-basic-margin-level-check","title":"1) Basic margin level check","text":"<pre><code>margin_level = await sugar.get_margin_level()\nprint(f\"Margin Level: {margin_level:.2f}%\")\n\nif margin_level &lt; 200:\n    print(\"WARNING: Low margin level\")\n# Output: Margin Level: 450.00%\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#2-risk-based-position-management","title":"2) Risk-based position management","text":"<pre><code>margin_level = await sugar.get_margin_level()\n\nif margin_level &lt; 100:\n    print(\"CRITICAL: Stop-out imminent!\")\n    # Close losing positions\n    await sugar.close_all_positions()\nelif margin_level &lt; 200:\n    print(\"WARNING: Reduce exposure\")\n    # Close 50% of positions\nelif margin_level &gt; 500:\n    print(\"Safe to trade\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#3-complete-margin-dashboard","title":"3) Complete margin dashboard","text":"<pre><code>equity = await sugar.get_equity()\nmargin = await sugar.get_margin()\nfree_margin = await sugar.get_free_margin()\nmargin_level = await sugar.get_margin_level()\n\nprint(\"=\" * 40)\nprint(\"MARGIN HEALTH DASHBOARD\")\nprint(\"=\" * 40)\nprint(f\"Equity:        ${equity:&gt;10,.2f}\")\nprint(f\"Used Margin:   ${margin:&gt;10,.2f}\")\nprint(f\"Free Margin:   ${free_margin:&gt;10,.2f}\")\nprint(f\"Margin Level:  {margin_level:&gt;9.2f}%\")\nprint(\"=\" * 40)\n\nif margin_level &lt; 100:\n    status = \"DANGER\"\nelif margin_level &lt; 200:\n    status = \"WARNING\"\nelse:\n    status = \"HEALTHY\"\n\nprint(f\"Status: {status}\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#related-methods","title":"Related Methods","text":"<p>Margin analysis methods:</p> <ul> <li><code>get_equity()</code> - Total account value</li> <li><code>get_margin()</code> - Used margin</li> <li><code>get_free_margin()</code> - Available margin</li> <li><code>get_balance()</code> - Account balance</li> <li><code>get_account_info()</code> - All account data at once</li> </ul> <p>Understanding margin levels: <pre><code># Manual calculation\nequity = await sugar.get_equity()\nmargin = await sugar.get_margin()\nmanual_level = (equity / margin * 100) if margin &gt; 0 else 0\n\n# Or get directly from MT5\nmargin_level = await sugar.get_margin_level()\n\n# Both should match\n</code></pre></p>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#1-not-understanding-margin-level-thresholds","title":"1) Not understanding margin level thresholds","text":"<pre><code># WRONG - not knowing broker limits\nmargin_level = await sugar.get_margin_level()\nif margin_level &lt; 50:\n    print(\"Need to close positions\")  # Too late!\n\n# CORRECT - act early\nif margin_level &lt; 200:\n    print(\"Reduce exposure now\")\nelif margin_level &lt; 100:\n    print(\"CRITICAL: Close positions immediately\")\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#2-ignoring-zero-margin-case","title":"2) Ignoring zero margin case","text":"<pre><code># WRONG - division by zero when no positions\nequity = await sugar.get_equity()\nmargin = await sugar.get_margin()\nlevel = equity / margin * 100  # Error if margin = 0!\n\n# CORRECT - use get_margin_level() or check first\nmargin_level = await sugar.get_margin_level()\n# Or manual with check:\nlevel = (equity / margin * 100) if margin &gt; 0 else 0\n</code></pre>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#pro-tips","title":"Pro Tips","text":"<ol> <li> <p>Broker thresholds - Typical stop-out levels: 20-50%, margin call: 80-100%</p> </li> <li> <p>Monitor continuously - In live trading, check every few minutes</p> </li> <li> <p>Set alerts - Trigger warnings at 200%, 150%, 100%</p> </li> <li> <p>Act early - Don't wait for margin call - reduce positions at 200%</p> </li> <li> <p>Zero = No positions - Margin level is 0 when you have no open positions</p> </li> </ol>"},{"location":"MT5Sugar/2.%20Account_Properties/get_margin_level/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_margin - Get used margin</li> <li>get_free_margin - Get available margin for trading</li> <li>get_equity - Get equity (balance + floating P/L)</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/","title":"Get ASK Price (<code>get_ask</code>)","text":"<p>Sugar method: Returns current ASK price for a symbol.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_ask(symbol)</code></li> <li>Returns: ASK price as <code>float</code></li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#method-signature","title":"Method Signature","text":"<pre><code>async def get_ask(self, symbol: Optional[str] = None) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#i-input-output","title":"\u2139\ufe0f Input / Output","text":"Input Type Description <code>symbol</code> <code>Optional[str]</code> Trading symbol (e.g., \"EURUSD\"). Uses default_symbol if None Output Type Description <code>ask</code> <code>float</code> Current ASK price"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<ul> <li>What it is: ASK price - the price at which you can BUY (open long / close short).</li> <li>Why you need it: Open long positions, close short positions, check execution price.</li> <li>Remember: ASK &gt; BID always (you pay the spread)</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_ask(symbol)\n    \u2193 calls\nMT5Service.get_symbol_tick(symbol)\n    \u2193 calls\nMT5Account.symbol_info_tick(symbol)\n    \u2193 gRPC protobuf\nMarketInfoService.SymbolInfoTick()\n    \u2193 MT5 Terminal\n</code></pre> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:502</code></li> <li>Service: <code>src/pymt5/mt5_service.py:680</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1095</code></li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#when-to-use","title":"When to Use","text":"<p>Open long positions - Buy at ASK price</p> <p>Close short positions - Exit price for shorts</p> <p>Calculate entry cost - ASK + spread</p> <p>Spread monitoring - ASK - BID</p> <p>Order validation - Verify favorable price</p>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#1-open-long-position-at-current-ask","title":"1) Open long position at current ASK","text":"<pre><code>ask = await sugar.get_ask(\"EURUSD\")\nprint(f\"Opening long at ASK: {ask:.5f}\")\n\nticket = await sugar.buy_market(\"EURUSD\", 0.1)\n# Position opens at ASK price\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#2-calculate-total-entry-cost-with-spread","title":"2) Calculate total entry cost with spread","text":"<pre><code>bid = await sugar.get_bid(\"EURUSD\")\nask = await sugar.get_ask(\"EURUSD\")\nspread = ask - bid\n\nprint(f\"BID:    {bid:.5f}\")\nprint(f\"ASK:    {ask:.5f}\")\nprint(f\"Spread: {spread:.5f}\")\nprint(f\"Cost:   ASK + spread = {ask:.5f}\")\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#3-wait-for-favorable-ask-price","title":"3) Wait for favorable ASK price","text":"<pre><code>max_ask = 1.09000\n\nwhile True:\n    ask = await sugar.get_ask(\"EURUSD\")\n    if ask &lt;= max_ask:\n        print(f\"Good price! ASK: {ask:.5f}\")\n        ticket = await sugar.buy_market(\"EURUSD\", 0.1)\n        break\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#related-methods","title":"Related Methods","text":"<p>Price methods:</p> <ul> <li><code>get_bid()</code> - BID price (sell price)</li> <li><code>get_spread()</code> - Spread in points</li> <li><code>get_price_info()</code> - Complete price data</li> <li><code>wait_for_price()</code> - Wait for price update</li> </ul> <p>Price relationships: <pre><code># ASK = price you BUY at\nask = await sugar.get_ask(\"EURUSD\")\n\n# BID = price you SELL at\nbid = await sugar.get_bid(\"EURUSD\")\n\n# Always true:\nassert ask &gt; bid\n</code></pre></p>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#1-using-ask-when-you-need-bid","title":"1) Using ASK when you need BID","text":"<pre><code># WRONG - using ASK to close long\nask = await sugar.get_ask(\"EURUSD\")\n# Long positions close at BID, not ASK!\n\n# CORRECT - close longs at BID\nbid = await sugar.get_bid(\"EURUSD\")\nticket = await sugar.close_position(position_ticket)\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#2-forgetting-spread-cost","title":"2) Forgetting spread cost","text":"<pre><code># WRONG - not accounting for spread\nask = await sugar.get_ask(\"EURUSD\")\n# To break even, price must move by spread amount!\n\n# CORRECT - factor in spread\nask = await sugar.get_ask(\"EURUSD\")\nbid = await sugar.get_bid(\"EURUSD\")\nspread_pips = (ask - bid) * 10000\nprint(f\"Need {spread_pips:.1f} pips just to break even\")\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#pro-tips","title":"Pro Tips","text":"<ol> <li> <p>ASK for opening longs - You buy at ASK price</p> </li> <li> <p>ASK for closing shorts - Short exit at ASK</p> </li> <li> <p>Always higher than BID - ASK = BID + spread</p> </li> <li> <p>Spread is your cost - Must overcome spread to profit</p> </li> <li> <p>Use get_price_info() - Get BID and ASK together</p> </li> </ol>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_ask/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_bid - Get BID price</li> <li>get_spread - Get bid-ask spread</li> <li>get_price_info - Get BID, ASK, and spread together</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/","title":"Get BID Price (<code>get_bid</code>)","text":"<p>Sugar method: Returns current BID price for a symbol.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_bid(symbol)</code></li> <li>Returns: BID price as <code>float</code></li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#method-signature","title":"Method Signature","text":"<pre><code>async def get_bid(self, symbol: Optional[str] = None) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#i-input-output","title":"\u2139\ufe0f Input / Output","text":"Input Type Description <code>symbol</code> <code>Optional[str]</code> Trading symbol (e.g., \"EURUSD\"). Uses default_symbol if None Output Type Description <code>bid</code> <code>float</code> Current BID price"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<ul> <li>What it is: BID price - the price at which you can SELL (close long / open short).</li> <li>Why you need it: Check current market price, calculate entry/exit points.</li> <li>Remember: BID &lt; ASK always (spread = ASK - BID)</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_bid(symbol)\n    \u2193 calls\nMT5Service.get_symbol_tick(symbol)\n    \u2193 calls\nMT5Account.symbol_info_tick(symbol)\n    \u2193 gRPC protobuf\nMarketInfoService.SymbolInfoTick()\n    \u2193 MT5 Terminal\n</code></pre> <p>What happens:</p> <ol> <li>Sugar Layer: Validates symbol, extracts bid field from tick</li> <li>Service Layer: Returns SymbolTick dataclass</li> <li>Account Layer: gRPC call to get last tick</li> <li>Result: Current BID price</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:488</code></li> <li>Service: <code>src/pymt5/mt5_service.py:680</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1095</code></li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#when-to-use","title":"When to Use","text":"<p>Close long positions - Sell at BID price</p> <p>Open short positions - Entry price for shorts</p> <p>Price monitoring - Track current market price</p> <p>Spread calculation - Compare BID vs ASK</p> <p>Order validation - Check if price is favorable</p>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#1-get-current-bid-price","title":"1) Get current BID price","text":"<pre><code>bid = await sugar.get_bid(\"EURUSD\")\nprint(f\"EURUSD BID: {bid:.5f}\")\n# Output: EURUSD BID: 1.08530\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#2-check-if-price-is-favorable-before-closing-long","title":"2) Check if price is favorable before closing long","text":"<pre><code># You have a long position at 1.08000\nentry_price = 1.08000\ntarget_profit = 50  # pips\n\nbid = await sugar.get_bid(\"EURUSD\")\nprofit_pips = (bid - entry_price) * 10000\n\nif profit_pips &gt;= target_profit:\n    print(f\"Target reached! Profit: {profit_pips:.1f} pips\")\n    ticket = await sugar.close_position(position_ticket)\nelse:\n    print(f\"Waiting... Current profit: {profit_pips:.1f} pips\")\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#3-calculate-spread","title":"3) Calculate spread","text":"<pre><code>bid = await sugar.get_bid(\"EURUSD\")\nask = await sugar.get_ask(\"EURUSD\")\nspread = (ask - bid) * 10000  # Convert to pips\n\nprint(f\"BID:    {bid:.5f}\")\nprint(f\"ASK:    {ask:.5f}\")\nprint(f\"Spread: {spread:.1f} pips\")\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#related-methods","title":"Related Methods","text":"<p>Price methods:</p> <ul> <li><code>get_ask()</code> - ASK price (buy price)</li> <li><code>get_spread()</code> - Spread in points</li> <li><code>get_price_info()</code> - Complete price data (BID, ASK, spread, time)</li> <li><code>wait_for_price()</code> - Wait for price update</li> </ul> <p>BID vs ASK:</p> <pre><code># BID = price you SELL at (close long, open short)\nbid = await sugar.get_bid(\"EURUSD\")\n\n# ASK = price you BUY at (open long, close short)\nask = await sugar.get_ask(\"EURUSD\")\n\n# Spread = broker's commission\nspread = ask - bid\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#1-using-bid-when-you-need-ask","title":"1) Using BID when you need ASK","text":"<pre><code># WRONG - using BID to open long position\nbid = await sugar.get_bid(\"EURUSD\")\n# Long positions open at ASK, not BID!\n\n# CORRECT - use ASK for opening longs\nask = await sugar.get_ask(\"EURUSD\")\nticket = await sugar.buy_market(\"EURUSD\", 0.1)\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#2-not-specifying-symbol","title":"2) Not specifying symbol","text":"<pre><code># WRONG - no default symbol set\nsugar = MT5Sugar(service)  # No default_symbol\nbid = await sugar.get_bid()  # ValueError!\n\n# CORRECT - specify symbol or set default\nsugar = MT5Sugar(service, default_symbol=\"EURUSD\")\nbid = await sugar.get_bid()  # Works\n# OR\nbid = await sugar.get_bid(\"EURUSD\")  # Always works\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#pro-tips","title":"Pro Tips","text":"<ol> <li> <p>BID for closing longs - You sell at BID price</p> </li> <li> <p>BID for opening shorts - Short entry at BID</p> </li> <li> <p>Always lower than ASK - BID + spread = ASK</p> </li> <li> <p>Use get_price_info() - Get BID, ASK, spread at once</p> </li> <li> <p>Updates in real-time - Price changes every tick</p> </li> </ol>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_bid/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_ask - Get ASK price</li> <li>get_spread - Get bid-ask spread</li> <li>get_price_info - Get BID, ASK, and spread together</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_price_info/","title":"Get Complete Price Information (<code>get_price_info</code>)","text":"<p>Sugar method: Returns complete price data (BID, ASK, spread, timestamp) in one call.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_price_info(symbol: Optional[str] = None)</code></li> <li>Returns: <code>PriceInfo</code> dataclass with bid, ask, spread, time, symbol</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_price_info/#method-signature","title":"Method Signature","text":"<pre><code>async def get_price_info(\n    self,\n    symbol: Optional[str] = None\n) -&gt; PriceInfo\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_price_info/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> Symbol name (uses default if not specified)"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_price_info/#return-value","title":"Return Value","text":"Field Type Description <code>symbol</code> <code>str</code> Symbol name <code>bid</code> <code>float</code> Current BID price (sell price) <code>ask</code> <code>float</code> Current ASK price (buy price) <code>spread</code> <code>float</code> Current spread (ask - bid) <code>time</code> <code>datetime</code> Price timestamp"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_price_info/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Fetches complete tick data from MT5 terminal</li> <li>Calculates spread automatically</li> <li>Returns structured PriceInfo dataclass</li> <li>Uses default symbol if not specified</li> </ul> <p>Key behaviors:</p> <ul> <li>Raises <code>ValueError</code> if no symbol specified and no default set</li> <li>Returns real-time market data</li> <li>Spread is calculated (not from terminal spread field)</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_price_info/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_price_info()\n    \u2193 calls\nMT5Service.get_symbol_tick()\n    \u2193 calls\nMT5Account.symbol_info_tick()\n    \u2193 gRPC protobuf\nMarketInfoService.SymbolInfoTick()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar validates symbol (uses default or raises error)</li> <li>Service retrieves tick via Account layer</li> <li>Account sends gRPC request to terminal</li> <li>Sugar wraps result in PriceInfo dataclass with calculated spread</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:530</code></li> <li>Service: <code>src/pymt5/mt5_service.py:1145</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1850</code></li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_price_info/#when-to-use","title":"When to Use","text":"<p>Use <code>get_price_info()</code> when:</p> <ul> <li>You need complete price snapshot with timestamp</li> <li>Building price monitoring systems</li> <li>Need to log price data with exact time</li> <li>Want structured data instead of separate calls</li> </ul> <p>Don't use when:</p> <ul> <li>You only need BID or ASK (use <code>get_bid()</code> or <code>get_ask()</code>)</li> <li>You only need spread (use <code>get_spread()</code>)</li> <li>Need streaming updates (use position profit streaming instead)</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_price_info/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/3.%20Prices_Quotes/get_price_info/#example-1-basic-price-information","title":"Example 1: Basic Price Information","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def check_current_price():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Get complete price info\n    price = await sugar.get_price_info()\n\n    print(f\"Symbol: {price.symbol}\")\n    print(f\"BID: {price.bid}\")\n    print(f\"ASK: {price.ask}\")\n    print(f\"Spread: {price.spread}\")\n    print(f\"Time: {price.time}\")\n\n    await sugar.disconnect()\n\n# Output:\n# Symbol: EURUSD\n# BID: 1.08432\n# ASK: 1.08445\n# Spread: 0.00013\n# Time: 2026-02-03 14:23:15\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_price_info/#example-2-price-for-specific-symbol","title":"Example 2: Price for Specific Symbol","text":"<pre><code>async def compare_symbols():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await sugar.connect()\n\n    # Get prices for multiple symbols\n    eurusd = await sugar.get_price_info(\"EURUSD\")\n    gbpusd = await sugar.get_price_info(\"GBPUSD\")\n\n    print(f\"EURUSD spread: {eurusd.spread:.5f}\")\n    print(f\"GBPUSD spread: {gbpusd.spread:.5f}\")\n\n    await sugar.disconnect()\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_price_info/#example-3-price-logging-system","title":"Example 3: Price Logging System","text":"<pre><code>import asyncio\nfrom datetime import datetime\n\nasync def log_prices():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Log prices every 5 seconds\n    for _ in range(10):\n        price = await sugar.get_price_info()\n\n        log_entry = (\n            f\"{price.time} | \"\n            f\"BID: {price.bid} | \"\n            f\"ASK: {price.ask} | \"\n            f\"Spread: {price.spread:.5f}\"\n        )\n        print(log_entry)\n\n        await asyncio.sleep(5)\n\n    await sugar.disconnect()\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_price_info/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: No default symbol set <pre><code># ERROR: No symbol specified\nsugar = MT5Sugar(user=123, password=\"pass\", grpc_server=\"server\")\nawait sugar.connect()\nprice = await sugar.get_price_info()  # Raises ValueError\n</code></pre></p> <p>Solution: Always specify symbol or set default <pre><code># Option 1: Set default\nsugar = MT5Sugar(..., default_symbol=\"EURUSD\")\nprice = await sugar.get_price_info()\n\n# Option 2: Pass explicitly\nprice = await sugar.get_price_info(\"EURUSD\")\n</code></pre></p> <p>Pitfall 2: Using stale price data <pre><code># Price is snapshot, not live-updating\nprice = await sugar.get_price_info()\nawait asyncio.sleep(60)\nprint(price.bid)  # Shows old price from 60 seconds ago\n</code></pre></p> <p>Solution: Always fetch fresh data before using <pre><code># Get new snapshot when needed\nprice = await sugar.get_price_info()\nprint(price.bid)  # Current price\n</code></pre></p>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_price_info/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Structured data for easy access</p> <pre><code>price = await sugar.get_price_info()\n\n# Clean access to all fields\nmid_price = (price.bid + price.ask) / 2\nspread_pct = (price.spread / price.bid) * 100\nage = datetime.now() - price.time\n</code></pre> <p>Tip 2: Use for price validation</p> <pre><code>price = await sugar.get_price_info()\n\n# Check if spread is too wide\nif price.spread &gt; 0.0005:  # 5 pips for EURUSD\n    print(f\"Warning: Wide spread detected ({price.spread})\")\n</code></pre> <p>Tip 3: Combine with symbol info</p> <pre><code># Get price and calculate in account currency\nprice = await sugar.get_price_info(\"EURUSD\")\nsymbol_info = await sugar._service.get_symbol_info(\"EURUSD\")\n\n# Use price with symbol digits for proper formatting\nformatted_bid = f\"{price.bid:.{symbol_info.digits}f}\"\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_price_info/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_bid - Get only BID price</li> <li>get_ask - Get only ASK price</li> <li>get_spread - Get only spread</li> <li>wait_for_price - Wait for price update with timeout</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/","title":"Get Spread (<code>get_spread</code>)","text":"<p>Sugar method: Returns current spread (ASK - BID) in price units.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_spread(symbol)</code></li> <li>Returns: Spread as <code>float</code> (in price units, not pips)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#method-signature","title":"Method Signature","text":"<pre><code>async def get_spread(self, symbol: Optional[str] = None) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#i-input-output","title":"\u2139\ufe0f Input / Output","text":"Input Type Description <code>symbol</code> <code>Optional[str]</code> Trading symbol (e.g., \"EURUSD\"). Uses default_symbol if None Output Type Description <code>spread</code> <code>float</code> Current spread (ASK - BID) in price units"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<ul> <li>What it is: Spread = ASK - BID, the broker's fee per trade.</li> <li>Why you need it: Assess trading costs, choose low-spread times.</li> <li>Formula: Spread (pips) = (ASK - BID) \u00d7 10000 (for EURUSD)</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_spread(symbol)\n    \u2193 calls\nMT5Service.get_symbol_tick(symbol)\n    \u2193 calls\nMT5Account.symbol_info_tick(symbol)\n    \u2193 gRPC protobuf\nMarketInfoService.SymbolInfoTick()\n    \u2193 MT5 Terminal\n</code></pre> <p>Calculation: Sugar layer calculates <code>tick.ask - tick.bid</code></p> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:516</code></li> <li>Service: <code>src/pymt5/mt5_service.py:680</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1095</code></li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#when-to-use","title":"When to Use","text":"<p>Cost analysis - Understand trading fees</p> <p>Timing trades - Choose low-spread periods</p> <p>Broker comparison - Compare execution costs</p> <p>Scalping - Critical for short-term strategies</p> <p>Risk calculation - Factor spread into P/L</p>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#usage-examples","title":"\ud83d\udd17 Usage Examples","text":""},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#1-check-current-spread","title":"1) Check current spread","text":"<pre><code>spread = await sugar.get_spread(\"EURUSD\")\nspread_pips = spread * 10000  # Convert to pips\n\nprint(f\"EURUSD Spread: {spread:.5f}\")\nprint(f\"Spread (pips): {spread_pips:.1f}\")\n# Output: Spread (pips): 1.2\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#2-wait-for-low-spread-before-trading","title":"2) Wait for low spread before trading","text":"<pre><code>max_spread_pips = 2.0\n\nspread = await sugar.get_spread(\"EURUSD\")\nspread_pips = spread * 10000\n\nif spread_pips &lt;= max_spread_pips:\n    print(f\"Good spread: {spread_pips:.1f} pips\")\n    ticket = await sugar.buy_market(\"EURUSD\", 0.1)\nelse:\n    print(f\"Spread too high: {spread_pips:.1f} pips - waiting\")\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#3-calculate-break-even-price","title":"3) Calculate break-even price","text":"<pre><code>ask = await sugar.get_ask(\"EURUSD\")\nspread = await sugar.get_spread(\"EURUSD\")\n\n# After buying at ASK, price must rise by spread to break even\nbreakeven = ask + spread\n\nprint(f\"Entry (ASK):  {ask:.5f}\")\nprint(f\"Spread:       {spread:.5f}\")\nprint(f\"Break-even:   {breakeven:.5f}\")\nprint(f\"Must move:    {spread * 10000:.1f} pips to profit\")\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#related-methods","title":"Related Methods","text":"<p>Price methods:</p> <ul> <li><code>get_bid()</code> - BID price</li> <li><code>get_ask()</code> - ASK price</li> <li><code>get_price_info()</code> - Complete price data including spread</li> <li><code>get_symbol_info()</code> - Symbol parameters including typical spread</li> </ul> <p>Manual calculation:</p> <pre><code># Method returns this automatically:\nbid = await sugar.get_bid(\"EURUSD\")\nask = await sugar.get_ask(\"EURUSD\")\nspread = ask - bid\n\n# Or use get_spread() directly:\nspread = await sugar.get_spread(\"EURUSD\")\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#1-confusing-price-units-with-pips","title":"1) Confusing price units with pips","text":"<pre><code># WRONG - spread is in price units, not pips\nspread = await sugar.get_spread(\"EURUSD\")\nprint(f\"Spread: {spread} pips\")  # Wrong! Shows 0.00012, not 1.2\n\n# CORRECT - convert to pips\nspread = await sugar.get_spread(\"EURUSD\")\nspread_pips = spread * 10000\nprint(f\"Spread: {spread_pips:.1f} pips\")\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#2-not-accounting-for-spread-in-profit-calculations","title":"2) Not accounting for spread in profit calculations","text":"<pre><code># WRONG - ignoring spread\nentry = await sugar.get_ask(\"EURUSD\")\ncurrent = await sugar.get_bid(\"EURUSD\")\nprofit_pips = (current - entry) * 10000  # Doesn't account for spread!\n\n# CORRECT - spread already factored in\n# When you buy at ASK and sell at BID, spread is automatic cost\nentry_ask = await sugar.get_ask(\"EURUSD\")\ncurrent_bid = await sugar.get_bid(\"EURUSD\")\nprofit_pips = (current_bid - entry_ask) * 10000  # Includes spread cost\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#pro-tips","title":"Pro Tips","text":"<ol> <li> <p>Varies by time - Spread increases during low liquidity (news, market open/close)</p> </li> <li> <p>Lower is better - Typical EURUSD spread: 0.5-2 pips</p> </li> <li> <p>Hidden cost - Spread is paid on every trade, both entry and exit</p> </li> <li> <p>Scalping killer - High spread makes short-term trading unprofitable</p> </li> <li> <p>Use get_price_info() - Get BID, ASK, and spread in one call</p> </li> </ol>"},{"location":"MT5Sugar/3.%20Prices_Quotes/get_spread/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_bid - Get BID price</li> <li>get_ask - Get ASK price</li> <li>get_price_info - Get BID, ASK, and spread together</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/wait_for_price/","title":"Wait for Price Update (<code>wait_for_price</code>)","text":"<p>Sugar method: Waits for valid price update with configurable timeout.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.wait_for_price(symbol: Optional[str] = None, timeout: float = 5.0)</code></li> <li>Returns: <code>PriceInfo</code> dataclass when price is received</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/wait_for_price/#method-signature","title":"Method Signature","text":"<pre><code>async def wait_for_price(\n    self,\n    symbol: Optional[str] = None,\n    timeout: float = 5.0\n) -&gt; PriceInfo\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/wait_for_price/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> Symbol name (uses default if not specified) <code>timeout</code> <code>float</code> No <code>5.0</code> Maximum wait time in seconds"},{"location":"MT5Sugar/3.%20Prices_Quotes/wait_for_price/#return-value","title":"Return Value","text":"Field Type Description <code>symbol</code> <code>str</code> Symbol name <code>bid</code> <code>float</code> Current BID price (sell price) <code>ask</code> <code>float</code> Current ASK price (buy price) <code>spread</code> <code>float</code> Current spread (ask - bid) <code>time</code> <code>datetime</code> Price timestamp"},{"location":"MT5Sugar/3.%20Prices_Quotes/wait_for_price/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Attempts to fetch price within timeout period</li> <li>Uses asyncio.timeout for time-limited operation</li> <li>Raises TimeoutError if no price received in time</li> <li>Returns PriceInfo on success</li> </ul> <p>Key behaviors:</p> <ul> <li>Raises <code>ValueError</code> if no symbol specified and no default set</li> <li>Raises <code>TimeoutError</code> if timeout expires before price received</li> <li>Default timeout is 5 seconds</li> <li>Internally calls <code>get_price_info()</code></li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/wait_for_price/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.wait_for_price()\n    \u2193 wraps with timeout\nMT5Sugar.get_price_info()\n    \u2193 calls\nMT5Service.get_symbol_tick()\n    \u2193 calls\nMT5Account.symbol_info_tick()\n    \u2193 gRPC protobuf\nMarketInfoService.SymbolInfoTick()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar wraps get_price_info() with asyncio.timeout context</li> <li>If price received within timeout, returns PriceInfo</li> <li>If timeout expires, raises TimeoutError with descriptive message</li> <li>Timeout mechanism prevents indefinite hanging</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:545</code></li> <li>Internal call to get_price_info: <code>src/pymt5/mt5_sugar.py:530</code></li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/wait_for_price/#when-to-use","title":"When to Use","text":"<p>Use <code>wait_for_price()</code> when:</p> <ul> <li>Starting up and need to ensure market connection</li> <li>Validating symbol has live quotes</li> <li>Need price with timeout guarantee</li> <li>Building robust startup sequences</li> </ul> <p>Don't use when:</p> <ul> <li>You know market is open (use <code>get_price_info()</code>)</li> <li>Need streaming updates (use position profit streaming)</li> <li>Timeout isn't important (use <code>get_price_info()</code>)</li> </ul>"},{"location":"MT5Sugar/3.%20Prices_Quotes/wait_for_price/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/3.%20Prices_Quotes/wait_for_price/#example-1-safe-connection-startup","title":"Example 1: Safe Connection Startup","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def connect_and_validate():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    try:\n        # Wait up to 10 seconds for valid price\n        price = await sugar.wait_for_price(timeout=10.0)\n        print(f\"Connection validated! BID: {price.bid}\")\n\n    except TimeoutError as e:\n        print(f\"Failed to get price: {e}\")\n        await sugar.disconnect()\n        return\n\n    # Continue with trading logic\n    await sugar.disconnect()\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/wait_for_price/#example-2-multiple-symbol-validation","title":"Example 2: Multiple Symbol Validation","text":"<pre><code>async def validate_symbols():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await sugar.connect()\n\n    symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\n\n    for symbol in symbols:\n        try:\n            price = await sugar.wait_for_price(symbol, timeout=3.0)\n            print(f\"{symbol}: OK (BID: {price.bid})\")\n\n        except TimeoutError:\n            print(f\"{symbol}: No quotes available\")\n\n    await sugar.disconnect()\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/wait_for_price/#example-3-retry-with-exponential-backoff","title":"Example 3: Retry with Exponential Backoff","text":"<pre><code>import asyncio\n\nasync def get_price_with_retry():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    max_attempts = 3\n    timeout = 5.0\n\n    for attempt in range(max_attempts):\n        try:\n            price = await sugar.wait_for_price(timeout=timeout)\n            print(f\"Success on attempt {attempt + 1}\")\n            print(f\"BID: {price.bid}, ASK: {price.ask}\")\n            break\n\n        except TimeoutError:\n            print(f\"Attempt {attempt + 1} failed, retrying...\")\n            timeout *= 2  # Exponential backoff\n\n            if attempt == max_attempts - 1:\n                print(\"All attempts failed\")\n\n    await sugar.disconnect()\n</code></pre>"},{"location":"MT5Sugar/3.%20Prices_Quotes/wait_for_price/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Too short timeout <pre><code># ERROR: Timeout too short for slow connections\ntry:\n    price = await sugar.wait_for_price(timeout=0.1)\nexcept TimeoutError:\n    # Fails even with valid connection\n    pass\n</code></pre></p> <p>Solution: Use reasonable timeout (5-10 seconds) <pre><code># Give enough time for network and terminal\nprice = await sugar.wait_for_price(timeout=10.0)\n</code></pre></p> <p>Pitfall 2: Using during market close <pre><code># Market closed, will always timeout\ntry:\n    price = await sugar.wait_for_price(\"EURUSD\", timeout=5.0)\nexcept TimeoutError:\n    # Expected during weekends/holidays\n    pass\n</code></pre></p> <p>Solution: Check market hours first or handle timeout gracefully <pre><code>try:\n    price = await sugar.wait_for_price(timeout=5.0)\nexcept TimeoutError:\n    print(\"Market may be closed or symbol unavailable\")\n</code></pre></p> <p>Pitfall 3: Not handling TimeoutError <pre><code># ERROR: Unhandled exception crashes program\nprice = await sugar.wait_for_price(timeout=3.0)  # May raise!\n</code></pre></p> <p>Solution: Always wrap in try-except <pre><code>try:\n    price = await sugar.wait_for_price(timeout=3.0)\nexcept TimeoutError as e:\n    # Handle timeout gracefully\n    logger.error(f\"Price timeout: {e}\")\n</code></pre></p>"},{"location":"MT5Sugar/3.%20Prices_Quotes/wait_for_price/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Validate connection after connect <pre><code>await sugar.connect()\n\n# Ensure connection is fully operational\ntry:\n    await sugar.wait_for_price(timeout=10.0)\n    print(\"Connection ready\")\nexcept TimeoutError:\n    print(\"Connection established but no market data\")\n</code></pre></p> <p>Tip 2: Use for market hours detection <pre><code># Quick market availability check\ntry:\n    await sugar.wait_for_price(timeout=2.0)\n    market_open = True\nexcept TimeoutError:\n    market_open = False\n\nprint(f\"Market {'open' if market_open else 'closed'}\")\n</code></pre></p> <p>Tip 3: Combine with symbol selection <pre><code># Ensure symbol is selected and has quotes\nsymbol = \"EURUSD\"\nawait sugar._service.symbol_select(symbol, True)\n\n# Wait for price to confirm selection worked\ntry:\n    price = await sugar.wait_for_price(symbol, timeout=5.0)\n    print(f\"{symbol} selected and receiving quotes\")\nexcept TimeoutError:\n    print(f\"{symbol} selection failed or no quotes\")\n</code></pre></p>"},{"location":"MT5Sugar/3.%20Prices_Quotes/wait_for_price/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_price_info - Get price without timeout</li> <li>get_bid - Get only BID price</li> <li>get_ask - Get only ASK price</li> <li>get_spread - Get only spread</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_limit/","title":"Place BUY LIMIT Order (<code>buy_limit</code>)","text":"<p>Sugar method: Places BUY LIMIT pending order to buy below current price.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.buy_limit(symbol, volume, price, comment, magic)</code></li> <li>Returns: Order ticket number (<code>int</code>)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_limit/#method-signature","title":"Method Signature","text":"<pre><code>async def buy_limit(\n    self,\n    symbol: Optional[str] = None,\n    volume: float = 0.01,\n    price: float = 0.0,\n    comment: str = \"\",\n    magic: int = 0\n) -&gt; int\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_limit/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> Trading symbol (uses default if not specified) <code>volume</code> <code>float</code> No <code>0.01</code> Order volume in lots <code>price</code> <code>float</code> Yes <code>0.0</code> Limit price (must be BELOW current ASK) <code>comment</code> <code>str</code> No <code>\"\"</code> Order comment (visible in terminal) <code>magic</code> <code>int</code> No <code>0</code> Magic number for order identification"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_limit/#return-value","title":"Return Value","text":"Type Description <code>int</code> Order ticket number (unique identifier) <p>Raises:</p> <ul> <li><code>ValueError</code> if symbol not specified and no default set</li> <li><code>RuntimeError</code> if order placement fails (returned_code != 10009)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_limit/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Creates pending BUY LIMIT order</li> <li>Order triggers when ASK price falls to specified level</li> <li>Automatically converts to BUY position when triggered</li> <li>Order remains pending until triggered or cancelled</li> </ul> <p>Key behaviors:</p> <ul> <li>BUY LIMIT price must be BELOW current ASK</li> <li>Order executes only at specified price or better</li> <li>Used to buy at lower price (buy the dip)</li> <li>Does not use slippage (limit order fills at exact price)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_limit/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.buy_limit()\n    \u2193 builds OrderSendRequest\nMT5Service.place_order()\n    \u2193 calls\nMT5Account.order_send()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderSend()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar builds OrderSendRequest with TMT5_ORDER_TYPE_BUY_LIMIT</li> <li>Sugar calls Service.place_order() with request</li> <li>Service forwards to Account.order_send()</li> <li>Account sends gRPC request to terminal</li> <li>Sugar validates returned_code == 10009 (TRADE_RETCODE_DONE)</li> <li>Returns order ticket from result.order</li> <li>Order stays pending in terminal until price reached</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:658</code></li> <li>Service: <code>src/pymt5/mt5_service.py:929</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1713</code></li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_limit/#when-to-use","title":"When to Use","text":"<p>Use <code>buy_limit()</code> when:</p> <ul> <li>Want to buy at lower price (wait for pullback)</li> <li>Planning entry before price reaches level</li> <li>Avoid paying spread on immediate execution</li> <li>Implementing buy the dip strategy</li> </ul> <p>Don't use when:</p> <ul> <li>Need immediate position (use <code>buy_market()</code>)</li> <li>Want to buy above current price (use <code>buy_stop()</code>)</li> <li>Price may never reach limit level (consider market order)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_limit/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/4.%20Simple_Trading/buy_limit/#example-1-basic-buy-limit-order","title":"Example 1: Basic Buy Limit Order","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def buy_the_dip():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Current ASK: 1.0850\n    # Place BUY LIMIT at 1.0840 (below current price)\n    ticket = await sugar.buy_limit(\n        price=1.0840,\n        volume=0.1,\n        comment=\"Buy dip at 1.0840\"\n    )\n\n    print(f\"BUY LIMIT order placed: #{ticket}\")\n\n# Output:\n# BUY LIMIT order placed: #123456791\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_limit/#example-2-multiple-limit-orders-grid-trading","title":"Example 2: Multiple Limit Orders (Grid Trading)","text":"<pre><code>async def buy_grid():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Current price: 1.0850\n    # Place BUY LIMIT orders at multiple levels\n    levels = [1.0840, 1.0830, 1.0820, 1.0810]\n\n    tickets = []\n    for price in levels:\n        ticket = await sugar.buy_limit(\n            price=price,\n            volume=0.01,\n            comment=f\"Grid buy at {price}\"\n        )\n        tickets.append(ticket)\n        print(f\"Order #{ticket} at {price}\")\n\n    print(f\"Total orders placed: {len(tickets)}\")\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_limit/#example-3-conditional-limit-order","title":"Example 3: Conditional Limit Order","text":"<pre><code>async def smart_limit():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Get current price\n    ask = await sugar.get_ask()\n\n    # Place limit 20 pips below current price\n    symbol_info = await sugar.get_symbol_info()\n    point = symbol_info.point\n\n    limit_price = ask - (20 * point * 10)  # 20 pips below\n\n    # Ensure price is reasonable\n    if limit_price &gt; 0:\n        ticket = await sugar.buy_limit(\n            price=limit_price,\n            volume=0.1,\n            comment=f\"Limit 20 pips below\"\n        )\n        print(f\"BUY LIMIT set at {limit_price}\")\n    else:\n        print(\"Invalid limit price calculated\")\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_limit/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Price above current ASK <pre><code># ERROR: BUY LIMIT must be BELOW current price\n# Current ASK: 1.0850\ntry:\n    ticket = await sugar.buy_limit(price=1.0860)  # Above current price\nexcept RuntimeError as e:\n    print(e)  # \"Order failed: Invalid price for BUY LIMIT\"\n</code></pre></p> <p>Solution: Ensure limit price is below current ASK <pre><code>ask = await sugar.get_ask()  # 1.0850\nlimit_price = ask - 0.0010   # 1.0840 (below current)\nticket = await sugar.buy_limit(price=limit_price)\n</code></pre></p> <p>Pitfall 2: Wrong price format <pre><code># ERROR: Using pips instead of price\nticket = await sugar.buy_limit(price=20)  # WRONG: 20 is not a price\n</code></pre></p> <p>Solution: Use actual price, not pips <pre><code># Get current price first\nask = await sugar.get_ask()  # 1.0850\n\n# Calculate target price\ntarget = ask - 0.0020  # 20 pips below for EURUSD\n\nticket = await sugar.buy_limit(price=target)  # 1.0830\n</code></pre></p>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_limit/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Use symbol digits for price precision <pre><code># Ensure price has correct decimal places\nsymbol_info = await sugar.get_symbol_info()\ndigits = symbol_info.digits\n\n# Round limit price to symbol digits\nask = await sugar.get_ask()\nlimit_price = round(ask - 0.0020, digits)\n\nticket = await sugar.buy_limit(price=limit_price)\n</code></pre></p> <p>Tip 2: Monitor pending orders <pre><code># Place limit order\nticket = await sugar.buy_limit(price=1.0840)\n\n# Check if order is still pending or filled\norders = await sugar._service.get_opened_orders()\n\nfor order in orders.order_infos:\n    if order.ticket == ticket:\n        print(f\"Order {ticket} still pending\")\n        break\nelse:\n    print(f\"Order {ticket} filled (became position)\")\n</code></pre></p> <p>Tip 3: Combine with Stop Loss <pre><code># Place limit order, then modify with SL once filled\nticket = await sugar.buy_limit(price=1.0840, volume=0.1)\n\n# Wait for order to fill (becomes position)\n# Then add stop loss\ntry:\n    await sugar.modify_position_sltp(\n        ticket=ticket,\n        sl=1.0820  # 20 pips SL\n    )\nexcept ValueError:\n    print(\"Order not yet filled\")\n</code></pre></p>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_limit/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>sell_limit - Place SELL LIMIT pending order</li> <li>buy_stop - Place BUY STOP pending order</li> <li>buy_market - Open BUY position immediately</li> <li>buy_limit_with_sltp - BUY LIMIT with SL/TP</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_market/","title":"Open BUY Position at Market (<code>buy_market</code>)","text":"<p>Sugar method: Opens BUY position at current market price in one call.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.buy_market(symbol, volume, comment, magic)</code></li> <li>Returns: Position ticket number (<code>int</code>)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_market/#method-signature","title":"Method Signature","text":"<pre><code>async def buy_market(\n    self,\n    symbol: Optional[str] = None,\n    volume: float = 0.01,\n    comment: str = \"\",\n    magic: int = 0\n) -&gt; int\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_market/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> Trading symbol (uses default if not specified) <code>volume</code> <code>float</code> No <code>0.01</code> Position volume in lots <code>comment</code> <code>str</code> No <code>\"\"</code> Order comment (visible in terminal) <code>magic</code> <code>int</code> No <code>0</code> Magic number for order identification"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_market/#return-value","title":"Return Value","text":"Type Description <code>int</code> Position ticket number (unique identifier) <p>Raises:</p> <ul> <li><code>ValueError</code> if symbol not specified and no default set</li> <li><code>RuntimeError</code> if order execution fails (returned_code != 10009)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_market/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Fetches current ASK price from terminal</li> <li>Creates BUY market order request</li> <li>Executes order with 10 points slippage tolerance</li> <li>Returns ticket number on success</li> </ul> <p>Key behaviors:</p> <ul> <li>BUY = profit when price RISES</li> <li>Uses ASK price (higher price)</li> <li>Default slippage: 10 points</li> <li>Raises exception if order fails</li> <li>Position opens immediately at market</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_market/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.buy_market()\n    \u2193 fetches price\nMT5Service.get_symbol_tick()\n    \u2193 builds OrderSendRequest\nMT5Service.place_order()\n    \u2193 calls\nMT5Account.order_send()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderSend()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar fetches current tick via Service layer</li> <li>Sugar builds OrderSendRequest with TMT5_ORDER_TYPE_BUY</li> <li>Sugar calls Service.place_order() with request</li> <li>Service forwards to Account.order_send()</li> <li>Account sends gRPC request to terminal</li> <li>Sugar validates returned_code == 10009 (TRADE_RETCODE_DONE)</li> <li>Returns ticket number from result.order</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:568</code></li> <li>Service: <code>src/pymt5/mt5_service.py:929</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1713</code></li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_market/#when-to-use","title":"When to Use","text":"<p>Use <code>buy_market()</code> when:</p> <ul> <li>You expect price to go UP</li> <li>Need immediate position execution</li> <li>Don't need Stop Loss or Take Profit (simple entry)</li> <li>Building basic trading strategies</li> </ul> <p>Don't use when:</p> <ul> <li>Need SL/TP on entry (use <code>buy_market_with_sltp()</code>)</li> <li>Want to enter at specific price (use <code>buy_limit()</code> or <code>buy_stop()</code>)</li> <li>Market is closed or illiquid</li> <li>Price is moving too fast (consider pending orders)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_market/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/4.%20Simple_Trading/buy_market/#example-1-basic-buy-position","title":"Example 1: Basic BUY Position","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def simple_buy():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open BUY position with default volume (0.01 lot)\n    ticket = await sugar.buy_market()\n    print(f\"Position opened: #{ticket}\")\n\n# Output:\n# Position opened: #123456789\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_market/#example-2-buy-with-custom-parameters","title":"Example 2: BUY with Custom Parameters","text":"<pre><code>async def buy_with_params():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await sugar.connect()\n\n    # Open 0.1 lot BUY position on GBPUSD\n    ticket = await sugar.buy_market(\n        symbol=\"GBPUSD\",\n        volume=0.1,\n        comment=\"Bull trend entry\",\n        magic=12345\n    )\n\n    print(f\"GBPUSD BUY: ticket #{ticket}\")\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_market/#example-3-error-handling","title":"Example 3: Error Handling","text":"<pre><code>async def safe_buy():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    try:\n        ticket = await sugar.buy_market(volume=0.1)\n        print(f\"Success! Ticket: {ticket}\")\n\n        # Get current balance after trade\n        balance = await sugar.get_balance()\n        print(f\"New balance: ${balance}\")\n\n    except RuntimeError as e:\n        print(f\"Order failed: {e}\")\n        # Handle failure (e.g., insufficient margin, market closed)\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_market/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: No symbol specified <pre><code># ERROR: No default symbol set\nsugar = MT5Sugar(user=123, password=\"pass\", grpc_server=\"server\")\nawait sugar.connect()\nticket = await sugar.buy_market()  # Raises ValueError\n</code></pre></p> <p>Solution: Always set default or pass symbol explicitly <pre><code># Option 1: Set default\nsugar = MT5Sugar(..., default_symbol=\"EURUSD\")\nticket = await sugar.buy_market()\n\n# Option 2: Pass explicitly\nticket = await sugar.buy_market(symbol=\"EURUSD\")\n</code></pre></p> <p>Pitfall 2: Insufficient margin <pre><code># ERROR: Trying to open position larger than account margin allows\ntry:\n    ticket = await sugar.buy_market(volume=10.0)  # Too large\nexcept RuntimeError as e:\n    print(e)  # \"Order failed: code=10019, comment=Insufficient margin\"\n</code></pre></p> <p>Solution: Check free margin before trading <pre><code>free_margin = await sugar.get_free_margin()\n# Calculate safe volume based on free margin\nsafe_volume = min(requested_volume, free_margin / margin_per_lot)\n</code></pre></p> <p>Pitfall 3: Market closed <pre><code># ERROR: Trying to trade during weekend or holidays\ntry:\n    ticket = await sugar.buy_market()  # Market closed\nexcept RuntimeError as e:\n    print(e)  # \"Order failed: code=10018, comment=Market is closed\"\n</code></pre></p> <p>Solution: Check market hours or handle gracefully <pre><code>try:\n    ticket = await sugar.buy_market()\nexcept RuntimeError as e:\n    if \"Market is closed\" in str(e):\n        print(\"Market closed, will retry later\")\n    else:\n        raise\n</code></pre></p>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_market/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Save ticket for later operations <pre><code># Open position and save ticket\nticket = await sugar.buy_market(volume=0.1)\n\n# Later: close this specific position\nawait sugar.close_position(ticket)\n</code></pre></p> <p>Tip 2: Use magic numbers to group trades <pre><code># Strategy 1 trades use magic 1000\nticket1 = await sugar.buy_market(magic=1000)\n\n# Strategy 2 trades use magic 2000\nticket2 = await sugar.buy_market(magic=2000)\n\n# Close only strategy 1 trades by filtering magic number\n</code></pre></p> <p>Tip 3: Check price before opening <pre><code># Validate entry price is reasonable\nbid = await sugar.get_bid()\nask = await sugar.get_ask()\nspread = ask - bid\n\n# Only trade if spread is reasonable\nif spread &lt; 0.0005:  # 5 pips for EURUSD\n    ticket = await sugar.buy_market()\nelse:\n    print(f\"Spread too wide: {spread}\")\n</code></pre></p>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_market/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>sell_market - Open SELL position at market</li> <li>buy_limit - Place BUY LIMIT pending order</li> <li>buy_stop - Place BUY STOP pending order</li> <li>buy_market_with_sltp - Open BUY with SL/TP</li> <li>close_position - Close position by ticket</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_stop/","title":"Place BUY STOP Order (<code>buy_stop</code>)","text":"<p>Sugar method: Places BUY STOP pending order to buy above current price (breakout entry).</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.buy_stop(symbol, volume, price, comment, magic)</code></li> <li>Returns: Order ticket number (<code>int</code>)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_stop/#method-signature","title":"Method Signature","text":"<pre><code>async def buy_stop(\n    self,\n    symbol: Optional[str] = None,\n    volume: float = 0.01,\n    price: float = 0.0,\n    comment: str = \"\",\n    magic: int = 0\n) -&gt; int\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_stop/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> Trading symbol (uses default if not specified) <code>volume</code> <code>float</code> No <code>0.01</code> Order volume in lots <code>price</code> <code>float</code> Yes <code>0.0</code> Stop price (must be ABOVE current ASK) <code>comment</code> <code>str</code> No <code>\"\"</code> Order comment (visible in terminal) <code>magic</code> <code>int</code> No <code>0</code> Magic number for order identification"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_stop/#return-value","title":"Return Value","text":"Type Description <code>int</code> Order ticket number (unique identifier) <p>Raises:</p> <ul> <li><code>ValueError</code> if symbol not specified and no default set</li> <li><code>RuntimeError</code> if order placement fails (returned_code != 10009)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_stop/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Creates pending BUY STOP order</li> <li>Order triggers when ASK price rises to specified level</li> <li>Automatically converts to BUY position when triggered</li> <li>Order remains pending until triggered or cancelled</li> </ul> <p>Key behaviors:</p> <ul> <li>BUY STOP price must be ABOVE current ASK</li> <li>Used for breakout trading (buy when price breaks resistance)</li> <li>Executes at market once stop price reached (not at exact price)</li> <li>Useful for trend following strategies</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_stop/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.buy_stop()\n    \u2193 builds OrderSendRequest\nMT5Service.place_order()\n    \u2193 calls\nMT5Account.order_send()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderSend()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar builds OrderSendRequest with TMT5_ORDER_TYPE_BUY_STOP</li> <li>Sugar calls Service.place_order() with request</li> <li>Service forwards to Account.order_send()</li> <li>Account sends gRPC request to terminal</li> <li>Sugar validates returned_code == 10009 (TRADE_RETCODE_DONE)</li> <li>Returns order ticket from result.order</li> <li>Order stays pending until price reaches stop level</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:738</code></li> <li>Service: <code>src/pymt5/mt5_service.py:929</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1713</code></li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_stop/#when-to-use","title":"When to Use","text":"<p>Use <code>buy_stop()</code> when:</p> <ul> <li>Trading breakouts above resistance</li> <li>Following upward trend (buy momentum)</li> <li>Want to enter only if price confirms direction</li> <li>Implementing breakout strategies</li> </ul> <p>Don't use when:</p> <ul> <li>Need immediate position (use <code>buy_market()</code>)</li> <li>Want to buy at lower price (use <code>buy_limit()</code>)</li> <li>Price may reverse before reaching stop</li> <li>In ranging market (false breakouts)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_stop/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/4.%20Simple_Trading/buy_stop/#example-1-basic-breakout-entry","title":"Example 1: Basic Breakout Entry","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def breakout_buy():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Current ASK: 1.0850\n    # Resistance at 1.0870\n    # Place BUY STOP above resistance\n    ticket = await sugar.buy_stop(\n        price=1.0875,\n        volume=0.1,\n        comment=\"Breakout buy at 1.0875\"\n    )\n\n    print(f\"BUY STOP order placed: #{ticket}\")\n\n# Output:\n# BUY STOP order placed: #123456793\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_stop/#example-2-multiple-breakout-levels","title":"Example 2: Multiple Breakout Levels","text":"<pre><code>async def tiered_breakout():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Current price: 1.0850\n    # Key resistance levels\n    resistances = [1.0870, 1.0900, 1.0930]\n\n    tickets = []\n    for resistance in resistances:\n        # Place BUY STOP slightly above each resistance\n        stop_price = resistance + 0.0005  # 5 pips above\n\n        ticket = await sugar.buy_stop(\n            price=stop_price,\n            volume=0.01,\n            comment=f\"Breakout {resistance}\"\n        )\n        tickets.append(ticket)\n        print(f\"BUY STOP at {stop_price}: #{ticket}\")\n\n    print(f\"Total breakout orders: {len(tickets)}\")\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_stop/#example-3-trend-following-with-buy-stop","title":"Example 3: Trend Following with BUY STOP","text":"<pre><code>async def trend_following():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Get current high\n    ask = await sugar.get_ask()\n\n    # Place BUY STOP 20 pips above current price\n    # (enters only if uptrend continues)\n    symbol_info = await sugar.get_symbol_info()\n    point = symbol_info.point\n\n    stop_price = ask + (20 * point * 10)  # 20 pips above\n\n    ticket = await sugar.buy_stop(\n        price=stop_price,\n        volume=0.1,\n        comment=\"Trend confirmation\"\n    )\n\n    print(f\"BUY STOP at {stop_price} (confirms uptrend)\")\n    print(f\"Order: #{ticket}\")\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_stop/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Price below current ASK <pre><code># ERROR: BUY STOP must be ABOVE current price\n# Current ASK: 1.0850\ntry:\n    ticket = await sugar.buy_stop(price=1.0840)  # Below current price\nexcept RuntimeError as e:\n    print(e)  # \"Order failed: Invalid price for BUY STOP\"\n</code></pre></p> <p>Solution: Ensure stop price is above current ASK <pre><code>ask = await sugar.get_ask()  # 1.0850\nstop_price = ask + 0.0020    # 1.0870 (above current)\nticket = await sugar.buy_stop(price=stop_price)\n</code></pre></p> <p>Pitfall 2: Confusing BUY STOP with BUY LIMIT <pre><code># BUY LIMIT: Buy BELOW current price (better price)\n# BUY STOP: Buy ABOVE current price (breakout)\n\n# Current price: 1.0850\n\n# LIMIT: Buy if price drops to 1.0840\nbuy_limit = await sugar.buy_limit(price=1.0840)\n\n# STOP: Buy if price rises to 1.0870\nbuy_stop = await sugar.buy_stop(price=1.0870)\n</code></pre></p> <p>Pitfall 3: False breakouts <pre><code># Price touches stop level then reverses\n# Order gets triggered at 1.0870, then price falls to 1.0850\n# Result: Immediate loss\n\n# Stop order placed at 1.0870\nticket = await sugar.buy_stop(price=1.0870)\n# Price spikes to 1.0871 (triggers order)\n# Price falls back to 1.0850 (loss)\n</code></pre></p> <p>Solution: Place stop beyond significant level with buffer <pre><code># Add buffer beyond resistance\nresistance = 1.0870\nbuffer = 0.0005  # 5 pips buffer\n\nstop_price = resistance + buffer  # 1.0875\nticket = await sugar.buy_stop(price=stop_price)\n</code></pre></p>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_stop/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Combine with Stop Loss <pre><code># Place BUY STOP with immediate SL plan\nstop_price = 1.0870\nstop_loss = 1.0850  # 20 pips below entry\n\n# Place order\nticket = await sugar.buy_stop(price=stop_price)\n\n# After order fills (becomes position), add SL\n# Monitor and modify once position opens\n</code></pre></p> <p>Tip 2: Use with daily high <pre><code># Breakout strategy: buy above yesterday's high\nyesterday_high = 1.0865\n\n# Place BUY STOP 5 pips above\nstop_price = yesterday_high + 0.0005\n\nticket = await sugar.buy_stop(\n    price=stop_price,\n    volume=0.1,\n    comment=\"Above yesterday high\"\n)\n</code></pre></p>"},{"location":"MT5Sugar/4.%20Simple_Trading/buy_stop/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>sell_stop - Place SELL STOP pending order</li> <li>buy_limit - Place BUY LIMIT pending order</li> <li>buy_market - Open BUY position immediately</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_limit/","title":"Place SELL LIMIT Order (<code>sell_limit</code>)","text":"<p>Sugar method: Places SELL LIMIT pending order to sell above current price.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.sell_limit(symbol, volume, price, comment, magic)</code></li> <li>Returns: Order ticket number (<code>int</code>)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_limit/#method-signature","title":"Method Signature","text":"<pre><code>async def sell_limit(\n    self,\n    symbol: Optional[str] = None,\n    volume: float = 0.01,\n    price: float = 0.0,\n    comment: str = \"\",\n    magic: int = 0\n) -&gt; int\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_limit/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> Trading symbol (uses default if not specified) <code>volume</code> <code>float</code> No <code>0.01</code> Order volume in lots <code>price</code> <code>float</code> Yes <code>0.0</code> Limit price (must be ABOVE current BID) <code>comment</code> <code>str</code> No <code>\"\"</code> Order comment (visible in terminal) <code>magic</code> <code>int</code> No <code>0</code> Magic number for order identification"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_limit/#return-value","title":"Return Value","text":"Type Description <code>int</code> Order ticket number (unique identifier) <p>Raises:</p> <ul> <li><code>ValueError</code> if symbol not specified and no default set</li> <li><code>RuntimeError</code> if order placement fails (returned_code != 10009)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_limit/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Creates pending SELL LIMIT order</li> <li>Order triggers when BID price rises to specified level</li> <li>Automatically converts to SELL position when triggered</li> <li>Order remains pending until triggered or cancelled</li> </ul> <p>Key behaviors:</p> <ul> <li>SELL LIMIT price must be ABOVE current BID</li> <li>Order executes only at specified price or better</li> <li>Used to sell at higher price (sell the rally)</li> <li>Does not use slippage (limit order fills at exact price)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_limit/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.sell_limit()\n    \u2193 builds OrderSendRequest\nMT5Service.place_order()\n    \u2193 calls\nMT5Account.order_send()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderSend()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar builds OrderSendRequest with TMT5_ORDER_TYPE_SELL_LIMIT</li> <li>Sugar calls Service.place_order() with request</li> <li>Service forwards to Account.order_send()</li> <li>Account sends gRPC request to terminal</li> <li>Sugar validates returned_code == 10009 (TRADE_RETCODE_DONE)</li> <li>Returns order ticket from result.order</li> <li>Order stays pending in terminal until price reached</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:698</code></li> <li>Service: <code>src/pymt5/mt5_service.py:929</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1713</code></li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_limit/#when-to-use","title":"When to Use","text":"<p>Use <code>sell_limit()</code> when:</p> <ul> <li>Want to sell at higher price (wait for rally)</li> <li>Planning entry before price reaches level</li> <li>Expecting price to rise then fall (sell the top)</li> <li>Implementing sell the rally strategy</li> </ul> <p>Don't use when:</p> <ul> <li>Need immediate position (use <code>sell_market()</code>)</li> <li>Want to sell below current price (use <code>sell_stop()</code>)</li> <li>Price may never reach limit level (consider market order)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_limit/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/4.%20Simple_Trading/sell_limit/#example-1-basic-sell-limit-order","title":"Example 1: Basic Sell Limit Order","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def sell_the_rally():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Current BID: 1.0850\n    # Place SELL LIMIT at 1.0860 (above current price)\n    ticket = await sugar.sell_limit(\n        price=1.0860,\n        volume=0.1,\n        comment=\"Sell rally at 1.0860\"\n    )\n\n    print(f\"SELL LIMIT order placed: #{ticket}\")\n\n# Output:\n# SELL LIMIT order placed: #123456792\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_limit/#example-2-take-profit-targets","title":"Example 2: Take Profit Targets","text":"<pre><code>async def profit_targets():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open BUY position first\n    buy_ticket = await sugar.buy_market(volume=0.3)\n    print(f\"BUY position: #{buy_ticket}\")\n\n    # Set SELL LIMIT orders as profit targets\n    # Current price: 1.0850\n    bid = await sugar.get_bid()\n\n    targets = [\n        (0.1, bid + 0.0030),  # Take profit 30 pips: 0.1 lot\n        (0.1, bid + 0.0050),  # Take profit 50 pips: 0.1 lot\n        (0.1, bid + 0.0100)   # Take profit 100 pips: 0.1 lot\n    ]\n\n    for volume, price in targets:\n        ticket = await sugar.sell_limit(\n            price=price,\n            volume=volume,\n            comment=f\"TP at {price}\"\n        )\n        print(f\"Profit target #{ticket} at {price}\")\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_limit/#example-3-resistance-level-selling","title":"Example 3: Resistance Level Selling","text":"<pre><code>async def sell_at_resistance():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Known resistance level\n    resistance = 1.0900\n\n    # Current price\n    bid = await sugar.get_bid()\n\n    # Only place order if below resistance\n    if bid &lt; resistance:\n        ticket = await sugar.sell_limit(\n            price=resistance,\n            volume=0.1,\n            comment=\"Sell at resistance\"\n        )\n        print(f\"SELL LIMIT at resistance {resistance}: #{ticket}\")\n\n        # Distance to resistance\n        pips_away = (resistance - bid) / 0.0001\n        print(f\"Resistance is {pips_away:.1f} pips away\")\n    else:\n        print(\"Already above resistance level\")\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_limit/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Price below current BID <pre><code># ERROR: SELL LIMIT must be ABOVE current price\n# Current BID: 1.0850\ntry:\n    ticket = await sugar.sell_limit(price=1.0840)  # Below current price\nexcept RuntimeError as e:\n    print(e)  # \"Order failed: Invalid price for SELL LIMIT\"\n</code></pre></p> <p>Solution: Ensure limit price is above current BID <pre><code>bid = await sugar.get_bid()  # 1.0850\nlimit_price = bid + 0.0010   # 1.0860 (above current)\nticket = await sugar.sell_limit(price=limit_price)\n</code></pre></p> <p>Pitfall 2: Confusing with BUY close <pre><code># WRONG: Thinking SELL LIMIT will close a BUY position\nbuy_ticket = await sugar.buy_market()\n\n# This does NOT close the BUY position\n# It creates a NEW pending SELL LIMIT order\nsell_ticket = await sugar.sell_limit(price=1.0870)\n\n# To close BUY position, use:\nawait sugar.close_position(buy_ticket)\n</code></pre></p> <p>Pitfall 3: Too far from current price <pre><code># Order may never fill if price too far away\nbid = await sugar.get_bid()  # 1.0850\n\n# Placing 500 pips above (may never reach)\nticket = await sugar.sell_limit(price=bid + 0.0500)  # 1.1350\n# Order sits pending indefinitely\n</code></pre></p> <p>Solution: Use realistic price targets <pre><code>bid = await sugar.get_bid()\n\n# Reasonable target: 20-50 pips above\nrealistic_target = bid + 0.0030  # 30 pips\nticket = await sugar.sell_limit(price=realistic_target)\n</code></pre></p>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_limit/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Grid selling strategy <pre><code># Place multiple SELL LIMIT orders above current price\nbid = await sugar.get_bid()\n\n# Create grid every 10 pips\nfor i in range(1, 6):\n    price = bid + (i * 0.0010)  # +10, +20, +30, +40, +50 pips\n    ticket = await sugar.sell_limit(\n        price=price,\n        volume=0.01,\n        comment=f\"Grid sell {i}\"\n    )\n    print(f\"Grid level {i}: {price}\")\n</code></pre></p> <p>Tip 2: Combine with support/resistance <pre><code># Technical analysis: place order at resistance\nresistance_levels = [1.0900, 1.0950, 1.1000]\n\nbid = await sugar.get_bid()\n\n# Place SELL LIMIT at nearest resistance above\nfor level in resistance_levels:\n    if level &gt; bid:\n        ticket = await sugar.sell_limit(\n            price=level,\n            volume=0.1,\n            comment=f\"Resistance at {level}\"\n        )\n        print(f\"Order placed at resistance: {level}\")\n        break\n</code></pre></p>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_limit/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>buy_limit - Place BUY LIMIT pending order</li> <li>sell_stop - Place SELL STOP pending order</li> <li>sell_market - Open SELL position immediately</li> <li>sell_limit_with_sltp - SELL LIMIT with SL/TP</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_market/","title":"Open SELL Position at Market (<code>sell_market</code>)","text":"<p>Sugar method: Opens SELL position at current market price in one call.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.sell_market(symbol, volume, comment, magic)</code></li> <li>Returns: Position ticket number (<code>int</code>)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_market/#method-signature","title":"Method Signature","text":"<pre><code>async def sell_market(\n    self,\n    symbol: Optional[str] = None,\n    volume: float = 0.01,\n    comment: str = \"\",\n    magic: int = 0\n) -&gt; int\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_market/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> Trading symbol (uses default if not specified) <code>volume</code> <code>float</code> No <code>0.01</code> Position volume in lots <code>comment</code> <code>str</code> No <code>\"\"</code> Order comment (visible in terminal) <code>magic</code> <code>int</code> No <code>0</code> Magic number for order identification"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_market/#return-value","title":"Return Value","text":"Type Description <code>int</code> Position ticket number (unique identifier) <p>Raises:</p> <ul> <li><code>ValueError</code> if symbol not specified and no default set</li> <li><code>RuntimeError</code> if order execution fails (returned_code != 10009)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_market/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Fetches current BID price from terminal</li> <li>Creates SELL market order request</li> <li>Executes order with 10 points slippage tolerance</li> <li>Returns ticket number on success</li> </ul> <p>Key behaviors:</p> <ul> <li>SELL = profit when price FALLS</li> <li>Uses BID price (lower price)</li> <li>Default slippage: 10 points</li> <li>Raises exception if order fails</li> <li>Position opens immediately at market</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_market/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.sell_market()\n    \u2193 fetches price\nMT5Service.get_symbol_tick()\n    \u2193 builds OrderSendRequest\nMT5Service.place_order()\n    \u2193 calls\nMT5Account.order_send()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderSend()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar fetches current tick via Service layer</li> <li>Sugar builds OrderSendRequest with TMT5_ORDER_TYPE_SELL</li> <li>Sugar calls Service.place_order() with request</li> <li>Service forwards to Account.order_send()</li> <li>Account sends gRPC request to terminal</li> <li>Sugar validates returned_code == 10009 (TRADE_RETCODE_DONE)</li> <li>Returns ticket number from result.order</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:613</code></li> <li>Service: <code>src/pymt5/mt5_service.py:929</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1713</code></li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_market/#when-to-use","title":"When to Use","text":"<p>Use <code>sell_market()</code> when:</p> <ul> <li>You expect price to go DOWN</li> <li>Need immediate position execution</li> <li>Don't need Stop Loss or Take Profit (simple entry)</li> <li>Building basic trading strategies</li> </ul> <p>Don't use when:</p> <ul> <li>Need SL/TP on entry (use <code>sell_market_with_sltp()</code>)</li> <li>Want to enter at specific price (use <code>sell_limit()</code> or <code>sell_stop()</code>)</li> <li>Market is closed or illiquid</li> <li>Price is moving too fast (consider pending orders)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_market/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/4.%20Simple_Trading/sell_market/#example-1-basic-sell-position","title":"Example 1: Basic SELL Position","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def simple_sell():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open SELL position with default volume (0.01 lot)\n    ticket = await sugar.sell_market()\n    print(f\"Position opened: #{ticket}\")\n\n# Output:\n# Position opened: #123456790\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_market/#example-2-sell-with-custom-parameters","title":"Example 2: SELL with Custom Parameters","text":"<pre><code>async def sell_with_params():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await sugar.connect()\n\n    # Open 0.1 lot SELL position on GBPUSD\n    ticket = await sugar.sell_market(\n        symbol=\"GBPUSD\",\n        volume=0.1,\n        comment=\"Bear trend entry\",\n        magic=12345\n    )\n\n    print(f\"GBPUSD SELL: ticket #{ticket}\")\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_market/#example-3-hedging-strategy-buy-sell","title":"Example 3: Hedging Strategy (BUY + SELL)","text":"<pre><code>async def hedging_positions():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    try:\n        # Open opposite positions to hedge\n        buy_ticket = await sugar.buy_market(volume=0.1, magic=1000)\n        sell_ticket = await sugar.sell_market(volume=0.1, magic=1000)\n\n        print(f\"Hedge opened: BUY #{buy_ticket}, SELL #{sell_ticket}\")\n\n        # Monitor and close profitable side later\n        balance = await sugar.get_balance()\n        print(f\"Balance: ${balance}\")\n\n    except RuntimeError as e:\n        print(f\"Hedging failed: {e}\")\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_market/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Confusing BUY and SELL <pre><code># WRONG: Thinking SELL means \"sell to close\" a position\n# SELL opens NEW position that profits from price falling\nticket = await sugar.sell_market()  # Opens new SELL position\n\n# To close position, use close_position() instead\nawait sugar.close_position(ticket)\n</code></pre></p> <p>Solution: Remember SELL = open short position <pre><code># Open short (SELL) position\nsell_ticket = await sugar.sell_market()  # Profit if price drops\n\n# Close that position\nawait sugar.close_position(sell_ticket)\n</code></pre></p> <p>Pitfall 2: Using ASK instead of BID mentally <pre><code># SELL uses BID price (lower)\n# If current prices: BID=1.08430, ASK=1.08445\n# SELL opens at 1.08430 (BID)\n# Profit if price falls below 1.08430\n</code></pre></p> <p>Solution: Remember: SELL uses BID, BUY uses ASK <pre><code>bid = await sugar.get_bid()    # 1.08430\nask = await sugar.get_ask()    # 1.08445\n\n# SELL opens at BID\nsell_ticket = await sugar.sell_market()  # Opens at 1.08430\n</code></pre></p> <p>Pitfall 3: Wrong expectations about profit direction <pre><code># WRONG: Expecting profit when price rises\nticket = await sugar.sell_market()\n# Price goes from 1.0843 \u2192 1.0850\n# Result: LOSS (not profit)\n\n# CORRECT: Profit when price falls\nticket = await sugar.sell_market()\n# Price goes from 1.0843 \u2192 1.0835\n# Result: PROFIT\n</code></pre></p>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_market/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Check trend before SELL <pre><code># Simple moving average crossover for trend\ncurrent_price = await sugar.get_bid()\n\n# SELL when price is below moving average (downtrend)\nif current_price &lt; moving_average:\n    ticket = await sugar.sell_market()\n</code></pre></p> <p>Tip 2: Combine with position monitoring <pre><code># Open SELL and monitor profit\nticket = await sugar.sell_market(volume=0.1)\n\n# Subscribe to position profit updates\nasync for profit in sugar.stream_position_profit(ticket):\n    print(f\"Current profit: ${profit}\")\n\n    # Close if profit target reached\n    if profit &gt;= 50.0:\n        await sugar.close_position(ticket)\n        break\n</code></pre></p> <p>Tip 3: Use spread check before SELL <pre><code># Ensure tight spread before selling\nspread = await sugar.get_spread()\n\nif spread &lt; 0.0002:  # 2 pips for EURUSD\n    ticket = await sugar.sell_market()\nelse:\n    print(f\"Spread too wide for SELL: {spread}\")\n</code></pre></p>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_market/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>buy_market - Open BUY position at market</li> <li>sell_limit - Place SELL LIMIT pending order</li> <li>sell_stop - Place SELL STOP pending order</li> <li>sell_market_with_sltp - Open SELL with SL/TP</li> <li>close_position - Close position by ticket</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_stop/","title":"Place SELL STOP Order (<code>sell_stop</code>)","text":"<p>Sugar method: Places SELL STOP pending order to sell below current price (breakdown entry).</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.sell_stop(symbol, volume, price, comment, magic)</code></li> <li>Returns: Order ticket number (<code>int</code>)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_stop/#method-signature","title":"Method Signature","text":"<pre><code>async def sell_stop(\n    self,\n    symbol: Optional[str] = None,\n    volume: float = 0.01,\n    price: float = 0.0,\n    comment: str = \"\",\n    magic: int = 0\n) -&gt; int\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_stop/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> Trading symbol (uses default if not specified) <code>volume</code> <code>float</code> No <code>0.01</code> Order volume in lots <code>price</code> <code>float</code> Yes <code>0.0</code> Stop price (must be BELOW current BID) <code>comment</code> <code>str</code> No <code>\"\"</code> Order comment (visible in terminal) <code>magic</code> <code>int</code> No <code>0</code> Magic number for order identification"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_stop/#return-value","title":"Return Value","text":"Type Description <code>int</code> Order ticket number (unique identifier) <p>Raises:</p> <ul> <li><code>ValueError</code> if symbol not specified and no default set</li> <li><code>RuntimeError</code> if order placement fails (returned_code != 10009)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_stop/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Creates pending SELL STOP order</li> <li>Order triggers when BID price falls to specified level</li> <li>Automatically converts to SELL position when triggered</li> <li>Order remains pending until triggered or cancelled</li> </ul> <p>Key behaviors:</p> <ul> <li>SELL STOP price must be BELOW current BID</li> <li>Used for breakdown trading (sell when price breaks support)</li> <li>Executes at market once stop price reached (not at exact price)</li> <li>Useful for trend following and support breakdown strategies</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_stop/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.sell_stop()\n    \u2193 builds OrderSendRequest\nMT5Service.place_order()\n    \u2193 calls\nMT5Account.order_send()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderSend()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar builds OrderSendRequest with TMT5_ORDER_TYPE_SELL_STOP</li> <li>Sugar calls Service.place_order() with request</li> <li>Service forwards to Account.order_send()</li> <li>Account sends gRPC request to terminal</li> <li>Sugar validates returned_code == 10009 (TRADE_RETCODE_DONE)</li> <li>Returns order ticket from result.order</li> <li>Order stays pending until price reaches stop level</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:778</code></li> <li>Service: <code>src/pymt5/mt5_service.py:929</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1713</code></li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_stop/#when-to-use","title":"When to Use","text":"<p>Use <code>sell_stop()</code> when:</p> <ul> <li>Trading breakdowns below support</li> <li>Following downward trend (sell momentum)</li> <li>Want to enter only if price confirms direction</li> <li>Implementing breakdown strategies</li> </ul> <p>Don't use when:</p> <ul> <li>Need immediate position (use <code>sell_market()</code>)</li> <li>Want to sell at higher price (use <code>sell_limit()</code>)</li> <li>Price may reverse before reaching stop</li> <li>In ranging market (false breakdowns)</li> </ul>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_stop/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/4.%20Simple_Trading/sell_stop/#example-1-basic-breakdown-entry","title":"Example 1: Basic Breakdown Entry","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def breakdown_sell():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Current BID: 1.0850\n    # Support at 1.0830\n    # Place SELL STOP below support\n    ticket = await sugar.sell_stop(\n        price=1.0825,\n        volume=0.1,\n        comment=\"Breakdown sell at 1.0825\"\n    )\n\n    print(f\"SELL STOP order placed: #{ticket}\")\n\n# Output:\n# SELL STOP order placed: #123456794\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_stop/#example-2-multiple-support-levels","title":"Example 2: Multiple Support Levels","text":"<pre><code>async def tiered_breakdown():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Current price: 1.0850\n    # Key support levels\n    supports = [1.0830, 1.0800, 1.0770]\n\n    tickets = []\n    for support in supports:\n        # Place SELL STOP slightly below each support\n        stop_price = support - 0.0005  # 5 pips below\n\n        ticket = await sugar.sell_stop(\n            price=stop_price,\n            volume=0.01,\n            comment=f\"Breakdown {support}\"\n        )\n        tickets.append(ticket)\n        print(f\"SELL STOP at {stop_price}: #{ticket}\")\n\n    print(f\"Total breakdown orders: {len(tickets)}\")\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_stop/#example-3-trend-following-with-sell-stop","title":"Example 3: Trend Following with SELL STOP","text":"<pre><code>async def downtrend_following():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Get current low\n    bid = await sugar.get_bid()\n\n    # Place SELL STOP 20 pips below current price\n    # (enters only if downtrend continues)\n    symbol_info = await sugar.get_symbol_info()\n    point = symbol_info.point\n\n    stop_price = bid - (20 * point * 10)  # 20 pips below\n\n    ticket = await sugar.sell_stop(\n        price=stop_price,\n        volume=0.1,\n        comment=\"Downtrend confirmation\"\n    )\n\n    print(f\"SELL STOP at {stop_price} (confirms downtrend)\")\n    print(f\"Order: #{ticket}\")\n</code></pre>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_stop/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Price above current BID <pre><code># ERROR: SELL STOP must be BELOW current price\n# Current BID: 1.0850\ntry:\n    ticket = await sugar.sell_stop(price=1.0860)  # Above current price\nexcept RuntimeError as e:\n    print(e)  # \"Order failed: Invalid price for SELL STOP\"\n</code></pre></p> <p>Solution: Ensure stop price is below current BID <pre><code>bid = await sugar.get_bid()  # 1.0850\nstop_price = bid - 0.0020    # 1.0830 (below current)\nticket = await sugar.sell_stop(price=stop_price)\n</code></pre></p> <p>Pitfall 2: Confusing SELL STOP with SELL LIMIT <pre><code># SELL LIMIT: Sell ABOVE current price (better price)\n# SELL STOP: Sell BELOW current price (breakdown)\n\n# Current price: 1.0850\n\n# LIMIT: Sell if price rises to 1.0870\nsell_limit = await sugar.sell_limit(price=1.0870)\n\n# STOP: Sell if price falls to 1.0830\nsell_stop = await sugar.sell_stop(price=1.0830)\n</code></pre></p> <p>Pitfall 3: False breakdowns <pre><code># Price touches stop level then reverses\n# Order gets triggered at 1.0830, then price rises to 1.0850\n# Result: Immediate loss\n\n# Stop order placed at 1.0830\nticket = await sugar.sell_stop(price=1.0830)\n# Price spikes to 1.0829 (triggers order)\n# Price rises back to 1.0850 (loss)\n</code></pre></p> <p>Solution: Place stop beyond significant level with buffer <pre><code># Add buffer beyond support\nsupport = 1.0830\nbuffer = 0.0005  # 5 pips buffer\n\nstop_price = support - buffer  # 1.0825\nticket = await sugar.sell_stop(price=stop_price)\n</code></pre></p>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_stop/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Use with daily low <pre><code># Breakdown strategy: sell below yesterday's low\nyesterday_low = 1.0835\n\n# Place SELL STOP 5 pips below\nstop_price = yesterday_low - 0.0005\n\nticket = await sugar.sell_stop(\n    price=stop_price,\n    volume=0.1,\n    comment=\"Below yesterday low\"\n)\n</code></pre></p> <p>Tip 2: Combine with multiple timeframes <pre><code># Place SELL STOP below support on multiple timeframes\nh4_support = 1.0830\nh1_support = 1.0840\nm15_support = 1.0845\n\n# Use the strongest (lowest) support\nmain_support = min(h4_support, h1_support, m15_support)\n\n# Place below strongest support\nstop_price = main_support - 0.0005\n\nticket = await sugar.sell_stop(\n    price=stop_price,\n    comment=\"Multi-timeframe breakdown\"\n)\n</code></pre></p>"},{"location":"MT5Sugar/4.%20Simple_Trading/sell_stop/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>buy_stop - Place BUY STOP pending order</li> <li>sell_limit - Place SELL LIMIT pending order</li> <li>sell_market - Open SELL position immediately</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_limit_with_sltp/","title":"Place BUY LIMIT with SL/TP (<code>buy_limit_with_sltp</code>)","text":"<p>Sugar method: Places BUY LIMIT pending order with Stop Loss and Take Profit.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.buy_limit_with_sltp(symbol, volume, price, sl, tp, sl_pips, tp_pips, comment, magic)</code></li> <li>Returns: Order ticket number (<code>int</code>)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_limit_with_sltp/#method-signature","title":"Method Signature","text":"<pre><code>async def buy_limit_with_sltp(\n    self,\n    symbol: Optional[str] = None,\n    volume: float = 0.01,\n    price: float = 0.0,\n    sl: Optional[float] = None,\n    tp: Optional[float] = None,\n    sl_pips: Optional[float] = None,\n    tp_pips: Optional[float] = None,\n    comment: str = \"\",\n    magic: int = 0\n) -&gt; int\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_limit_with_sltp/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> Trading symbol (uses default if not specified) <code>volume</code> <code>float</code> No <code>0.01</code> Order volume in lots <code>price</code> <code>float</code> Yes <code>0.0</code> Limit price (must be BELOW current ASK) <code>sl</code> <code>Optional[float]</code> No <code>None</code> Stop Loss price (absolute price) <code>tp</code> <code>Optional[float]</code> No <code>None</code> Take Profit price (absolute price) <code>sl_pips</code> <code>Optional[float]</code> No <code>None</code> Stop Loss in pips from entry (alternative to sl) <code>tp_pips</code> <code>Optional[float]</code> No <code>None</code> Take Profit in pips from entry (alternative to tp) <code>comment</code> <code>str</code> No <code>\"\"</code> Order comment (visible in terminal) <code>magic</code> <code>int</code> No <code>0</code> Magic number for order identification"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_limit_with_sltp/#return-value","title":"Return Value","text":"Type Description <code>int</code> Order ticket number (unique identifier) <p>Raises:</p> <ul> <li><code>ValueError</code> if symbol not specified and no default set</li> <li><code>RuntimeError</code> if order placement fails (returned_code != 10009)</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_limit_with_sltp/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Places BUY LIMIT order below current price</li> <li>Sets SL/TP on the pending order</li> <li>When order fills, SL/TP automatically active</li> <li>Supports both absolute prices and pips from entry</li> </ul> <p>Key behaviors:</p> <ul> <li>BUY LIMIT price must be BELOW current ASK</li> <li>SL/TP calculated from entry price (not current price)</li> <li>BUY: SL below entry, TP above entry</li> <li>Pips calculation uses entry price as reference</li> <li>Order stays pending until price reached</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_limit_with_sltp/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.buy_limit_with_sltp()\n    \u2193 if pips provided, fetches\nMT5Sugar.get_symbol_info()\n    \u2193 calculates SL/TP from entry price\n    \u2193 builds OrderSendRequest with SL/TP\nMT5Service.place_order()\n    \u2193 calls\nMT5Account.order_send()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderSend()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar validates entry price parameter</li> <li>If sl_pips or tp_pips provided, fetches symbol info for point value</li> <li>Calculates SL/TP from entry price: SL = price - (pips \u00d7 point \u00d7 10), TP = price + (pips \u00d7 point \u00d7 10)</li> <li>Builds OrderSendRequest with TMT5_ORDER_TYPE_BUY_LIMIT and SL/TP</li> <li>Sends order through Service \u2192 Account \u2192 gRPC</li> <li>Returns order ticket, order stays pending</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:984</code></li> <li>Service: <code>src/pymt5/mt5_service.py:929</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1713</code></li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_limit_with_sltp/#when-to-use","title":"When to Use","text":"<p>Use <code>buy_limit_with_sltp()</code> when:</p> <ul> <li>Want to buy at lower price with automatic risk management</li> <li>Planning entry with predefined SL/TP</li> <li>Buy the dip strategy with protection</li> <li>Setting up orders before market moves</li> </ul> <p>Don't use when:</p> <ul> <li>Need immediate entry (use <code>buy_market_with_sltp()</code>)</li> <li>Want to modify SL/TP after order fills</li> <li>Price may never reach limit level</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_limit_with_sltp/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_limit_with_sltp/#example-1-buy-dip-with-pips-protection","title":"Example 1: Buy Dip with Pips Protection","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def buy_dip_protected():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Current ASK: 1.0850\n    # Place BUY LIMIT at 1.0840 with SL/TP\n    ticket = await sugar.buy_limit_with_sltp(\n        price=1.0840,\n        volume=0.1,\n        sl_pips=50,   # 50 pips below 1.0840 entry\n        tp_pips=100,  # 100 pips above 1.0840 entry\n        comment=\"Buy dip protected\"\n    )\n\n    print(f\"BUY LIMIT order: #{ticket} at 1.0840\")\n    print(f\"When filled: SL=1.0790, TP=1.0940\")\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_limit_with_sltp/#example-2-support-level-entry","title":"Example 2: Support Level Entry","text":"<pre><code>async def buy_at_support():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Support at 1.0820\n    support = 1.0820\n\n    # Place BUY LIMIT at support with absolute SL/TP\n    ticket = await sugar.buy_limit_with_sltp(\n        price=support,\n        volume=0.1,\n        sl=support - 0.0030,  # SL 30 pips below support\n        tp=support + 0.0100,  # TP 100 pips above\n        comment=\"Support bounce\"\n    )\n\n    print(f\"Order at support {support}: #{ticket}\")\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_limit_with_sltp/#example-3-grid-trading-with-protection","title":"Example 3: Grid Trading with Protection","text":"<pre><code>async def protected_grid():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Current ASK: 1.0850\n    # Place grid of BUY LIMIT orders below\n    base_price = 1.0840\n    grid_step = 0.0010  # 10 pips\n\n    tickets = []\n    for i in range(5):\n        entry_price = base_price - (i * grid_step)\n\n        ticket = await sugar.buy_limit_with_sltp(\n            price=entry_price,\n            volume=0.01,\n            sl_pips=50,\n            tp_pips=100,\n            comment=f\"Grid {i+1} at {entry_price}\"\n        )\n        tickets.append(ticket)\n        print(f\"Grid order #{ticket} at {entry_price}\")\n\n    print(f\"Total grid orders: {len(tickets)}\")\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_limit_with_sltp/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Using current price for SL/TP calculation <pre><code># WRONG: Calculating SL/TP from current price\nask = await sugar.get_ask()  # 1.0850\nentry_price = 1.0840\n\n# ERROR: SL/TP should be relative to entry (1.0840), not current (1.0850)\nticket = await sugar.buy_limit_with_sltp(\n    price=entry_price,\n    sl=ask - 0.0050,  # WRONG: Based on current price\n    tp=ask + 0.0100   # WRONG: Based on current price\n)\n</code></pre></p> <p>Solution: Calculate SL/TP from entry price or use pips <pre><code>entry_price = 1.0840\n\n# Option 1: Use pips (automatic calculation from entry)\nticket = await sugar.buy_limit_with_sltp(\n    price=entry_price,\n    sl_pips=50,\n    tp_pips=100\n)\n\n# Option 2: Calculate from entry price\nticket = await sugar.buy_limit_with_sltp(\n    price=entry_price,\n    sl=entry_price - 0.0050,  # From entry\n    tp=entry_price + 0.0100   # From entry\n)\n</code></pre></p> <p>Pitfall 2: Entry price above current ASK <pre><code># ERROR: BUY LIMIT must be BELOW current price\nask = await sugar.get_ask()  # 1.0850\n\ntry:\n    ticket = await sugar.buy_limit_with_sltp(\n        price=1.0860,  # Above current ASK\n        sl_pips=50,\n        tp_pips=100\n    )\nexcept RuntimeError as e:\n    print(e)  # \"Order failed: Invalid price\"\n</code></pre></p> <p>Solution: Ensure limit price below current ASK <pre><code>ask = await sugar.get_ask()  # 1.0850\nentry_price = ask - 0.0010   # 1.0840 (below)\n\nticket = await sugar.buy_limit_with_sltp(\n    price=entry_price,\n    sl_pips=50,\n    tp_pips=100\n)\n</code></pre></p> <p>Pitfall 3: Forgetting SL/TP direction <pre><code># ERROR: SL above entry, TP below entry (backwards!)\nticket = await sugar.buy_limit_with_sltp(\n    price=1.0840,\n    sl=1.0850,  # WRONG: Above entry\n    tp=1.0830   # WRONG: Below entry\n)\n</code></pre></p> <p>Solution: BUY = SL below, TP above <pre><code>entry = 1.0840\n\nticket = await sugar.buy_limit_with_sltp(\n    price=entry,\n    sl=entry - 0.0050,  # Below entry\n    tp=entry + 0.0100   # Above entry\n)\n</code></pre></p>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_limit_with_sltp/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Use pips for clean orders <pre><code># Pips automatically calculate correct SL/TP from entry\nticket = await sugar.buy_limit_with_sltp(\n    price=1.0840,\n    volume=0.1,\n    sl_pips=50,   # Will be 1.0790\n    tp_pips=100,  # Will be 1.0940\n    comment=\"Clean setup\"\n)\n</code></pre></p> <p>Tip 2: Place orders ahead of known levels <pre><code># Economic calendar: support at 1.0820\n# Place order before market reaches level\nticket = await sugar.buy_limit_with_sltp(\n    price=1.0820,\n    volume=0.1,\n    sl_pips=30,\n    tp_pips=90,\n    comment=\"Pre-placed at support\"\n)\n# Order waits until price drops to 1.0820\n</code></pre></p> <p>Tip 3: Check order status later <pre><code># Place order\nticket = await sugar.buy_limit_with_sltp(\n    price=1.0840,\n    sl_pips=50,\n    tp_pips=100\n)\n\n# Later: check if filled\npositions = await sugar._service.get_opened_orders()\n\nfilled = False\nfor pos in positions.position_infos:\n    if pos.ticket == ticket:\n        filled = True\n        print(f\"Order #{ticket} filled and now a position\")\n        break\n\nif not filled:\n    print(f\"Order #{ticket} still pending\")\n</code></pre></p>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_limit_with_sltp/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>sell_limit_with_sltp - SELL LIMIT with SL/TP</li> <li>buy_market_with_sltp - BUY at market with SL/TP</li> <li>buy_limit - BUY LIMIT without SL/TP</li> <li>modify_position_sltp - Modify SL/TP after fill</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_market_with_sltp/","title":"Open BUY Position with SL/TP (<code>buy_market_with_sltp</code>)","text":"<p>Sugar method: Opens BUY position at market with Stop Loss and Take Profit in one call.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.buy_market_with_sltp(symbol, volume, sl, tp, sl_pips, tp_pips, comment, magic)</code></li> <li>Returns: Position ticket number (<code>int</code>)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_market_with_sltp/#method-signature","title":"Method Signature","text":"<pre><code>async def buy_market_with_sltp(\n    self,\n    symbol: Optional[str] = None,\n    volume: float = 0.01,\n    sl: Optional[float] = None,\n    tp: Optional[float] = None,\n    sl_pips: Optional[float] = None,\n    tp_pips: Optional[float] = None,\n    comment: str = \"\",\n    magic: int = 0\n) -&gt; int\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_market_with_sltp/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> Trading symbol (uses default if not specified) <code>volume</code> <code>float</code> No <code>0.01</code> Position volume in lots <code>sl</code> <code>Optional[float]</code> No <code>None</code> Stop Loss price (absolute price) <code>tp</code> <code>Optional[float]</code> No <code>None</code> Take Profit price (absolute price) <code>sl_pips</code> <code>Optional[float]</code> No <code>None</code> Stop Loss in pips (alternative to sl) <code>tp_pips</code> <code>Optional[float]</code> No <code>None</code> Take Profit in pips (alternative to tp) <code>comment</code> <code>str</code> No <code>\"\"</code> Order comment (visible in terminal) <code>magic</code> <code>int</code> No <code>0</code> Magic number for order identification"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_market_with_sltp/#return-value","title":"Return Value","text":"Type Description <code>int</code> Position ticket number (unique identifier) <p>Raises:</p> <ul> <li><code>ValueError</code> if symbol not specified and no default set</li> <li><code>RuntimeError</code> if order execution fails (returned_code != 10009)</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_market_with_sltp/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Opens BUY position at current ASK price</li> <li>Sets Stop Loss and Take Profit automatically</li> <li>Supports both absolute prices and pips notation</li> <li>Calculates SL/TP from pips using symbol point value</li> </ul> <p>Key behaviors:</p> <ul> <li>BUY: SL below entry, TP above entry</li> <li>Can use absolute prices (sl, tp) OR pips (sl_pips, tp_pips)</li> <li>Pips calculation: <code>price \u00b1 (pips \u00d7 point \u00d7 10)</code></li> <li>Fetches symbol info if pips used</li> <li>Default slippage: 10 points</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_market_with_sltp/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.buy_market_with_sltp()\n    \u2193 fetches price\nMT5Service.get_symbol_tick()\n    \u2193 if pips provided, fetches\nMT5Sugar.get_symbol_info()\n    \u2193 calculates SL/TP prices\n    \u2193 builds OrderSendRequest with SL/TP\nMT5Service.place_order()\n    \u2193 calls\nMT5Account.order_send()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderSend()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar fetches current tick (ASK price)</li> <li>If sl_pips or tp_pips provided, fetches symbol info for point value</li> <li>Calculates SL/TP prices: SL = ask - (pips \u00d7 point \u00d7 10), TP = ask + (pips \u00d7 point \u00d7 10)</li> <li>Builds OrderSendRequest with stop_loss and take_profit fields</li> <li>Sends order through Service \u2192 Account \u2192 gRPC</li> <li>Returns ticket number on success</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:824</code></li> <li>Service: <code>src/pymt5/mt5_service.py:929</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1713</code></li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_market_with_sltp/#when-to-use","title":"When to Use","text":"<p>Use <code>buy_market_with_sltp()</code> when:</p> <ul> <li>Need risk management from entry (SL/TP required)</li> <li>Want to set SL/TP in pips (easier than calculating prices)</li> <li>Implementing automated strategies with fixed risk/reward</li> <li>Need position opened with protection immediately</li> </ul> <p>Don't use when:</p> <ul> <li>Want to add SL/TP later (use <code>buy_market()</code> then <code>modify_position_sltp()</code>)</li> <li>Need complex order modification logic</li> <li>SL/TP not required initially</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_market_with_sltp/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_market_with_sltp/#example-1-using-pips-recommended","title":"Example 1: Using Pips (Recommended)","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def buy_with_pips():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open BUY with 50 pips SL and 100 pips TP\n    ticket = await sugar.buy_market_with_sltp(\n        volume=0.1,\n        sl_pips=50,   # Stop Loss 50 pips below entry\n        tp_pips=100,  # Take Profit 100 pips above entry\n        comment=\"1:2 risk/reward\"\n    )\n\n    print(f\"BUY position opened: #{ticket}\")\n    print(f\"SL: 50 pips, TP: 100 pips (1:2 R/R)\")\n\n# Output:\n# BUY position opened: #123456795\n# SL: 50 pips, TP: 100 pips (1:2 R/R)\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_market_with_sltp/#example-2-using-absolute-prices","title":"Example 2: Using Absolute Prices","text":"<pre><code>async def buy_with_prices():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Get current price\n    ask = await sugar.get_ask()  # 1.0850\n\n    # Open BUY with specific SL/TP prices\n    ticket = await sugar.buy_market_with_sltp(\n        volume=0.1,\n        sl=1.0800,  # Stop Loss at 1.0800\n        tp=1.0950,  # Take Profit at 1.0950\n        comment=\"Support/Resistance levels\"\n    )\n\n    print(f\"BUY at {ask}\")\n    print(f\"SL: 1.0800, TP: 1.0950\")\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_market_with_sltp/#example-3-risk-management-strategy","title":"Example 3: Risk Management Strategy","text":"<pre><code>async def fixed_risk_trade():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Fixed risk: 1% account balance\n    balance = await sugar.get_balance()\n    risk_amount = balance * 0.01  # 1% risk\n\n    # Calculate volume based on 50 pip SL\n    # For EURUSD: 1 pip = $1 per 0.1 lot\n    sl_pips = 50\n    volume = risk_amount / (sl_pips * 10)  # Simplified\n\n    # Open with 1:2 risk/reward\n    ticket = await sugar.buy_market_with_sltp(\n        volume=round(volume, 2),\n        sl_pips=50,\n        tp_pips=100,  # 2x reward\n        comment=f\"1% risk = ${risk_amount:.2f}\"\n    )\n\n    print(f\"Position: #{ticket}\")\n    print(f\"Risk: ${risk_amount:.2f} (1% of ${balance})\")\n    print(f\"Volume: {volume:.2f} lots\")\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_market_with_sltp/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Mixing pips and prices <pre><code># ERROR: Don't mix sl/tp with sl_pips/tp_pips\nticket = await sugar.buy_market_with_sltp(\n    sl=1.0800,      # Absolute price\n    tp_pips=100     # Pips\n)\n# Both will be used, tp_pips overwrites tp\n</code></pre></p> <p>Solution: Use either absolute OR pips, not both <pre><code># Option 1: All pips\nticket = await sugar.buy_market_with_sltp(sl_pips=50, tp_pips=100)\n\n# Option 2: All absolute\nticket = await sugar.buy_market_with_sltp(sl=1.0800, tp=1.0950)\n</code></pre></p> <p>Pitfall 2: Wrong SL/TP direction for BUY <pre><code># ERROR: SL above entry, TP below entry (backwards!)\nask = await sugar.get_ask()  # 1.0850\n\nticket = await sugar.buy_market_with_sltp(\n    sl=1.0900,  # WRONG: SL above entry\n    tp=1.0800   # WRONG: TP below entry\n)\n# Order will likely fail or trigger immediately\n</code></pre></p> <p>Solution: Remember BUY: SL below, TP above <pre><code>ask = await sugar.get_ask()  # 1.0850\n\nticket = await sugar.buy_market_with_sltp(\n    sl=1.0800,  # Correct: SL below entry (50 pips)\n    tp=1.0950   # Correct: TP above entry (100 pips)\n)\n</code></pre></p> <p>Pitfall 3: SL/TP too close to entry <pre><code># ERROR: Broker minimum stop level not respected\ntry:\n    ticket = await sugar.buy_market_with_sltp(\n        sl_pips=1,   # Too close (broker min is 10 pips)\n        tp_pips=2\n    )\nexcept RuntimeError as e:\n    print(e)  # \"Order failed: Invalid stops\"\n</code></pre></p> <p>Solution: Check broker's minimum stop level <pre><code># Use reasonable SL/TP distances\nticket = await sugar.buy_market_with_sltp(\n    sl_pips=20,   # Above broker minimum\n    tp_pips=40\n)\n</code></pre></p>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_market_with_sltp/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Quick 1:2 risk/reward ratio <pre><code># Set TP to 2x SL for 1:2 R/R\nsl_pips = 50\ntp_pips = sl_pips * 2  # 100 pips\n\nticket = await sugar.buy_market_with_sltp(\n    volume=0.1,\n    sl_pips=sl_pips,\n    tp_pips=tp_pips,\n    comment=\"1:2 R/R\"\n)\n</code></pre></p> <p>Tip 2: Use pips for consistent risk across symbols <pre><code># Same pip values work across different symbols\nfor symbol in [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]:\n    ticket = await sugar.buy_market_with_sltp(\n        symbol=symbol,\n        volume=0.01,\n        sl_pips=50,\n        tp_pips=100\n    )\n    print(f\"{symbol} position: #{ticket}\")\n</code></pre></p> <p>Tip 3: Calculate actual risk amount <pre><code># Check actual dollar risk before trading\nsl_pips = 50\nvolume = 0.1\n\n# For EURUSD: 1 pip \u2248 $1 per 0.1 lot\nrisk_dollars = sl_pips * (volume / 0.1) * 1\n\nprint(f\"Risk: ${risk_dollars} for {volume} lots with {sl_pips} pip SL\")\n\nif risk_dollars &lt;= 100:  # Max risk check\n    ticket = await sugar.buy_market_with_sltp(\n        volume=volume,\n        sl_pips=sl_pips,\n        tp_pips=sl_pips * 2\n    )\n</code></pre></p>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/buy_market_with_sltp/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>sell_market_with_sltp - Open SELL with SL/TP</li> <li>buy_limit_with_sltp - BUY LIMIT with SL/TP</li> <li>buy_market - Open BUY without SL/TP</li> <li>modify_position_sltp - Modify SL/TP after opening</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_limit_with_sltp/","title":"Place SELL LIMIT with SL/TP (<code>sell_limit_with_sltp</code>)","text":"<p>Sugar method: Places SELL LIMIT pending order with Stop Loss and Take Profit.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.sell_limit_with_sltp(symbol, volume, price, sl, tp, sl_pips, tp_pips, comment, magic)</code></li> <li>Returns: Order ticket number (<code>int</code>)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_limit_with_sltp/#method-signature","title":"Method Signature","text":"<pre><code>async def sell_limit_with_sltp(\n    self,\n    symbol: Optional[str] = None,\n    volume: float = 0.01,\n    price: float = 0.0,\n    sl: Optional[float] = None,\n    tp: Optional[float] = None,\n    sl_pips: Optional[float] = None,\n    tp_pips: Optional[float] = None,\n    comment: str = \"\",\n    magic: int = 0\n) -&gt; int\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_limit_with_sltp/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> Trading symbol (uses default if not specified) <code>volume</code> <code>float</code> No <code>0.01</code> Order volume in lots <code>price</code> <code>float</code> Yes <code>0.0</code> Limit price (must be ABOVE current BID) <code>sl</code> <code>Optional[float]</code> No <code>None</code> Stop Loss price (absolute price) <code>tp</code> <code>Optional[float]</code> No <code>None</code> Take Profit price (absolute price) <code>sl_pips</code> <code>Optional[float]</code> No <code>None</code> Stop Loss in pips from entry (alternative to sl) <code>tp_pips</code> <code>Optional[float]</code> No <code>None</code> Take Profit in pips from entry (alternative to tp) <code>comment</code> <code>str</code> No <code>\"\"</code> Order comment (visible in terminal) <code>magic</code> <code>int</code> No <code>0</code> Magic number for order identification"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_limit_with_sltp/#return-value","title":"Return Value","text":"Type Description <code>int</code> Order ticket number (unique identifier) <p>Raises:</p> <ul> <li><code>ValueError</code> if symbol not specified and no default set</li> <li><code>RuntimeError</code> if order placement fails (returned_code != 10009)</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_limit_with_sltp/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Places SELL LIMIT order above current price</li> <li>Sets SL/TP on the pending order</li> <li>When order fills, SL/TP automatically active</li> <li>Supports both absolute prices and pips from entry</li> </ul> <p>Key behaviors:</p> <ul> <li>SELL LIMIT price must be ABOVE current BID</li> <li>SL/TP calculated from entry price (not current price)</li> <li>SELL: SL above entry, TP below entry</li> <li>Pips calculation uses entry price as reference</li> <li>Order stays pending until price reached</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_limit_with_sltp/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.sell_limit_with_sltp()\n    \u2193 if pips provided, fetches\nMT5Sugar.get_symbol_info()\n    \u2193 calculates SL/TP from entry price\n    \u2193 builds OrderSendRequest with SL/TP\nMT5Service.place_order()\n    \u2193 calls\nMT5Account.order_send()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderSend()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar validates entry price parameter</li> <li>If sl_pips or tp_pips provided, fetches symbol info for point value</li> <li>Calculates SL/TP from entry price: SL = price + (pips \u00d7 point \u00d7 10), TP = price - (pips \u00d7 point \u00d7 10)</li> <li>Builds OrderSendRequest with TMT5_ORDER_TYPE_SELL_LIMIT and SL/TP</li> <li>Sends order through Service \u2192 Account \u2192 gRPC</li> <li>Returns order ticket, order stays pending</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1059</code></li> <li>Service: <code>src/pymt5/mt5_service.py:929</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1713</code></li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_limit_with_sltp/#when-to-use","title":"When to Use","text":"<p>Use <code>sell_limit_with_sltp()</code> when:</p> <ul> <li>Want to sell at higher price with automatic risk management</li> <li>Planning entry with predefined SL/TP</li> <li>Sell the rally strategy with protection</li> <li>Setting up orders before market moves</li> </ul> <p>Don't use when:</p> <ul> <li>Need immediate entry (use <code>sell_market_with_sltp()</code>)</li> <li>Want to modify SL/TP after order fills</li> <li>Price may never reach limit level</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_limit_with_sltp/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_limit_with_sltp/#example-1-sell-rally-with-pips-protection","title":"Example 1: Sell Rally with Pips Protection","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def sell_rally_protected():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Current BID: 1.0850\n    # Place SELL LIMIT at 1.0870 with SL/TP\n    ticket = await sugar.sell_limit_with_sltp(\n        price=1.0870,\n        volume=0.1,\n        sl_pips=50,   # 50 pips above 1.0870 entry\n        tp_pips=100,  # 100 pips below 1.0870 entry\n        comment=\"Sell rally protected\"\n    )\n\n    print(f\"SELL LIMIT order: #{ticket} at 1.0870\")\n    print(f\"When filled: SL=1.0920, TP=1.0770\")\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_limit_with_sltp/#example-2-resistance-level-entry","title":"Example 2: Resistance Level Entry","text":"<pre><code>async def sell_at_resistance():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Resistance at 1.0900\n    resistance = 1.0900\n\n    # Place SELL LIMIT at resistance with absolute SL/TP\n    ticket = await sugar.sell_limit_with_sltp(\n        price=resistance,\n        volume=0.1,\n        sl=resistance + 0.0030,  # SL 30 pips above resistance\n        tp=resistance - 0.0100,  # TP 100 pips below\n        comment=\"Resistance rejection\"\n    )\n\n    print(f\"Order at resistance {resistance}: #{ticket}\")\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_limit_with_sltp/#example-3-profit-target-ladder","title":"Example 3: Profit Target Ladder","text":"<pre><code>async def profit_ladder():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open SELL position first\n    sell_ticket = await sugar.sell_market(volume=0.3)\n\n    # Then place SELL LIMIT orders as profit targets\n    bid = await sugar.get_bid()  # 1.0850\n\n    targets = [\n        (0.1, bid + 0.0030, 50),   # +30 pips: close 0.1, SL 50\n        (0.1, bid + 0.0050, 30),   # +50 pips: close 0.1, SL 30\n        (0.1, bid + 0.0100, 20)    # +100 pips: close 0.1, SL 20\n    ]\n\n    tickets = []\n    for volume, entry, sl_pips in targets:\n        ticket = await sugar.sell_limit_with_sltp(\n            price=entry,\n            volume=volume,\n            sl_pips=sl_pips,\n            tp_pips=50,\n            comment=f\"Target at {entry}\"\n        )\n        tickets.append(ticket)\n        print(f\"Profit target #{ticket} at {entry}\")\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_limit_with_sltp/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Entry price below current BID <pre><code># ERROR: SELL LIMIT must be ABOVE current price\nbid = await sugar.get_bid()  # 1.0850\n\ntry:\n    ticket = await sugar.sell_limit_with_sltp(\n        price=1.0840,  # Below current BID\n        sl_pips=50,\n        tp_pips=100\n    )\nexcept RuntimeError as e:\n    print(e)  # \"Order failed: Invalid price\"\n</code></pre></p> <p>Solution: Ensure limit price above current BID <pre><code>bid = await sugar.get_bid()  # 1.0850\nentry_price = bid + 0.0020   # 1.0870 (above)\n\nticket = await sugar.sell_limit_with_sltp(\n    price=entry_price,\n    sl_pips=50,\n    tp_pips=100\n)\n</code></pre></p> <p>Pitfall 2: Wrong SL/TP direction for SELL <pre><code># ERROR: SL below entry, TP above entry (backwards!)\nticket = await sugar.sell_limit_with_sltp(\n    price=1.0870,\n    sl=1.0850,  # WRONG: Below entry\n    tp=1.0900   # WRONG: Above entry\n)\n</code></pre></p> <p>Solution: SELL = SL above, TP below <pre><code>entry = 1.0870\n\nticket = await sugar.sell_limit_with_sltp(\n    price=entry,\n    sl=entry + 0.0050,  # Above entry (1.0920)\n    tp=entry - 0.0100   # Below entry (1.0770)\n)\n</code></pre></p> <p>Pitfall 3: Calculating from current price instead of entry <pre><code># WRONG: SL/TP relative to current, not entry\nbid = await sugar.get_bid()  # 1.0850\nentry = 1.0870\n\nticket = await sugar.sell_limit_with_sltp(\n    price=entry,\n    sl=bid + 0.0050,  # WRONG: From current (1.0900)\n    tp=bid - 0.0100   # WRONG: From current (1.0750)\n)\n# When order fills at 1.0870, SL is only 30 pips away!\n</code></pre></p> <p>Solution: Use pips or calculate from entry price <pre><code>entry = 1.0870\n\n# Option 1: Use pips (automatic)\nticket = await sugar.sell_limit_with_sltp(\n    price=entry,\n    sl_pips=50,   # 50 pips from entry\n    tp_pips=100   # 100 pips from entry\n)\n\n# Option 2: Calculate from entry\nticket = await sugar.sell_limit_with_sltp(\n    price=entry,\n    sl=entry + 0.0050,  # From entry\n    tp=entry - 0.0100   # From entry\n)\n</code></pre></p>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_limit_with_sltp/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Pre-place orders at key levels <pre><code># Place orders before market reaches resistance\nresistances = [1.0900, 1.0950, 1.1000]\n\ntickets = []\nfor resistance in resistances:\n    ticket = await sugar.sell_limit_with_sltp(\n        price=resistance,\n        volume=0.01,\n        sl_pips=50,\n        tp_pips=100,\n        comment=f\"R at {resistance}\"\n    )\n    tickets.append(ticket)\n\nprint(f\"Placed {len(tickets)} resistance orders\")\n</code></pre></p> <p>Tip 2: Dynamic SL based on entry distance <pre><code># Tighter SL for closer targets\nbid = await sugar.get_bid()  # 1.0850\n\ntargets = [\n    (1.0860, 30),  # Close target = tight SL\n    (1.0880, 40),  # Medium target = medium SL\n    (1.0900, 50)   # Far target = wider SL\n]\n\nfor entry, sl_pips in targets:\n    ticket = await sugar.sell_limit_with_sltp(\n        price=entry,\n        volume=0.01,\n        sl_pips=sl_pips,\n        tp_pips=100,\n        comment=f\"Entry {entry}, SL {sl_pips}\"\n    )\n</code></pre></p> <p>Tip 3: Combine with position scaling <pre><code># Open small position, add more with limits\ninitial = await sugar.sell_market_with_sltp(\n    volume=0.05,\n    sl_pips=50,\n    tp_pips=150\n)\n\n# Add more if price rallies to resistance\nbid = await sugar.get_bid()\nadd_on = await sugar.sell_limit_with_sltp(\n    price=bid + 0.0020,  # 20 pips above\n    volume=0.05,\n    sl_pips=50,\n    tp_pips=150,\n    comment=\"Add-on position\"\n)\n\nprint(f\"Initial: #{initial}, Add-on: #{add_on}\")\n</code></pre></p>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_limit_with_sltp/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>buy_limit_with_sltp - BUY LIMIT with SL/TP</li> <li>sell_market_with_sltp - SELL at market with SL/TP</li> <li>sell_limit - SELL LIMIT without SL/TP</li> <li>modify_position_sltp - Modify SL/TP after fill</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_market_with_sltp/","title":"Open SELL Position with SL/TP (<code>sell_market_with_sltp</code>)","text":"<p>Sugar method: Opens SELL position at market with Stop Loss and Take Profit in one call.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.sell_market_with_sltp(symbol, volume, sl, tp, sl_pips, tp_pips, comment, magic)</code></li> <li>Returns: Position ticket number (<code>int</code>)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_market_with_sltp/#method-signature","title":"Method Signature","text":"<pre><code>async def sell_market_with_sltp(\n    self,\n    symbol: Optional[str] = None,\n    volume: float = 0.01,\n    sl: Optional[float] = None,\n    tp: Optional[float] = None,\n    sl_pips: Optional[float] = None,\n    tp_pips: Optional[float] = None,\n    comment: str = \"\",\n    magic: int = 0\n) -&gt; int\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_market_with_sltp/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> Trading symbol (uses default if not specified) <code>volume</code> <code>float</code> No <code>0.01</code> Position volume in lots <code>sl</code> <code>Optional[float]</code> No <code>None</code> Stop Loss price (absolute price) <code>tp</code> <code>Optional[float]</code> No <code>None</code> Take Profit price (absolute price) <code>sl_pips</code> <code>Optional[float]</code> No <code>None</code> Stop Loss in pips (alternative to sl) <code>tp_pips</code> <code>Optional[float]</code> No <code>None</code> Take Profit in pips (alternative to tp) <code>comment</code> <code>str</code> No <code>\"\"</code> Order comment (visible in terminal) <code>magic</code> <code>int</code> No <code>0</code> Magic number for order identification"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_market_with_sltp/#return-value","title":"Return Value","text":"Type Description <code>int</code> Position ticket number (unique identifier) <p>Raises:</p> <ul> <li><code>ValueError</code> if symbol not specified and no default set</li> <li><code>RuntimeError</code> if order execution fails (returned_code != 10009)</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_market_with_sltp/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Opens SELL position at current BID price</li> <li>Sets Stop Loss and Take Profit automatically</li> <li>Supports both absolute prices and pips notation</li> <li>Calculates SL/TP from pips using symbol point value</li> </ul> <p>Key behaviors:</p> <ul> <li>SELL: SL above entry, TP below entry</li> <li>Can use absolute prices (sl, tp) OR pips (sl_pips, tp_pips)</li> <li>Pips calculation: SL = bid + (pips \u00d7 point \u00d7 10), TP = bid - (pips \u00d7 point \u00d7 10)</li> <li>Fetches symbol info if pips used</li> <li>Default slippage: 10 points</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_market_with_sltp/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.sell_market_with_sltp()\n    \u2193 fetches price\nMT5Service.get_symbol_tick()\n    \u2193 if pips provided, fetches\nMT5Sugar.get_symbol_info()\n    \u2193 calculates SL/TP prices\n    \u2193 builds OrderSendRequest with SL/TP\nMT5Service.place_order()\n    \u2193 calls\nMT5Account.order_send()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderSend()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar fetches current tick (BID price)</li> <li>If sl_pips or tp_pips provided, fetches symbol info for point value</li> <li>Calculates SL/TP prices: SL = bid + (pips \u00d7 point \u00d7 10), TP = bid - (pips \u00d7 point \u00d7 10)</li> <li>Builds OrderSendRequest with stop_loss and take_profit fields</li> <li>Sends order through Service \u2192 Account \u2192 gRPC</li> <li>Returns ticket number on success</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:903</code></li> <li>Service: <code>src/pymt5/mt5_service.py:929</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1713</code></li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_market_with_sltp/#when-to-use","title":"When to Use","text":"<p>Use <code>sell_market_with_sltp()</code> when:</p> <ul> <li>Need risk management from entry (SL/TP required)</li> <li>Want to set SL/TP in pips (easier than calculating prices)</li> <li>Implementing automated strategies with fixed risk/reward</li> <li>Expecting price to fall with defined risk</li> </ul> <p>Don't use when:</p> <ul> <li>Want to add SL/TP later (use <code>sell_market()</code> then <code>modify_position_sltp()</code>)</li> <li>Need complex order modification logic</li> <li>SL/TP not required initially</li> </ul>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_market_with_sltp/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_market_with_sltp/#example-1-using-pips-recommended","title":"Example 1: Using Pips (Recommended)","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def sell_with_pips():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open SELL with 50 pips SL and 100 pips TP\n    ticket = await sugar.sell_market_with_sltp(\n        volume=0.1,\n        sl_pips=50,   # Stop Loss 50 pips above entry\n        tp_pips=100,  # Take Profit 100 pips below entry\n        comment=\"1:2 risk/reward\"\n    )\n\n    print(f\"SELL position opened: #{ticket}\")\n    print(f\"SL: 50 pips, TP: 100 pips (1:2 R/R)\")\n\n# Output:\n# SELL position opened: #123456796\n# SL: 50 pips, TP: 100 pips (1:2 R/R)\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_market_with_sltp/#example-2-using-absolute-prices","title":"Example 2: Using Absolute Prices","text":"<pre><code>async def sell_with_prices():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Get current price\n    bid = await sugar.get_bid()  # 1.0850\n\n    # Open SELL with specific SL/TP prices\n    ticket = await sugar.sell_market_with_sltp(\n        volume=0.1,\n        sl=1.0900,  # Stop Loss at 1.0900 (above entry)\n        tp=1.0750,  # Take Profit at 1.0750 (below entry)\n        comment=\"Resistance/Support levels\"\n    )\n\n    print(f\"SELL at {bid}\")\n    print(f\"SL: 1.0900, TP: 1.0750\")\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_market_with_sltp/#example-3-downtrend-strategy","title":"Example 3: Downtrend Strategy","text":"<pre><code>async def downtrend_trade():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Check if in downtrend (simplified)\n    bid = await sugar.get_bid()\n\n    # Open SELL expecting continuation\n    ticket = await sugar.sell_market_with_sltp(\n        volume=0.1,\n        sl_pips=40,   # Tight stop\n        tp_pips=120,  # 3x reward\n        comment=\"Downtrend continuation\"\n    )\n\n    print(f\"SELL position: #{ticket}\")\n    print(f\"Risk/Reward: 1:3\")\n\n    # Monitor position\n    floating_profit = await sugar.get_floating_profit()\n    print(f\"Current P&amp;L: ${floating_profit:.2f}\")\n</code></pre>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_market_with_sltp/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Wrong SL/TP direction for SELL <pre><code># ERROR: SL below entry, TP above entry (backwards!)\nbid = await sugar.get_bid()  # 1.0850\n\nticket = await sugar.sell_market_with_sltp(\n    sl=1.0800,  # WRONG: SL below entry\n    tp=1.0900   # WRONG: TP above entry\n)\n# Order will likely fail or trigger immediately\n</code></pre></p> <p>Solution: Remember SELL: SL above, TP below <pre><code>bid = await sugar.get_bid()  # 1.0850\n\nticket = await sugar.sell_market_with_sltp(\n    sl=1.0900,  # Correct: SL above entry (50 pips)\n    tp=1.0750   # Correct: TP below entry (100 pips)\n)\n</code></pre></p> <p>Pitfall 2: Confusing BUY and SELL SL/TP logic <pre><code># BUY: SL below, TP above\nbuy_ticket = await sugar.buy_market_with_sltp(\n    sl_pips=50,  # 50 pips BELOW entry\n    tp_pips=100  # 100 pips ABOVE entry\n)\n\n# SELL: SL above, TP below (opposite!)\nsell_ticket = await sugar.sell_market_with_sltp(\n    sl_pips=50,  # 50 pips ABOVE entry\n    tp_pips=100  # 100 pips BELOW entry\n)\n</code></pre></p> <p>Pitfall 3: Using same absolute prices for multiple trades <pre><code># ERROR: Market moved, old SL/TP prices invalid\nfirst_bid = await sugar.get_bid()  # 1.0850\nticket1 = await sugar.sell_market_with_sltp(\n    sl=1.0900,\n    tp=1.0750\n)\n\n# 1 hour later, price at 1.0800\nticket2 = await sugar.sell_market_with_sltp(\n    sl=1.0900,  # Still valid but very far (100 pips!)\n    tp=1.0750   # Already hit! Order fails\n)\n</code></pre></p> <p>Solution: Use pips for consistent behavior <pre><code># Works regardless of current price\nticket1 = await sugar.sell_market_with_sltp(sl_pips=50, tp_pips=100)\n\n# Later, still works correctly\nticket2 = await sugar.sell_market_with_sltp(sl_pips=50, tp_pips=100)\n</code></pre></p>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_market_with_sltp/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Trailing SELL with improving entry <pre><code># If price moving down, wait for better entry\ninitial_bid = await sugar.get_bid()  # 1.0850\n\n# Wait 60 seconds\nawait asyncio.sleep(60)\n\nnew_bid = await sugar.get_bid()  # 1.0840\n\n# Better entry (price dropped)\nif new_bid &lt; initial_bid:\n    ticket = await sugar.sell_market_with_sltp(\n        volume=0.1,\n        sl_pips=50,\n        tp_pips=100,\n        comment=\"Improved entry\"\n    )\n</code></pre></p> <p>Tip 2: Combine with resistance levels <pre><code># Sell at resistance with SL above resistance\nresistance = 1.0900\nbid = await sugar.get_bid()\n\n# Only trade if near resistance\nif abs(bid - resistance) &lt; 0.0010:  # Within 10 pips\n    ticket = await sugar.sell_market_with_sltp(\n        volume=0.1,\n        sl=resistance + 0.0010,  # SL 10 pips above resistance\n        tp=resistance - 0.0100,  # TP 100 pips below\n        comment=\"Sell at resistance\"\n    )\n</code></pre></p> <p>Tip 3: Scale in with multiple positions <pre><code># Open multiple SELL positions with different TP levels\nbase_sl_pips = 50\n\ntickets = []\nfor i in range(3):\n    tp_pips = 50 + (i * 25)  # 50, 75, 100 pips TP\n\n    ticket = await sugar.sell_market_with_sltp(\n        volume=0.01,\n        sl_pips=base_sl_pips,\n        tp_pips=tp_pips,\n        comment=f\"Scaled TP {tp_pips}\"\n    )\n    tickets.append(ticket)\n\nprint(f\"Opened {len(tickets)} scaled positions\")\n</code></pre></p>"},{"location":"MT5Sugar/5.%20Trading_With_SLTP/sell_market_with_sltp/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>buy_market_with_sltp - Open BUY with SL/TP</li> <li>sell_limit_with_sltp - SELL LIMIT with SL/TP</li> <li>sell_market - Open SELL without SL/TP</li> <li>modify_position_sltp - Modify SL/TP after opening</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_all_positions/","title":"Close All Positions (<code>close_all_positions</code>)","text":"<p>Sugar method: Closes all open positions, optionally filtered by symbol.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.close_all_positions(symbol: Optional[str] = None)</code></li> <li>Returns: Number of positions closed (<code>int</code>)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_all_positions/#method-signature","title":"Method Signature","text":"<pre><code>async def close_all_positions(self, symbol: Optional[str] = None) -&gt; int\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/close_all_positions/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> If specified, close only positions for this symbol"},{"location":"MT5Sugar/6.%20Position_Management/close_all_positions/#return-value","title":"Return Value","text":"Type Description <code>int</code> Number of positions successfully closed"},{"location":"MT5Sugar/6.%20Position_Management/close_all_positions/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Fetches all open positions from terminal</li> <li>Closes each position one by one</li> <li>Optionally filters by symbol</li> <li>Continues closing even if some fail</li> </ul> <p>Key behaviors:</p> <ul> <li>Returns count of successfully closed positions</li> <li>Filters by symbol if provided</li> <li>Continues on individual failures (error logged)</li> <li>Safe for empty position list (returns 0)</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_all_positions/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.close_all_positions()\n    \u2193 fetches all positions\nMT5Service.get_opened_orders()\n    \u2193 iterates and closes each\nMT5Sugar.close_position() (for each)\n    \u2193 calls\nMT5Service.close_order()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderClose()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.get_opened_orders() to fetch all positions</li> <li>Sugar iterates through position_infos list</li> <li>If symbol filter provided, skips positions not matching symbol</li> <li>For each position, calls close_position() internally</li> <li>Counts successful closes (where close_position returned True)</li> <li>Continues even if individual closes fail (logs error)</li> <li>Returns total count of successful closes</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1165</code></li> <li>Service: <code>src/pymt5/mt5_service.py:742</code></li> <li>Internal close: <code>src/pymt5/mt5_sugar.py:1141</code></li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_all_positions/#when-to-use","title":"When to Use","text":"<p>Use <code>close_all_positions()</code> when:</p> <ul> <li>End of trading day/session cleanup</li> <li>Emergency exit all positions</li> <li>Strategy reset or restart</li> <li>Account-wide risk management</li> </ul> <p>Don't use when:</p> <ul> <li>Want to close specific position (use <code>close_position()</code>)</li> <li>Need partial closes (use <code>close_position_partial()</code>)</li> <li>Want to keep some positions open</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_all_positions/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/6.%20Position_Management/close_all_positions/#example-1-close-all-positions-no-filter","title":"Example 1: Close All Positions (No Filter)","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def close_everything():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open several positions\n    ticket1 = await sugar.buy_market(\"EURUSD\", volume=0.1)\n    ticket2 = await sugar.sell_market(\"GBPUSD\", volume=0.1)\n    ticket3 = await sugar.buy_market(\"USDJPY\", volume=0.1)\n\n    print(f\"Opened positions: #{ticket1}, #{ticket2}, #{ticket3}\")\n\n    # Close all positions\n    closed_count = await sugar.close_all_positions()\n\n    print(f\"Closed {closed_count} positions\")\n\n# Output:\n# Opened positions: #123456, #123457, #123458\n# Closed 3 positions\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/close_all_positions/#example-2-close-positions-for-specific-symbol","title":"Example 2: Close Positions for Specific Symbol","text":"<pre><code>async def close_symbol_positions():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n\n    await sugar.connect()\n\n    # Open positions on different symbols\n    await sugar.buy_market(\"EURUSD\", volume=0.1)\n    await sugar.buy_market(\"EURUSD\", volume=0.1)\n    await sugar.sell_market(\"GBPUSD\", volume=0.1)\n\n    # Close only EURUSD positions\n    eurusd_closed = await sugar.close_all_positions(symbol=\"EURUSD\")\n\n    print(f\"Closed {eurusd_closed} EURUSD positions\")\n    print(\"GBPUSD position still open\")\n\n# Output:\n# Closed 2 EURUSD positions\n# GBPUSD position still open\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/close_all_positions/#example-3-end-of-day-cleanup","title":"Example 3: End of Day Cleanup","text":"<pre><code>import asyncio\nfrom datetime import datetime, time\n\nasync def end_of_day_close():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Trading logic during the day...\n    # (open positions, monitor, etc.)\n\n    # At 5 PM, close all positions\n    while True:\n        now = datetime.now().time()\n        close_time = time(17, 0)  # 5:00 PM\n\n        if now &gt;= close_time:\n            print(\"End of day - closing all positions\")\n\n            closed_count = await sugar.close_all_positions()\n            print(f\"Closed {closed_count} positions\")\n\n            # Show final balance\n            balance = await sugar.get_balance()\n            print(f\"Final balance: ${balance}\")\n\n            break\n\n        await asyncio.sleep(60)  # Check every minute\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/close_all_positions/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Expecting all positions to close <pre><code># Some positions may fail to close\nclosed = await sugar.close_all_positions()\n\n# If you had 5 positions, closed might be 4 or 3\n# (some may fail due to market conditions, etc.)\n</code></pre></p> <p>Solution: Check return value and verify <pre><code># Get count before closing\npositions_data = await sugar._service.get_opened_orders()\ninitial_count = len(positions_data.position_infos)\n\n# Close all\nclosed_count = await sugar.close_all_positions()\n\nif closed_count &lt; initial_count:\n    print(f\"Warning: Only {closed_count}/{initial_count} closed\")\n    # Retry or investigate\n</code></pre></p> <p>Pitfall 2: Closing positions with pending orders <pre><code># close_all_positions() only closes POSITIONS, not PENDING ORDERS\nawait sugar.buy_limit(price=1.0840)  # Pending order\nawait sugar.buy_market()              # Open position\n\nclosed = await sugar.close_all_positions()  # Only closes position\n# Pending order still active!\n</code></pre></p> <p>Solution: Cancel pending orders separately <pre><code># Close positions\nawait sugar.close_all_positions()\n\n# Cancel pending orders (if method exists)\n# await sugar.cancel_all_orders()\n</code></pre></p> <p>Pitfall 3: Not handling partial failures <pre><code># If 1 out of 5 fails, you might not notice\nclosed = await sugar.close_all_positions()\n# Silently continues, returns 4 instead of 5\n</code></pre></p> <p>Solution: Log and check <pre><code>positions_before = await sugar._service.get_opened_orders()\ninitial = len(positions_before.position_infos)\n\nclosed = await sugar.close_all_positions()\n\nif closed &lt; initial:\n    print(f\"Failed to close {initial - closed} positions\")\n\n    # Check which positions remain\n    positions_after = await sugar._service.get_opened_orders()\n    for pos in positions_after.position_infos:\n        print(f\"Position #{pos.ticket} still open\")\n</code></pre></p>"},{"location":"MT5Sugar/6.%20Position_Management/close_all_positions/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Get total profit before closing <pre><code># Check total profit/loss before closing all\ntotal_profit = await sugar.get_floating_profit()\n\nprint(f\"Total P&amp;L: ${total_profit:.2f}\")\n\n# Close all positions\nclosed = await sugar.close_all_positions()\n\nprint(f\"Closed {closed} positions with ${total_profit:.2f} P&amp;L\")\n</code></pre></p> <p>Tip 2: Close by symbol in sequence <pre><code># Close positions symbol by symbol for better control\nsymbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\n\ntotal_closed = 0\nfor symbol in symbols:\n    count = await sugar.close_all_positions(symbol=symbol)\n    print(f\"{symbol}: closed {count} positions\")\n    total_closed += count\n\nprint(f\"Total closed: {total_closed}\")\n</code></pre></p> <p>Tip 3: Retry on partial failure <pre><code># Retry closing remaining positions\nmax_retries = 3\n\nfor attempt in range(max_retries):\n    positions_data = await sugar._service.get_opened_orders()\n    remaining = len(positions_data.position_infos)\n\n    if remaining == 0:\n        print(\"All positions closed\")\n        break\n\n    print(f\"Attempt {attempt + 1}: Closing {remaining} positions\")\n    closed = await sugar.close_all_positions()\n\n    if closed == remaining:\n        print(\"All positions closed\")\n        break\n\n    await asyncio.sleep(2)  # Wait before retry\n</code></pre></p>"},{"location":"MT5Sugar/6.%20Position_Management/close_all_positions/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>close_position - Close specific position by ticket</li> <li>close_position_partial - Close position partially</li> <li>get_floating_profit - Get total unrealized profit</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_position/","title":"Close Position Completely (<code>close_position</code>)","text":"<p>Sugar method: Closes open position by ticket number in one call.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.close_position(ticket: int)</code></li> <li>Returns: <code>True</code> if closed successfully, <code>False</code> otherwise</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_position/#method-signature","title":"Method Signature","text":"<pre><code>async def close_position(self, ticket: int) -&gt; bool\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/close_position/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>ticket</code> <code>int</code> Yes - Position ticket number to close"},{"location":"MT5Sugar/6.%20Position_Management/close_position/#return-value","title":"Return Value","text":"Type Description <code>bool</code> <code>True</code> if position closed (return_code == 10009), <code>False</code> otherwise"},{"location":"MT5Sugar/6.%20Position_Management/close_position/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Closes entire position by ticket number</li> <li>Creates opposite market order automatically (BUY\u2192SELL, SELL\u2192BUY)</li> <li>Returns boolean success status</li> <li>Validates return code from terminal</li> </ul> <p>Key behaviors:</p> <ul> <li>BUY positions closed with SELL at BID price</li> <li>SELL positions closed with BUY at ASK price</li> <li>Returns False if close failed (no exception)</li> <li>Position removed from terminal on success</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_position/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.close_position()\n    \u2193 builds OrderCloseRequest\nMT5Service.close_order()\n    \u2193 calls\nMT5Account.order_close()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderClose()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar creates OrderCloseRequest with ticket</li> <li>Sugar calls Service.close_order()</li> <li>Service forwards to Account.order_close()</li> <li>Account sends gRPC request to terminal</li> <li>Terminal creates opposite market order to close position</li> <li>Sugar checks return_code == 10009 (TRADE_RETCODE_DONE)</li> <li>Returns True on success, False on failure</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1141</code></li> <li>Service: <code>src/pymt5/mt5_service.py:996</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1803</code></li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_position/#when-to-use","title":"When to Use","text":"<p>Use <code>close_position()</code> when:</p> <ul> <li>Need to exit position completely</li> <li>Take profit or cut losses manually</li> <li>Emergency position closure</li> <li>End of trading session cleanup</li> </ul> <p>Don't use when:</p> <ul> <li>Want partial close (use <code>close_position_partial()</code>)</li> <li>Want to close all positions (use <code>close_all_positions()</code>)</li> <li>Position already closed</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_position/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/6.%20Position_Management/close_position/#example-1-basic-position-close","title":"Example 1: Basic Position Close","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def simple_close():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open position\n    ticket = await sugar.buy_market(volume=0.1)\n    print(f\"Position opened: #{ticket}\")\n\n    # Close position\n    success = await sugar.close_position(ticket)\n\n    if success:\n        print(f\"Position #{ticket} closed successfully\")\n    else:\n        print(f\"Failed to close position #{ticket}\")\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/close_position/#example-2-close-with-profit-check","title":"Example 2: Close with Profit Check","text":"<pre><code>async def close_with_profit_check():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open position\n    ticket = await sugar.buy_market(volume=0.1)\n\n    # Monitor profit\n    while True:\n        profit = await sugar.get_floating_profit()\n        print(f\"Current profit: ${profit:.2f}\")\n\n        # Close if profit &gt;= $50 or loss &gt;= $20\n        if profit &gt;= 50 or profit &lt;= -20:\n            success = await sugar.close_position(ticket)\n\n            if success:\n                print(f\"Position closed at ${profit:.2f}\")\n                break\n            else:\n                print(\"Close failed, retrying...\")\n\n        await asyncio.sleep(5)\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/close_position/#example-3-close-multiple-positions","title":"Example 3: Close Multiple Positions","text":"<pre><code>async def close_multiple():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open multiple positions\n    tickets = []\n    for i in range(3):\n        ticket = await sugar.buy_market(volume=0.01)\n        tickets.append(ticket)\n        print(f\"Position {i+1}: #{ticket}\")\n\n    # Close each position\n    for ticket in tickets:\n        success = await sugar.close_position(ticket)\n\n        if success:\n            print(f\"Closed #{ticket}\")\n        else:\n            print(f\"Failed #{ticket}\")\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/close_position/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Not checking return value <pre><code># BAD: Assuming close always succeeds\nawait sugar.close_position(ticket)\n# Position may still be open if close failed!\n</code></pre></p> <p>Solution: Always check return value <pre><code>success = await sugar.close_position(ticket)\n\nif not success:\n    print(f\"Position {ticket} failed to close\")\n    # Handle failure (retry, alert, etc.)\n</code></pre></p> <p>Pitfall 2: Trying to close already closed position <pre><code># Close position\nawait sugar.close_position(ticket)\n\n# ERROR: Trying to close again\nawait sugar.close_position(ticket)  # Returns False\n</code></pre></p> <p>Solution: Track closed positions <pre><code>success = await sugar.close_position(ticket)\n\nif success:\n    closed_tickets.add(ticket)\n\n# Later: check before closing\nif ticket not in closed_tickets:\n    await sugar.close_position(ticket)\n</code></pre></p> <p>Pitfall 3: Ignoring market conditions <pre><code># Market closed on weekend\nsuccess = await sugar.close_position(ticket)  # Returns False\n</code></pre></p> <p>Solution: Check market hours or handle gracefully <pre><code>success = await sugar.close_position(ticket)\n\nif not success:\n    # Could be market closed, connection issue, etc.\n    print(\"Close failed - check market status\")\n</code></pre></p>"},{"location":"MT5Sugar/6.%20Position_Management/close_position/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Use with try-except for robustness <pre><code>try:\n    success = await sugar.close_position(ticket)\n\n    if success:\n        print(\"Position closed\")\n    else:\n        print(\"Close returned False\")\n\nexcept Exception as e:\n    print(f\"Exception during close: {e}\")\n</code></pre></p> <p>Tip 2: Combine with position profit check <pre><code># Get final profit before closing\nprofit = await sugar.get_floating_profit()\n\nsuccess = await sugar.close_position(ticket)\n\nif success:\n    print(f\"Closed with profit: ${profit:.2f}\")\n</code></pre></p> <p>Tip 3: Close positions by magic number <pre><code># Get all positions\npositions_data = await sugar._service.get_opened_orders()\n\n# Close only positions with specific magic\nmagic_to_close = 12345\n\nfor pos in positions_data.position_infos:\n    if pos.expert_id == magic_to_close:\n        success = await sugar.close_position(pos.ticket)\n        print(f\"Closed magic {magic_to_close}: #{pos.ticket}\")\n</code></pre></p>"},{"location":"MT5Sugar/6.%20Position_Management/close_position/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>close_all_positions - Close all open positions</li> <li>close_position_partial - Close position partially</li> <li>buy_market - Open BUY position</li> <li>sell_market - Open SELL position</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_position_partial/","title":"Close Position Partially (<code>close_position_partial</code>)","text":"<p>Sugar method: Closes part of a position by specified volume.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.close_position_partial(ticket, volume)</code></li> <li>Returns: <code>True</code> if partial close successful, <code>False</code> otherwise</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_position_partial/#method-signature","title":"Method Signature","text":"<pre><code>async def close_position_partial(self, ticket: int, volume: float) -&gt; bool\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/close_position_partial/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>ticket</code> <code>int</code> Yes - Position ticket number <code>volume</code> <code>float</code> Yes - Volume to close (must be less than position volume)"},{"location":"MT5Sugar/6.%20Position_Management/close_position_partial/#return-value","title":"Return Value","text":"Type Description <code>bool</code> <code>True</code> if partial close successful (return_code == 10009), <code>False</code> otherwise <p>Raises:</p> <ul> <li><code>ValueError</code> if position not found</li> <li><code>ValueError</code> if volume &gt;= position volume</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_position_partial/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Closes specified volume of an open position</li> <li>Remaining volume stays as original position</li> <li>Creates opposite market order for specified volume</li> <li>Original position ticket remains with reduced volume</li> </ul> <p>Key behaviors:</p> <ul> <li>Volume must be less than position volume</li> <li>BUY positions: closes with SELL at BID price</li> <li>SELL positions: closes with BUY at ASK price</li> <li>Remaining position keeps same ticket number</li> <li>Uses default 10 points slippage</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_position_partial/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.close_position_partial()\n    \u2193 fetches position\nMT5Service.get_opened_orders()\n    \u2193 validates volume &lt; position.volume\n    \u2193 determines opposite order type\n    \u2193 fetches current price\nMT5Service.get_symbol_tick()\n    \u2193 builds OrderSendRequest (opposite direction)\nMT5Service.place_order()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderSend()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar fetches all positions to find matching ticket</li> <li>Raises ValueError if position not found</li> <li>Validates volume &lt; position.volume (raises if &gt;=)</li> <li>Determines opposite order type (BUY\u2192SELL, SELL\u2192BUY)</li> <li>Fetches current tick price (BID for SELL, ASK for BUY)</li> <li>Creates OrderSendRequest with opposite operation and partial volume</li> <li>Sends order through Service.place_order()</li> <li>Returns True if returned_code == 10009</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1241</code></li> <li>Service: <code>src/pymt5/mt5_service.py:929</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1713</code></li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_position_partial/#when-to-use","title":"When to Use","text":"<p>Use <code>close_position_partial()</code> when:</p> <ul> <li>Taking partial profits at targets</li> <li>Scaling out of positions gradually</li> <li>Reducing exposure while keeping position open</li> <li>Implementing tiered exit strategies</li> </ul> <p>Don't use when:</p> <ul> <li>Want to close entire position (use <code>close_position()</code>)</li> <li>Volume equals or exceeds position volume</li> <li>Position already closed</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/close_position_partial/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/6.%20Position_Management/close_position_partial/#example-1-take-half-profit","title":"Example 1: Take Half Profit","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def take_half_profit():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open 0.1 lot position\n    ticket = await sugar.buy_market(volume=0.10)\n    print(f\"Position opened: #{ticket}, 0.10 lots\")\n\n    # Wait for profit (simplified)\n    profit = await sugar.get_floating_profit()\n    while profit &lt; 50:\n        await asyncio.sleep(5)\n        profit = await sugar.get_floating_profit()\n\n    # Close half the position\n    success = await sugar.close_position_partial(ticket, volume=0.05)\n\n    if success:\n        print(\"Closed 0.05 lots, 0.05 lots remaining\")\n    else:\n        print(\"Partial close failed\")\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/close_position_partial/#example-2-tiered-exit-strategy","title":"Example 2: Tiered Exit Strategy","text":"<pre><code>async def tiered_exit():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open 0.3 lot position\n    ticket = await sugar.buy_market(volume=0.30)\n    entry_price = await sugar.get_ask()\n\n    print(f\"Position: #{ticket}, 0.30 lots at {entry_price}\")\n\n    # Exit in 3 stages\n    targets = [\n        (entry_price + 0.0030, 0.10, \"Target 1: +30 pips\"),\n        (entry_price + 0.0060, 0.10, \"Target 2: +60 pips\"),\n        (entry_price + 0.0100, 0.10, \"Target 3: +100 pips\")\n    ]\n\n    for target_price, close_volume, label in targets:\n        # Wait for price to reach target\n        while True:\n            current = await sugar.get_bid()\n\n            if current &gt;= target_price:\n                success = await sugar.close_position_partial(\n                    ticket,\n                    volume=close_volume\n                )\n\n                if success:\n                    print(f\"{label} - Closed {close_volume} lots\")\n                    break\n\n            await asyncio.sleep(5)\n\n    print(\"All targets hit, position fully closed\")\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/close_position_partial/#example-3-risk-reduction-on-profit","title":"Example 3: Risk Reduction on Profit","text":"<pre><code>async def reduce_risk_on_profit():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open position\n    ticket = await sugar.buy_market(volume=0.20)\n    entry_price = await sugar.get_ask()\n\n    # Close 75% when in 50 pips profit, let 25% run\n    while True:\n        current_price = await sugar.get_bid()\n        profit_pips = (current_price - entry_price) / 0.0001\n\n        if profit_pips &gt;= 50:\n            # Close 0.15 lots (75%), keep 0.05 lots (25%)\n            success = await sugar.close_position_partial(\n                ticket,\n                volume=0.15\n            )\n\n            if success:\n                print(\"Closed 75%, letting 25% run with trailing stop\")\n\n                # Move remaining 0.05 lots to breakeven\n                await sugar.modify_position_sltp(\n                    ticket,\n                    sl=entry_price,\n                    tp=None\n                )\n                break\n\n        await asyncio.sleep(5)\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/close_position_partial/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Volume too large <pre><code># Position has 0.10 lots\nticket = await sugar.buy_market(volume=0.10)\n\n# ERROR: Can't close 0.10 or more\ntry:\n    await sugar.close_position_partial(ticket, volume=0.10)\nexcept ValueError as e:\n    print(e)  # \"Partial volume must be less than position volume\"\n</code></pre></p> <p>Solution: Always close less than position volume <pre><code># Close part, not all\nawait sugar.close_position_partial(ticket, volume=0.05)  # OK\nawait sugar.close_position_partial(ticket, volume=0.09)  # OK\n</code></pre></p> <p>Pitfall 2: Not tracking remaining volume <pre><code># Open 0.10 lots\nticket = await sugar.buy_market(volume=0.10)\n\n# Close 0.05 lots\nawait sugar.close_position_partial(ticket, volume=0.05)\n\n# ERROR: Can't close 0.06 (only 0.05 remaining)\nawait sugar.close_position_partial(ticket, volume=0.06)\n</code></pre></p> <p>Solution: Track or check remaining volume <pre><code># Check position volume before closing\npositions_data = await sugar._service.get_opened_orders()\n\nfor pos in positions_data.position_infos:\n    if pos.ticket == ticket:\n        remaining = pos.volume\n        print(f\"Remaining volume: {remaining}\")\n\n        # Close only what remains\n        close_vol = min(0.05, remaining)\n        await sugar.close_position_partial(ticket, close_vol)\n</code></pre></p> <p>Pitfall 3: Multiple partial closes not updating volume <pre><code># Open 0.30 lots\nticket = await sugar.buy_market(volume=0.30)\n\n# Close in steps\nawait sugar.close_position_partial(ticket, 0.10)  # 0.20 left\nawait sugar.close_position_partial(ticket, 0.10)  # 0.10 left\nawait sugar.close_position_partial(ticket, 0.10)  # 0.00 left\n\n# ERROR: Position fully closed, ticket invalid for further partials\nawait sugar.close_position_partial(ticket, 0.05)\n</code></pre></p> <p>Solution: Check if position still exists <pre><code># After each partial close, verify position exists\nsuccess = await sugar.close_position_partial(ticket, 0.10)\n\nif success:\n    # Check if position still exists\n    positions_data = await sugar._service.get_opened_orders()\n    still_open = any(p.ticket == ticket for p in positions_data.position_infos)\n\n    if not still_open:\n        print(\"Position fully closed\")\n</code></pre></p>"},{"location":"MT5Sugar/6.%20Position_Management/close_position_partial/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Scale out with percentage <pre><code># Get current position volume\npositions_data = await sugar._service.get_opened_orders()\n\nfor pos in positions_data.position_infos:\n    if pos.ticket == ticket:\n        # Close 50% of position\n        close_volume = pos.volume * 0.5\n\n        await sugar.close_position_partial(ticket, close_volume)\n        print(f\"Closed 50%: {close_volume} lots\")\n</code></pre></p> <p>Tip 2: Combine with SL adjustment <pre><code># Close partial and move SL to breakeven\nentry_price = 1.0850\n\n# Close 50%\nawait sugar.close_position_partial(ticket, volume=0.05)\n\n# Move SL to breakeven for remaining\nawait sugar.modify_position_sltp(ticket, sl=entry_price, tp=None)\n</code></pre></p> <p>Tip 3: Pyramid exit strategy <pre><code># Exit in pyramid fashion (larger amounts first)\ntotal_volume = 0.30\n\nexits = [\n    (0.15, \"50%\"),  # Close half\n    (0.10, \"33%\"),  # Close third of remaining\n    (0.05, \"17%\")   # Let small amount run\n]\n\nfor volume, label in exits:\n    success = await sugar.close_position_partial(ticket, volume)\n\n    if success:\n        print(f\"Closed {label}: {volume} lots\")\n\n    await asyncio.sleep(60)  # Wait between exits\n</code></pre></p>"},{"location":"MT5Sugar/6.%20Position_Management/close_position_partial/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>close_position - Close entire position</li> <li>close_all_positions - Close all positions</li> <li>modify_position_sltp - Modify SL/TP</li> <li>buy_market - Open BUY position</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sl/","title":"Modify Position Stop Loss Only (<code>modify_position_sl</code>)","text":"<p>Sugar method: Convenience method to modify only the Stop Loss of a position.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.modify_position_sl(ticket, sl)</code></li> <li>Returns: <code>True</code> if modified successfully, <code>False</code> otherwise</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sl/#method-signature","title":"Method Signature","text":"<pre><code>async def modify_position_sl(self, ticket: int, sl: float) -&gt; bool\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sl/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>ticket</code> <code>int</code> Yes - Position ticket number <code>sl</code> <code>float</code> Yes - New Stop Loss price"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sl/#return-value","title":"Return Value","text":"Type Description <code>bool</code> <code>True</code> if modification successful (return_code == 10009), <code>False</code> otherwise <p>Raises: - <code>ValueError</code> if position with given ticket not found</p>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sl/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Modifies only the Stop Loss price</li> <li>Keeps Take Profit unchanged</li> <li>Convenience wrapper around <code>modify_position_sltp()</code></li> <li>Cleaner syntax for SL-only modifications</li> </ul> <p>Key behaviors:</p> <ul> <li>Take Profit remains unchanged</li> <li>Must respect broker's minimum stop level</li> <li>SL must be valid for position direction</li> <li>Internally calls <code>modify_position_sltp(ticket, sl=sl, tp=None)</code></li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sl/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.modify_position_sl()\n    \u2193 calls\nMT5Sugar.modify_position_sltp(ticket, sl=sl, tp=None)\n    \u2193 fetches position\nMT5Service.get_opened_orders()\n    \u2193 builds OrderModifyRequest\nMT5Service.modify_order()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderModify()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls modify_position_sltp() with sl parameter and tp=None</li> <li>See modify_position_sltp for full chain</li> <li>Take Profit value is preserved from current position</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1299</code></li> <li>Internal call: <code>src/pymt5/mt5_sugar.py:1196</code></li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sl/#when-to-use","title":"When to Use","text":"<p>Use <code>modify_position_sl()</code> when:</p> <ul> <li>Only need to change Stop Loss</li> <li>Implementing trailing stops</li> <li>Moving SL to breakeven</li> <li>Take Profit should stay unchanged</li> </ul> <p>Don't use when:</p> <ul> <li>Need to modify both SL and TP (use <code>modify_position_sltp()</code>)</li> <li>Only want to modify TP (use <code>modify_position_tp()</code>)</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sl/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sl/#example-1-move-sl-to-breakeven","title":"Example 1: Move SL to Breakeven","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def breakeven_sl():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open position at 1.0850\n    ticket = await sugar.buy_market_with_sltp(\n        volume=0.1,\n        sl_pips=50,\n        tp_pips=100\n    )\n\n    entry_price = await sugar.get_ask()  # 1.0850\n\n    # Wait for 30 pips profit\n    while True:\n        current = await sugar.get_bid()\n\n        if current &gt;= entry_price + 0.0030:\n            # Move SL to breakeven (TP stays at original target)\n            success = await sugar.modify_position_sl(ticket, sl=entry_price)\n\n            if success:\n                print(f\"SL moved to breakeven: {entry_price}\")\n                break\n\n        await asyncio.sleep(5)\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sl/#example-2-tighten-stop-loss","title":"Example 2: Tighten Stop Loss","text":"<pre><code>async def tighten_sl():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open with 50 pip SL\n    ticket = await sugar.buy_market_with_sltp(\n        volume=0.1,\n        sl_pips=50,\n        tp_pips=100\n    )\n\n    entry = await sugar.get_ask()\n    initial_sl = entry - 0.0050  # 50 pips\n\n    print(f\"Initial SL: {initial_sl}\")\n\n    # After some time, tighten to 30 pips\n    await asyncio.sleep(300)\n\n    new_sl = entry - 0.0030  # 30 pips\n    success = await sugar.modify_position_sl(ticket, sl=new_sl)\n\n    if success:\n        print(f\"SL tightened to: {new_sl}\")\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sl/#example-3-simple-trailing-stop","title":"Example 3: Simple Trailing Stop","text":"<pre><code>async def simple_trailing():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open position\n    ticket = await sugar.buy_market(volume=0.1)\n\n    entry = await sugar.get_ask()\n    trail_distance = 0.0030  # 30 pips\n\n    current_sl = entry - 0.0050  # Initial SL\n    await sugar.modify_position_sl(ticket, sl=current_sl)\n\n    # Trail the stop\n    highest = entry\n\n    while True:\n        price = await sugar.get_bid()\n\n        if price &gt; highest:\n            highest = price\n            new_sl = highest - trail_distance\n\n            # Only move SL up\n            if new_sl &gt; current_sl:\n                success = await sugar.modify_position_sl(ticket, sl=new_sl)\n\n                if success:\n                    current_sl = new_sl\n                    print(f\"SL trailed to: {new_sl:.5f}\")\n\n        await asyncio.sleep(5)\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sl/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Forgetting TP remains unchanged <pre><code># If position had TP at 1.0950, it stays at 1.0950\nawait sugar.modify_position_sl(ticket, sl=1.0800)\n\n# TP is still 1.0950, not removed\n</code></pre></p> <p>Solution: To also modify TP, use modify_position_sltp() <pre><code># Modify both\nawait sugar.modify_position_sltp(ticket, sl=1.0800, tp=1.1000)\n</code></pre></p> <p>Pitfall 2: Wrong SL direction <pre><code># BUY position at 1.0850\nticket = await sugar.buy_market()\n\n# ERROR: SL above entry price\nawait sugar.modify_position_sl(ticket, sl=1.0900)  # Wrong direction\n</code></pre></p> <p>Solution: Remember BUY: SL below entry <pre><code>await sugar.modify_position_sl(ticket, sl=1.0800)  # Correct\n</code></pre></p> <p>Pitfall 3: Not checking return value <pre><code># Modification may fail (broker limits, etc.)\nawait sugar.modify_position_sl(ticket, sl=1.0800)\n# SL may not have changed if it failed\n</code></pre></p> <p>Solution: Check return value <pre><code>success = await sugar.modify_position_sl(ticket, sl=1.0800)\n\nif not success:\n    print(\"SL modification failed\")\n</code></pre></p>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sl/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Remove SL by setting to 0 <pre><code># Remove Stop Loss (keep TP)\nawait sugar.modify_position_sl(ticket, sl=0.0)\n</code></pre></p> <p>Tip 2: Batch modify SL for all positions <pre><code># Move all positions to breakeven\npositions_data = await sugar._service.get_opened_orders()\n\nfor pos in positions_data.position_infos:\n    if pos.profit &gt; 0:\n        # Move SL to entry price\n        await sugar.modify_position_sl(pos.ticket, sl=pos.price_open)\n        print(f\"Position #{pos.ticket} moved to breakeven\")\n</code></pre></p> <p>Tip 3: Incremental SL tightening <pre><code># Gradually tighten SL as price moves\nentry = 1.0850\nstops = [1.0830, 1.0840, 1.0845, 1.0850]  # Progressively tighter\n\nfor new_sl in stops:\n    # Wait for price to justify tighter SL\n    while await sugar.get_bid() &lt; new_sl + 0.0030:\n        await asyncio.sleep(10)\n\n    await sugar.modify_position_sl(ticket, sl=new_sl)\n    print(f\"SL tightened to {new_sl}\")\n</code></pre></p>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sl/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>modify_position_tp - Modify only Take Profit</li> <li>modify_position_sltp - Modify both SL and TP</li> <li>buy_market_with_sltp - Open with SL/TP</li> <li>close_position - Close position</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sltp/","title":"Modify Position SL/TP (<code>modify_position_sltp</code>)","text":"<p>Sugar method: Modifies Stop Loss and/or Take Profit of an open position.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.modify_position_sltp(ticket, sl, tp)</code></li> <li>Returns: <code>True</code> if modified successfully, <code>False</code> otherwise</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sltp/#method-signature","title":"Method Signature","text":"<pre><code>async def modify_position_sltp(\n    self,\n    ticket: int,\n    sl: Optional[float] = None,\n    tp: Optional[float] = None\n) -&gt; bool\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sltp/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>ticket</code> <code>int</code> Yes - Position ticket number <code>sl</code> <code>Optional[float]</code> No <code>None</code> New Stop Loss price (None to keep current) <code>tp</code> <code>Optional[float]</code> No <code>None</code> New Take Profit price (None to keep current)"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sltp/#return-value","title":"Return Value","text":"Type Description <code>bool</code> <code>True</code> if modification successful (return_code == 10009), <code>False</code> otherwise <p>Raises: - <code>ValueError</code> if position with given ticket not found</p>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sltp/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Fetches current position by ticket</li> <li>Modifies Stop Loss and/or Take Profit</li> <li>Preserves unmodified values</li> <li>Validates modification with terminal</li> </ul> <p>Key behaviors:</p> <ul> <li>Pass <code>None</code> to keep current SL or TP unchanged</li> <li>Must respect broker's minimum stop level</li> <li>SL/TP must be valid for position direction</li> <li>Returns False if modification failed</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sltp/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.modify_position_sltp()\n    \u2193 fetches position\nMT5Service.get_opened_orders()\n    \u2193 finds position, preserves current SL/TP\n    \u2193 builds OrderModifyRequest\nMT5Service.modify_order()\n    \u2193 calls\nMT5Account.order_modify()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderModify()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar fetches all positions via Service.get_opened_orders()</li> <li>Sugar searches for position with matching ticket</li> <li>If not found, raises ValueError</li> <li>Sugar preserves current SL/TP if new values are None</li> <li>Sugar creates OrderModifyRequest with ticket and new SL/TP</li> <li>Sugar calls Service.modify_order()</li> <li>Service forwards to Account.order_modify()</li> <li>Returns True if returned_code == 10009, False otherwise</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1196</code></li> <li>Service: <code>src/pymt5/mt5_service.py:963</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1758</code></li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sltp/#when-to-use","title":"When to Use","text":"<p>Use <code>modify_position_sltp()</code> when:</p> <ul> <li>Adjusting Stop Loss after position moves in profit</li> <li>Setting Take Profit after opening position</li> <li>Implementing trailing stop strategies</li> <li>Risk management adjustments</li> </ul> <p>Don't use when:</p> <ul> <li>Want to modify only SL (use <code>modify_position_sl()</code> for clarity)</li> <li>Want to modify only TP (use <code>modify_position_tp()</code> for clarity)</li> <li>Position already closed</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sltp/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sltp/#example-1-add-sltp-to-existing-position","title":"Example 1: Add SL/TP to Existing Position","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def add_stops():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open position without SL/TP\n    ticket = await sugar.buy_market(volume=0.1)\n    print(f\"Position opened: #{ticket}\")\n\n    # Add SL/TP after opening\n    success = await sugar.modify_position_sltp(\n        ticket=ticket,\n        sl=1.0800,  # Stop Loss at 1.0800\n        tp=1.0950   # Take Profit at 1.0950\n    )\n\n    if success:\n        print(\"SL/TP added successfully\")\n    else:\n        print(\"Failed to add SL/TP\")\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sltp/#example-2-move-stop-loss-to-breakeven","title":"Example 2: Move Stop Loss to Breakeven","text":"<pre><code>async def breakeven_stop():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open BUY position at 1.0850\n    ticket = await sugar.buy_market_with_sltp(\n        volume=0.1,\n        sl_pips=50,   # Initial SL 50 pips\n        tp_pips=100\n    )\n\n    entry_price = await sugar.get_ask()  # 1.0850\n\n    # Monitor position\n    while True:\n        current_price = await sugar.get_bid()\n\n        # Move SL to breakeven when in 30 pips profit\n        if current_price &gt;= entry_price + 0.0030:\n            success = await sugar.modify_position_sltp(\n                ticket=ticket,\n                sl=entry_price,  # Move SL to entry (breakeven)\n                tp=None          # Keep TP unchanged\n            )\n\n            if success:\n                print(\"Stop Loss moved to breakeven\")\n                break\n\n        await asyncio.sleep(5)\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sltp/#example-3-trailing-stop","title":"Example 3: Trailing Stop","text":"<pre><code>async def trailing_stop():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open BUY position\n    ticket = await sugar.buy_market(volume=0.1)\n\n    entry_price = await sugar.get_ask()\n    trailing_distance = 0.0030  # 30 pips\n\n    best_price = entry_price\n    current_sl = entry_price - 0.0050  # Initial SL 50 pips\n\n    # Set initial SL\n    await sugar.modify_position_sltp(ticket, sl=current_sl, tp=None)\n\n    # Trail the stop\n    while True:\n        current_price = await sugar.get_bid()\n\n        # Update best price\n        if current_price &gt; best_price:\n            best_price = current_price\n\n            # Calculate new SL\n            new_sl = best_price - trailing_distance\n\n            # Only move SL up, never down\n            if new_sl &gt; current_sl:\n                success = await sugar.modify_position_sltp(\n                    ticket=ticket,\n                    sl=new_sl,\n                    tp=None\n                )\n\n                if success:\n                    current_sl = new_sl\n                    print(f\"SL trailed to {new_sl:.5f}\")\n\n        await asyncio.sleep(5)\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sltp/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Wrong SL/TP direction <pre><code># BUY position opened at 1.0850\nticket = await sugar.buy_market()\n\n# ERROR: SL above entry, TP below entry (backwards!)\nawait sugar.modify_position_sltp(\n    ticket=ticket,\n    sl=1.0900,  # WRONG: SL above entry\n    tp=1.0800   # WRONG: TP below entry\n)\n# Modification will likely fail\n</code></pre></p> <p>Solution: Remember BUY: SL below, TP above <pre><code># BUY position at 1.0850\nawait sugar.modify_position_sltp(\n    ticket=ticket,\n    sl=1.0800,  # Correct: SL below entry\n    tp=1.0950   # Correct: TP above entry\n)\n</code></pre></p> <p>Pitfall 2: Not handling position not found <pre><code># Position already closed or invalid ticket\ntry:\n    await sugar.modify_position_sltp(ticket=999999, sl=1.0800)\nexcept ValueError as e:\n    print(e)  # \"Position 999999 not found\"\n</code></pre></p> <p>Solution: Check position exists first <pre><code>positions_data = await sugar._service.get_opened_orders()\n\nposition_exists = any(pos.ticket == ticket for pos in positions_data.position_infos)\n\nif position_exists:\n    await sugar.modify_position_sltp(ticket, sl=1.0800)\nelse:\n    print(f\"Position {ticket} not found\")\n</code></pre></p> <p>Pitfall 3: SL/TP too close to current price <pre><code># Broker requires minimum 10 pips stop level\nbid = await sugar.get_bid()  # 1.0850\n\n# ERROR: SL only 2 pips away (broker minimum is 10)\nawait sugar.modify_position_sltp(\n    ticket=ticket,\n    sl=bid - 0.0002  # Too close!\n)\n# Returns False\n</code></pre></p> <p>Solution: Respect broker's minimum stop level <pre><code>bid = await sugar.get_bid()\n\n# Use at least broker minimum (e.g., 10 pips)\nawait sugar.modify_position_sltp(\n    ticket=ticket,\n    sl=bid - 0.0010  # 10 pips away\n)\n</code></pre></p>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sltp/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Modify only what you need <pre><code># Only modify SL, keep TP unchanged\nawait sugar.modify_position_sltp(ticket, sl=1.0800, tp=None)\n\n# Only modify TP, keep SL unchanged\nawait sugar.modify_position_sltp(ticket, sl=None, tp=1.0950)\n\n# Modify both\nawait sugar.modify_position_sltp(ticket, sl=1.0800, tp=1.0950)\n</code></pre></p> <p>Tip 2: Remove SL/TP by setting to 0 <pre><code># Remove Stop Loss and Take Profit\nawait sugar.modify_position_sltp(ticket, sl=0.0, tp=0.0)\n</code></pre></p> <p>Tip 3: Batch modify multiple positions <pre><code># Modify SL for all positions\npositions_data = await sugar._service.get_opened_orders()\n\nfor pos in positions_data.position_infos:\n    # Move SL to breakeven for all profitable positions\n    if pos.profit &gt; 0:\n        await sugar.modify_position_sltp(\n            ticket=pos.ticket,\n            sl=pos.price_open,  # Entry price\n            tp=None\n        )\n        print(f\"Position #{pos.ticket} moved to breakeven\")\n</code></pre></p>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_sltp/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>modify_position_sl - Modify only Stop Loss</li> <li>modify_position_tp - Modify only Take Profit</li> <li>buy_market_with_sltp - Open with SL/TP</li> <li>close_position - Close position completely</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_tp/","title":"Modify Position Take Profit Only (<code>modify_position_tp</code>)","text":"<p>Sugar method: Convenience method to modify only the Take Profit of a position.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.modify_position_tp(ticket, tp)</code></li> <li>Returns: <code>True</code> if modified successfully, <code>False</code> otherwise</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_tp/#method-signature","title":"Method Signature","text":"<pre><code>async def modify_position_tp(self, ticket: int, tp: float) -&gt; bool\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_tp/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>ticket</code> <code>int</code> Yes - Position ticket number <code>tp</code> <code>float</code> Yes - New Take Profit price"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_tp/#return-value","title":"Return Value","text":"Type Description <code>bool</code> <code>True</code> if modification successful (return_code == 10009), <code>False</code> otherwise <p>Raises: - <code>ValueError</code> if position with given ticket not found</p>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_tp/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Modifies only the Take Profit price</li> <li>Keeps Stop Loss unchanged</li> <li>Convenience wrapper around <code>modify_position_sltp()</code></li> <li>Cleaner syntax for TP-only modifications</li> </ul> <p>Key behaviors:</p> <ul> <li>Stop Loss remains unchanged</li> <li>Must respect broker's minimum stop level</li> <li>TP must be valid for position direction</li> <li>Internally calls <code>modify_position_sltp(ticket, sl=None, tp=tp)</code></li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_tp/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.modify_position_tp()\n    \u2193 calls\nMT5Sugar.modify_position_sltp(ticket, sl=None, tp=tp)\n    \u2193 fetches position\nMT5Service.get_opened_orders()\n    \u2193 builds OrderModifyRequest\nMT5Service.modify_order()\n    \u2193 gRPC protobuf\nTradingHelperService.OrderModify()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls modify_position_sltp() with tp parameter and sl=None</li> <li>See modify_position_sltp for full chain</li> <li>Stop Loss value is preserved from current position</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1315</code></li> <li>Internal call: <code>src/pymt5/mt5_sugar.py:1196</code></li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_tp/#when-to-use","title":"When to Use","text":"<p>Use <code>modify_position_tp()</code> when:</p> <ul> <li>Only need to change Take Profit</li> <li>Extending profit target</li> <li>Adding TP to position without TP</li> <li>Stop Loss should stay unchanged</li> </ul> <p>Don't use when:</p> <ul> <li>Need to modify both SL and TP (use <code>modify_position_sltp()</code>)</li> <li>Only want to modify SL (use <code>modify_position_sl()</code>)</li> </ul>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_tp/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/6.%20Position_Management/modify_position_tp/#example-1-add-tp-to-position","title":"Example 1: Add TP to Position","text":"<pre><code>from pymt5 import MT5Sugar\n\nasync def add_tp():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open position without TP\n    ticket = await sugar.buy_market_with_sltp(\n        volume=0.1,\n        sl_pips=50,\n        tp_pips=None  # No TP initially\n    )\n\n    print(f\"Position opened: #{ticket} with SL only\")\n\n    # Later, add Take Profit\n    entry = 1.0850\n    tp_price = entry + 0.0100  # 100 pips TP\n\n    success = await sugar.modify_position_tp(ticket, tp=tp_price)\n\n    if success:\n        print(f\"TP added at {tp_price}\")\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_tp/#example-2-extend-profit-target","title":"Example 2: Extend Profit Target","text":"<pre><code>async def extend_tp():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open with conservative TP\n    ticket = await sugar.buy_market_with_sltp(\n        volume=0.1,\n        sl_pips=50,\n        tp_pips=50  # Conservative 1:1 R/R\n    )\n\n    entry = await sugar.get_ask()\n    initial_tp = entry + 0.0050\n\n    print(f\"Initial TP: {initial_tp} (50 pips)\")\n\n    # If trend continues, extend TP\n    await asyncio.sleep(300)\n\n    current = await sugar.get_bid()\n    if current &gt; entry + 0.0030:\n        # Extend TP to 100 pips\n        new_tp = entry + 0.0100\n\n        success = await sugar.modify_position_tp(ticket, tp=new_tp)\n\n        if success:\n            print(f\"TP extended to {new_tp} (100 pips)\")\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_tp/#example-3-dynamic-tp-based-on-volatility","title":"Example 3: Dynamic TP Based on Volatility","text":"<pre><code>async def dynamic_tp():\n    sugar = MT5Sugar(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\",\n        default_symbol=\"EURUSD\"\n    )\n\n    await sugar.connect()\n\n    # Open position\n    ticket = await sugar.buy_market_with_sltp(\n        volume=0.1,\n        sl_pips=50,\n        tp_pips=None\n    )\n\n    entry = await sugar.get_ask()\n\n    # Calculate TP based on recent price movement (simplified)\n    # In real scenario, use ATR or other volatility measure\n    spread = await sugar.get_spread()\n    volatility_multiplier = 3\n\n    # Set TP to 3x current spread\n    tp_distance = spread * volatility_multiplier\n    tp_price = entry + tp_distance\n\n    success = await sugar.modify_position_tp(ticket, tp=tp_price)\n\n    if success:\n        print(f\"Dynamic TP set at {tp_price}\")\n        print(f\"TP distance: {tp_distance:.5f}\")\n</code></pre>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_tp/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Forgetting SL remains unchanged <pre><code># If position had SL at 1.0800, it stays at 1.0800\nawait sugar.modify_position_tp(ticket, tp=1.0950)\n\n# SL is still 1.0800, not removed\n</code></pre></p> <p>Solution: To also modify SL, use modify_position_sltp() <pre><code># Modify both\nawait sugar.modify_position_sltp(ticket, sl=1.0800, tp=1.0950)\n</code></pre></p> <p>Pitfall 2: Wrong TP direction <pre><code># BUY position at 1.0850\nticket = await sugar.buy_market()\n\n# ERROR: TP below entry price\nawait sugar.modify_position_tp(ticket, tp=1.0800)  # Wrong direction\n</code></pre></p> <p>Solution: Remember BUY: TP above entry <pre><code>await sugar.modify_position_tp(ticket, tp=1.0950)  # Correct\n</code></pre></p> <p>Pitfall 3: Setting TP too close <pre><code># Broker requires minimum distance\nbid = await sugar.get_bid()  # 1.0850\n\n# ERROR: TP only 2 pips away (broker minimum is 10)\nawait sugar.modify_position_tp(ticket, tp=bid + 0.0002)\n# Returns False\n</code></pre></p> <p>Solution: Respect broker's minimum stop level <pre><code>bid = await sugar.get_bid()\n\n# Use at least broker minimum (e.g., 10 pips)\nawait sugar.modify_position_tp(ticket, tp=bid + 0.0010)\n</code></pre></p>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_tp/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Remove TP by setting to 0 <pre><code># Remove Take Profit (keep SL)\nawait sugar.modify_position_tp(ticket, tp=0.0)\n</code></pre></p> <p>Tip 2: Scale TP based on position size <pre><code># Larger positions = closer TP (less risk)\npositions_data = await sugar._service.get_opened_orders()\n\nfor pos in positions_data.position_infos:\n    if pos.volume &gt;= 0.5:\n        # Large position: conservative TP (50 pips)\n        tp = pos.price_open + 0.0050\n    else:\n        # Small position: aggressive TP (100 pips)\n        tp = pos.price_open + 0.0100\n\n    # For BUY positions\n    if pos.type == 0:  # BUY\n        await sugar.modify_position_tp(pos.ticket, tp=tp)\n</code></pre></p> <p>Tip 3: Progressive TP adjustment <pre><code># Extend TP as position moves in profit\nentry = 1.0850\ntps = [1.0900, 1.0950, 1.1000]  # Progressive targets\n\nfor new_tp in tps:\n    # Wait for price to move closer to current TP\n    while await sugar.get_bid() &lt; new_tp - 0.0030:\n        await asyncio.sleep(10)\n\n    await sugar.modify_position_tp(ticket, tp=new_tp)\n    print(f\"TP extended to {new_tp}\")\n</code></pre></p>"},{"location":"MT5Sugar/6.%20Position_Management/modify_position_tp/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>modify_position_sl - Modify only Stop Loss</li> <li>modify_position_sltp - Modify both SL and TP</li> <li>buy_market_with_sltp - Open with SL/TP</li> <li>close_position - Close position</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/count_open_positions/","title":"Count Open Positions (<code>count_open_positions</code>)","text":"<p>Sugar method: Returns number of open positions (optionally filtered by symbol).</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.count_open_positions(symbol: Optional[str] = None)</code></li> <li>Returns: Number of positions as integer</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/count_open_positions/#method-signature","title":"Method Signature","text":"<pre><code>async def count_open_positions(self, symbol: Optional[str] = None) -&gt; int\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/count_open_positions/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> Filter by symbol (None = count all)"},{"location":"MT5Sugar/7.%20Position_Information/count_open_positions/#return-value","title":"Return Value","text":"Type Description <code>int</code> Number of open positions (0 if none)"},{"location":"MT5Sugar/7.%20Position_Information/count_open_positions/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Counts open positions</li> <li>Optionally filters by symbol</li> <li>Returns integer count</li> <li>Returns 0 if no positions</li> </ul> <p>Key behaviors:</p> <ul> <li>No symbol: counts ALL positions</li> <li>With symbol: counts only that symbol</li> <li>Case-sensitive symbol matching</li> <li>Always returns integer (never None)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/count_open_positions/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.count_open_positions()\n    \u2193 calls\nMT5Service.get_opened_orders(sort_mode=0)\n    \u2193 counts len(position_infos)\n    \u2193 or sum(1 for pos if pos.symbol == symbol)\n    \u2193 returns count\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.get_opened_orders()</li> <li>If no symbol: returns len(position_infos)</li> <li>If symbol provided: counts matching positions</li> <li>Returns integer count</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1368</code></li> <li>Service: <code>src/pymt5/mt5_service.py:742</code></li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/count_open_positions/#when-to-use","title":"When to Use","text":"<p>Use <code>count_open_positions()</code> when:</p> <ul> <li>Need number of positions</li> <li>Limiting maximum positions</li> <li>Monitoring position count</li> <li>Statistics and reporting</li> </ul> <p>Don't use when:</p> <ul> <li>Only checking existence (use <code>has_open_position()</code>)</li> <li>Need position details (use <code>get_open_positions()</code>)</li> <li>Need specific position (use <code>get_position_by_ticket()</code>)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/count_open_positions/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/7.%20Position_Information/count_open_positions/#example-1-basic-position-count","title":"Example 1: Basic Position Count","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def check_count():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Count all positions\n    total = await sugar.count_open_positions()\n    print(f\"Total open positions: {total}\")\n\n    # Count by symbol\n    eurusd_count = await sugar.count_open_positions(\"EURUSD\")\n    gbpusd_count = await sugar.count_open_positions(\"GBPUSD\")\n\n    print(f\"EURUSD: {eurusd_count}\")\n    print(f\"GBPUSD: {gbpusd_count}\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/count_open_positions/#example-2-limit-maximum-positions","title":"Example 2: Limit Maximum Positions","text":"<pre><code>async def limit_positions():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    max_positions = 5\n\n    # Check before opening\n    current_count = await sugar.count_open_positions()\n\n    if current_count &lt; max_positions:\n        ticket = await sugar.buy_market(volume=0.1)\n        print(f\"Opened position #{ticket} ({current_count + 1}/{max_positions})\")\n    else:\n        print(f\"Maximum positions reached ({max_positions})\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/count_open_positions/#example-3-symbol-specific-limits","title":"Example 3: Symbol-Specific Limits","text":"<pre><code>async def symbol_limits():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n    max_per_symbol = 3\n\n    # Count EURUSD positions\n    eurusd_count = await sugar.count_open_positions(symbol)\n\n    if eurusd_count &lt; max_per_symbol:\n        ticket = await sugar.buy_market(symbol, volume=0.1)\n        print(f\"Opened {symbol} position ({eurusd_count + 1}/{max_per_symbol})\")\n    else:\n        print(f\"Max {symbol} positions reached\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/count_open_positions/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Case-sensitive symbol <pre><code># ERROR: Symbol case matters\ncount = await sugar.count_open_positions(\"eurusd\")\n# Returns 0 if positions are \"EURUSD\"\n</code></pre></p> <p>Solution: Use uppercase symbols <pre><code>count = await sugar.count_open_positions(\"EURUSD\")\n</code></pre></p> <p>Pitfall 2: Expecting None instead of 0 <pre><code># count_open_positions returns 0, not None\ncount = await sugar.count_open_positions()\n\nif count:  # This works (0 is falsy)\n    print(\"Have positions\")\n</code></pre></p> <p>Solution: Compare explicitly or use truthiness <pre><code># Both work\nif count &gt; 0:\n    print(\"Have positions\")\n\nif count:\n    print(\"Have positions\")\n</code></pre></p> <p>Pitfall 3: Not caching count <pre><code># Inefficient: counting repeatedly in loop\nfor _ in range(100):\n    if await sugar.count_open_positions() &lt; 5:\n        # Fetches all positions every iteration\n        pass\n</code></pre></p> <p>Solution: Cache count if checking multiple times <pre><code>count = await sugar.count_open_positions()\n\nfor _ in range(100):\n    if count &lt; 5:\n        # Use cached value\n        pass\n</code></pre></p>"},{"location":"MT5Sugar/7.%20Position_Information/count_open_positions/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Position capacity check</p> <pre><code>async def get_remaining_capacity(sugar, max_positions=10):\n    \"\"\"Get how many more positions can be opened.\"\"\"\n    current = await sugar.count_open_positions()\n    remaining = max(0, max_positions - current)\n    return remaining\n\n# Usage\nremaining = await get_remaining_capacity(sugar)\nprint(f\"Can open {remaining} more positions\")\n</code></pre> <p>Tip 2: Symbol distribution analysis <pre><code># Analyze position distribution across symbols\nall_positions = await sugar.get_open_positions()\nsymbols = set(p.symbol for p in all_positions)\n\nfor symbol in symbols:\n    count = await sugar.count_open_positions(symbol)\n    print(f\"{symbol}: {count} positions\")\n</code></pre></p> <p>Tip 3: Wait until count reaches target <pre><code>import asyncio\n\nasync def wait_for_fills(sugar, expected_count):\n    \"\"\"Wait until position count reaches expected.\"\"\"\n    while True:\n        current = await sugar.count_open_positions()\n\n        if current &gt;= expected_count:\n            print(f\"Reached {current} positions\")\n            break\n\n        print(f\"Waiting... {current}/{expected_count}\")\n        await asyncio.sleep(2)\n</code></pre></p>"},{"location":"MT5Sugar/7.%20Position_Information/count_open_positions/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>has_open_position - Check if positions exist</li> <li>get_open_positions - Get all positions</li> <li>get_positions_by_symbol - Get symbol positions</li> <li>close_all_positions - Close all</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_open_positions/","title":"Get All Open Positions (<code>get_open_positions</code>)","text":"<p>Sugar method: Returns list of all currently open positions.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_open_positions()</code></li> <li>Returns: List of position objects</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_open_positions/#method-signature","title":"Method Signature","text":"<pre><code>async def get_open_positions(self)\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_open_positions/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"<p>None</p>"},{"location":"MT5Sugar/7.%20Position_Information/get_open_positions/#return-value","title":"Return Value","text":"Type Description <code>list[PositionInfo]</code> List of all open positions (empty list if none)"},{"location":"MT5Sugar/7.%20Position_Information/get_open_positions/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Fetches all currently open positions from terminal</li> <li>Returns as Python list</li> <li>Each position contains full information (ticket, symbol, volume, profit, etc.)</li> <li>Returns empty list if no positions open</li> </ul> <p>Key behaviors:</p> <ul> <li>Returns actual position objects (not summary)</li> <li>List may be empty (no positions)</li> <li>Each position has: ticket, symbol, type, volume, price_open, profit, sl, tp, etc.</li> <li>Sorted by default sort mode (0)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_open_positions/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_open_positions()\n    \u2193 calls\nMT5Service.get_opened_orders(sort_mode=0)\n    \u2193 calls\nMT5Account.opened_orders()\n    \u2193 gRPC protobuf\nTradingHelperService.OpenedOrders()\n    \u2193 MT5 Terminal\n    \u2193 returns position_infos list\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.get_opened_orders() with sort_mode=0</li> <li>Service forwards to Account.opened_orders()</li> <li>Account sends gRPC request to terminal</li> <li>Terminal returns all open positions</li> <li>Sugar converts to Python list from position_infos</li> <li>Returns list (may be empty)</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1338</code></li> <li>Service: <code>src/pymt5/mt5_service.py:742</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1316</code></li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_open_positions/#when-to-use","title":"When to Use","text":"<p>Use <code>get_open_positions()</code> when:</p> <ul> <li>Need to iterate through all positions</li> <li>Checking position details</li> <li>Building custom position filters</li> <li>Monitoring all active trades</li> </ul> <p>Don't use when:</p> <ul> <li>Only need position count (use <code>count_open_positions()</code>)</li> <li>Only checking if positions exist (use <code>has_open_position()</code>)</li> <li>Only need specific position (use <code>get_position_by_ticket()</code>)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_open_positions/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/7.%20Position_Information/get_open_positions/#example-1-list-all-positions","title":"Example 1: List All Positions","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def list_positions():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get all positions\n    positions = await sugar.get_open_positions()\n\n    if not positions:\n        print(\"No open positions\")\n    else:\n        print(f\"Open positions: {len(positions)}\")\n\n        for pos in positions:\n            print(f\"#{pos.ticket}: {pos.symbol} {pos.volume} lots, \"\n                  f\"Profit: ${pos.profit:.2f}\")\n\n# Output:\n# Open positions: 3\n# #123456: EURUSD 0.1 lots, Profit: $12.50\n# #123457: GBPUSD 0.05 lots, Profit: -$5.30\n# #123458: USDJPY 0.2 lots, Profit: $25.80\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_open_positions/#example-2-calculate-statistics","title":"Example 2: Calculate Statistics","text":"<pre><code>async def position_statistics():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    positions = await sugar.get_open_positions()\n\n    if positions:\n        # Calculate stats\n        total_volume = sum(pos.volume for pos in positions)\n        total_profit = sum(pos.profit for pos in positions)\n        profitable = sum(1 for pos in positions if pos.profit &gt; 0)\n        losing = sum(1 for pos in positions if pos.profit &lt; 0)\n\n        print(f\"Total positions: {len(positions)}\")\n        print(f\"Total volume: {total_volume} lots\")\n        print(f\"Total profit: ${total_profit:.2f}\")\n        print(f\"Profitable: {profitable}, Losing: {losing}\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_open_positions/#example-3-close-all-profitable-positions","title":"Example 3: Close All Profitable Positions","text":"<pre><code>async def close_profitable():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    positions = await sugar.get_open_positions()\n\n    closed_count = 0\n    for pos in positions:\n        if pos.profit &gt; 0:\n            success = await sugar.close_position(pos.ticket)\n\n            if success:\n                closed_count += 1\n                print(f\"Closed #{pos.ticket} with ${pos.profit:.2f} profit\")\n\n    print(f\"Closed {closed_count} profitable positions\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_open_positions/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Assuming positions list is never empty <pre><code># ERROR: Crashes if no positions\npositions = await sugar.get_open_positions()\nfirst_position = positions[0]  # IndexError if empty\n</code></pre></p> <p>Solution: Always check if list is empty <pre><code>positions = await sugar.get_open_positions()\n\nif positions:\n    first_position = positions[0]\nelse:\n    print(\"No positions open\")\n</code></pre></p> <p>Pitfall 2: Modifying while iterating <pre><code># ERROR: Modifying list while iterating\npositions = await sugar.get_open_positions()\n\nfor pos in positions:\n    await sugar.close_position(pos.ticket)\n    # List may change during iteration\n</code></pre></p> <p>Solution: Iterate over copy or collect tickets first <pre><code>positions = await sugar.get_open_positions()\ntickets = [pos.ticket for pos in positions]\n\nfor ticket in tickets:\n    await sugar.close_position(ticket)\n</code></pre></p> <p>Pitfall 3: Not handling position types <pre><code># Treating all positions as BUY\nfor pos in positions:\n    # pos.type might be SELL!\n    pass\n</code></pre></p> <p>Solution: Check position type <pre><code>for pos in positions:\n    if pos.type == 0:  # BUY\n        print(f\"BUY position: {pos.symbol}\")\n    else:  # SELL\n        print(f\"SELL position: {pos.symbol}\")\n</code></pre></p>"},{"location":"MT5Sugar/7.%20Position_Information/get_open_positions/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Filter by multiple criteria <pre><code>positions = await sugar.get_open_positions()\n\n# Get large profitable EUR positions\neur_profitable = [\n    pos for pos in positions\n    if 'EUR' in pos.symbol\n    and pos.profit &gt; 0\n    and pos.volume &gt;= 0.1\n]\n\nprint(f\"Found {len(eur_profitable)} large profitable EUR positions\")\n</code></pre></p> <p>Tip 2: Group by symbol <pre><code>from collections import defaultdict\n\npositions = await sugar.get_open_positions()\n\n# Group positions by symbol\nby_symbol = defaultdict(list)\nfor pos in positions:\n    by_symbol[pos.symbol].append(pos)\n\nfor symbol, symbol_positions in by_symbol.items():\n    total_volume = sum(p.volume for p in symbol_positions)\n    total_profit = sum(p.profit for p in symbol_positions)\n    print(f\"{symbol}: {len(symbol_positions)} pos, \"\n          f\"{total_volume} lots, ${total_profit:.2f}\")\n</code></pre></p> <p>Tip 3: Sort by profit</p> <pre><code>positions = await sugar.get_open_positions()\n\n# Sort by profit (descending)\nsorted_positions = sorted(positions, key=lambda p: p.profit, reverse=True)\n\nprint(\"Best performers:\")\nfor pos in sorted_positions[:3]:\n    print(f\"#{pos.ticket}: ${pos.profit:.2f}\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_open_positions/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_position_by_ticket - Get specific position</li> <li>get_positions_by_symbol - Filter by symbol</li> <li>count_open_positions - Get position count</li> <li>has_open_position - Check if positions exist</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_position_by_ticket/","title":"Get Position by Ticket (<code>get_position_by_ticket</code>)","text":"<p>Sugar method: Returns specific position by ticket number.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_position_by_ticket(ticket)</code></li> <li>Returns: Position object or <code>None</code> if not found</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_position_by_ticket/#method-signature","title":"Method Signature","text":"<pre><code>async def get_position_by_ticket(self, ticket: int)\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_position_by_ticket/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>ticket</code> <code>int</code> Yes - Position ticket number to find"},{"location":"MT5Sugar/7.%20Position_Information/get_position_by_ticket/#return-value","title":"Return Value","text":"Type Description <code>PositionInfo \\| None</code> Position object if found, <code>None</code> if not found"},{"location":"MT5Sugar/7.%20Position_Information/get_position_by_ticket/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Searches for position with specific ticket number</li> <li>Returns full position information if found</li> <li>Returns <code>None</code> if position not found</li> <li>Searches through all open positions</li> </ul> <p>Key behaviors:</p> <ul> <li>Returns None (not exception) if not found</li> <li>Only searches open positions (not closed)</li> <li>Returns first match (tickets are unique)</li> <li>Full position object with all fields</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_position_by_ticket/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_position_by_ticket()\n    \u2193 calls\nMT5Service.get_opened_orders(sort_mode=0)\n    \u2193 iterates position_infos\n    \u2193 matches ticket\n    \u2193 returns position or None\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.get_opened_orders()</li> <li>Sugar iterates through position_infos list</li> <li>Compares each pos.ticket with target ticket</li> <li>Returns position object on match</li> <li>Returns None if no match found</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1343</code></li> <li>Service: <code>src/pymt5/mt5_service.py:742</code></li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_position_by_ticket/#when-to-use","title":"When to Use","text":"<p>Use <code>get_position_by_ticket()</code> when:</p> <ul> <li>Need details of specific position</li> <li>Have ticket number from previous operation</li> <li>Checking if specific position still open</li> <li>Monitoring specific trade</li> </ul> <p>Don't use when:</p> <ul> <li>Need all positions (use <code>get_open_positions()</code>)</li> <li>Only checking existence (use <code>has_open_position()</code>)</li> <li>Need positions by symbol (use <code>get_positions_by_symbol()</code>)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_position_by_ticket/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/7.%20Position_Information/get_position_by_ticket/#example-1-check-position-status","title":"Example 1: Check Position Status","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def check_position():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Open position\n    ticket = await sugar.buy_market(volume=0.1)\n    print(f\"Opened position #{ticket}\")\n\n    # Later: get position details\n    position = await sugar.get_position_by_ticket(ticket)\n\n    if position:\n        print(f\"Position found:\")\n        print(f\"  Symbol: {position.symbol}\")\n        print(f\"  Volume: {position.volume}\")\n        print(f\"  Profit: ${position.profit:.2f}\")\n    else:\n        print(f\"Position #{ticket} not found (already closed?)\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_position_by_ticket/#example-2-monitor-position-until-target","title":"Example 2: Monitor Position Until Target","text":"<pre><code>import asyncio\n\nasync def monitor_until_target():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Open position\n    ticket = await sugar.buy_market(volume=0.1)\n    target_profit = 50.0\n\n    print(f\"Monitoring position #{ticket} until ${target_profit} profit\")\n\n    while True:\n        position = await sugar.get_position_by_ticket(ticket)\n\n        if position is None:\n            print(\"Position closed (SL/TP hit or manually closed)\")\n            break\n\n        print(f\"Current profit: ${position.profit:.2f}\")\n\n        if position.profit &gt;= target_profit:\n            print(\"Target reached, closing position\")\n            await sugar.close_position(ticket)\n            break\n\n        await asyncio.sleep(5)\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_position_by_ticket/#example-3-verify-multiple-positions","title":"Example 3: Verify Multiple Positions","text":"<pre><code>async def verify_positions():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Open several positions\n    tickets = []\n    for _ in range(3):\n        ticket = await sugar.buy_market(volume=0.01)\n        tickets.append(ticket)\n\n    # Later: verify all still open\n    still_open = []\n    closed = []\n\n    for ticket in tickets:\n        position = await sugar.get_position_by_ticket(ticket)\n\n        if position:\n            still_open.append(ticket)\n        else:\n            closed.append(ticket)\n\n    print(f\"Still open: {len(still_open)}\")\n    print(f\"Closed: {len(closed)}\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_position_by_ticket/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Not checking for None <pre><code># ERROR: Crashes if position closed\nposition = await sugar.get_position_by_ticket(ticket)\nprofit = position.profit  # AttributeError if None\n</code></pre></p> <p>Solution: Always check for None <pre><code>position = await sugar.get_position_by_ticket(ticket)\n\nif position:\n    profit = position.profit\nelse:\n    print(\"Position not found\")\n</code></pre></p> <p>Pitfall 2: Using wrong ticket <pre><code># Ticket from order placement (pending order)\norder_ticket = await sugar.buy_limit(price=1.0840)\n\n# ERROR: Pending order ticket != position ticket\nposition = await sugar.get_position_by_ticket(order_ticket)\n# Returns None until order fills\n</code></pre></p> <p>Solution: Distinguish between order and position tickets <pre><code># When limit order fills, it becomes position with SAME ticket\norder_ticket = await sugar.buy_limit(price=1.0840)\n\n# Wait for order to fill...\n# Then it becomes position\nposition = await sugar.get_position_by_ticket(order_ticket)\n</code></pre></p> <p>Pitfall 3: Repeated calls in tight loop <pre><code># Inefficient: fetching all positions repeatedly\nwhile True:\n    pos = await sugar.get_position_by_ticket(ticket)\n    # Fetches ALL positions every iteration\n    await asyncio.sleep(0.1)  # 10 times per second!\n</code></pre></p> <p>Solution: Use reasonable polling interval <pre><code>while True:\n    pos = await sugar.get_position_by_ticket(ticket)\n    await asyncio.sleep(5)  # Once every 5 seconds\n</code></pre></p>"},{"location":"MT5Sugar/7.%20Position_Information/get_position_by_ticket/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Cache position data</p> <pre><code># Avoid repeated lookups\nposition = await sugar.get_position_by_ticket(ticket)\n\nif position:\n    # Use cached data for multiple operations\n    symbol = position.symbol\n    volume = position.volume\n    profit = position.profit\n\n    print(f\"{symbol}: {volume} lots = ${profit:.2f}\")\n</code></pre> <p>Tip 2: Track position across operations <pre><code># Open and track position\nticket = await sugar.buy_market(volume=0.1)\nentry_price = (await sugar.get_position_by_ticket(ticket)).price_open\n\n# After some time\nposition = await sugar.get_position_by_ticket(ticket)\n\nif position:\n    pips_moved = (position.price_current - entry_price) / 0.0001\n    print(f\"Moved {pips_moved:.1f} pips from entry\")\n</code></pre></p> <p>Tip 3: Batch check multiple tickets</p> <pre><code>async def check_tickets(sugar, tickets):\n    \"\"\"Check multiple tickets efficiently.\"\"\"\n    # Get all positions once\n    all_positions = await sugar.get_open_positions()\n    ticket_set = set(tickets)\n\n    # Filter in memory\n    found = [p for p in all_positions if p.ticket in ticket_set]\n\n    return found\n\n# Usage\ntickets = [123456, 123457, 123458]\npositions = await check_tickets(sugar, tickets)\nprint(f\"Found {len(positions)} of {len(tickets)} positions\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_position_by_ticket/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_open_positions - Get all positions</li> <li>get_positions_by_symbol - Filter by symbol</li> <li>has_open_position - Check if positions exist</li> <li>close_position - Close position</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_positions_by_symbol/","title":"Get Positions by Symbol (<code>get_positions_by_symbol</code>)","text":"<p>Sugar method: Returns all positions for specific symbol.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_positions_by_symbol(symbol)</code></li> <li>Returns: List of positions for symbol (may be empty)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_positions_by_symbol/#method-signature","title":"Method Signature","text":"<pre><code>async def get_positions_by_symbol(self, symbol: str)\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_positions_by_symbol/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>str</code> Yes - Trading symbol (e.g., \"EURUSD\")"},{"location":"MT5Sugar/7.%20Position_Information/get_positions_by_symbol/#return-value","title":"Return Value","text":"Type Description <code>list[PositionInfo]</code> List of positions for symbol (empty list if none)"},{"location":"MT5Sugar/7.%20Position_Information/get_positions_by_symbol/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Filters all open positions by symbol</li> <li>Returns list of matching positions</li> <li>Returns empty list if no matches</li> <li>Case-sensitive symbol matching</li> </ul> <p>Key behaviors:</p> <ul> <li>Returns list (may be empty)</li> <li>Exact symbol match required</li> <li>Includes both BUY and SELL positions</li> <li>Multiple positions for same symbol supported</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_positions_by_symbol/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_positions_by_symbol()\n    \u2193 calls\nMT5Service.get_opened_orders(sort_mode=0)\n    \u2193 filters position_infos\n    \u2193 pos.symbol == symbol\n    \u2193 returns filtered list\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.get_opened_orders()</li> <li>Sugar filters position_infos by symbol</li> <li>Returns list of matching positions</li> <li>Returns empty list if no matches</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1353</code></li> <li>Service: <code>src/pymt5/mt5_service.py:742</code></li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_positions_by_symbol/#when-to-use","title":"When to Use","text":"<p>Use <code>get_positions_by_symbol()</code> when:</p> <ul> <li>Managing positions for specific symbol</li> <li>Calculating symbol-specific exposure</li> <li>Closing all positions for symbol</li> <li>Symbol-focused strategies</li> </ul> <p>Don't use when:</p> <ul> <li>Need all positions (use <code>get_open_positions()</code>)</li> <li>Only need count (use <code>count_open_positions(symbol)</code>)</li> <li>Only checking existence (use <code>has_open_position(symbol)</code>)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_positions_by_symbol/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/7.%20Position_Information/get_positions_by_symbol/#example-1-get-eurusd-positions","title":"Example 1: Get EURUSD Positions","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def eurusd_positions():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get all EURUSD positions\n    eurusd_positions = await sugar.get_positions_by_symbol(\"EURUSD\")\n\n    if not eurusd_positions:\n        print(\"No EURUSD positions\")\n    else:\n        print(f\"EURUSD positions: {len(eurusd_positions)}\")\n\n        for pos in eurusd_positions:\n            direction = \"BUY\" if pos.type == 0 else \"SELL\"\n            print(f\"  #{pos.ticket}: {direction} {pos.volume} lots, \"\n                  f\"${pos.profit:.2f}\")\n\n# Output:\n# EURUSD positions: 2\n#   #123456: BUY 0.1 lots, $12.50\n#   #123457: SELL 0.05 lots, -$3.20\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_positions_by_symbol/#example-2-close-all-symbol-positions","title":"Example 2: Close All Symbol Positions","text":"<pre><code>async def close_symbol_positions():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"GBPUSD\"\n\n    # Get all GBPUSD positions\n    positions = await sugar.get_positions_by_symbol(symbol)\n\n    print(f\"Closing {len(positions)} {symbol} positions...\")\n\n    closed = 0\n    for pos in positions:\n        success = await sugar.close_position(pos.ticket)\n\n        if success:\n            closed += 1\n            print(f\"Closed #{pos.ticket}\")\n\n    print(f\"Closed {closed}/{len(positions)} positions\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_positions_by_symbol/#example-3-symbol-exposure-analysis","title":"Example 3: Symbol Exposure Analysis","text":"<pre><code>async def symbol_exposure():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n    positions = await sugar.get_positions_by_symbol(symbol)\n\n    if positions:\n        # Calculate net exposure\n        buy_volume = sum(p.volume for p in positions if p.type == 0)\n        sell_volume = sum(p.volume for p in positions if p.type == 1)\n        net_volume = buy_volume - sell_volume\n\n        # Calculate P&amp;L\n        total_profit = sum(p.profit for p in positions)\n\n        print(f\"{symbol} Exposure:\")\n        print(f\"  BUY: {buy_volume} lots\")\n        print(f\"  SELL: {sell_volume} lots\")\n        print(f\"  NET: {net_volume:+.2f} lots\")\n        print(f\"  P&amp;L: ${total_profit:.2f}\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_positions_by_symbol/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Case sensitivity <pre><code># ERROR: Symbol case matters\npositions = await sugar.get_positions_by_symbol(\"eurusd\")\n# Returns [] if positions are \"EURUSD\"\n</code></pre></p> <p>Solution: Use uppercase symbol names <pre><code>positions = await sugar.get_positions_by_symbol(\"EURUSD\")\n# or\nsymbol = \"eurusd\".upper()\npositions = await sugar.get_positions_by_symbol(symbol)\n</code></pre></p> <p>Pitfall 2: Assuming list is never empty <pre><code># ERROR: Crashes if no positions\npositions = await sugar.get_positions_by_symbol(\"EURUSD\")\nfirst = positions[0]  # IndexError if empty\n</code></pre></p> <p>Solution: Check if list is empty <pre><code>positions = await sugar.get_positions_by_symbol(\"EURUSD\")\n\nif positions:\n    first = positions[0]\nelse:\n    print(\"No EURUSD positions\")\n</code></pre></p> <p>Pitfall 3: Modifying while iterating <pre><code># ERROR: Closing positions while iterating\npositions = await sugar.get_positions_by_symbol(\"EURUSD\")\n\nfor pos in positions:\n    await sugar.close_position(pos.ticket)\n    # List won't update during iteration\n</code></pre></p> <p>Solution: Collect tickets first <pre><code>positions = await sugar.get_positions_by_symbol(\"EURUSD\")\ntickets = [p.ticket for p in positions]\n\nfor ticket in tickets:\n    await sugar.close_position(ticket)\n</code></pre></p>"},{"location":"MT5Sugar/7.%20Position_Information/get_positions_by_symbol/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Calculate net position <pre><code>positions = await sugar.get_positions_by_symbol(\"EURUSD\")\n\n# Calculate net exposure (BUY - SELL)\nnet = sum(\n    p.volume if p.type == 0 else -p.volume\n    for p in positions\n)\n\nif net &gt; 0:\n    print(f\"Net LONG: {net} lots\")\nelif net &lt; 0:\n    print(f\"Net SHORT: {abs(net)} lots\")\nelse:\n    print(\"Flat (hedged)\")\n</code></pre></p> <p>Tip 2: Find largest position <pre><code>positions = await sugar.get_positions_by_symbol(\"EURUSD\")\n\nif positions:\n    largest = max(positions, key=lambda p: p.volume)\n    print(f\"Largest position: #{largest.ticket} ({largest.volume} lots)\")\n</code></pre></p> <p>Tip 3: Check all symbols at once <pre><code>async def analyze_all_symbols(sugar):\n    \"\"\"Analyze exposure for all traded symbols.\"\"\"\n    all_positions = await sugar.get_open_positions()\n\n    # Group by symbol\n    symbols = set(p.symbol for p in all_positions)\n\n    for symbol in symbols:\n        symbol_positions = await sugar.get_positions_by_symbol(symbol)\n\n        total_volume = sum(p.volume for p in symbol_positions)\n        total_profit = sum(p.profit for p in symbol_positions)\n\n        print(f\"{symbol}: {len(symbol_positions)} pos, \"\n              f\"{total_volume} lots, ${total_profit:.2f}\")\n</code></pre></p>"},{"location":"MT5Sugar/7.%20Position_Information/get_positions_by_symbol/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_open_positions - Get all positions</li> <li>get_position_by_ticket - Get specific position</li> <li>count_open_positions - Count by symbol</li> <li>get_profit_by_symbol - Symbol profit</li> <li>close_all_positions - Close all for symbol</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_profit_by_symbol/","title":"Get Profit by Symbol (<code>get_profit_by_symbol</code>)","text":"<p>Sugar method: Returns total unrealized profit/loss for specific symbol.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_profit_by_symbol(symbol)</code></li> <li>Returns: Total floating P&amp;L for symbol as float</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_profit_by_symbol/#method-signature","title":"Method Signature","text":"<pre><code>async def get_profit_by_symbol(self, symbol: str) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_profit_by_symbol/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>str</code> Yes - Trading symbol (e.g., \"EURUSD\")"},{"location":"MT5Sugar/7.%20Position_Information/get_profit_by_symbol/#return-value","title":"Return Value","text":"Type Description <code>float</code> Total floating P&amp;L for symbol in account currency (positive = profit, negative = loss)"},{"location":"MT5Sugar/7.%20Position_Information/get_profit_by_symbol/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Sums profit/loss for all positions of specified symbol</li> <li>Returns total unrealized P&amp;L for that symbol</li> <li>Returns 0.0 if no positions for symbol</li> <li>Calculated in account currency</li> </ul> <p>Key behaviors:</p> <ul> <li>Case-sensitive symbol matching</li> <li>Includes both BUY and SELL positions</li> <li>Returns 0.0 if no matching positions</li> <li>Floating (unrealized) P&amp;L only</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_profit_by_symbol/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_profit_by_symbol()\n    \u2193 calls\nMT5Service.get_opened_orders(sort_mode=0)\n    \u2193 filters by symbol\n    \u2193 sums pos.profit where pos.symbol == symbol\n    \u2193 returns total\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.get_opened_orders()</li> <li>Sugar filters position_infos by symbol</li> <li>Sums pos.profit for matching positions</li> <li>Returns total sum (0.0 if no matches)</li> </ol> <p>Related files: - Sugar: <code>src/pymt5/mt5_sugar.py:1383</code> - Service: <code>src/pymt5/mt5_service.py:742</code></p>"},{"location":"MT5Sugar/7.%20Position_Information/get_profit_by_symbol/#when-to-use","title":"When to Use","text":"<p>Use <code>get_profit_by_symbol()</code> when:</p> <ul> <li>Monitoring symbol-specific performance</li> <li>Symbol-based risk management</li> <li>Comparing profitability across symbols</li> <li>Symbol-focused strategies</li> </ul> <p>Don't use when:</p> <ul> <li>Need total profit for all symbols (use <code>get_total_profit()</code>)</li> <li>Need profit for specific position (use position.profit)</li> <li>Need realized profit (use history methods)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_profit_by_symbol/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/7.%20Position_Information/get_profit_by_symbol/#example-1-basic-symbol-pl","title":"Example 1: Basic Symbol P&amp;L","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def symbol_profit():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get profit for EURUSD\n    eurusd_profit = await sugar.get_profit_by_symbol(\"EURUSD\")\n\n    if eurusd_profit &gt; 0:\n        print(f\"EURUSD profit: ${eurusd_profit:.2f}\")\n    elif eurusd_profit &lt; 0:\n        print(f\"EURUSD loss: ${abs(eurusd_profit):.2f}\")\n    else:\n        print(\"EURUSD breakeven or no positions\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_profit_by_symbol/#example-2-compare-symbol-performance","title":"Example 2: Compare Symbol Performance","text":"<pre><code>async def compare_symbols():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\n\n    print(\"Symbol Performance:\")\n    for symbol in symbols:\n        profit = await sugar.get_profit_by_symbol(symbol)\n\n        if profit != 0.0:\n            status = \"profit\" if profit &gt; 0 else \"loss\"\n            print(f\"  {symbol}: ${profit:+.2f} ({status})\")\n        else:\n            print(f\"  {symbol}: no positions\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_profit_by_symbol/#example-3-symbol-specific-stop-loss","title":"Example 3: Symbol-Specific Stop Loss","text":"<pre><code>import asyncio\n\nasync def symbol_stop_loss():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n    max_loss = -50.0  # Close EURUSD if loss exceeds $50\n\n    # Open EURUSD positions\n    await sugar.buy_market(symbol, volume=0.1)\n\n    print(f\"Monitoring {symbol} for max loss ${max_loss}...\")\n\n    while True:\n        profit = await sugar.get_profit_by_symbol(symbol)\n\n        print(f\"{symbol} P&amp;L: ${profit:.2f}\")\n\n        if profit &lt;= max_loss:\n            print(f\"Max loss reached, closing all {symbol} positions\")\n\n            # Close all symbol positions\n            closed = await sugar.close_all_positions(symbol=symbol)\n            print(f\"Closed {closed} {symbol} positions\")\n            break\n\n        await asyncio.sleep(5)\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_profit_by_symbol/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Case-sensitive symbol <pre><code># ERROR: Symbol case matters\nprofit = await sugar.get_profit_by_symbol(\"eurusd\")\n# Returns 0.0 if positions are \"EURUSD\"\n</code></pre></p> <p>Solution: Use uppercase symbols <pre><code>profit = await sugar.get_profit_by_symbol(\"EURUSD\")\n</code></pre></p> <p>Pitfall 2: Expecting None instead of 0 <pre><code># Returns 0.0 if no positions, not None\nprofit = await sugar.get_profit_by_symbol(\"EURUSD\")\n\nif profit:  # 0.0 is falsy\n    print(\"Have profit/loss\")\n</code></pre></p> <p>Solution: Compare explicitly <pre><code>profit = await sugar.get_profit_by_symbol(\"EURUSD\")\n\nif profit != 0.0:\n    print(f\"EURUSD P&amp;L: ${profit:.2f}\")\nelse:\n    print(\"EURUSD flat or no positions\")\n</code></pre></p> <p>Pitfall 3: Not checking if positions exist <pre><code># Getting profit for symbol without positions\nprofit = await sugar.get_profit_by_symbol(\"XAUUSD\")\n# Returns 0.0, can't distinguish between:\n# 1. No positions\n# 2. Positions at breakeven\n</code></pre></p> <p>Solution: Check position count first <pre><code>count = await sugar.count_open_positions(\"XAUUSD\")\n\nif count &gt; 0:\n    profit = await sugar.get_profit_by_symbol(\"XAUUSD\")\n    print(f\"XAUUSD {count} positions: ${profit:.2f}\")\nelse:\n    print(\"No XAUUSD positions\")\n</code></pre></p>"},{"location":"MT5Sugar/7.%20Position_Information/get_profit_by_symbol/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Find best/worst performing symbol <pre><code># Get all traded symbols\nall_positions = await sugar.get_open_positions()\nsymbols = set(p.symbol for p in all_positions)\n\n# Find best performer\nprofits = {}\nfor symbol in symbols:\n    profits[symbol] = await sugar.get_profit_by_symbol(symbol)\n\nbest_symbol = max(profits, key=profits.get)\nworst_symbol = min(profits, key=profits.get)\n\nprint(f\"Best: {best_symbol} (${profits[best_symbol]:.2f})\")\nprint(f\"Worst: {worst_symbol} (${profits[worst_symbol]:.2f})\")\n</code></pre></p> <p>Tip 2: Symbol exposure with P&amp;L <pre><code>async def symbol_exposure(sugar, symbol):\n    \"\"\"Get complete symbol exposure info.\"\"\"\n    count = await sugar.count_open_positions(symbol)\n    profit = await sugar.get_profit_by_symbol(symbol)\n\n    positions = await sugar.get_positions_by_symbol(symbol)\n    total_volume = sum(p.volume for p in positions)\n\n    return {\n        \"symbol\": symbol,\n        \"count\": count,\n        \"volume\": total_volume,\n        \"profit\": profit\n    }\n\n# Usage\nexposure = await symbol_exposure(sugar, \"EURUSD\")\nprint(f\"{exposure['symbol']}: {exposure['count']} pos, \"\n      f\"{exposure['volume']} lots, ${exposure['profit']:.2f}\")\n</code></pre></p> <p>Tip 3: Close symbol if unprofitable <pre><code>async def close_losing_symbols(sugar, max_loss=-20.0):\n    \"\"\"Close positions for symbols with loss &gt; threshold.\"\"\"\n    all_positions = await sugar.get_open_positions()\n    symbols = set(p.symbol for p in all_positions)\n\n    for symbol in symbols:\n        profit = await sugar.get_profit_by_symbol(symbol)\n\n        if profit &lt; max_loss:\n            closed = await sugar.close_all_positions(symbol=symbol)\n            print(f\"Closed {closed} {symbol} positions (loss: ${profit:.2f})\")\n</code></pre></p>"},{"location":"MT5Sugar/7.%20Position_Information/get_profit_by_symbol/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_total_profit - Total profit all symbols</li> <li>get_positions_by_symbol - Get symbol positions</li> <li>count_open_positions - Count by symbol</li> <li>close_all_positions - Close all for symbol</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_total_profit/","title":"Get Total Floating Profit (<code>get_total_profit</code>)","text":"<p>Sugar method: Returns total unrealized profit/loss across all open positions.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_total_profit()</code></li> <li>Returns: Total floating P&amp;L as float</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_total_profit/#method-signature","title":"Method Signature","text":"<pre><code>async def get_total_profit(self) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_total_profit/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"<p>None</p>"},{"location":"MT5Sugar/7.%20Position_Information/get_total_profit/#return-value","title":"Return Value","text":"Type Description <code>float</code> Total floating profit/loss in account currency (positive = profit, negative = loss)"},{"location":"MT5Sugar/7.%20Position_Information/get_total_profit/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Sums profit/loss from all open positions</li> <li>Returns total unrealized P&amp;L</li> <li>Returns 0.0 if no positions</li> <li>Calculated in account currency (USD, EUR, etc.)</li> </ul> <p>Key behaviors:</p> <ul> <li>Includes ALL open positions</li> <li>Positive = total profit</li> <li>Negative = total loss</li> <li>Returns 0.0 if no positions (not None)</li> <li>Floating (unrealized) P&amp;L only</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_total_profit/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_total_profit()\n    \u2193 calls\nMT5Service.get_opened_orders(sort_mode=0)\n    \u2193 sums all pos.profit values\n    \u2193 returns total\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.get_opened_orders()</li> <li>Sugar iterates through position_infos</li> <li>Sums pos.profit for each position</li> <li>Returns total sum</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1377</code></li> <li>Service: <code>src/pymt5/mt5_service.py:742</code></li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_total_profit/#when-to-use","title":"When to Use","text":"<p>Use <code>get_total_profit()</code> when:</p> <ul> <li>Monitoring overall account performance</li> <li>Risk management (close all if loss too high)</li> <li>Daily profit/loss tracking</li> <li>Account-wide P&amp;L limits</li> </ul> <p>Don't use when:</p> <ul> <li>Need profit for specific symbol (use <code>get_profit_by_symbol()</code>)</li> <li>Need realized profit (use history methods)</li> <li>Need floating profit property (use <code>get_floating_profit()</code>)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/get_total_profit/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/7.%20Position_Information/get_total_profit/#example-1-basic-pl-check","title":"Example 1: Basic P&amp;L Check","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def check_profit():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get total profit\n    total = await sugar.get_total_profit()\n\n    if total &gt; 0:\n        print(f\"Total profit: ${total:.2f}\")\n    elif total &lt; 0:\n        print(f\"Total loss: ${abs(total):.2f}\")\n    else:\n        print(\"Breakeven or no positions\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_total_profit/#example-2-stop-loss-all-positions","title":"Example 2: Stop Loss All Positions","text":"<pre><code>import asyncio\n\nasync def stop_loss_monitor():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    max_loss = -100.0  # Close all if loss exceeds $100\n\n    while True:\n        total_profit = await sugar.get_total_profit()\n\n        print(f\"Current P&amp;L: ${total_profit:.2f}\")\n\n        if total_profit &lt;= max_loss:\n            print(f\"Max loss reached (${total_profit:.2f}), closing all positions\")\n            closed = await sugar.close_all_positions()\n            print(f\"Closed {closed} positions\")\n            break\n\n        await asyncio.sleep(5)\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_total_profit/#example-3-profit-target","title":"Example 3: Profit Target","text":"<pre><code>async def profit_target():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Open multiple positions\n    await sugar.buy_market(\"EURUSD\", volume=0.1)\n    await sugar.buy_market(\"GBPUSD\", volume=0.1)\n\n    target_profit = 50.0\n\n    print(f\"Monitoring for ${target_profit} total profit...\")\n\n    while True:\n        total = await sugar.get_total_profit()\n\n        if total &gt;= target_profit:\n            print(f\"Target reached: ${total:.2f}\")\n\n            # Close all and lock in profit\n            await sugar.close_all_positions()\n            break\n\n        print(f\"Current: ${total:.2f} / ${target_profit:.2f}\")\n        await asyncio.sleep(5)\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/get_total_profit/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Confusing with floating_profit property <pre><code># Both do same thing, but different syntax\ntotal1 = await sugar.get_total_profit()      # Method\ntotal2 = await sugar.get_floating_profit()   # Also method (Account_Properties)\n\n# Use get_floating_profit() from Account_Properties group\n</code></pre></p> <p>Pitfall 2: Expecting None instead of 0 <pre><code># Returns 0.0 if no positions, not None\nprofit = await sugar.get_total_profit()\n\nif profit:  # 0.0 is falsy, but valid\n    print(\"Have profit/loss\")\n</code></pre></p> <p>Solution: Compare explicitly <pre><code>profit = await sugar.get_total_profit()\n\nif profit != 0.0:\n    print(f\"P&amp;L: ${profit:.2f}\")\nelse:\n    print(\"No P&amp;L or no positions\")\n</code></pre></p> <p>Pitfall 3: Using for realized profit <pre><code># ERROR: get_total_profit() only shows OPEN positions\n# Closed positions profit not included\nprofit = await sugar.get_total_profit()\n# This is only floating (unrealized) profit\n</code></pre></p> <p>Solution: Use history methods for realized profit <pre><code># Floating profit (open positions)\nfloating = await sugar.get_total_profit()\n\n# Realized profit (closed today)\n# realized = await sugar.get_profit_today()\n\nprint(f\"Floating: ${floating:.2f}\")\n# print(f\"Realized: ${realized:.2f}\")\n</code></pre></p>"},{"location":"MT5Sugar/7.%20Position_Information/get_total_profit/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Calculate profit percentage</p> <pre><code>balance = await sugar.get_balance()\nprofit = await sugar.get_total_profit()\n\nprofit_pct = (profit / balance) * 100\n\nprint(f\"Floating P&amp;L: ${profit:.2f} ({profit_pct:+.2f}%)\")\n</code></pre> <p>Tip 2: Compare to margin used <pre><code>margin = await sugar.get_margin()\nprofit = await sugar.get_total_profit()\n\nif margin &gt; 0:\n    return_on_margin = (profit / margin) * 100\n    print(f\"Return on margin: {return_on_margin:+.2f}%\")\n</code></pre></p> <p>Tip 3: Log profit changes <pre><code>import asyncio\n\nasync def log_profit_changes():\n    previous = await sugar.get_total_profit()\n\n    while True:\n        await asyncio.sleep(10)\n\n        current = await sugar.get_total_profit()\n        change = current - previous\n\n        if abs(change) &gt;= 1.0:  # Log if change &gt;= $1\n            print(f\"P&amp;L changed: ${previous:.2f} \u2192 ${current:.2f} \"\n                  f\"({change:+.2f})\")\n            previous = current\n</code></pre></p>"},{"location":"MT5Sugar/7.%20Position_Information/get_total_profit/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_profit_by_symbol - Profit for specific symbol</li> <li>get_floating_profit - Same as get_total_profit</li> <li>get_open_positions - Get all positions</li> <li>close_all_positions - Close all</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/has_open_position/","title":"Check if Positions Exist (<code>has_open_position</code>)","text":"<p>Sugar method: Quick check if any positions are open (optionally filtered by symbol).</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.has_open_position(symbol: Optional[str] = None)</code></li> <li>Returns: <code>True</code> if positions exist, <code>False</code> otherwise</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/has_open_position/#method-signature","title":"Method Signature","text":"<pre><code>async def has_open_position(self, symbol: Optional[str] = None) -&gt; bool\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/has_open_position/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>Optional[str]</code> No <code>None</code> Filter by symbol (None = check any symbol)"},{"location":"MT5Sugar/7.%20Position_Information/has_open_position/#return-value","title":"Return Value","text":"Type Description <code>bool</code> <code>True</code> if positions exist (matching filter), <code>False</code> otherwise"},{"location":"MT5Sugar/7.%20Position_Information/has_open_position/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Checks if any open positions exist</li> <li>Optionally filters by symbol</li> <li>Returns boolean (True/False)</li> <li>Efficient check without retrieving full details</li> </ul> <p>Key behaviors:</p> <ul> <li>No symbol: checks ANY open position</li> <li>With symbol: checks positions for that symbol only</li> <li>Case-sensitive symbol matching</li> <li>Returns False if no positions</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/has_open_position/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.has_open_position()\n    \u2193 calls\nMT5Service.get_opened_orders(sort_mode=0)\n    \u2193 checks len(position_infos) &gt; 0\n    \u2193 or any(pos.symbol == symbol)\n    \u2193 returns boolean\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.get_opened_orders()</li> <li>If no symbol: checks if position_infos length &gt; 0</li> <li>If symbol provided: checks if any position matches symbol</li> <li>Returns True if found, False otherwise</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1359</code></li> <li>Service: <code>src/pymt5/mt5_service.py:742</code></li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/has_open_position/#when-to-use","title":"When to Use","text":"<p>Use <code>has_open_position()</code> when:</p> <ul> <li>Quick existence check before operations</li> <li>Validating no positions before action</li> <li>Conditional logic based on positions</li> <li>Pre-flight checks</li> </ul> <p>Don't use when:</p> <ul> <li>Need position count (use <code>count_open_positions()</code>)</li> <li>Need position details (use <code>get_open_positions()</code>)</li> <li>Need specific position (use <code>get_position_by_ticket()</code>)</li> </ul>"},{"location":"MT5Sugar/7.%20Position_Information/has_open_position/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/7.%20Position_Information/has_open_position/#example-1-check-before-opening","title":"Example 1: Check Before Opening","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def safe_open():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Only open if no positions\n    if not await sugar.has_open_position():\n        ticket = await sugar.buy_market(volume=0.1)\n        print(f\"Opened position #{ticket}\")\n    else:\n        print(\"Already have open positions, skipping\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/has_open_position/#example-2-symbol-specific-check","title":"Example 2: Symbol-Specific Check","text":"<pre><code>async def symbol_check():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Check specific symbol\n    has_eurusd = await sugar.has_open_position(\"EURUSD\")\n    has_gbpusd = await sugar.has_open_position(\"GBPUSD\")\n\n    print(f\"EURUSD positions: {'Yes' if has_eurusd else 'No'}\")\n    print(f\"GBPUSD positions: {'Yes' if has_gbpusd else 'No'}\")\n\n    # Open only if no EURUSD\n    if not has_eurusd:\n        await sugar.buy_market(\"EURUSD\", volume=0.1)\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/has_open_position/#example-3-wait-until-all-closed","title":"Example 3: Wait Until All Closed","text":"<pre><code>import asyncio\n\nasync def wait_until_flat():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Close all positions\n    await sugar.close_all_positions()\n\n    print(\"Waiting for all positions to close...\")\n\n    # Wait until no positions remain\n    while await sugar.has_open_position():\n        print(\"Still have open positions...\")\n        await asyncio.sleep(2)\n\n    print(\"All positions closed\")\n</code></pre>"},{"location":"MT5Sugar/7.%20Position_Information/has_open_position/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Case-sensitive symbol <pre><code># ERROR: Symbol case matters\nhas_pos = await sugar.has_open_position(\"eurusd\")\n# Returns False if positions are \"EURUSD\"\n</code></pre></p> <p>Solution: Use uppercase symbols <pre><code>has_pos = await sugar.has_open_position(\"EURUSD\")\n</code></pre></p> <p>Pitfall 2: Confusing with count <pre><code># has_open_position returns bool, not count\nif await sugar.has_open_position():\n    # Don't know HOW MANY positions\n    pass\n</code></pre></p> <p>Solution: Use count if you need number <pre><code>count = await sugar.count_open_positions()\nprint(f\"Have {count} positions\")\n</code></pre></p> <p>Pitfall 3: Not awaiting (async method) <pre><code># ERROR: Forgetting await\nif sugar.has_open_position():  # Missing await\n    pass\n</code></pre></p> <p>Solution: Always await async methods <pre><code>if await sugar.has_open_position():\n    pass\n</code></pre></p>"},{"location":"MT5Sugar/7.%20Position_Information/has_open_position/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Quick pre-check pattern <pre><code># Common pattern: check before action\nif await sugar.has_open_position(\"EURUSD\"):\n    print(\"Already trading EURUSD\")\nelse:\n    # Safe to open new position\n    await sugar.buy_market(\"EURUSD\", volume=0.1)\n</code></pre></p> <p>Tip 2: Multiple symbol check <pre><code># Check multiple symbols efficiently\nsymbols = [\"EURUSD\", \"GBPUSD\", \"USDJPY\"]\n\nfor symbol in symbols:\n    if await sugar.has_open_position(symbol):\n        print(f\"{symbol}: trading\")\n    else:\n        print(f\"{symbol}: flat\")\n</code></pre></p> <p>Tip 3: Use as assertion <pre><code># Ensure no positions before test\nassert not await sugar.has_open_position(), \"Must start with no positions\"\n\n# Run test logic\nticket = await sugar.buy_market(volume=0.01)\n\n# Verify position opened\nassert await sugar.has_open_position(), \"Position should be open\"\n</code></pre></p>"},{"location":"MT5Sugar/7.%20Position_Information/has_open_position/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>count_open_positions - Get position count</li> <li>get_open_positions - Get all positions</li> <li>get_positions_by_symbol - Get symbol positions</li> <li>close_all_positions - Close all</li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_daily_stats/","title":"Get Daily Statistics (<code>get_daily_stats</code>)","text":"<p>Sugar method: Returns comprehensive trading statistics for specific day.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_daily_stats(target_date)</code></li> <li>Returns: <code>DailyStats</code> dataclass with complete statistics</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_daily_stats/#method-signature","title":"Method Signature","text":"<pre><code>async def get_daily_stats(self, target_date: Optional[date] = None) -&gt; DailyStats\n</code></pre>"},{"location":"MT5Sugar/8.%20History_Statistics/get_daily_stats/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>target_date</code> <code>Optional[date]</code> No <code>None</code> Date to get stats for (None = today)"},{"location":"MT5Sugar/8.%20History_Statistics/get_daily_stats/#return-value","title":"Return Value","text":"<p><code>DailyStats</code> dataclass with the following fields:</p> Field Type Description <code>date</code> <code>date</code> The date for these statistics <code>deals_count</code> <code>int</code> Number of closed positions <code>profit</code> <code>float</code> Total gross profit/loss <code>commission</code> <code>float</code> Total commission paid <code>swap</code> <code>float</code> Total swap (rollover) <code>volume</code> <code>float</code> Total volume traded in lots <p>Calculated field:</p> <ul> <li><code>net_profit = profit + commission + swap</code> (calculate manually)</li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_daily_stats/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Fetches all closed positions for specified day</li> <li>Calculates comprehensive statistics</li> <li>Returns structured DailyStats object</li> <li>Includes commission and swap breakdown</li> </ul> <p>Key behaviors:</p> <ul> <li>Defaults to today if no date specified</li> <li>Fetches up to 10,000 positions</li> <li>Commission is usually negative</li> <li>Swap can be positive or negative</li> <li>Returns stats even if no deals (all zeros)</li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_daily_stats/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_daily_stats()\n    \u2193 converts date to datetime range\n    \u2193 calls\nMT5Service.get_positions_history()\n    \u2193 iterates positions\n    \u2193 sums profit, commission, swap, volume\n    \u2193 returns DailyStats dataclass\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar converts date to datetime range (00:00:00 to 23:59:59)</li> <li>Sugar calls Service.get_positions_history() for day</li> <li>Sugar iterates through history_positions</li> <li>Sugar sums: profit, commission, swap, volume</li> <li>Returns DailyStats dataclass with results</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:2061</code></li> <li>DailyStats: <code>src/pymt5/mt5_sugar.py:209</code></li> <li>Service: <code>src/pymt5/mt5_service.py:810</code></li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_daily_stats/#when-to-use","title":"When to Use","text":"<p>Use <code>get_daily_stats()</code> when:</p> <ul> <li>Need complete daily breakdown</li> <li>Tracking commission costs</li> <li>Analyzing net profit after fees</li> <li>Daily performance reports</li> <li>Volume analysis</li> </ul> <p>Don't use when:</p> <ul> <li>Only need gross profit (use <code>get_profit()</code>)</li> <li>Need deal details (use <code>get_deals()</code>)</li> <li>Need multi-day statistics (call multiple times)</li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_daily_stats/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/8.%20History_Statistics/get_daily_stats/#example-1-todays-complete-stats","title":"Example 1: Today's Complete Stats","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def daily_report():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get today's statistics\n    stats = await sugar.get_daily_stats()\n\n    # Calculate net profit\n    net_profit = stats.profit + stats.commission + stats.swap\n\n    print(f\"Daily Report for {stats.date}:\")\n    print(f\"  Trades: {stats.deals_count}\")\n    print(f\"  Volume: {stats.volume} lots\")\n    print(f\"  Gross Profit: ${stats.profit:.2f}\")\n    print(f\"  Commission: ${stats.commission:.2f}\")\n    print(f\"  Swap: ${stats.swap:.2f}\")\n    print(f\"  Net Profit: ${net_profit:.2f}\")\n\n# Output:\n# Daily Report for 2026-02-03:\n#   Trades: 12\n#   Volume: 1.5 lots\n#   Gross Profit: $180.50\n#   Commission: $-15.30\n#   Swap: $-2.10\n#   Net Profit: $163.10\n</code></pre>"},{"location":"MT5Sugar/8.%20History_Statistics/get_daily_stats/#example-2-compare-multiple-days","title":"Example 2: Compare Multiple Days","text":"<pre><code>from datetime import date, timedelta\n\nasync def compare_days():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get last 5 days\n    print(\"Last 5 Days Performance:\")\n\n    for i in range(5):\n        target = date.today() - timedelta(days=i)\n        stats = await sugar.get_daily_stats(target)\n\n        net = stats.profit + stats.commission + stats.swap\n\n        print(f\"{target}: {stats.deals_count} trades, \"\n              f\"${net:+.2f} net P&amp;L\")\n\n# Output:\n# Last 5 Days Performance:\n# 2026-02-03: 12 trades, $+163.10 net P&amp;L\n# 2026-02-02: 8 trades, $-45.20 net P&amp;L\n# 2026-02-01: 15 trades, $+220.50 net P&amp;L\n</code></pre>"},{"location":"MT5Sugar/8.%20History_Statistics/get_daily_stats/#example-3-cost-analysis","title":"Example 3: Cost Analysis","text":"<pre><code>async def cost_analysis():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    stats = await sugar.get_daily_stats()\n\n    if stats.deals_count &gt; 0:\n        # Calculate costs per trade\n        avg_commission = abs(stats.commission) / stats.deals_count\n        total_costs = abs(stats.commission) + abs(stats.swap)\n        costs_pct = (total_costs / abs(stats.profit)) * 100 if stats.profit != 0 else 0\n\n        print(f\"Cost Analysis:\")\n        print(f\"  Average commission per trade: ${avg_commission:.2f}\")\n        print(f\"  Total trading costs: ${total_costs:.2f}\")\n        print(f\"  Costs as % of gross profit: {costs_pct:.1f}%\")\n</code></pre>"},{"location":"MT5Sugar/8.%20History_Statistics/get_daily_stats/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Forgetting commission is negative <pre><code>stats = await sugar.get_daily_stats()\n\n# ERROR: Commission is already negative, don't subtract again\nnet_profit = stats.profit - stats.commission  # WRONG!\n\n# CORRECT: Commission is negative, so add it\nnet_profit = stats.profit + stats.commission  # RIGHT\n</code></pre></p> <p>Pitfall 2: Not checking deals_count <pre><code>stats = await sugar.get_daily_stats()\n\n# Calculating average without checking for zero\navg_profit = stats.profit / stats.deals_count  # ZeroDivisionError if no deals\n</code></pre></p> <p>Solution: Always check deals_count first <pre><code>stats = await sugar.get_daily_stats()\n\nif stats.deals_count &gt; 0:\n    avg_profit = stats.profit / stats.deals_count\nelse:\n    avg_profit = 0.0\n</code></pre></p> <p>Pitfall 3: Expecting historical data to exist <pre><code># Asking for date before account existed\nstats = await sugar.get_daily_stats(date(2020, 1, 1))\n# Returns all zeros, not an error\n</code></pre></p> <p>Solution: Check if data exists <pre><code>stats = await sugar.get_daily_stats(date(2020, 1, 1))\n\nif stats.deals_count == 0:\n    print(\"No trades on this date\")\n</code></pre></p>"},{"location":"MT5Sugar/8.%20History_Statistics/get_daily_stats/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Calculate net profit helper <pre><code>def calculate_net(stats):\n    \"\"\"Calculate net profit from DailyStats.\"\"\"\n    return stats.profit + stats.commission + stats.swap\n\nstats = await sugar.get_daily_stats()\nnet = calculate_net(stats)\nprint(f\"Net profit: ${net:.2f}\")\n</code></pre></p> <p>Tip 2: Weekly summary <pre><code>from datetime import date, timedelta\n\nasync def weekly_summary():\n    \"\"\"Aggregate weekly statistics.\"\"\"\n    total_deals = 0\n    total_profit = 0.0\n    total_commission = 0.0\n    total_swap = 0.0\n    total_volume = 0.0\n\n    # Get last 7 days\n    for i in range(7):\n        target = date.today() - timedelta(days=i)\n        stats = await sugar.get_daily_stats(target)\n\n        total_deals += stats.deals_count\n        total_profit += stats.profit\n        total_commission += stats.commission\n        total_swap += stats.swap\n        total_volume += stats.volume\n\n    net_profit = total_profit + total_commission + total_swap\n\n    print(f\"Weekly Summary:\")\n    print(f\"  Total trades: {total_deals}\")\n    print(f\"  Total volume: {total_volume} lots\")\n    print(f\"  Net profit: ${net_profit:.2f}\")\n</code></pre></p> <p>Tip 3: Profit factor calculation <pre><code>async def profit_factor():\n    \"\"\"Calculate profit factor (gross profit / gross loss).\"\"\"\n    from datetime import date, timedelta\n\n    gross_profit = 0.0\n    gross_loss = 0.0\n\n    # Get this month\n    for i in range(30):\n        target = date.today() - timedelta(days=i)\n        deals = await sugar.get_deals(Period.CUSTOM, target, target)\n\n        for deal in deals:\n            if deal.profit &gt; 0:\n                gross_profit += deal.profit\n            else:\n                gross_loss += abs(deal.profit)\n\n    if gross_loss &gt; 0:\n        pf = gross_profit / gross_loss\n        print(f\"Profit Factor: {pf:.2f}\")\n    else:\n        print(\"No losing trades\")\n</code></pre></p>"},{"location":"MT5Sugar/8.%20History_Statistics/get_daily_stats/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_deals - Get historical deals</li> <li>get_profit - Get gross profit for period</li> <li>get_total_profit - Floating profit</li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/","title":"Get Historical Deals (<code>get_deals</code>)","text":"<p>Sugar method: Retrieves closed positions (deals) for specified time period.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_deals(period, from_date, to_date)</code></li> <li>Returns: List of closed position objects</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/#method-signature","title":"Method Signature","text":"<pre><code>async def get_deals(\n    self,\n    period: Period = Period.TODAY,\n    from_date: Optional[date] = None,\n    to_date: Optional[date] = None\n) -&gt; List\n</code></pre>"},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>period</code> <code>Period</code> No <code>Period.TODAY</code> Time period enum (TODAY, YESTERDAY, THIS_WEEK, THIS_MONTH, CUSTOM) <code>from_date</code> <code>Optional[date]</code> No <code>None</code> Start date (required if period=CUSTOM) <code>to_date</code> <code>Optional[date]</code> No <code>None</code> End date (required if period=CUSTOM)"},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/#return-value","title":"Return Value","text":"Type Description <code>List</code> List of closed position objects (empty list if no deals)"},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Fetches closed positions from history</li> <li>Supports predefined periods via Period enum</li> <li>Returns full position details (ticket, symbol, profit, commission, swap, etc.)</li> <li>Fetches up to 10,000 positions per request</li> </ul> <p>Key behaviors:</p> <ul> <li>Uses positions_history (includes profit/commission/swap)</li> <li>Sorted by open time ascending</li> <li>Returns empty list if no deals</li> <li>CUSTOM period requires from_date and to_date</li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_deals()\n    \u2193 converts period to datetime range\nMT5Sugar._get_period_range()\n    \u2193 calls\nMT5Service.get_positions_history()\n    \u2193 calls\nMT5Account.positions_history()\n    \u2193 gRPC protobuf\nAccountHelperService.PositionsHistory()\n    \u2193 MT5 Terminal\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar converts Period enum to datetime range</li> <li>Sugar calls Service.get_positions_history() with date range</li> <li>Service forwards to Account.positions_history()</li> <li>Account sends gRPC request to terminal</li> <li>Returns list of history_positions (up to 10,000)</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1437</code></li> <li>Service: <code>src/pymt5/mt5_service.py:810</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1475</code></li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/#convenience-methods","title":"Convenience Methods","text":"<p>All these methods internally call <code>get_deals()</code> with different periods:</p> <pre><code># Today's deals\ndeals = await sugar.get_deals_today()\n# Same as: await sugar.get_deals(Period.TODAY)\n\n# Yesterday's deals\ndeals = await sugar.get_deals_yesterday()\n# Same as: await sugar.get_deals(Period.YESTERDAY)\n\n# This week's deals (Monday to today)\ndeals = await sugar.get_deals_this_week()\n# Same as: await sugar.get_deals(Period.THIS_WEEK)\n\n# This month's deals\ndeals = await sugar.get_deals_this_month()\n# Same as: await sugar.get_deals(Period.THIS_MONTH)\n\n# Custom date range\ndeals = await sugar.get_deals_date_range(date(2024, 1, 1), date(2024, 1, 31))\n# Same as: await sugar.get_deals(Period.CUSTOM, date(2024, 1, 1), date(2024, 1, 31))\n</code></pre>"},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/#when-to-use","title":"When to Use","text":"<p>Use <code>get_deals()</code> when:</p> <ul> <li>Analyzing trading history</li> <li>Calculating statistics (win rate, avg profit, etc.)</li> <li>Reviewing past trades</li> <li>Building trading journal</li> </ul> <p>Don't use when:</p> <ul> <li>Need only profit total (use <code>get_profit()</code>)</li> <li>Need current open positions (use <code>get_open_positions()</code>)</li> <li>Need real-time data (this is historical)</li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/#example-1-todays-deals","title":"Example 1: Today's Deals","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\nfrom pymt5.constants import Period\n\nasync def todays_deals():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get today's deals\n    deals = await sugar.get_deals(Period.TODAY)\n    # Or: deals = await sugar.get_deals_today()\n\n    print(f\"Today's deals: {len(deals)}\")\n\n    for deal in deals:\n        print(f\"#{deal.ticket}: {deal.symbol} {deal.volume} lots, \"\n              f\"Profit: ${deal.profit:.2f}\")\n\n# Output:\n# Today's deals: 5\n# #123456: EURUSD 0.1 lots, Profit: $12.50\n# #123457: GBPUSD 0.05 lots, Profit: -$3.20\n</code></pre>"},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/#example-2-this-weeks-performance","title":"Example 2: This Week's Performance","text":"<pre><code>from datetime import date\n\nasync def weekly_performance():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get this week's deals\n    deals = await sugar.get_deals_this_week()\n\n    if deals:\n        # Calculate statistics\n        total_trades = len(deals)\n        winning = sum(1 for d in deals if d.profit &gt; 0)\n        losing = sum(1 for d in deals if d.profit &lt; 0)\n        win_rate = (winning / total_trades) * 100\n\n        total_profit = sum(d.profit for d in deals)\n\n        print(f\"This Week's Performance:\")\n        print(f\"  Total trades: {total_trades}\")\n        print(f\"  Win rate: {win_rate:.1f}%\")\n        print(f\"  Total P&amp;L: ${total_profit:.2f}\")\n</code></pre>"},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/#example-3-custom-date-range-analysis","title":"Example 3: Custom Date Range Analysis","text":"<pre><code>from datetime import date\n\nasync def january_analysis():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get January 2024 deals\n    deals = await sugar.get_deals(\n        period=Period.CUSTOM,\n        from_date=date(2024, 1, 1),\n        to_date=date(2024, 1, 31)\n    )\n    # Or: deals = await sugar.get_deals_date_range(date(2024, 1, 1), date(2024, 1, 31))\n\n    # Analyze by symbol\n    from collections import defaultdict\n    by_symbol = defaultdict(list)\n\n    for deal in deals:\n        by_symbol[deal.symbol].append(deal)\n\n    print(\"January 2024 by Symbol:\")\n    for symbol, symbol_deals in by_symbol.items():\n        profit = sum(d.profit for d in symbol_deals)\n        print(f\"  {symbol}: {len(symbol_deals)} trades, ${profit:.2f}\")\n</code></pre>"},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Missing from_date/to_date for CUSTOM period <pre><code># ERROR: CUSTOM requires dates\ntry:\n    deals = await sugar.get_deals(Period.CUSTOM)\nexcept ValueError as e:\n    print(e)  # \"from_date and to_date required for CUSTOM period\"\n</code></pre></p> <p>Solution: Always provide dates for CUSTOM <pre><code>deals = await sugar.get_deals(\n    Period.CUSTOM,\n    from_date=date(2024, 1, 1),\n    to_date=date(2024, 1, 31)\n)\n</code></pre></p> <p>Pitfall 2: Assuming list is never empty <pre><code># ERROR: Crashes if no deals\ndeals = await sugar.get_deals_today()\nfirst_deal = deals[0]  # IndexError if empty\n</code></pre></p> <p>Solution: Check if list is empty <pre><code>deals = await sugar.get_deals_today()\n\nif deals:\n    first_deal = deals[0]\nelse:\n    print(\"No deals today\")\n</code></pre></p> <p>Pitfall 3: Exceeding 10,000 position limit <pre><code># Get deals for entire year\ndeals = await sugar.get_deals(\n    Period.CUSTOM,\n    from_date=date(2023, 1, 1),\n    to_date=date(2023, 12, 31)\n)\n# Returns max 10,000 positions\n</code></pre></p> <p>Solution: Split large date ranges <pre><code># Get deals month by month for large ranges\nfrom datetime import date, timedelta\n\nall_deals = []\nstart = date(2023, 1, 1)\nend = date(2023, 12, 31)\n\ncurrent = start\nwhile current &lt;= end:\n    month_end = min(current.replace(day=28) + timedelta(days=4), end)\n    month_end = month_end.replace(day=1) - timedelta(days=1)\n\n    deals = await sugar.get_deals(Period.CUSTOM, current, month_end)\n    all_deals.extend(deals)\n\n    current = month_end + timedelta(days=1)\n</code></pre></p>"},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Calculate win rate</p> <pre><code>deals = await sugar.get_deals_today()\n\nif deals:\n    winners = [d for d in deals if d.profit &gt; 0]\n    losers = [d for d in deals if d.profit &lt; 0]\n\n    win_rate = (len(winners) / len(deals)) * 100\n    print(f\"Win rate: {win_rate:.1f}%\")\n</code></pre> <p>Tip 2: Find best/worst trade <pre><code>deals = await sugar.get_deals_this_week()\n\nif deals:\n    best = max(deals, key=lambda d: d.profit)\n    worst = min(deals, key=lambda d: d.profit)\n\n    print(f\"Best trade: #{best.ticket} ${best.profit:.2f}\")\n    print(f\"Worst trade: #{worst.ticket} ${worst.profit:.2f}\")\n</code></pre></p> <p>Tip 3: Average profit per trade <pre><code>deals = await sugar.get_deals_this_month()\n\nif deals:\n    total_profit = sum(d.profit for d in deals)\n    avg_profit = total_profit / len(deals)\n\n    print(f\"Average per trade: ${avg_profit:.2f}\")\n</code></pre></p>"},{"location":"MT5Sugar/8.%20History_Statistics/get_deals/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_profit - Get total profit for period</li> <li>get_daily_stats - Comprehensive daily statistics</li> <li>get_open_positions - Current positions</li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/","title":"Get Historical Profit (<code>get_profit</code>)","text":"<p>Sugar method: Calculates total realized profit/loss for specified time period.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_profit(period, from_date, to_date)</code></li> <li>Returns: Total profit as float</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/#method-signature","title":"Method Signature","text":"<pre><code>async def get_profit(\n    self,\n    period: Period = Period.TODAY,\n    from_date: Optional[date] = None,\n    to_date: Optional[date] = None\n) -&gt; float\n</code></pre>"},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>period</code> <code>Period</code> No <code>Period.TODAY</code> Time period enum (TODAY, YESTERDAY, THIS_WEEK, THIS_MONTH, CUSTOM) <code>from_date</code> <code>Optional[date]</code> No <code>None</code> Start date (required if period=CUSTOM) <code>to_date</code> <code>Optional[date]</code> No <code>None</code> End date (required if period=CUSTOM)"},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/#return-value","title":"Return Value","text":"Type Description <code>float</code> Total realized profit/loss in account currency (positive = profit, negative = loss)"},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Fetches closed positions for period</li> <li>Sums profit field from all deals</li> <li>Returns total realized P&amp;L</li> <li>Returns 0.0 if no deals</li> </ul> <p>Key behaviors:</p> <ul> <li>Only closed positions (realized profit)</li> <li>Includes both profits and losses</li> <li>Does NOT subtract commission/swap (use <code>get_daily_stats</code> for net)</li> <li>Returns 0.0 if no deals (not None)</li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_profit()\n    \u2193 calls\nMT5Sugar.get_deals(period, from_date, to_date)\n    \u2193 sums order.profit for all deals\n    \u2193 returns total\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls get_deals() to fetch positions</li> <li>Sugar sums order.profit field from all positions</li> <li>Returns total sum</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1473</code></li> <li>Calls get_deals: <code>src/pymt5/mt5_sugar.py:1437</code></li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/#convenience-methods","title":"Convenience Methods","text":"<p>All these methods internally call <code>get_profit()</code> with different periods:</p> <pre><code># Today's profit\nprofit = await sugar.get_profit_today()\n# Same as: await sugar.get_profit(Period.TODAY)\n\n# This week's profit (Monday to today)\nprofit = await sugar.get_profit_this_week()\n# Same as: await sugar.get_profit(Period.THIS_WEEK)\n\n# This month's profit\nprofit = await sugar.get_profit_this_month()\n# Same as: await sugar.get_profit(Period.THIS_MONTH)\n\n# Custom date range\nprofit = await sugar.get_profit(Period.CUSTOM, date(2024, 1, 1), date(2024, 1, 31))\n</code></pre>"},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/#when-to-use","title":"When to Use","text":"<p>Use <code>get_profit()</code> when:</p> <ul> <li>Quick profit check for period</li> <li>Daily/weekly/monthly performance tracking</li> <li>Comparing profitability across periods</li> <li>Performance reports</li> </ul> <p>Don't use when:</p> <ul> <li>Need deal details (use <code>get_deals()</code>)</li> <li>Need commission/swap breakdown (use <code>get_daily_stats()</code>)</li> <li>Need floating profit (use <code>get_total_profit()</code>)</li> </ul>"},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/#example-1-todays-performance","title":"Example 1: Today's Performance","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\nfrom pymt5.constants import Period\n\nasync def daily_profit():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get today's profit\n    profit = await sugar.get_profit(Period.TODAY)\n    # Or: profit = await sugar.get_profit_today()\n\n    if profit &gt; 0:\n        print(f\"Today's profit: ${profit:.2f}\")\n    elif profit &lt; 0:\n        print(f\"Today's loss: ${abs(profit):.2f}\")\n    else:\n        print(\"Breakeven or no trades today\")\n\n# Output:\n# Today's profit: $125.50\n</code></pre>"},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/#example-2-weekly-progress-tracking","title":"Example 2: Weekly Progress Tracking","text":"<pre><code>async def weekly_progress():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get this week's profit\n    weekly = await sugar.get_profit_this_week()\n\n    # Get balance to calculate percentage\n    balance = await sugar.get_balance()\n    weekly_pct = (weekly / balance) * 100\n\n    print(f\"This Week's Performance:\")\n    print(f\"  Profit: ${weekly:.2f}\")\n    print(f\"  Return: {weekly_pct:+.2f}%\")\n</code></pre>"},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/#example-3-monthly-comparison","title":"Example 3: Monthly Comparison","text":"<pre><code>from datetime import date\n\nasync def compare_months():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Compare last 3 months\n    months = [\n        (\"January\", date(2024, 1, 1), date(2024, 1, 31)),\n        (\"February\", date(2024, 2, 1), date(2024, 2, 29)),\n        (\"March\", date(2024, 3, 1), date(2024, 3, 31))\n    ]\n\n    print(\"Monthly Performance:\")\n    for name, start, end in months:\n        profit = await sugar.get_profit(Period.CUSTOM, start, end)\n        print(f\"  {name}: ${profit:+.2f}\")\n\n# Output:\n# Monthly Performance:\n#   January: $+250.30\n#   February: $-45.20\n#   March: $+180.50\n</code></pre>"},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Confusing with floating profit <pre><code># get_profit() = REALIZED profit (closed positions)\nrealized = await sugar.get_profit_today()\n\n# get_total_profit() = FLOATING profit (open positions)\nfloating = await sugar.get_total_profit()\n\n# They're different!\nprint(f\"Realized: ${realized:.2f}\")\nprint(f\"Floating: ${floating:.2f}\")\n</code></pre></p> <p>Pitfall 2: Expecting None instead of 0 <pre><code># Returns 0.0 if no trades, not None\nprofit = await sugar.get_profit_today()\n\nif profit:  # 0.0 is falsy, but valid\n    print(\"Made profit/loss\")\n</code></pre></p> <p>Solution: Compare explicitly <pre><code>profit = await sugar.get_profit_today()\n\nif profit &gt; 0:\n    print(f\"Profit: ${profit:.2f}\")\nelif profit &lt; 0:\n    print(f\"Loss: ${abs(profit):.2f}\")\nelse:\n    print(\"No trades or breakeven\")\n</code></pre></p> <p>Pitfall 3: Not accounting for commission/swap <pre><code># get_profit() only sums order.profit field\n# Doesn't subtract commission and swap separately\nprofit = await sugar.get_profit_today()\n# This is gross profit, not net\n</code></pre></p> <p>Solution: Use get_daily_stats for breakdown <pre><code>stats = await sugar.get_daily_stats()\nprint(f\"Gross profit: ${stats.total_profit:.2f}\")\nprint(f\"Commission: ${stats.total_commission:.2f}\")\nprint(f\"Swap: ${stats.total_swap:.2f}\")\nprint(f\"Net profit: ${stats.net_profit:.2f}\")\n</code></pre></p>"},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Daily profit target <pre><code># Set daily profit target\ndaily_target = 100.0\n\nprofit = await sugar.get_profit_today()\n\nif profit &gt;= daily_target:\n    print(f\"Target reached: ${profit:.2f}\")\n\n    # Stop trading for the day\n    await sugar.close_all_positions()\n</code></pre></p> <p>Tip 2: Compare today vs yesterday <pre><code>today = await sugar.get_profit_today()\nyesterday = await sugar.get_profit(Period.YESTERDAY)\n\nchange = today - yesterday\nprint(f\"Today: ${today:.2f}\")\nprint(f\"Yesterday: ${yesterday:.2f}\")\nprint(f\"Change: ${change:+.2f}\")\n</code></pre></p> <p>Tip 3: Profit per day of week <pre><code>from datetime import date, timedelta\n\nasync def profit_by_weekday():\n    \"\"\"Calculate average profit by day of week.\"\"\"\n    from collections import defaultdict\n\n    # Get last month's data\n    today = date.today()\n    start = today.replace(day=1)\n\n    deals = await sugar.get_deals(Period.CUSTOM, start, today)\n\n    by_weekday = defaultdict(list)\n    for deal in deals:\n        weekday = deal.time_open.weekday()  # 0=Mon, 6=Sun\n        by_weekday[weekday].append(deal.profit)\n\n    days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n    for i, day in enumerate(days):\n        if by_weekday[i]:\n            avg = sum(by_weekday[i]) / len(by_weekday[i])\n            print(f\"{day}: ${avg:.2f} avg\")\n</code></pre></p>"},{"location":"MT5Sugar/8.%20History_Statistics/get_profit/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_deals - Get historical deals (positions)</li> <li>get_daily_stats - Comprehensive daily statistics with commission/swap</li> <li>get_total_profit - Floating profit (open positions)</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_all_symbols/","title":"Get All Symbols (<code>get_all_symbols</code>)","text":"<p>Sugar method: Returns complete list of all available trading symbols.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_all_symbols()</code></li> <li>Returns: List of symbol names (strings)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_all_symbols/#method-signature","title":"Method Signature","text":"<pre><code>async def get_all_symbols(self) -&gt; List[str]\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_all_symbols/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"<p>No parameters required.</p>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_all_symbols/#return-value","title":"Return Value","text":"Type Description <code>List[str]</code> List of all available symbol names (e.g., [\"EURUSD\", \"GBPUSD\", ...])"},{"location":"MT5Sugar/9.%20Symbol_Information/get_all_symbols/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Fetches complete list of all symbols available on broker</li> <li>Uses optimized batch fetching with pagination</li> <li>Returns 100 symbols per page</li> <li>More efficient than individual symbol queries</li> </ul> <p>Key behaviors:</p> <ul> <li>Automatically handles pagination</li> <li>Returns ALL symbols (not just visible ones)</li> <li>Fetches 100 symbols per request</li> <li>Can return hundreds of symbols</li> <li>Returns symbol names only (not full info)</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_all_symbols/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_all_symbols()\n    \u2193 loops with pagination (100 per page)\n    \u2193 calls\nMT5Service.get_symbol_params_many(name_filter=None)\n    \u2193 calls\nMT5Account.symbol_params_many()\n    \u2193 gRPC protobuf\nMarketInfoService.SymbolParamsMany()\n    \u2193 MT5 Terminal\n    \u2193 extracts symbol names from SymbolParams\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar starts pagination loop (page=1, size=100)</li> <li>Sugar calls Service.get_symbol_params_many() with no filter</li> <li>Service forwards to Account.symbol_params_many()</li> <li>Account sends gRPC request to terminal</li> <li>Sugar extracts name from each SymbolParams</li> <li>Continues pagination until all symbols fetched</li> <li>Returns complete list of symbol names</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1642</code></li> <li>Service: <code>src/pymt5/mt5_service.py:658</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1221</code></li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_all_symbols/#when-to-use","title":"When to Use","text":"<p>Use <code>get_all_symbols()</code> when:</p> <ul> <li>Building symbol selection UI</li> <li>Scanning all symbols for opportunities</li> <li>Validating symbol lists</li> <li>Discovering available instruments</li> <li>Symbol autocomplete features</li> </ul> <p>Don't use when:</p> <ul> <li>Only need specific symbols (hardcode them)</li> <li>Only need forex pairs (use filtered approach)</li> <li>Need full symbol info (use <code>get_symbol_info()</code>)</li> <li>Checking if one symbol exists (use <code>is_symbol_available()</code>)</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_all_symbols/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/9.%20Symbol_Information/get_all_symbols/#example-1-list-all-available-symbols","title":"Example 1: List All Available Symbols","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def list_symbols():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get all symbols\n    symbols = await sugar.get_all_symbols()\n\n    print(f\"Total symbols available: {len(symbols)}\")\n    print(f\"First 10 symbols: {symbols[:10]}\")\n\n# Output:\n# Total symbols available: 358\n# First 10 symbols: ['AUDCAD', 'AUDCHF', 'AUDJPY', 'AUDNZD', 'AUDUSD', 'CADCHF', 'CADJPY', 'CHFJPY', 'EURAUD', 'EURCAD']\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_all_symbols/#example-2-find-forex-pairs-only","title":"Example 2: Find Forex Pairs Only","text":"<pre><code>async def find_forex_pairs():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get all symbols\n    all_symbols = await sugar.get_all_symbols()\n\n    # Common forex currency codes\n    currencies = ['EUR', 'USD', 'GBP', 'JPY', 'AUD', 'CAD', 'CHF', 'NZD']\n\n    # Filter forex pairs (both currencies in common list)\n    forex_pairs = [\n        s for s in all_symbols\n        if len(s) == 6 and s[:3] in currencies and s[3:] in currencies\n    ]\n\n    print(f\"Forex pairs: {len(forex_pairs)}\")\n    print(forex_pairs)\n\n# Output:\n# Forex pairs: 28\n# ['AUDCAD', 'AUDCHF', 'AUDJPY', 'AUDNZD', 'AUDUSD', ...]\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_all_symbols/#example-3-search-for-specific-symbols","title":"Example 3: Search for Specific Symbols","text":"<pre><code>async def search_symbols():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get all symbols\n    all_symbols = await sugar.get_all_symbols()\n\n    # Find gold symbols\n    gold_symbols = [s for s in all_symbols if 'XAU' in s or 'GOLD' in s]\n    print(f\"Gold symbols: {gold_symbols}\")\n\n    # Find EUR pairs\n    eur_pairs = [s for s in all_symbols if s.startswith('EUR')]\n    print(f\"EUR pairs ({len(eur_pairs)}): {eur_pairs}\")\n\n    # Find crypto\n    crypto = [s for s in all_symbols if 'BTC' in s or 'ETH' in s]\n    print(f\"Crypto: {crypto}\")\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_all_symbols/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Expecting sorted results <pre><code># Symbols may not be in alphabetical order\nsymbols = await sugar.get_all_symbols()\n# Order depends on broker's response\n</code></pre></p> <p>Solution: Sort manually if needed <pre><code>symbols = await sugar.get_all_symbols()\nsymbols_sorted = sorted(symbols)\n</code></pre></p> <p>Pitfall 2: Not caching results <pre><code># Fetching all symbols repeatedly is slow\nfor i in range(10):\n    symbols = await sugar.get_all_symbols()  # Slow!\n    # Do something with symbols\n</code></pre></p> <p>Solution: Cache the list <pre><code># Fetch once\nsymbols_cache = await sugar.get_all_symbols()\n\n# Use cached list\nfor i in range(10):\n    # Use symbols_cache\n    pass\n</code></pre></p> <p>Pitfall 3: Assuming all symbols are tradable <pre><code># Not all symbols may be currently tradable\nsymbols = await sugar.get_all_symbols()\n\n# Some might be disabled or restricted\nfor symbol in symbols:\n    await sugar.buy_market(symbol, volume=0.01)  # May fail!\n</code></pre></p> <p>Solution: Check if symbol is tradable first <pre><code>symbols = await sugar.get_all_symbols()\n\nfor symbol in symbols:\n    # Check availability\n    is_available = await sugar.is_symbol_available(symbol)\n\n    if is_available:\n        # Now safe to trade\n        pass\n</code></pre></p>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_all_symbols/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Cache symbols with TTL <pre><code>from datetime import datetime, timedelta\n\nclass SymbolCache:\n    def __init__(self, ttl_minutes=60):\n        self.symbols = None\n        self.last_fetch = None\n        self.ttl = timedelta(minutes=ttl_minutes)\n\n    async def get_symbols(self, sugar):\n        \"\"\"Get symbols with 1-hour cache.\"\"\"\n        now = datetime.now()\n\n        if self.symbols is None or (now - self.last_fetch) &gt; self.ttl:\n            self.symbols = await sugar.get_all_symbols()\n            self.last_fetch = now\n\n        return self.symbols\n\n# Usage\ncache = SymbolCache(ttl_minutes=60)\nsymbols = await cache.get_symbols(sugar)\n</code></pre></p> <p>Tip 2: Group symbols by type <pre><code>from collections import defaultdict\n\nasync def group_symbols_by_type():\n    \"\"\"Group symbols into categories.\"\"\"\n    symbols = await sugar.get_all_symbols()\n\n    groups = defaultdict(list)\n\n    for symbol in symbols:\n        if 'XAU' in symbol or 'GOLD' in symbol:\n            groups['Metals'].append(symbol)\n        elif 'BTC' in symbol or 'ETH' in symbol:\n            groups['Crypto'].append(symbol)\n        elif len(symbol) == 6:  # Likely forex\n            groups['Forex'].append(symbol)\n        else:\n            groups['Other'].append(symbol)\n\n    for category, syms in groups.items():\n        print(f\"{category}: {len(syms)} symbols\")\n</code></pre></p> <p>Tip 3: Create symbol autocomplete <pre><code>async def autocomplete_symbol(prefix: str):\n    \"\"\"Autocomplete symbol names.\"\"\"\n    all_symbols = await sugar.get_all_symbols()\n\n    # Find matches\n    matches = [s for s in all_symbols if s.startswith(prefix.upper())]\n\n    return matches[:10]  # Return top 10 matches\n\n# Usage\nmatches = await autocomplete_symbol(\"EUR\")\nprint(matches)  # ['EURAUD', 'EURCAD', 'EURCHF', ...]\n</code></pre></p>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_all_symbols/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_symbol_info - Get complete symbol parameters</li> <li>is_symbol_available - Check if symbol exists</li> <li>get_symbol_digits - Get decimal places for symbol</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_min_stop_level/","title":"Get Minimum Stop Level (<code>get_min_stop_level</code>)","text":"<p>Sugar method: Returns minimum allowed distance for Stop Loss and Take Profit in points.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_min_stop_level(symbol)</code></li> <li>Returns: Minimum stop level in points (integer)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_min_stop_level/#method-signature","title":"Method Signature","text":"<pre><code>async def get_min_stop_level(self, symbol: str) -&gt; int\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_min_stop_level/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>str</code> Yes - Trading symbol (e.g., \"EURUSD\")"},{"location":"MT5Sugar/9.%20Symbol_Information/get_min_stop_level/#return-value","title":"Return Value","text":"Type Description <code>int</code> Minimum stop level in points (0 means no restriction)"},{"location":"MT5Sugar/9.%20Symbol_Information/get_min_stop_level/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Gets minimum allowed distance between price and SL/TP</li> <li>Returns value in points (not pips)</li> <li>Used to validate SL/TP placement</li> <li>Broker-defined restriction</li> </ul> <p>Key behaviors:</p> <ul> <li>Returns 0 if no minimum restriction</li> <li>Value is in points (EURUSD: 1 point = 0.00001)</li> <li>Same minimum applies to both SL and TP</li> <li>Measured from current price, not open price</li> <li>Violating this causes trade rejection</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_min_stop_level/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_min_stop_level()\n    \u2193 calls\nMT5Service.get_symbol_integer(symbol, SYMBOL_TRADE_STOPS_LEVEL)\n    \u2193 calls\nMT5Account.symbol_info_integer()\n    \u2193 gRPC protobuf\nMarketInfoService.SymbolInfoInteger(property=SYMBOL_TRADE_STOPS_LEVEL)\n    \u2193 MT5 Terminal\n    \u2193 returns minimum stop level\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.get_symbol_integer() with SYMBOL_TRADE_STOPS_LEVEL property</li> <li>Service forwards to Account.symbol_info_integer()</li> <li>Account sends gRPC request with property enum</li> <li>Terminal retrieves minimum stop level for symbol</li> <li>Returns integer value in points</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1677</code></li> <li>Service: <code>src/pymt5/mt5_service.py:497</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:951</code></li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_min_stop_level/#when-to-use","title":"When to Use","text":"<p>Use <code>get_min_stop_level()</code> when:</p> <ul> <li>Validating SL/TP before order placement</li> <li>Calculating safe SL/TP distances</li> <li>Building order validation logic</li> <li>Error prevention in automated trading</li> <li>Adjusting SL/TP to broker requirements</li> </ul> <p>Don't use when:</p> <ul> <li>Broker has no restrictions (returns 0 anyway)</li> <li>Already know the minimum level</li> <li>Not using SL/TP in orders</li> <li>Only doing market orders without SL/TP</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_min_stop_level/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/9.%20Symbol_Information/get_min_stop_level/#example-1-check-minimum-stop-level","title":"Example 1: Check Minimum Stop Level","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def check_min_level():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n\n    # Get minimum stop level\n    min_level = await sugar.get_min_stop_level(symbol)\n\n    if min_level == 0:\n        print(f\"{symbol}: No minimum stop level restriction\")\n    else:\n        print(f\"{symbol}: Minimum stop level = {min_level} points\")\n\n        # Get symbol info to convert points to price\n        info = await sugar.get_symbol_info(symbol)\n        min_distance = min_level * info.point\n\n        print(f\"Minimum SL/TP distance: {min_distance:.{info.digits}f}\")\n\n# Output:\n# EURUSD: Minimum stop level = 20 points\n# Minimum SL/TP distance: 0.00020\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_min_stop_level/#example-2-validate-sltp-before-order","title":"Example 2: Validate SL/TP Before Order","text":"<pre><code>async def validate_sltp():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n\n    # Get current price and min level\n    bid = await sugar.get_bid(symbol)\n    min_level = await sugar.get_min_stop_level(symbol)\n    info = await sugar.get_symbol_info(symbol)\n\n    # Desired SL 10 points from price\n    desired_sl_points = 10\n    desired_sl = bid - (desired_sl_points * info.point)\n\n    # Validate\n    if min_level &gt; 0 and desired_sl_points &lt; min_level:\n        print(f\"ERROR: SL too close to price\")\n        print(f\"Desired: {desired_sl_points} points\")\n        print(f\"Minimum: {min_level} points\")\n\n        # Adjust to minimum\n        adjusted_sl = bid - (min_level * info.point)\n        print(f\"Adjusted SL: {adjusted_sl:.{info.digits}f}\")\n    else:\n        print(f\"SL validation passed\")\n\n        # Safe to place order\n        ticket = await sugar.sell_market_with_sltp(\n            symbol,\n            volume=0.1,\n            sl=desired_sl\n        )\n\n# Output:\n# ERROR: SL too close to price\n# Desired: 10 points\n# Minimum: 20 points\n# Adjusted SL: 1.08412\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_min_stop_level/#example-3-safe-sltp-calculator","title":"Example 3: Safe SL/TP Calculator","text":"<pre><code>async def calculate_safe_sltp():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n\n    # Get requirements\n    ask = await sugar.get_ask(symbol)\n    min_level = await sugar.get_min_stop_level(symbol)\n    info = await sugar.get_symbol_info(symbol)\n\n    # User wants 50 pips SL/TP\n    desired_pips = 50\n    desired_points = desired_pips * 10  # 500 points\n\n    # Check against minimum\n    actual_points = max(desired_points, min_level)\n\n    if actual_points &gt; desired_points:\n        print(f\"Adjusted from {desired_pips} to {actual_points/10} pips (broker minimum)\")\n\n    # Calculate SL/TP for BUY order\n    sl_price = ask - (actual_points * info.point)\n    tp_price = ask + (actual_points * info.point)\n\n    print(f\"Entry: {ask:.{info.digits}f}\")\n    print(f\"SL: {sl_price:.{info.digits}f} ({actual_points} points)\")\n    print(f\"TP: {tp_price:.{info.digits}f} ({actual_points} points)\")\n\n    # Place order\n    ticket = await sugar.buy_market_with_sltp(\n        symbol,\n        volume=0.1,\n        sl=sl_price,\n        tp=tp_price\n    )\n    print(f\"Order placed: {ticket}\")\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_min_stop_level/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Confusing points and pips <pre><code># ERROR: min_level is in points, not pips\nmin_level = await sugar.get_min_stop_level(\"EURUSD\")\n# Returns 20 (points), not 2 (pips)\n\n# Setting SL 20 pips away instead of 20 points\ninfo = await sugar.get_symbol_info(\"EURUSD\")\nsl = bid - (min_level * info.point * 10)  # WRONG! Too far\n</code></pre></p> <p>Solution: Use points directly <pre><code>min_level = await sugar.get_min_stop_level(\"EURUSD\")\ninfo = await sugar.get_symbol_info(\"EURUSD\")\n\n# Correct: min_level is already in points\nsl = bid - (min_level * info.point)\n</code></pre></p> <p>Pitfall 2: Not checking for zero <pre><code># Assuming minimum always exists\nmin_level = await sugar.get_min_stop_level(\"EURUSD\")\n\n# If returns 0, no minimum required\n# Your validation logic might fail\nif desired_points &lt; min_level:  # Always False if min_level=0\n    print(\"Too close\")\n</code></pre></p> <p>Solution: Check for zero explicitly <pre><code>min_level = await sugar.get_min_stop_level(\"EURUSD\")\n\nif min_level &gt; 0 and desired_points &lt; min_level:\n    print(f\"Too close, minimum is {min_level} points\")\n</code></pre></p> <p>Pitfall 3: Using open price instead of current price <pre><code># ERROR: Minimum is from CURRENT price, not open price\nopen_price = 1.08500\nsl = open_price - (min_level * info.point)\n\n# If current price moved, this SL might violate minimum\n</code></pre></p> <p>Solution: Always use current market price <pre><code># For BUY position (check against BID)\ncurrent_bid = await sugar.get_bid(symbol)\nsl = current_bid - (min_level * info.point)\n\n# For SELL position (check against ASK)\ncurrent_ask = await sugar.get_ask(symbol)\nsl = current_ask + (min_level * info.point)\n</code></pre></p>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_min_stop_level/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: SL/TP validator helper <pre><code>async def validate_sltp_distance(sugar, symbol, order_type, price, sl, tp):\n    \"\"\"Validate SL/TP meet minimum distance requirement.\"\"\"\n    min_level = await sugar.get_min_stop_level(symbol)\n\n    if min_level == 0:\n        return True  # No restriction\n\n    info = await sugar.get_symbol_info(symbol)\n    min_distance = min_level * info.point\n\n    # Check SL\n    if sl is not None:\n        sl_distance = abs(price - sl)\n        if sl_distance &lt; min_distance:\n            print(f\"SL too close: {sl_distance:.{info.digits}f} &lt; {min_distance:.{info.digits}f}\")\n            return False\n\n    # Check TP\n    if tp is not None:\n        tp_distance = abs(price - tp)\n        if tp_distance &lt; min_distance:\n            print(f\"TP too close: {tp_distance:.{info.digits}f} &lt; {min_distance:.{info.digits}f}\")\n            return False\n\n    return True\n\n# Usage\nask = await sugar.get_ask(\"EURUSD\")\nsl = ask - 0.00010  # 10 points\n\nis_valid = await validate_sltp_distance(sugar, \"EURUSD\", \"BUY\", ask, sl, None)\n</code></pre></p> <p>Tip 2: Auto-adjust to minimum <pre><code>async def adjust_sltp_to_minimum(sugar, symbol, desired_points):\n    \"\"\"Ensure SL/TP meets minimum requirement.\"\"\"\n    min_level = await sugar.get_min_stop_level(symbol)\n\n    # Use greater of desired or minimum\n    actual_points = max(desired_points, min_level)\n\n    if actual_points &gt; desired_points:\n        print(f\"Adjusted from {desired_points} to {actual_points} points (broker minimum)\")\n\n    return actual_points\n\n# Usage\nactual_points = await adjust_sltp_to_minimum(sugar, \"EURUSD\", desired_points=10)\n</code></pre></p> <p>Tip 3: Convert points to price helper <pre><code>async def calculate_sltp_prices(sugar, symbol, order_type, distance_points):\n    \"\"\"Calculate SL/TP prices ensuring minimum distance.\"\"\"\n    # Get minimum and adjust\n    min_level = await sugar.get_min_stop_level(symbol)\n    actual_points = max(distance_points, min_level)\n\n    info = await sugar.get_symbol_info(symbol)\n    distance = actual_points * info.point\n\n    if order_type == \"BUY\":\n        price = info.ask\n        sl = price - distance\n        tp = price + distance\n    else:  # SELL\n        price = info.bid\n        sl = price + distance\n        tp = price - distance\n\n    return {\n        \"entry\": price,\n        \"sl\": sl,\n        \"tp\": tp,\n        \"distance_points\": actual_points\n    }\n\n# Usage\nprices = await calculate_sltp_prices(sugar, \"EURUSD\", \"BUY\", distance_points=50)\nprint(f\"Entry: {prices['entry']}, SL: {prices['sl']}, TP: {prices['tp']}\")\n</code></pre></p>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_min_stop_level/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_symbol_info - Get symbol parameters including point value</li> <li>buy_market_with_sltp - Open BUY with SL/TP</li> <li>modify_position_sltp - Modify SL/TP on position</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_digits/","title":"Get Symbol Digits (<code>get_symbol_digits</code>)","text":"<p>Sugar method: Returns number of decimal places in symbol price.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_symbol_digits(symbol)</code></li> <li>Returns: Number of digits after decimal point (integer)</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_digits/#method-signature","title":"Method Signature","text":"<pre><code>async def get_symbol_digits(self, symbol: str) -&gt; int\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_digits/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>str</code> Yes - Trading symbol (e.g., \"EURUSD\")"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_digits/#return-value","title":"Return Value","text":"Type Description <code>int</code> Number of decimal places (e.g., 5 for EURUSD, 3 for USDJPY, 2 for XAUUSD)"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_digits/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Gets decimal precision for symbol prices</li> <li>Essential for price formatting</li> <li>Used in price calculations</li> <li>Broker-specific value</li> </ul> <p>Key behaviors:</p> <ul> <li>Forex majors typically 5 digits (EURUSD: 1.08432)</li> <li>JPY pairs typically 3 digits (USDJPY: 149.385)</li> <li>Metals typically 2 digits (XAUUSD: 2043.50)</li> <li>Required for proper price display</li> <li>Used in rounding calculations</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_digits/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_symbol_digits()\n    \u2193 calls\nMT5Service.get_symbol_integer(symbol, SYMBOL_DIGITS)\n    \u2193 calls\nMT5Account.symbol_info_integer()\n    \u2193 gRPC protobuf\nMarketInfoService.SymbolInfoInteger(property=SYMBOL_DIGITS)\n    \u2193 MT5 Terminal\n    \u2193 returns digits value\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.get_symbol_integer() with SYMBOL_DIGITS property</li> <li>Service forwards to Account.symbol_info_integer()</li> <li>Account sends gRPC request with property enum</li> <li>Terminal retrieves digits value for symbol</li> <li>Returns integer (number of decimal places)</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1697</code></li> <li>Service: <code>src/pymt5/mt5_service.py:497</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:951</code></li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_digits/#when-to-use","title":"When to Use","text":"<p>Use <code>get_symbol_digits()</code> when:</p> <ul> <li>Formatting prices for display</li> <li>Rounding prices to valid precision</li> <li>Calculating price differences</li> <li>Logging price values</li> <li>Building price input validation</li> </ul> <p>Don't use when:</p> <ul> <li>Already have SymbolInfo (use info.digits)</li> <li>Hardcoded symbols with known digits</li> <li>Don't need precise formatting</li> <li>Working with volumes (not prices)</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_digits/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_digits/#example-1-format-prices-correctly","title":"Example 1: Format Prices Correctly","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def format_prices():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbols = [\"EURUSD\", \"USDJPY\", \"XAUUSD\"]\n\n    for symbol in symbols:\n        # Get digits\n        digits = await sugar.get_symbol_digits(symbol)\n\n        # Get current price\n        bid = await sugar.get_bid(symbol)\n\n        # Format with correct precision\n        formatted = f\"{bid:.{digits}f}\"\n\n        print(f\"{symbol}: {formatted} ({digits} digits)\")\n\n# Output:\n# EURUSD: 1.08432 (5 digits)\n# USDJPY: 149.385 (3 digits)\n# XAUUSD: 2043.50 (2 digits)\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_digits/#example-2-round-price-to-valid-precision","title":"Example 2: Round Price to Valid Precision","text":"<pre><code>async def round_price():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n\n    # User calculates custom price\n    calculated_price = 1.084567890123  # Too many decimals\n\n    # Get valid precision\n    digits = await sugar.get_symbol_digits(symbol)\n\n    # Round to valid precision\n    valid_price = round(calculated_price, digits)\n\n    print(f\"Calculated: {calculated_price}\")\n    print(f\"Rounded ({digits} digits): {valid_price:.{digits}f}\")\n\n    # Now safe to use in order\n    ticket = await sugar.buy_limit(\n        symbol,\n        volume=0.1,\n        price=valid_price\n    )\n\n# Output:\n# Calculated: 1.084567890123\n# Rounded (5 digits): 1.08457\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_digits/#example-3-calculate-pip-value","title":"Example 3: Calculate Pip Value","text":"<pre><code>async def calculate_pips():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n\n    # Get two prices\n    price1 = 1.08432\n    price2 = 1.08567\n\n    # Get digits to determine pip size\n    digits = await sugar.get_symbol_digits(symbol)\n\n    # Calculate difference\n    diff = abs(price2 - price1)\n\n    # Convert to pips based on digits\n    if digits == 5 or digits == 3:\n        # 5-digit pricing: 1 pip = 10 points\n        pips = diff * (10 ** (digits - 1)) / 10\n    elif digits == 4 or digits == 2:\n        # 4-digit pricing: 1 pip = 1 point\n        pips = diff * (10 ** digits)\n    else:\n        pips = 0\n\n    print(f\"{symbol} ({digits} digits):\")\n    print(f\"Price 1: {price1:.{digits}f}\")\n    print(f\"Price 2: {price2:.{digits}f}\")\n    print(f\"Difference: {pips:.1f} pips\")\n\n# Output:\n# EURUSD (5 digits):\n# Price 1: 1.08432\n# Price 2: 1.08567\n# Difference: 13.5 pips\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_digits/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Hardcoding digits <pre><code># ERROR: Digits can vary by broker\nprice = 1.08432\nformatted = f\"{price:.5f}\"  # Assumes 5 digits\n\n# Works for some brokers, fails for others\n</code></pre></p> <p>Solution: Always fetch dynamically <pre><code>digits = await sugar.get_symbol_digits(symbol)\nformatted = f\"{price:.{digits}f}\"\n</code></pre></p> <p>Pitfall 2: Confusing digits with point <pre><code># ERROR: digits != point value\ndigits = await sugar.get_symbol_digits(\"EURUSD\")  # Returns 5\n\n# This is NOT the same as point (0.00001)\npoint = 10 ** -digits  # 0.00001 \u2713\n</code></pre></p> <p>Solution: Use SymbolInfo for point <pre><code>info = await sugar.get_symbol_info(\"EURUSD\")\ndigits = info.digits  # 5\npoint = info.point    # 0.00001\n</code></pre></p> <p>Pitfall 3: Using wrong decimal separator <pre><code># System locale might use comma\nimport locale\nlocale.setlocale(locale.LC_ALL, 'de_DE')\n\nprice = 1.08432\nformatted = f\"{price:.5f}\"  # Might print \"1,08432\" in some locales\n\n# MT5 expects dot, not comma\n</code></pre></p> <p>Solution: Force dot separator <pre><code># Always use dot for MT5\nformatted = f\"{price:.{digits}f}\".replace(',', '.')\n\n# Or use explicit formatting\nformatted = \"{:.{}f}\".format(price, digits)\n</code></pre></p>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_digits/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Price formatter helper <pre><code>async def format_price(sugar, symbol, price):\n    \"\"\"Format price with correct precision for symbol.\"\"\"\n    digits = await sugar.get_symbol_digits(symbol)\n    return f\"{price:.{digits}f}\"\n\n# Usage\nbid = await sugar.get_bid(\"EURUSD\")\nformatted = await format_price(sugar, \"EURUSD\", bid)\nprint(f\"BID: {formatted}\")\n</code></pre></p> <p>Tip 2: Price validator <pre><code>async def validate_price_precision(sugar, symbol, price):\n    \"\"\"Check if price has valid precision.\"\"\"\n    digits = await sugar.get_symbol_digits(symbol)\n\n    # Round to valid precision\n    rounded = round(price, digits)\n\n    # Check if it changed\n    if rounded != price:\n        print(f\"Warning: Price {price} rounded to {rounded:.{digits}f}\")\n        return rounded\n\n    return price\n\n# Usage\nprice = 1.084567890  # Too many decimals\nvalid_price = await validate_price_precision(sugar, \"EURUSD\", price)\n</code></pre></p> <p>Tip 3: Multi-symbol price table <pre><code>async def price_table(sugar, symbols):\n    \"\"\"Display formatted prices for multiple symbols.\"\"\"\n    print(f\"{'Symbol':&lt;10} {'BID':&lt;12} {'ASK':&lt;12} {'Spread'}\")\n    print(\"-\" * 50)\n\n    for symbol in symbols:\n        digits = await sugar.get_symbol_digits(symbol)\n        bid = await sugar.get_bid(symbol)\n        ask = await sugar.get_ask(symbol)\n        spread = ask - bid\n\n        print(f\"{symbol:&lt;10} \"\n              f\"{bid:&lt;12.{digits}f} \"\n              f\"{ask:&lt;12.{digits}f} \"\n              f\"{spread:.{digits}f}\")\n\n# Usage\nawait price_table(sugar, [\"EURUSD\", \"GBPUSD\", \"USDJPY\", \"XAUUSD\"])\n\n# Output:\n# Symbol     BID          ASK          Spread\n# --------------------------------------------------\n# EURUSD     1.08432      1.08445      0.00013\n# GBPUSD     1.26789      1.26805      0.00016\n# USDJPY     149.385      149.398      0.013\n# XAUUSD     2043.50      2043.80      0.30\n</code></pre></p>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_digits/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_symbol_info - Get complete symbol info (includes digits)</li> <li>get_bid - Get current BID price</li> <li>get_ask - Get current ASK price</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_info/","title":"Get Symbol Information (<code>get_symbol_info</code>)","text":"<p>Sugar method: Returns complete trading parameters for symbol.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.get_symbol_info(symbol)</code></li> <li>Returns: <code>SymbolInfo</code> dataclass with trading parameters</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_info/#method-signature","title":"Method Signature","text":"<pre><code>async def get_symbol_info(self, symbol: str) -&gt; SymbolInfo\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_info/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>str</code> Yes - Trading symbol (e.g., \"EURUSD\")"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_info/#return-value","title":"Return Value","text":"<p><code>SymbolInfo</code> dataclass with the following fields:</p> Field Type Description <code>name</code> <code>str</code> Symbol name <code>bid</code> <code>float</code> Current BID price <code>ask</code> <code>float</code> Current ASK price <code>spread</code> <code>int</code> Current spread in points <code>digits</code> <code>int</code> Decimal places in price <code>point</code> <code>float</code> Minimum price change (0.00001 for EURUSD) <code>volume_min</code> <code>float</code> Minimum volume in lots <code>volume_max</code> <code>float</code> Maximum volume in lots <code>volume_step</code> <code>float</code> Volume step (e.g., 0.01) <code>contract_size</code> <code>float</code> Contract size (100,000 for standard forex) <p>Raises:</p> <ul> <li><code>ValueError</code> if symbol not found</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_info/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Fetches complete symbol parameters in one call</li> <li>Returns structured SymbolInfo object</li> <li>More efficient than multiple separate calls</li> <li>Includes current prices and trading constraints</li> </ul> <p>Key behaviors:</p> <ul> <li>Raises ValueError if symbol doesn't exist</li> <li>Returns current prices (bid/ask)</li> <li>Includes volume constraints for validation</li> <li>Contract size for margin/pip calculations</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_info/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.get_symbol_info()\n    \u2193 calls\nMT5Service.get_symbol_params_many(name_filter=symbol)\n    \u2193 calls\nMT5Account.symbol_params_many()\n    \u2193 gRPC protobuf\nMarketInfoService.SymbolParamsMany()\n    \u2193 MT5 Terminal\n    \u2193 extracts 10 key fields into SymbolInfo\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.get_symbol_params_many() with symbol filter</li> <li>Service forwards to Account.symbol_params_many()</li> <li>Account sends gRPC request to terminal</li> <li>Sugar extracts 10 key fields from SymbolParams</li> <li>Returns SymbolInfo dataclass</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1615</code></li> <li>SymbolInfo dataclass: <code>src/pymt5/mt5_sugar.py:179</code></li> <li>Service: <code>src/pymt5/mt5_service.py:658</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:1221</code></li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_info/#when-to-use","title":"When to Use","text":"<p>Use <code>get_symbol_info()</code> when:</p> <ul> <li>Need multiple symbol parameters</li> <li>Validating volume before trading</li> <li>Calculating pip values</li> <li>Price formatting with correct digits</li> <li>Checking trading constraints</li> </ul> <p>Don't use when:</p> <ul> <li>Only need current price (use <code>get_bid()</code>/<code>get_ask()</code>)</li> <li>Only need one parameter (use specific methods)</li> <li>Need all symbols (use <code>get_all_symbols()</code>)</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_info/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_info/#example-1-basic-symbol-information","title":"Example 1: Basic Symbol Information","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def symbol_details():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # Get EURUSD information\n    info = await sugar.get_symbol_info(\"EURUSD\")\n\n    print(f\"Symbol: {info.name}\")\n    print(f\"BID: {info.bid:.{info.digits}f}\")\n    print(f\"ASK: {info.ask:.{info.digits}f}\")\n    print(f\"Spread: {info.spread} points\")\n    print(f\"Digits: {info.digits}\")\n    print(f\"Point: {info.point}\")\n    print(f\"Volume limits: {info.volume_min} - {info.volume_max}\")\n    print(f\"Volume step: {info.volume_step}\")\n    print(f\"Contract size: {info.contract_size}\")\n\n# Output:\n# Symbol: EURUSD\n# BID: 1.08432\n# ASK: 1.08445\n# Spread: 13 points\n# Digits: 5\n# Point: 0.00001\n# Volume limits: 0.01 - 100.0\n# Volume step: 0.01\n# Contract size: 100000.0\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_info/#example-2-volume-validation","title":"Example 2: Volume Validation","text":"<pre><code>async def validate_volume():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n    desired_volume = 0.15\n\n    # Get symbol info\n    info = await sugar.get_symbol_info(symbol)\n\n    # Validate volume\n    if desired_volume &lt; info.volume_min:\n        print(f\"Volume too small (min: {info.volume_min})\")\n    elif desired_volume &gt; info.volume_max:\n        print(f\"Volume too large (max: {info.volume_max})\")\n    elif (desired_volume % info.volume_step) != 0:\n        # Round to nearest step\n        adjusted = round(desired_volume / info.volume_step) * info.volume_step\n        print(f\"Volume adjusted: {desired_volume} \u2192 {adjusted}\")\n        desired_volume = adjusted\n\n    # Now safe to trade\n    ticket = await sugar.buy_market(symbol, volume=desired_volume)\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_info/#example-3-calculate-pip-value","title":"Example 3: Calculate Pip Value","text":"<pre><code>async def calculate_pip_value():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n    info = await sugar.get_symbol_info(symbol)\n\n    # Calculate pip value for 1 lot\n    # For forex: pip_value = point * 10 * contract_size\n    pip_value = info.point * 10 * info.contract_size\n\n    print(f\"{symbol} Pip Value (1 lot):\")\n    print(f\"  Point: {info.point}\")\n    print(f\"  Contract size: {info.contract_size}\")\n    print(f\"  1 pip = ${pip_value:.2f}\")\n\n    # For 0.1 lot\n    pip_value_mini = pip_value * 0.1\n    print(f\"  0.1 lot: ${pip_value_mini:.2f} per pip\")\n\n# Output:\n# EURUSD Pip Value (1 lot):\n#   Point: 1e-05\n#   Contract size: 100000.0\n#   1 pip = $10.00\n#   0.1 lot: $1.00 per pip\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_info/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Not handling ValueError <pre><code># ERROR: Symbol doesn't exist\ntry:\n    info = await sugar.get_symbol_info(\"FAKEUSD\")\nexcept ValueError as e:\n    print(e)  # \"Symbol FAKEUSD not found\"\n</code></pre></p> <p>Solution: Wrap in try-except or check first <pre><code># Check if exists first\nexists = await sugar.is_symbol_available(\"EURUSD\")\n\nif exists:\n    info = await sugar.get_symbol_info(\"EURUSD\")\n</code></pre></p> <p>Pitfall 2: Using stale prices <pre><code># Prices in SymbolInfo are snapshot\ninfo = await sugar.get_symbol_info(\"EURUSD\")\nawait asyncio.sleep(60)\n\n# info.bid and info.ask are 60 seconds old now!\n</code></pre></p> <p>Solution: Refresh info or use get_bid()/get_ask() <pre><code># For current price, use dedicated methods\ncurrent_bid = await sugar.get_bid(\"EURUSD\")\n\n# Or refresh symbol info\ninfo = await sugar.get_symbol_info(\"EURUSD\")\n</code></pre></p> <p>Pitfall 3: Confusing point and pip <pre><code># Point != Pip\ninfo = await sugar.get_symbol_info(\"EURUSD\")\n\n# Point = minimum price change (0.00001)\n# Pip = 10 points (0.0001)\n\n# Calculate pips from points\nspread_pips = info.spread / 10  # Convert points to pips\n</code></pre></p>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_info/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Format prices correctly <pre><code>info = await sugar.get_symbol_info(\"EURUSD\")\n\n# Use digits for formatting\nprice = info.bid\nformatted = f\"{price:.{info.digits}f}\"\nprint(f\"Price: {formatted}\")  # 1.08432 (5 decimals)\n</code></pre></p> <p>Tip 2: Validate and adjust volume <pre><code>def adjust_volume(desired, info):\n    \"\"\"Adjust volume to symbol constraints.\"\"\"\n    # Clamp to min/max\n    volume = max(info.volume_min, min(desired, info.volume_max))\n\n    # Round to step\n    volume = round(volume / info.volume_step) * info.volume_step\n\n    return volume\n\ninfo = await sugar.get_symbol_info(\"EURUSD\")\nsafe_volume = adjust_volume(0.15, info)\n</code></pre></p> <p>Tip 3: Cache symbol info <pre><code># Cache frequently used symbols\nsymbol_cache = {}\n\nasync def get_cached_symbol_info(sugar, symbol):\n    \"\"\"Get symbol info with caching.\"\"\"\n    if symbol not in symbol_cache:\n        symbol_cache[symbol] = await sugar.get_symbol_info(symbol)\n\n    return symbol_cache[symbol]\n\n# Use cached info\ninfo = await get_cached_symbol_info(sugar, \"EURUSD\")\n</code></pre></p>"},{"location":"MT5Sugar/9.%20Symbol_Information/get_symbol_info/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_all_symbols - List all available symbols</li> <li>is_symbol_available - Check if symbol exists</li> <li>get_symbol_digits - Get decimal places only</li> <li>get_min_stop_level - Get minimum SL/TP distance</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/is_symbol_available/","title":"Is Symbol Available (<code>is_symbol_available</code>)","text":"<p>Sugar method: Checks if trading symbol exists and is available.</p> <p>API Information:</p> <ul> <li>Method: <code>sugar.is_symbol_available(symbol)</code></li> <li>Returns: Boolean indicating if symbol exists</li> <li>Layer: HIGH (MT5Sugar)</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/is_symbol_available/#method-signature","title":"Method Signature","text":"<pre><code>async def is_symbol_available(self, symbol: str) -&gt; bool\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/is_symbol_available/#input-parameters","title":"\ud83d\udd3d Input Parameters","text":"Parameter Type Required Default Description <code>symbol</code> <code>str</code> Yes - Trading symbol to check (e.g., \"EURUSD\")"},{"location":"MT5Sugar/9.%20Symbol_Information/is_symbol_available/#return-value","title":"Return Value","text":"Type Description <code>bool</code> <code>True</code> if symbol exists and is available, <code>False</code> otherwise"},{"location":"MT5Sugar/9.%20Symbol_Information/is_symbol_available/#essentials","title":"\ud83c\udfdb\ufe0f Essentials","text":"<p>What it does:</p> <ul> <li>Checks if symbol exists on broker</li> <li>Verifies symbol is currently available</li> <li>Fast validation before trading</li> <li>Returns boolean (True/False)</li> </ul> <p>Key behaviors:</p> <ul> <li>Returns False if symbol doesn't exist</li> <li>Returns False if symbol is disabled</li> <li>Case-sensitive symbol name</li> <li>Fast single query (not batch)</li> <li>Does NOT check if symbol is tradable (only if it exists)</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/is_symbol_available/#under-the-hood","title":"\u26a1 Under the Hood","text":"<pre><code>MT5Sugar.is_symbol_available()\n    \u2193 calls\nMT5Service.symbol_exist(symbol)\n    \u2193 calls\nMT5Account.symbol_exist()\n    \u2193 gRPC protobuf\nMarketInfoService.SymbolExist()\n    \u2193 MT5 Terminal\n    \u2193 returns (exists: bool, _)\n</code></pre> <p>Call chain:</p> <ol> <li>Sugar calls Service.symbol_exist() with symbol name</li> <li>Service forwards to Account.symbol_exist()</li> <li>Account sends gRPC request to terminal</li> <li>Terminal checks if symbol exists</li> <li>Returns tuple (exists: bool, unknown)</li> <li>Sugar extracts and returns exists boolean</li> </ol> <p>Related files:</p> <ul> <li>Sugar: <code>src/pymt5/mt5_sugar.py:1672</code></li> <li>Service: <code>src/pymt5/mt5_service.py:567</code></li> <li>Account: <code>package/MetaRpcMT5/helpers/mt5_account.py:730</code></li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/is_symbol_available/#when-to-use","title":"When to Use","text":"<p>Use <code>is_symbol_available()</code> when:</p> <ul> <li>Validating user input before trading</li> <li>Checking symbol existence before fetching info</li> <li>Error prevention in trading loops</li> <li>Symbol validation in configuration</li> <li>Building safe trading applications</li> </ul> <p>Don't use when:</p> <ul> <li>Already know symbol exists (skip check)</li> <li>Need full symbol info (use <code>get_symbol_info()</code>)</li> <li>Listing all symbols (use <code>get_all_symbols()</code>)</li> <li>Symbol is hardcoded and known valid</li> </ul>"},{"location":"MT5Sugar/9.%20Symbol_Information/is_symbol_available/#examples","title":"\ud83d\udd17 Examples","text":""},{"location":"MT5Sugar/9.%20Symbol_Information/is_symbol_available/#example-1-validate-symbol-before-trading","title":"Example 1: Validate Symbol Before Trading","text":"<pre><code>from pymt5 import MT5Sugar, MT5Service, MT5Account\n\nasync def safe_trade():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    symbol = \"EURUSD\"\n\n    # Check if symbol exists\n    if await sugar.is_symbol_available(symbol):\n        print(f\"{symbol} is available\")\n\n        # Safe to trade\n        ticket = await sugar.buy_market(symbol, volume=0.1)\n        print(f\"Order placed: {ticket}\")\n    else:\n        print(f\"{symbol} not available on this broker\")\n\n# Output:\n# EURUSD is available\n# Order placed: 123456789\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/is_symbol_available/#example-2-validate-user-input","title":"Example 2: Validate User Input","text":"<pre><code>async def validate_user_symbol():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # User provides symbol\n    user_symbol = input(\"Enter symbol: \").upper()\n\n    # Validate\n    if not await sugar.is_symbol_available(user_symbol):\n        print(f\"Error: '{user_symbol}' is not available\")\n        print(\"Please check the symbol name and try again\")\n        return\n\n    # Continue with valid symbol\n    info = await sugar.get_symbol_info(user_symbol)\n    print(f\"{user_symbol}: BID={info.bid}, ASK={info.ask}\")\n\n# Example interaction:\n# Enter symbol: FAKEUSD\n# Error: 'FAKEUSD' is not available\n# Please check the symbol name and try again\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/is_symbol_available/#example-3-validate-symbol-list","title":"Example 3: Validate Symbol List","text":"<pre><code>async def validate_watchlist():\n    account = MT5Account.create(\n        user=591129415,\n        password=\"your_password\",\n        grpc_server=\"mt5.mrpc.pro:443\"\n    )\n    service = MT5Service(account)\n    sugar = MT5Sugar(service)\n\n    await sugar.quick_connect(\"FxPro-MT5 Demo\")\n\n    # User's watchlist\n    watchlist = [\"EURUSD\", \"GBPUSD\", \"FAKEUSD\", \"USDJPY\", \"XAUUSD\"]\n\n    # Validate all symbols\n    valid_symbols = []\n    invalid_symbols = []\n\n    for symbol in watchlist:\n        if await sugar.is_symbol_available(symbol):\n            valid_symbols.append(symbol)\n        else:\n            invalid_symbols.append(symbol)\n\n    print(f\"Valid symbols ({len(valid_symbols)}): {valid_symbols}\")\n    print(f\"Invalid symbols ({len(invalid_symbols)}): {invalid_symbols}\")\n\n# Output:\n# Valid symbols (4): ['EURUSD', 'GBPUSD', 'USDJPY', 'XAUUSD']\n# Invalid symbols (1): ['FAKEUSD']\n</code></pre>"},{"location":"MT5Sugar/9.%20Symbol_Information/is_symbol_available/#common-pitfalls","title":"Common Pitfalls","text":"<p>Pitfall 1: Case sensitivity <pre><code># ERROR: Symbol case matters\nexists = await sugar.is_symbol_available(\"eurusd\")\n# Returns False if broker uses \"EURUSD\"\n</code></pre></p> <p>Solution: Always use uppercase <pre><code>symbol = \"eurusd\"\nexists = await sugar.is_symbol_available(symbol.upper())\n</code></pre></p> <p>Pitfall 2: Assuming available means tradable <pre><code># Symbol exists but might not be tradable right now\nif await sugar.is_symbol_available(\"EURUSD\"):\n    # Symbol exists, but might be:\n    # - Market closed\n    # - Trading disabled\n    # - Insufficient margin\n    await sugar.buy_market(\"EURUSD\", volume=0.1)  # May still fail\n</code></pre></p> <p>Solution: Handle trade errors separately <pre><code>if await sugar.is_symbol_available(\"EURUSD\"):\n    try:\n        ticket = await sugar.buy_market(\"EURUSD\", volume=0.1)\n    except Exception as e:\n        print(f\"Trade failed: {e}\")\n</code></pre></p> <p>Pitfall 3: Checking before every operation <pre><code># Redundant checks\nif await sugar.is_symbol_available(\"EURUSD\"):\n    info = await sugar.get_symbol_info(\"EURUSD\")  # Already validates\n\nif await sugar.is_symbol_available(\"EURUSD\"):\n    bid = await sugar.get_bid(\"EURUSD\")  # Also validates\n</code></pre></p> <p>Solution: Check once, then proceed <pre><code># Single validation\nif await sugar.is_symbol_available(\"EURUSD\"):\n    # All subsequent calls will work\n    info = await sugar.get_symbol_info(\"EURUSD\")\n    bid = await sugar.get_bid(\"EURUSD\")\n</code></pre></p>"},{"location":"MT5Sugar/9.%20Symbol_Information/is_symbol_available/#pro-tips","title":"Pro Tips","text":"<p>Tip 1: Validate with fallback <pre><code>async def get_symbol_with_fallback(primary, fallback):\n    \"\"\"Try primary symbol, fall back if unavailable.\"\"\"\n    if await sugar.is_symbol_available(primary):\n        return primary\n    elif await sugar.is_symbol_available(fallback):\n        print(f\"{primary} not available, using {fallback}\")\n        return fallback\n    else:\n        raise ValueError(f\"Neither {primary} nor {fallback} available\")\n\n# Usage\nsymbol = await get_symbol_with_fallback(\"EURUSD\", \"EURUSD.a\")\n</code></pre></p> <p>Tip 2: Batch validation helper <pre><code>async def validate_symbols(symbols: List[str]) -&gt; dict:\n    \"\"\"Validate multiple symbols efficiently.\"\"\"\n    results = {}\n\n    for symbol in symbols:\n        results[symbol] = await sugar.is_symbol_available(symbol)\n\n    return results\n\n# Usage\nsymbols = [\"EURUSD\", \"GBPUSD\", \"FAKEUSD\"]\nresults = await validate_symbols(symbols)\n\nvalid = [s for s, exists in results.items() if exists]\ninvalid = [s for s, exists in results.items() if not exists]\n\nprint(f\"Valid: {valid}\")\nprint(f\"Invalid: {invalid}\")\n</code></pre></p> <p>Tip 3: Safe symbol getter <pre><code>async def get_symbol_info_safe(symbol: str):\n    \"\"\"Get symbol info with existence check.\"\"\"\n    if not await sugar.is_symbol_available(symbol):\n        raise ValueError(f\"Symbol '{symbol}' not available\")\n\n    return await sugar.get_symbol_info(symbol)\n\n# Usage\ntry:\n    info = await get_symbol_info_safe(\"EURUSD\")\n    print(f\"Got info: {info.name}\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</code></pre></p>"},{"location":"MT5Sugar/9.%20Symbol_Information/is_symbol_available/#see-also","title":"\ud83d\udcda See Also","text":"<ul> <li>get_symbol_info - Get complete symbol information</li> <li>get_all_symbols - List all available symbols</li> <li>get_symbol_digits - Get decimal places</li> </ul>"}]}